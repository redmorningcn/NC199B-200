###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       11/Jul/2018  11:13:10
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC210\NC210-200处理板\source\Software\uCOS-III\Source\os_tick.c
#    Command line =  
#        F:\iar\NC210\NC210-200处理板\source\Software\uCOS-III\Source\os_tick.c
#        -D USE_STDPERIPH_DRIVER -D APP_RELEASE -lCN
#        F:\iar\NC210\NC210-200处理板\project\app_release\List -o
#        F:\iar\NC210\NC210-200处理板\project\app_release\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC210\NC210-200处理板\project\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\config\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\task\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\user\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\OS\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\Ports\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\driver\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-LIB\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Source\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\ST\STM32\inc\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Ports\STM32\STM32F103\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Source\
#        -Ol --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC210\NC210-200处理板\project\app_release\List\os_tick.lst
#    Object file  =  
#        F:\iar\NC210\NC210-200处理板\project\app_release\Obj\os_tick.o
#
###############################################################################

F:\iar\NC210\NC210-200处理板\source\Software\uCOS-III\Source\os_tick.c
      1          /*
      2          ***********************************************************************************************************************
      3          *                                                      uC/OS-III
      4          *                                                 The Real-Time Kernel
      5          *
      6          *                                  (c) Copyright 2009-2016; Micrium, Inc.; Weston, FL
      7          *                           All rights reserved.  Protected by international copyright laws.
      8          *
      9          *                                                   TICK MANAGEMENT
     10          *
     11          * File    : OS_TICK.C
     12          * By      : JJL
     13          * Version : V3.06.00
     14          *
     15          * LICENSING TERMS:
     16          * ---------------
     17          *           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or
     18          *           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
     19          *           product then, you need to contact Micrium to properly license uC/OS-III for its use in your
     20          *           application/product.   We provide ALL the source code for your convenience and to help you
     21          *           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use
     22          *           it commercially without paying a licensing fee.
     23          *
     24          *           Knowledge of the source code may NOT be used to develop a similar product.
     25          *
     26          *           Please help us continue to provide the embedded community with the finest software available.
     27          *           Your honesty is greatly appreciated.
     28          *
     29          *           You can find our product's user manual, API reference, release notes and
     30          *           more information at https://doc.micrium.com.
     31          *           You can contact us at www.micrium.com.
     32          ************************************************************************************************************************
     33          */
     34          
     35          #define  MICRIUM_SOURCE
     36          #include "os.h"
     37          
     38          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     39          const  CPU_CHAR  *os_tick__c = "$Id: $";
     40          #endif
     41          
     42          #if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
     43          /*
     44          ************************************************************************************************************************
     45          *                                                 FUNCTION PROTOTYPES
     46          ************************************************************************************************************************
     47          */
     48          
     49          static  CPU_TS  OS_TickListUpdateDly     (OS_TICK ticks);
     50          static  CPU_TS  OS_TickListUpdateTimeout (OS_TICK ticks);
     51          
     52          /*
     53          ************************************************************************************************************************
     54          *                                                      TICK TASK
     55          *
     56          * Description: This task is internal to uC/OS-III and is triggered by the tick interrupt.
     57          *
     58          * Arguments  : p_arg     is an argument passed to the task when the task is created (unused).
     59          *
     60          * Returns    : none
     61          *
     62          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
     63          ************************************************************************************************************************
     64          */
     65          

   \                                 In section .text, align 2, keep-with-next
     66          void  OS_TickTask (void  *p_arg)
     67          {
   \                     OS_TickTask: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
     68              OS_ERR   err;
     69          #if (OS_CFG_TS_EN == DEF_ENABLED)
     70              CPU_TS   ts_delta;
     71              CPU_TS   ts_delta_dly;
     72              CPU_TS   ts_delta_timeout;
     73          #endif
     74          #if (OS_CFG_DYN_TICK_EN == DEF_ENABLED)
     75              OS_TICK  tick_step_dly;
     76              OS_TICK  tick_step_timeout;
     77          #endif
     78              OS_TICK  tick_step;
     79              CPU_SR_ALLOC();
   \   00000004   0x2400             MOVS     R4,#+0
     80          
     81          
     82              (void)p_arg;                                                /* Prevent compiler warning                             */
     83          
     84              for (;;) {
     85                  (void)OSTaskSemPend(0u,
     86                                      OS_OPT_PEND_BLOCKING,
     87                                      DEF_NULL,
     88                                      &err);                              /* Wait for signal from tick interrupt                  */
   \                     ??OS_TickTask_0: (+1)
   \   00000006   0x466B             MOV      R3,SP
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x.... 0x....      BL       OSTaskSemPend
     89                  if (err == OS_ERR_NONE) {
   \   00000012   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD1F5             BNE.N    ??OS_TickTask_0
     90                      CPU_CRITICAL_ENTER();
   \   0000001A   0x.... 0x....      BL       CPU_SR_Save
   \   0000001E   0x0004             MOVS     R4,R0
   \   00000020   0x.... 0x....      BL       CPU_IntDisMeasStart
     91          
     92          #if (OS_CFG_DYN_TICK_EN == DEF_ENABLED)
     93                      tick_step = OSTickCtrPend;
     94                      OSTickCtr += tick_step;
     95                      OSTickCtrPend = 0;
     96          #else
     97                      tick_step = 1u;                                     /* Always tick once when dynamic tick is disabled       */
   \   00000024   0x2601             MOVS     R6,#+1
     98                      OSTickCtr++;                                        /* Keep track of the number of ticks                    */
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable4
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x1C40             ADDS     R0,R0,#+1
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable4
   \   00000032   0x6008             STR      R0,[R1, #+0]
     99          #endif
    100          
    101                      OS_TRACE_TICK_INCREMENT(OSTickCtr);
    102          
    103          #if (OS_CFG_TS_EN == DEF_ENABLED)
    104                      ts_delta_dly     = OS_TickListUpdateDly(tick_step);
   \   00000034   0x0030             MOVS     R0,R6
   \   00000036   0x.... 0x....      BL       OS_TickListUpdateDly
   \   0000003A   0x0005             MOVS     R5,R0
    105                      ts_delta_timeout = OS_TickListUpdateTimeout(tick_step);
   \   0000003C   0x0030             MOVS     R0,R6
   \   0000003E   0x.... 0x....      BL       OS_TickListUpdateTimeout
    106                      ts_delta         = ts_delta_dly + ts_delta_timeout; /* Compute total execution time of list updates         */
   \   00000042   0x1940             ADDS     R0,R0,R5
    107                      if (OSTickTaskTimeMax < ts_delta) {
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable4_1
   \   00000048   0x6809             LDR      R1,[R1, #+0]
   \   0000004A   0x4281             CMP      R1,R0
   \   0000004C   0xD202             BCS.N    ??OS_TickTask_1
    108                          OSTickTaskTimeMax = ts_delta;
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable4_1
   \   00000052   0x6008             STR      R0,[R1, #+0]
    109                      }
    110          #else
    111                      (void)OS_TickListUpdateDly(tick_step);
    112                      (void)OS_TickListUpdateTimeout(tick_step);
    113          #endif
    114          
    115          #if (OS_CFG_DYN_TICK_EN == DEF_ENABLED)
    116                      tick_step_dly = (OS_TICK)-1;
    117                      tick_step_timeout = (OS_TICK)-1;
    118                      if(OSTickListDly.TCB_Ptr != DEF_NULL) {
    119                          tick_step_dly = OSTickListDly.TCB_Ptr->TickRemain;
    120                      }
    121                      if(OSTickListTimeout.TCB_Ptr != DEF_NULL) {
    122                          tick_step_timeout = OSTickListTimeout.TCB_Ptr->TickRemain;
    123                      }
    124                      OSTickCtrStep = (tick_step_dly < tick_step_timeout) ? tick_step_dly : tick_step_timeout;
    125                      BSP_OS_TickNextSet(OSTickCtrStep);
    126          #endif
    127                      CPU_CRITICAL_EXIT();
   \                     ??OS_TickTask_1: (+1)
   \   00000054   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000058   0x0020             MOVS     R0,R4
   \   0000005A   0x.... 0x....      BL       CPU_SR_Restore
   \   0000005E   0xE7D2             B.N      ??OS_TickTask_0
    128                  }
    129              }
    130          }
    131          
    132          /*
    133          ************************************************************************************************************************
    134          *                                                 INITIALIZE TICK TASK
    135          *
    136          * Description: This function is called by OSInit() to create the tick task.
    137          *
    138          * Arguments  : p_err   is a pointer to a variable that will hold the value of an error code:
    139          *
    140          *                          OS_ERR_TICK_STK_INVALID   if the pointer to the tick task stack is a NULL pointer
    141          *                          OS_ERR_TICK_STK_SIZE      indicates that the specified stack size
    142          *                          OS_ERR_PRIO_INVALID       if the priority you specified in the configuration is invalid
    143          *                                                      (There could be only one task at the Idle Task priority)
    144          *                                                      (Maybe the priority you specified is higher than OS_CFG_PRIO_MAX-1
    145          *                          OS_ERR_??                 other error code returned by OSTaskCreate()
    146          *
    147          * Returns    : none
    148          *
    149          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
    150          ************************************************************************************************************************
    151          */
    152          

   \                                 In section .text, align 2, keep-with-next
    153          void  OS_TickTaskInit (OS_ERR  *p_err)
    154          {
   \                     OS_TickTaskInit: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
    155              OSTickCtr                    = 0u;                          /* Clear the tick counter                               */
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x.... 0x....      LDR.W    R2,??DataTable4
   \   0000000A   0x6011             STR      R1,[R2, #+0]
    156          
    157          #if (OS_CFG_DYN_TICK_EN == DEF_ENABLED)
    158              OSTickCtrStep                = (OS_TICK)-1;
    159              OSTickCtrPend                = 0u;
    160          #endif
    161          
    162              OSTickListDly.TCB_Ptr        = DEF_NULL;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x.... 0x....      LDR.W    R2,??DataTable4_2
   \   00000012   0x6011             STR      R1,[R2, #+0]
    163              OSTickListTimeout.TCB_Ptr    = DEF_NULL;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x.... 0x....      LDR.W    R2,??DataTable4_3
   \   0000001A   0x6011             STR      R1,[R2, #+0]
    164          
    165          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    166              OSTickListDly.NbrEntries     = 0u;
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x.... 0x....      LDR.W    R2,??DataTable4_2
   \   00000022   0x8091             STRH     R1,[R2, #+4]
    167              OSTickListDly.NbrUpdated     = 0u;
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0x.... 0x....      LDR.W    R2,??DataTable4_2
   \   0000002A   0x80D1             STRH     R1,[R2, #+6]
    168          
    169              OSTickListTimeout.NbrEntries = 0u;
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x.... 0x....      LDR.W    R2,??DataTable4_3
   \   00000032   0x8091             STRH     R1,[R2, #+4]
    170              OSTickListTimeout.NbrUpdated = 0u;
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0x.... 0x....      LDR.W    R2,??DataTable4_3
   \   0000003A   0x80D1             STRH     R1,[R2, #+6]
    171          #endif
    172          
    173                                                                          /* --------------- CREATE THE TICK TASK --------------- */
    174              if (OSCfg_TickTaskStkBasePtr == DEF_NULL) {
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable4_4
   \   00000040   0x6809             LDR      R1,[R1, #+0]
   \   00000042   0x2900             CMP      R1,#+0
   \   00000044   0xD103             BNE.N    ??OS_TickTaskInit_0
    175                 *p_err = OS_ERR_TICK_STK_INVALID;
   \   00000046   0xF247 0x2112      MOVW     R1,#+29202
   \   0000004A   0x8001             STRH     R1,[R0, #+0]
    176                  return;
   \   0000004C   0xE032             B.N      ??OS_TickTaskInit_1
    177              }
    178          
    179              if (OSCfg_TickTaskStkSize < OSCfg_StkSizeMin) {
   \                     ??OS_TickTaskInit_0: (+1)
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable4_5
   \   00000052   0x6809             LDR      R1,[R1, #+0]
   \   00000054   0x.... 0x....      LDR.W    R2,??DataTable4_6
   \   00000058   0x6812             LDR      R2,[R2, #+0]
   \   0000005A   0x4291             CMP      R1,R2
   \   0000005C   0xD203             BCS.N    ??OS_TickTaskInit_2
    180                 *p_err = OS_ERR_TICK_STK_SIZE_INVALID;
   \   0000005E   0xF247 0x2113      MOVW     R1,#+29203
   \   00000062   0x8001             STRH     R1,[R0, #+0]
    181                  return;
   \   00000064   0xE026             B.N      ??OS_TickTaskInit_1
    182              }
    183          
    184              if (OSCfg_TickTaskPrio >= (OS_CFG_PRIO_MAX - 1u)) {         /* Only one task at the 'Idle Task' priority            */
   \                     ??OS_TickTaskInit_2: (+1)
   \   00000066   0x.... 0x....      LDR.W    R1,??DataTable4_7
   \   0000006A   0x7809             LDRB     R1,[R1, #+0]
   \   0000006C   0x293F             CMP      R1,#+63
   \   0000006E   0xD303             BCC.N    ??OS_TickTaskInit_3
    185                 *p_err = OS_ERR_TICK_PRIO_INVALID;
   \   00000070   0xF247 0x2111      MOVW     R1,#+29201
   \   00000074   0x8001             STRH     R1,[R0, #+0]
    186                  return;
   \   00000076   0xE01D             B.N      ??OS_TickTaskInit_1
    187              }
    188          
    189              OSTaskCreate(&OSTickTaskTCB,
    190                           (CPU_CHAR   *)("uC/OS-III Tick Task"),
    191                           OS_TickTask,
    192                           DEF_NULL,
    193                           OSCfg_TickTaskPrio,
    194                           OSCfg_TickTaskStkBasePtr,
    195                           OSCfg_TickTaskStkLimit,
    196                           OSCfg_TickTaskStkSize,
    197                           0u,
    198                           0u,
    199                           DEF_NULL,
    200                           (OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR | OS_OPT_TASK_NO_TLS),
    201                           p_err);
   \                     ??OS_TickTaskInit_3: (+1)
   \   00000078   0x9008             STR      R0,[SP, #+32]
   \   0000007A   0x200B             MOVS     R0,#+11
   \   0000007C   0x9007             STR      R0,[SP, #+28]
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x9006             STR      R0,[SP, #+24]
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x9005             STR      R0,[SP, #+20]
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0x9004             STR      R0,[SP, #+16]
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable4_5
   \   0000008E   0x6800             LDR      R0,[R0, #+0]
   \   00000090   0x9003             STR      R0,[SP, #+12]
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable4_8
   \   00000096   0x6800             LDR      R0,[R0, #+0]
   \   00000098   0x9002             STR      R0,[SP, #+8]
   \   0000009A   0x....             LDR.N    R0,??DataTable4_4
   \   0000009C   0x6800             LDR      R0,[R0, #+0]
   \   0000009E   0x9001             STR      R0,[SP, #+4]
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable4_7
   \   000000A4   0x7800             LDRB     R0,[R0, #+0]
   \   000000A6   0x9000             STR      R0,[SP, #+0]
   \   000000A8   0x2300             MOVS     R3,#+0
   \   000000AA   0x....             LDR.N    R2,??DataTable4_9
   \   000000AC   0x....             LDR.N    R1,??DataTable4_10
   \   000000AE   0x....             LDR.N    R0,??DataTable4_11
   \   000000B0   0x.... 0x....      BL       OSTaskCreate
    202          }
   \                     ??OS_TickTaskInit_1: (+1)
   \   000000B4   0xB009             ADD      SP,SP,#+36
   \   000000B6   0xBD00             POP      {PC}             ;; return
    203          
    204          /*
    205          ************************************************************************************************************************
    206          *                                                      INSERT
    207          *
    208          * Description: This task is internal to uC/OS-III and allows the insertion of a task in a tick list.
    209          *
    210          * Arguments  : p_list      is a pointer to the desired list
    211          *
    212          *              p_tcb       is a pointer to the TCB to insert in the list
    213          *
    214          *              time        is the amount of time remaining (in ticks) for the task to become ready
    215          *
    216          * Returns    : none
    217          *
    218          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
    219          ************************************************************************************************************************
    220          */
    221          

   \                                 In section .text, align 2, keep-with-next
    222          void  OS_TickListInsert (OS_TICK_LIST  *p_list,
    223                                   OS_TCB        *p_tcb,
    224                                   OS_TICK        time)
    225          {
   \                     OS_TickListInsert: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    226              OS_TCB  *p_tcb1;
    227              OS_TCB  *p_tcb2;
    228              OS_TICK  remain;
    229          #if (OS_CFG_DYN_TICK_EN == DEF_ENABLED)
    230              OS_TICK  tick_step = (OS_TICK)-1;
    231          #endif
    232          
    233          
    234              if (p_list->TCB_Ptr == DEF_NULL) {                          /* Is the list empty?                                   */
   \   00000002   0x6803             LDR      R3,[R0, #+0]
   \   00000004   0x2B00             CMP      R3,#+0
   \   00000006   0xD109             BNE.N    ??OS_TickListInsert_0
    235                  p_tcb->TickRemain  = time;                              /* Yes, Store time in TCB                               */
   \   00000008   0x658A             STR      R2,[R1, #+88]
    236                  p_tcb->TickNextPtr = DEF_NULL;
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x618A             STR      R2,[R1, #+24]
    237                  p_tcb->TickPrevPtr = DEF_NULL;
   \   0000000E   0x2200             MOVS     R2,#+0
   \   00000010   0x61CA             STR      R2,[R1, #+28]
    238                  p_tcb->TickListPtr = p_list;                            /* Link to this list                                    */
   \   00000012   0x6208             STR      R0,[R1, #+32]
    239                  p_list->TCB_Ptr    = p_tcb;                             /* Point to TCB of task to place in the list            */
   \   00000014   0x6001             STR      R1,[R0, #+0]
    240          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    241                  p_list->NbrEntries = 1u;                                /* List contains 1 entry                                */
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0x8081             STRH     R1,[R0, #+4]
   \   0000001A   0xE033             B.N      ??OS_TickListInsert_1
    242          #endif
    243          #if (OS_CFG_DYN_TICK_EN == DEF_ENABLED)
    244                  tick_step = time;
    245          #endif
    246              } else {
    247                  p_tcb1 = p_list->TCB_Ptr;
   \                     ??OS_TickListInsert_0: (+1)
   \   0000001C   0x6803             LDR      R3,[R0, #+0]
    248                  p_tcb2 = p_list->TCB_Ptr;                               /* No,  Insert somewhere in the list in delta order     */
   \   0000001E   0x6804             LDR      R4,[R0, #+0]
    249                  remain = time;
   \   00000020   0xE003             B.N      ??OS_TickListInsert_2
    250                  while (p_tcb2 != DEF_NULL) {
    251                      if (remain <= p_tcb2->TickRemain) {
    252                          if (p_tcb2->TickPrevPtr == DEF_NULL) {          /* Insert before the first entry in the list?           */
    253                              p_tcb->TickRemain   = remain;               /* Yes, Store remaining time                            */
    254                              p_tcb->TickPrevPtr  = DEF_NULL;
    255                              p_tcb->TickNextPtr  = p_tcb2;
    256                              p_tcb->TickListPtr  = p_list;               /* Link TCB to this list                                */
    257                              p_tcb2->TickRemain -= remain;               /* Reduce time of next entry in the list                */
    258                              p_tcb2->TickPrevPtr = p_tcb;
    259                              p_list->TCB_Ptr     = p_tcb;                /* Add TCB to the list                                  */
    260          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    261                              p_list->NbrEntries++;                       /* List contains an extra entry                         */
    262          #endif
    263          #if (OS_CFG_DYN_TICK_EN == DEF_ENABLED)
    264                              tick_step = remain;
    265          #endif
    266                          } else {                                        /* No,  Insert somewhere further in the list            */
    267                              p_tcb1              = p_tcb2->TickPrevPtr;
    268                              p_tcb->TickRemain   = remain;               /* Store remaining time                                 */
    269                              p_tcb->TickPrevPtr  = p_tcb1;
    270                              p_tcb->TickNextPtr  = p_tcb2;
    271                              p_tcb->TickListPtr  = p_list;               /* TCB points to this list                              */
    272                              p_tcb2->TickRemain -= remain;               /* Reduce time of next entry in the list                */
    273                              p_tcb2->TickPrevPtr = p_tcb;
    274                              p_tcb1->TickNextPtr = p_tcb;
    275          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    276                              p_list->NbrEntries++;                       /* List contains an extra entry                         */
    277          #endif
    278                          }
    279          
    280          #if (OS_CFG_DYN_TICK_EN == DEF_ENABLED)
    281                          if (tick_step < OSTickCtrStep) {
    282                              OSTickCtrStep = tick_step;
    283                              BSP_OS_TickNextSet(tick_step);
    284                          }
    285          #endif
    286          
    287                          return;
    288                      } else {
    289                          remain -= p_tcb2->TickRemain;                   /* Point to the next TCB in the list                    */
   \                     ??OS_TickListInsert_3: (+1)
   \   00000022   0x6DA3             LDR      R3,[R4, #+88]
   \   00000024   0x1AD2             SUBS     R2,R2,R3
    290                          p_tcb1  = p_tcb2;
   \   00000026   0x0023             MOVS     R3,R4
    291                          p_tcb2  = p_tcb2->TickNextPtr;
   \   00000028   0x69A4             LDR      R4,[R4, #+24]
    292                      }
   \                     ??OS_TickListInsert_2: (+1)
   \   0000002A   0x2C00             CMP      R4,#+0
   \   0000002C   0xD021             BEQ.N    ??OS_TickListInsert_4
   \   0000002E   0x6DA3             LDR      R3,[R4, #+88]
   \   00000030   0x4293             CMP      R3,R2
   \   00000032   0xD3F6             BCC.N    ??OS_TickListInsert_3
   \   00000034   0x69E3             LDR      R3,[R4, #+28]
   \   00000036   0x2B00             CMP      R3,#+0
   \   00000038   0xD10D             BNE.N    ??OS_TickListInsert_5
   \   0000003A   0x658A             STR      R2,[R1, #+88]
   \   0000003C   0x2300             MOVS     R3,#+0
   \   0000003E   0x61CB             STR      R3,[R1, #+28]
   \   00000040   0x618C             STR      R4,[R1, #+24]
   \   00000042   0x6208             STR      R0,[R1, #+32]
   \   00000044   0x6DA3             LDR      R3,[R4, #+88]
   \   00000046   0x1A9A             SUBS     R2,R3,R2
   \   00000048   0x65A2             STR      R2,[R4, #+88]
   \   0000004A   0x61E1             STR      R1,[R4, #+28]
   \   0000004C   0x6001             STR      R1,[R0, #+0]
   \   0000004E   0x8881             LDRH     R1,[R0, #+4]
   \   00000050   0x1C49             ADDS     R1,R1,#+1
   \   00000052   0x8081             STRH     R1,[R0, #+4]
   \   00000054   0xE00C             B.N      ??OS_TickListInsert_6
   \                     ??OS_TickListInsert_5: (+1)
   \   00000056   0x69E3             LDR      R3,[R4, #+28]
   \   00000058   0x658A             STR      R2,[R1, #+88]
   \   0000005A   0x61CB             STR      R3,[R1, #+28]
   \   0000005C   0x618C             STR      R4,[R1, #+24]
   \   0000005E   0x6208             STR      R0,[R1, #+32]
   \   00000060   0x6DA5             LDR      R5,[R4, #+88]
   \   00000062   0x1AAA             SUBS     R2,R5,R2
   \   00000064   0x65A2             STR      R2,[R4, #+88]
   \   00000066   0x61E1             STR      R1,[R4, #+28]
   \   00000068   0x6199             STR      R1,[R3, #+24]
   \   0000006A   0x8881             LDRH     R1,[R0, #+4]
   \   0000006C   0x1C49             ADDS     R1,R1,#+1
   \   0000006E   0x8081             STRH     R1,[R0, #+4]
   \                     ??OS_TickListInsert_6: (+1)
   \   00000070   0xE008             B.N      ??OS_TickListInsert_7
    293                  }
    294                  p_tcb->TickRemain   = remain;
   \                     ??OS_TickListInsert_4: (+1)
   \   00000072   0x658A             STR      R2,[R1, #+88]
    295                  p_tcb->TickPrevPtr  = p_tcb1;
   \   00000074   0x61CB             STR      R3,[R1, #+28]
    296                  p_tcb->TickNextPtr  = DEF_NULL;
   \   00000076   0x2200             MOVS     R2,#+0
   \   00000078   0x618A             STR      R2,[R1, #+24]
    297                  p_tcb->TickListPtr  = p_list;                           /* Link the list to the TCB                             */
   \   0000007A   0x6208             STR      R0,[R1, #+32]
    298                  p_tcb1->TickNextPtr = p_tcb;
   \   0000007C   0x6199             STR      R1,[R3, #+24]
    299          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    300                  p_list->NbrEntries++;                                   /* List contains an extra entry                         */
   \   0000007E   0x8881             LDRH     R1,[R0, #+4]
   \   00000080   0x1C49             ADDS     R1,R1,#+1
   \   00000082   0x8081             STRH     R1,[R0, #+4]
    301          #endif
    302              }
    303          
    304          #if (OS_CFG_DYN_TICK_EN == DEF_ENABLED)
    305              if (tick_step < OSTickCtrStep) {
    306                  OSTickCtrStep = tick_step;
    307                  BSP_OS_TickNextSet(tick_step);
    308              }
    309          #endif
    310          }
   \                     ??OS_TickListInsert_1: (+1)
   \                     ??OS_TickListInsert_7: (+1)
   \   00000084   0xBC30             POP      {R4,R5}
   \   00000086   0x4770             BX       LR               ;; return
    311          
    312          /*
    313          ************************************************************************************************************************
    314          *                                            ADD TASK TO DELAYED TICK LIST
    315          *
    316          * Description: This function is called to place a task in a list of task waiting for either time to expire
    317          *
    318          * Arguments  : p_tcb          is a pointer to the OS_TCB of the task to add to the tick list
    319          *              -----
    320          *
    321          *              time           represents either the 'match' value of OSTickCtr or a relative time from the current
    322          *                             value of OSTickCtr as specified by the 'opt' argument..
    323          *
    324          *                             relative when 'opt' is set to OS_OPT_TIME_DLY
    325          *                             relative when 'opt' is set to OS_OPT_TIME_TIMEOUT
    326          *                             match    when 'opt' is set to OS_OPT_TIME_MATCH
    327          *                             periodic when 'opt' is set to OS_OPT_TIME_PERIODIC
    328          *
    329          *              opt            is an option specifying how to calculate time.  The valid values are:
    330          *              ---
    331          *                                 OS_OPT_TIME_DLY
    332          *                                 OS_OPT_TIME_TIMEOUT
    333          *                                 OS_OPT_TIME_PERIODIC
    334          *                                 OS_OPT_TIME_MATCH
    335          *
    336          *              p_err          is a pointer to a variable that will contain an error code returned by this function.
    337          *              -----
    338          *                                 OS_ERR_NONE           the call was successful and the time delay was scheduled.
    339          *                                 OS_ERR_TIME_ZERO_DLY  if delay is zero or already occurred.
    340          *
    341          * Returns    : None
    342          *
    343          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    344          *
    345          *              2) This function is assumed to be called with interrupts disabled.
    346          ************************************************************************************************************************
    347          */
    348          

   \                                 In section .text, align 2, keep-with-next
    349          void  OS_TickListInsertDly (OS_TCB   *p_tcb,
    350                                      OS_TICK   time,
    351                                      OS_OPT    opt,
    352                                      OS_ERR   *p_err)
    353          {
   \                     OS_TickListInsertDly: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    354              OS_TICK   remain;
    355              OS_TICK   tick_ctr;
    356          
    357          
    358          #if (OS_CFG_DYN_TICK_EN == DEF_ENABLED)
    359              tick_ctr = BSP_OS_TickGet();
    360          #else
    361              tick_ctr = OSTickCtr;
   \   00000002   0x....             LDR.N    R4,??DataTable4
   \   00000004   0x6824             LDR      R4,[R4, #+0]
    362          #endif
    363          
    364              if (opt == OS_OPT_TIME_MATCH) {                             /* MATCH to absolute OSTickCtr value mode               */
   \   00000006   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000008   0x2A04             CMP      R2,#+4
   \   0000000A   0xD10B             BNE.N    ??OS_TickListInsertDly_0
    365                  remain = time - tick_ctr;
   \   0000000C   0x1B0A             SUBS     R2,R1,R4
    366                  if ((remain > OS_TICK_TH_RDY) ||                        /* If delay already occurred, ...                       */
    367                      (remain == 0u)) {
   \   0000000E   0x....             LDR.N    R1,??DataTable4_12  ;; 0xffff0001
   \   00000010   0x428A             CMP      R2,R1
   \   00000012   0xD201             BCS.N    ??OS_TickListInsertDly_1
   \   00000014   0x2A00             CMP      R2,#+0
   \   00000016   0xD12C             BNE.N    ??OS_TickListInsertDly_2
    368                      p_tcb->TickRemain = 0u;
   \                     ??OS_TickListInsertDly_1: (+1)
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x6581             STR      R1,[R0, #+88]
    369                     *p_err             =  OS_ERR_TIME_ZERO_DLY;          /* ... do NOT delay.                                    */
   \   0000001C   0xF247 0x207E      MOVW     R0,#+29310
   \   00000020   0x8018             STRH     R0,[R3, #+0]
    370                      return;
   \   00000022   0xE033             B.N      ??OS_TickListInsertDly_3
    371                  }
    372          
    373              } else if (opt == OS_OPT_TIME_PERIODIC) {                   /* PERIODIC mode.                                       */
   \                     ??OS_TickListInsertDly_0: (+1)
   \   00000024   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000026   0x2A08             CMP      R2,#+8
   \   00000028   0xD122             BNE.N    ??OS_TickListInsertDly_4
    374                  if ((tick_ctr - p_tcb->TickCtrPrev) > time) {
   \   0000002A   0x6DC2             LDR      R2,[R0, #+92]
   \   0000002C   0x1AA2             SUBS     R2,R4,R2
   \   0000002E   0x4291             CMP      R1,R2
   \   00000030   0xD203             BCS.N    ??OS_TickListInsertDly_5
    375                      remain             = time;                          /* ... first time we load .TickCtrPrev                  */
   \   00000032   0x000A             MOVS     R2,R1
    376                      p_tcb->TickCtrPrev = tick_ctr + time;
   \   00000034   0x1909             ADDS     R1,R1,R4
   \   00000036   0x65C1             STR      R1,[R0, #+92]
   \   00000038   0xE01B             B.N      ??OS_TickListInsertDly_2
    377                  } else {
    378                      remain = time - (tick_ctr - p_tcb->TickCtrPrev);
   \                     ??OS_TickListInsertDly_5: (+1)
   \   0000003A   0x1B0A             SUBS     R2,R1,R4
   \   0000003C   0x6DC5             LDR      R5,[R0, #+92]
   \   0000003E   0x18AA             ADDS     R2,R5,R2
    379                      if ((remain > OS_TICK_TH_RDY) ||                    /* If delay time has already passed, ...                */
    380                          (remain == 0u)) {
   \   00000040   0x....             LDR.N    R5,??DataTable4_12  ;; 0xffff0001
   \   00000042   0x42AA             CMP      R2,R5
   \   00000044   0xD201             BCS.N    ??OS_TickListInsertDly_6
   \   00000046   0x2A00             CMP      R2,#+0
   \   00000048   0xD10E             BNE.N    ??OS_TickListInsertDly_7
    381                          p_tcb->TickCtrPrev += time + (time * ((tick_ctr - p_tcb->TickCtrPrev) / time)); /* Try to recover the period*/
   \                     ??OS_TickListInsertDly_6: (+1)
   \   0000004A   0x6DC2             LDR      R2,[R0, #+92]
   \   0000004C   0x6DC5             LDR      R5,[R0, #+92]
   \   0000004E   0x1B64             SUBS     R4,R4,R5
   \   00000050   0xFBB4 0xF4F1      UDIV     R4,R4,R1
   \   00000054   0xFB04 0x1101      MLA      R1,R4,R1,R1
   \   00000058   0x1889             ADDS     R1,R1,R2
   \   0000005A   0x65C1             STR      R1,[R0, #+92]
    382                          p_tcb->TickRemain   = 0u;
   \   0000005C   0x2100             MOVS     R1,#+0
   \   0000005E   0x6581             STR      R1,[R0, #+88]
    383                         *p_err               =  OS_ERR_TIME_ZERO_DLY;    /* ... do NOT delay.                                    */
   \   00000060   0xF247 0x207E      MOVW     R0,#+29310
   \   00000064   0x8018             STRH     R0,[R3, #+0]
    384                          return;
   \   00000066   0xE011             B.N      ??OS_TickListInsertDly_3
    385                      }
    386                      p_tcb->TickCtrPrev += time;
   \                     ??OS_TickListInsertDly_7: (+1)
   \   00000068   0x6DC5             LDR      R5,[R0, #+92]
   \   0000006A   0x1949             ADDS     R1,R1,R5
   \   0000006C   0x65C1             STR      R1,[R0, #+92]
   \   0000006E   0xE000             B.N      ??OS_TickListInsertDly_2
    387                  }
    388          
    389              } else {                                                    /* RELATIVE time delay mode                             */
    390                  remain = time;
   \                     ??OS_TickListInsertDly_4: (+1)
   \   00000070   0x000A             MOVS     R2,R1
    391              }
    392          
    393             *p_err = OS_ERR_NONE;
   \                     ??OS_TickListInsertDly_2: (+1)
   \   00000072   0x2100             MOVS     R1,#+0
   \   00000074   0x8019             STRH     R1,[R3, #+0]
    394          
    395              p_tcb->TaskState = OS_TASK_STATE_DLY;
   \   00000076   0x2101             MOVS     R1,#+1
   \   00000078   0xF880 0x103E      STRB     R1,[R0, #+62]
    396              OS_TickListInsert(&OSTickListDly, p_tcb, remain + (tick_ctr - OSTickCtr));
   \   0000007C   0x18A1             ADDS     R1,R4,R2
   \   0000007E   0x....             LDR.N    R2,??DataTable4
   \   00000080   0x6812             LDR      R2,[R2, #+0]
   \   00000082   0x1A8A             SUBS     R2,R1,R2
   \   00000084   0x0001             MOVS     R1,R0
   \   00000086   0x....             LDR.N    R0,??DataTable4_2
   \   00000088   0x.... 0x....      BL       OS_TickListInsert
    397          }
   \                     ??OS_TickListInsertDly_3: (+1)
   \   0000008C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    398          
    399          /*
    400          ************************************************************************************************************************
    401          *                                         REMOVE A TASK FROM THE TICK LIST
    402          *
    403          * Description: This function is called to remove a task from the tick list
    404          *
    405          * Arguments  : p_tcb          Is a pointer to the OS_TCB to remove.
    406          *              -----
    407          *
    408          * Returns    : none
    409          *
    410          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    411          *
    412          *              2) This function is assumed to be called with interrupts disabled.
    413          ************************************************************************************************************************
    414          */
    415          

   \                                 In section .text, align 2, keep-with-next
    416          void  OS_TickListRemove (OS_TCB  *p_tcb)
    417          {
   \                     OS_TickListRemove: (+1)
   \   00000000   0xB410             PUSH     {R4}
    418              OS_TICK_LIST  *p_list;
    419              OS_TCB        *p_tcb1;
    420              OS_TCB        *p_tcb2;
    421          
    422          
    423              p_list = p_tcb->TickListPtr;
   \   00000002   0x6A01             LDR      R1,[R0, #+32]
    424              p_tcb1 = p_tcb->TickPrevPtr;
   \   00000004   0x69C2             LDR      R2,[R0, #+28]
    425              p_tcb2 = p_tcb->TickNextPtr;
   \   00000006   0x6983             LDR      R3,[R0, #+24]
    426              if (p_tcb1 == DEF_NULL) {
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xD11B             BNE.N    ??OS_TickListRemove_0
    427                  if (p_tcb2 == DEF_NULL) {                               /* Remove ONLY entry in the list?                       */
   \   0000000C   0x2B00             CMP      R3,#+0
   \   0000000E   0xD108             BNE.N    ??OS_TickListRemove_1
    428                      p_list->TCB_Ptr    = DEF_NULL;
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x600A             STR      R2,[R1, #+0]
    429          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    430                      p_list->NbrEntries = 0u;
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0x808A             STRH     R2,[R1, #+4]
    431          #endif
    432                      p_tcb->TickRemain   = 0u;
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x6581             STR      R1,[R0, #+88]
    433                      p_tcb->TickListPtr  = DEF_NULL;
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x6201             STR      R1,[R0, #+32]
   \   00000020   0xE023             B.N      ??OS_TickListRemove_2
    434                  } else {
    435                      p_tcb2->TickPrevPtr = DEF_NULL;
   \                     ??OS_TickListRemove_1: (+1)
   \   00000022   0x2200             MOVS     R2,#+0
   \   00000024   0x61DA             STR      R2,[R3, #+28]
    436                      p_tcb2->TickRemain += p_tcb->TickRemain;            /* Add back the ticks to the delta                      */
   \   00000026   0x6D9A             LDR      R2,[R3, #+88]
   \   00000028   0x6D84             LDR      R4,[R0, #+88]
   \   0000002A   0x18A2             ADDS     R2,R4,R2
   \   0000002C   0x659A             STR      R2,[R3, #+88]
    437                      p_list->TCB_Ptr    = p_tcb2;
   \   0000002E   0x600B             STR      R3,[R1, #+0]
    438          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    439                      p_list->NbrEntries--;
   \   00000030   0x888A             LDRH     R2,[R1, #+4]
   \   00000032   0x1E52             SUBS     R2,R2,#+1
   \   00000034   0x808A             STRH     R2,[R1, #+4]
    440          #endif
    441                      p_tcb->TickNextPtr  = DEF_NULL;
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0x6181             STR      R1,[R0, #+24]
    442                      p_tcb->TickRemain   = 0u;
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0x6581             STR      R1,[R0, #+88]
    443                      p_tcb->TickListPtr  = DEF_NULL;
   \   0000003E   0x2100             MOVS     R1,#+0
   \   00000040   0x6201             STR      R1,[R0, #+32]
   \   00000042   0xE012             B.N      ??OS_TickListRemove_2
    444                  }
    445              } else {
    446                  p_tcb1->TickNextPtr = p_tcb2;
   \                     ??OS_TickListRemove_0: (+1)
   \   00000044   0x6193             STR      R3,[R2, #+24]
    447                  if (p_tcb2 != DEF_NULL) {
   \   00000046   0x2B00             CMP      R3,#+0
   \   00000048   0xD004             BEQ.N    ??OS_TickListRemove_3
    448                      p_tcb2->TickPrevPtr = p_tcb1;
   \   0000004A   0x61DA             STR      R2,[R3, #+28]
    449                      p_tcb2->TickRemain += p_tcb->TickRemain;            /* Add back the ticks to the delta list                 */
   \   0000004C   0x6D9A             LDR      R2,[R3, #+88]
   \   0000004E   0x6D84             LDR      R4,[R0, #+88]
   \   00000050   0x18A2             ADDS     R2,R4,R2
   \   00000052   0x659A             STR      R2,[R3, #+88]
    450                  }
    451                  p_tcb->TickPrevPtr  = DEF_NULL;
   \                     ??OS_TickListRemove_3: (+1)
   \   00000054   0x2200             MOVS     R2,#+0
   \   00000056   0x61C2             STR      R2,[R0, #+28]
    452          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    453                  p_list->NbrEntries--;
   \   00000058   0x888A             LDRH     R2,[R1, #+4]
   \   0000005A   0x1E52             SUBS     R2,R2,#+1
   \   0000005C   0x808A             STRH     R2,[R1, #+4]
    454          #endif
    455                  p_tcb->TickNextPtr  = DEF_NULL;
   \   0000005E   0x2100             MOVS     R1,#+0
   \   00000060   0x6181             STR      R1,[R0, #+24]
    456                  p_tcb->TickRemain   = 0u;
   \   00000062   0x2100             MOVS     R1,#+0
   \   00000064   0x6581             STR      R1,[R0, #+88]
    457                  p_tcb->TickListPtr  = DEF_NULL;
   \   00000066   0x2100             MOVS     R1,#+0
   \   00000068   0x6201             STR      R1,[R0, #+32]
    458              }
    459          }
   \                     ??OS_TickListRemove_2: (+1)
   \   0000006A   0xBC10             POP      {R4}
   \   0000006C   0x4770             BX       LR               ;; return
    460          
    461          /*
    462          ************************************************************************************************************************
    463          *                                           UPDATE THE LIST OF TASKS DELAYED
    464          *
    465          * Description: This function updates the delta list which contains tasks that have been delayed.
    466          *
    467          * Arguments  : ticks          the number of ticks which have elapsed.
    468          *
    469          * Returns    : none
    470          *
    471          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    472          ************************************************************************************************************************
    473          */
    474          

   \                                 In section .text, align 2, keep-with-next
    475          static  CPU_TS  OS_TickListUpdateDly (OS_TICK  ticks)
    476          {
   \                     OS_TickListUpdateDly: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4680             MOV      R8,R0
    477              OS_TCB       *p_tcb;
    478              OS_TICK_LIST *p_list;
    479          #if (OS_CFG_TS_EN == DEF_ENABLED)
    480              CPU_TS        ts_start;
    481              CPU_TS        ts_delta_dly;
    482          #endif
    483          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    484              OS_OBJ_QTY    nbr_updated;
    485          #endif
    486          
    487                                                                          /*  ========= UPDATE TASKS WAITING FOR DELAY =========  */
    488          #if (OS_CFG_TS_EN == DEF_ENABLED)
    489              ts_start    = OS_TS_GET();
   \   00000006   0x.... 0x....      BL       CPU_TS_TmrRd
   \   0000000A   0x0004             MOVS     R4,R0
    490          #endif
    491          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    492              nbr_updated = (OS_OBJ_QTY)0u;
   \   0000000C   0x2500             MOVS     R5,#+0
    493          #endif
    494              p_list      = &OSTickListDly;
   \   0000000E   0x....             LDR.N    R6,??DataTable4_2
    495              p_tcb       = p_list->TCB_Ptr;
   \   00000010   0x6837             LDR      R7,[R6, #+0]
    496              if (p_tcb != DEF_NULL) {
   \   00000012   0x2F00             CMP      R7,#+0
   \   00000014   0xD02F             BEQ.N    ??OS_TickListUpdateDly_0
    497                  if (p_tcb->TickRemain <= ticks) {
   \   00000016   0x6DB8             LDR      R0,[R7, #+88]
   \   00000018   0x4580             CMP      R8,R0
   \   0000001A   0xD305             BCC.N    ??OS_TickListUpdateDly_1
    498                      ticks = ticks - p_tcb->TickRemain;
   \   0000001C   0x6DB8             LDR      R0,[R7, #+88]
   \   0000001E   0xEBB8 0x0800      SUBS     R8,R8,R0
    499                      p_tcb->TickRemain = 0u;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x65B8             STR      R0,[R7, #+88]
   \   00000026   0xE009             B.N      ??OS_TickListUpdateDly_2
    500                  } else {
    501                      p_tcb->TickRemain -= ticks;
   \                     ??OS_TickListUpdateDly_1: (+1)
   \   00000028   0x6DB8             LDR      R0,[R7, #+88]
   \   0000002A   0xEBB0 0x0008      SUBS     R0,R0,R8
   \   0000002E   0x65B8             STR      R0,[R7, #+88]
   \   00000030   0xE004             B.N      ??OS_TickListUpdateDly_2
    502                  }
    503          
    504                  while (p_tcb->TickRemain == 0u) {
    505          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    506                      nbr_updated++;                                      /* Keep track of the number of TCBs updated             */
    507          #endif
    508                      if (p_tcb->TaskState == OS_TASK_STATE_DLY) {
    509                          p_tcb->TaskState = OS_TASK_STATE_RDY;
    510                          OS_RdyListInsert(p_tcb);                        /* Insert the task in the ready list                    */
    511          
    512                      } else {
    513                          if (p_tcb->TaskState == OS_TASK_STATE_DLY_SUSPENDED) {
    514                              p_tcb->TaskState = OS_TASK_STATE_SUSPENDED;
    515                          }
    516                      }
    517          
    518                      p_list->TCB_Ptr = p_tcb->TickNextPtr;
    519                      p_tcb           = p_list->TCB_Ptr;                  /* Get 'p_tcb' again for loop                           */
    520                      if (p_tcb == DEF_NULL) {
    521          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    522                          p_list->NbrEntries = 0u;
    523          #endif
    524                          break;
    525                      } else {
    526          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    527                          p_list->NbrEntries--;
    528          #endif
    529                          p_tcb->TickPrevPtr = DEF_NULL;
    530                      }
    531          
    532                      if (p_tcb->TickRemain <= ticks) {
    533                          ticks = ticks - p_tcb->TickRemain;
   \                     ??OS_TickListUpdateDly_3: (+1)
   \   00000032   0x6DB8             LDR      R0,[R7, #+88]
   \   00000034   0xEBB8 0x0800      SUBS     R8,R8,R0
    534                          p_tcb->TickRemain = 0u;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x65B8             STR      R0,[R7, #+88]
    535                      } else {
   \                     ??OS_TickListUpdateDly_2: (+1)
   \   0000003C   0x6DB8             LDR      R0,[R7, #+88]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD119             BNE.N    ??OS_TickListUpdateDly_0
   \   00000042   0x1C6D             ADDS     R5,R5,#+1
   \   00000044   0xF897 0x003E      LDRB     R0,[R7, #+62]
   \   00000048   0x2801             CMP      R0,#+1
   \   0000004A   0xD106             BNE.N    ??OS_TickListUpdateDly_4
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xF887 0x003E      STRB     R0,[R7, #+62]
   \   00000052   0x0038             MOVS     R0,R7
   \   00000054   0x.... 0x....      BL       OS_RdyListInsert
   \   00000058   0xE006             B.N      ??OS_TickListUpdateDly_5
   \                     ??OS_TickListUpdateDly_4: (+1)
   \   0000005A   0xF897 0x003E      LDRB     R0,[R7, #+62]
   \   0000005E   0x2805             CMP      R0,#+5
   \   00000060   0xD102             BNE.N    ??OS_TickListUpdateDly_5
   \   00000062   0x2004             MOVS     R0,#+4
   \   00000064   0xF887 0x003E      STRB     R0,[R7, #+62]
   \                     ??OS_TickListUpdateDly_5: (+1)
   \   00000068   0x69B8             LDR      R0,[R7, #+24]
   \   0000006A   0x6030             STR      R0,[R6, #+0]
   \   0000006C   0x6837             LDR      R7,[R6, #+0]
   \   0000006E   0x2F00             CMP      R7,#+0
   \   00000070   0xD107             BNE.N    ??OS_TickListUpdateDly_6
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x80B0             STRH     R0,[R6, #+4]
    536                          p_tcb->TickRemain -= ticks;
    537                      }
    538                  }
    539              }
    540          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    541              p_list->NbrUpdated = nbr_updated;
   \                     ??OS_TickListUpdateDly_0: (+1)
   \   00000076   0x80F5             STRH     R5,[R6, #+6]
    542          #endif
    543          #if (OS_CFG_TS_EN == DEF_ENABLED)
    544              ts_delta_dly       = OS_TS_GET() - ts_start;                /* Measure execution time of the update                 */
   \   00000078   0x.... 0x....      BL       CPU_TS_TmrRd
   \   0000007C   0x1B00             SUBS     R0,R0,R4
    545          #endif
    546          
    547          #if (OS_CFG_TS_EN == DEF_ENABLED)
    548              return (ts_delta_dly);
   \   0000007E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   \                     ??OS_TickListUpdateDly_6: (+1)
   \   00000082   0x88B0             LDRH     R0,[R6, #+4]
   \   00000084   0x1E40             SUBS     R0,R0,#+1
   \   00000086   0x80B0             STRH     R0,[R6, #+4]
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0x61F8             STR      R0,[R7, #+28]
   \   0000008C   0x6DB8             LDR      R0,[R7, #+88]
   \   0000008E   0x4580             CMP      R8,R0
   \   00000090   0xD2CF             BCS.N    ??OS_TickListUpdateDly_3
   \   00000092   0x6DB8             LDR      R0,[R7, #+88]
   \   00000094   0xEBB0 0x0008      SUBS     R0,R0,R8
   \   00000098   0x65B8             STR      R0,[R7, #+88]
   \   0000009A   0xE7CF             B.N      ??OS_TickListUpdateDly_2
    549          #else
    550              return (0u);
    551          #endif
    552          }
    553          
    554          
    555          /*
    556          ************************************************************************************************************************
    557          *                                       UPDATE THE LIST OF TASKS PENDING WITH TIMEOUT
    558          *
    559          * Description: This function updates the delta list which contains tasks that are pending with a timeout.
    560          *
    561          * Arguments  : ticks          the number of ticks which have elapsed.
    562          *
    563          * Returns    : none
    564          *
    565          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    566          ************************************************************************************************************************
    567          */
    568          

   \                                 In section .text, align 2, keep-with-next
    569          static  CPU_TS  OS_TickListUpdateTimeout (OS_TICK  ticks)
    570          {
   \                     OS_TickListUpdateTimeout: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4680             MOV      R8,R0
    571              OS_TCB       *p_tcb;
    572              OS_TICK_LIST *p_list;
    573          #if (OS_CFG_TS_EN == DEF_ENABLED)
    574              CPU_TS        ts_start;
    575              CPU_TS        ts_delta_timeout;
    576          #endif
    577          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    578              OS_OBJ_QTY    nbr_updated;
    579          #endif
    580          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
    581              OS_TCB       *p_tcb_owner;
    582              OS_PRIO       prio_new;
    583          #endif
    584          
    585                                                                          /*  ======= UPDATE TASKS WAITING WITH TIMEOUT ========  */
    586          #if (OS_CFG_TS_EN == DEF_ENABLED)
    587              ts_start    = OS_TS_GET();
   \   00000006   0x.... 0x....      BL       CPU_TS_TmrRd
   \   0000000A   0x0004             MOVS     R4,R0
    588          #endif
    589          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    590              nbr_updated = 0u;
   \   0000000C   0x2500             MOVS     R5,#+0
    591          #endif
    592              p_list      = &OSTickListTimeout;
   \   0000000E   0x....             LDR.N    R6,??DataTable4_3
    593              p_tcb       = p_list->TCB_Ptr;
   \   00000010   0x6837             LDR      R7,[R6, #+0]
    594              if (p_tcb != DEF_NULL) {
   \   00000012   0x2F00             CMP      R7,#+0
   \   00000014   0xD06D             BEQ.N    ??OS_TickListUpdateTimeout_0
    595                  if (p_tcb->TickRemain <= ticks) {
   \   00000016   0x6DB8             LDR      R0,[R7, #+88]
   \   00000018   0x4580             CMP      R8,R0
   \   0000001A   0xD305             BCC.N    ??OS_TickListUpdateTimeout_1
    596                      ticks = ticks - p_tcb->TickRemain;
   \   0000001C   0x6DB8             LDR      R0,[R7, #+88]
   \   0000001E   0xEBB8 0x0800      SUBS     R8,R8,R0
    597                      p_tcb->TickRemain = 0u;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x65B8             STR      R0,[R7, #+88]
   \   00000026   0xE009             B.N      ??OS_TickListUpdateTimeout_2
    598                  } else {
    599                      p_tcb->TickRemain -= ticks;
   \                     ??OS_TickListUpdateTimeout_1: (+1)
   \   00000028   0x6DB8             LDR      R0,[R7, #+88]
   \   0000002A   0xEBB0 0x0008      SUBS     R0,R0,R8
   \   0000002E   0x65B8             STR      R0,[R7, #+88]
   \   00000030   0xE004             B.N      ??OS_TickListUpdateTimeout_2
    600                  }
    601          
    602                  while (p_tcb->TickRemain == 0u) {
    603          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    604                      nbr_updated++;
    605          #endif
    606          
    607          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
    608                      p_tcb_owner = (OS_TCB *)DEF_NULL;
    609                      if (p_tcb->PendOn == OS_TASK_PEND_ON_MUTEX) {
    610                          p_tcb_owner = (OS_TCB *)((OS_MUTEX *)p_tcb->PendObjPtr)->OwnerTCBPtr;
    611                      }
    612          #endif
    613          
    614          #if (OS_MSG_EN == DEF_ENABLED)
    615                      p_tcb->MsgPtr  = DEF_NULL;
    616                      p_tcb->MsgSize = 0u;
    617          #endif
    618          #if (OS_CFG_TS_EN == DEF_ENABLED)
    619                      p_tcb->TS      = OS_TS_GET();
    620          #endif
    621                      OS_PendListRemove(p_tcb);                           /* Remove task from pend list                           */
    622                      if (p_tcb->TaskState == OS_TASK_STATE_PEND_TIMEOUT) {
    623                          OS_RdyListInsert(p_tcb);                        /* Insert the task in the ready list                    */
    624                          p_tcb->TaskState  = OS_TASK_STATE_RDY;
    625          
    626                      } else {
    627                          if (p_tcb->TaskState == OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED) {
    628                              p_tcb->TaskState  = OS_TASK_STATE_SUSPENDED;
    629                          }
    630                      }
    631                      p_tcb->PendStatus = OS_STATUS_PEND_TIMEOUT;         /* Indicate pend timed out                              */
    632                      p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                           */
    633          
    634          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
    635                      if (p_tcb_owner != DEF_NULL) {
    636                          if ((p_tcb_owner->Prio != p_tcb_owner->BasePrio) &&
    637                              (p_tcb_owner->Prio == p_tcb->Prio)) {       /* Has the owner inherited a priority?                  */
    638                              prio_new = OS_MutexGrpPrioFindHighest(p_tcb_owner);
    639                              prio_new = (prio_new > p_tcb_owner->BasePrio) ? p_tcb_owner->BasePrio : prio_new;
    640                              if(prio_new != p_tcb_owner->Prio) {
    641                                  OS_TaskChangePrio(p_tcb_owner, prio_new);
    642                                  OS_TRACE_MUTEX_TASK_PRIO_DISINHERIT(p_tcb_owner, p_tcb_owner->Prio);
    643                              }
    644                          }
    645                      }
    646          #endif
    647          
    648                      p_list->TCB_Ptr = p_tcb->TickNextPtr;
    649                      p_tcb           = p_list->TCB_Ptr;                  /* Get 'p_tcb' again for loop                           */
    650                      if (p_tcb == DEF_NULL) {
    651          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    652                          p_list->NbrEntries = 0u;
    653          #endif
    654                          break;
    655                      } else {
    656          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    657                          p_list->NbrEntries--;
    658          #endif
    659                          p_tcb->TickPrevPtr = DEF_NULL;
    660                      }
    661                      if (p_tcb->TickRemain <= ticks) {
    662                          ticks = ticks - p_tcb->TickRemain;
   \                     ??OS_TickListUpdateTimeout_3: (+1)
   \   00000032   0x6DB8             LDR      R0,[R7, #+88]
   \   00000034   0xEBB8 0x0800      SUBS     R8,R8,R0
    663                          p_tcb->TickRemain = 0u;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x65B8             STR      R0,[R7, #+88]
    664                      } else {
   \                     ??OS_TickListUpdateTimeout_2: (+1)
   \   0000003C   0x6DB8             LDR      R0,[R7, #+88]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD157             BNE.N    ??OS_TickListUpdateTimeout_0
   \   00000042   0x1C6D             ADDS     R5,R5,#+1
   \   00000044   0xF05F 0x0900      MOVS     R9,#+0
   \   00000048   0xF897 0x003C      LDRB     R0,[R7, #+60]
   \   0000004C   0x2804             CMP      R0,#+4
   \   0000004E   0xD102             BNE.N    ??OS_TickListUpdateTimeout_4
   \   00000050   0x6BB8             LDR      R0,[R7, #+56]
   \   00000052   0xF8D0 0x9024      LDR      R9,[R0, #+36]
   \                     ??OS_TickListUpdateTimeout_4: (+1)
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x6638             STR      R0,[R7, #+96]
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0xF8A7 0x0064      STRH     R0,[R7, #+100]
   \   00000060   0x.... 0x....      BL       CPU_TS_TmrRd
   \   00000064   0x6538             STR      R0,[R7, #+80]
   \   00000066   0x0038             MOVS     R0,R7
   \   00000068   0x.... 0x....      BL       OS_PendListRemove
   \   0000006C   0xF897 0x003E      LDRB     R0,[R7, #+62]
   \   00000070   0x2803             CMP      R0,#+3
   \   00000072   0xD106             BNE.N    ??OS_TickListUpdateTimeout_5
   \   00000074   0x0038             MOVS     R0,R7
   \   00000076   0x.... 0x....      BL       OS_RdyListInsert
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0xF887 0x003E      STRB     R0,[R7, #+62]
   \   00000080   0xE006             B.N      ??OS_TickListUpdateTimeout_6
   \                     ??OS_TickListUpdateTimeout_5: (+1)
   \   00000082   0xF897 0x003E      LDRB     R0,[R7, #+62]
   \   00000086   0x2807             CMP      R0,#+7
   \   00000088   0xD102             BNE.N    ??OS_TickListUpdateTimeout_6
   \   0000008A   0x2004             MOVS     R0,#+4
   \   0000008C   0xF887 0x003E      STRB     R0,[R7, #+62]
   \                     ??OS_TickListUpdateTimeout_6: (+1)
   \   00000090   0x2003             MOVS     R0,#+3
   \   00000092   0xF887 0x003D      STRB     R0,[R7, #+61]
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0xF887 0x003C      STRB     R0,[R7, #+60]
   \   0000009C   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000A0   0xD020             BEQ.N    ??OS_TickListUpdateTimeout_7
   \   000000A2   0xF899 0x003F      LDRB     R0,[R9, #+63]
   \   000000A6   0xF899 0x1040      LDRB     R1,[R9, #+64]
   \   000000AA   0x4288             CMP      R0,R1
   \   000000AC   0xD01A             BEQ.N    ??OS_TickListUpdateTimeout_7
   \   000000AE   0xF899 0x003F      LDRB     R0,[R9, #+63]
   \   000000B2   0xF897 0x103F      LDRB     R1,[R7, #+63]
   \   000000B6   0x4288             CMP      R0,R1
   \   000000B8   0xD114             BNE.N    ??OS_TickListUpdateTimeout_7
   \   000000BA   0x4648             MOV      R0,R9
   \   000000BC   0x.... 0x....      BL       OS_MutexGrpPrioFindHighest
   \   000000C0   0x0001             MOVS     R1,R0
   \   000000C2   0xF899 0x0040      LDRB     R0,[R9, #+64]
   \   000000C6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000C8   0x4288             CMP      R0,R1
   \   000000CA   0xD202             BCS.N    ??OS_TickListUpdateTimeout_8
   \   000000CC   0xF899 0x1040      LDRB     R1,[R9, #+64]
   \   000000D0   0xE7FF             B.N      ??OS_TickListUpdateTimeout_9
   \                     ??OS_TickListUpdateTimeout_8: (+1)
   \                     ??OS_TickListUpdateTimeout_9: (+1)
   \   000000D2   0xF899 0x003F      LDRB     R0,[R9, #+63]
   \   000000D6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000D8   0x4281             CMP      R1,R0
   \   000000DA   0xD003             BEQ.N    ??OS_TickListUpdateTimeout_7
   \   000000DC   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000DE   0x4648             MOV      R0,R9
   \   000000E0   0x.... 0x....      BL       OS_TaskChangePrio
   \                     ??OS_TickListUpdateTimeout_7: (+1)
   \   000000E4   0x69B8             LDR      R0,[R7, #+24]
   \   000000E6   0x6030             STR      R0,[R6, #+0]
   \   000000E8   0x6837             LDR      R7,[R6, #+0]
   \   000000EA   0x2F00             CMP      R7,#+0
   \   000000EC   0xD107             BNE.N    ??OS_TickListUpdateTimeout_10
   \   000000EE   0x2000             MOVS     R0,#+0
   \   000000F0   0x80B0             STRH     R0,[R6, #+4]
    665                          p_tcb->TickRemain -= ticks;
    666                      }
    667                  }
    668              }
    669          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    670              p_list->NbrUpdated = nbr_updated;
   \                     ??OS_TickListUpdateTimeout_0: (+1)
   \   000000F2   0x80F5             STRH     R5,[R6, #+6]
    671          #endif
    672          #if (OS_CFG_TS_EN == DEF_ENABLED)
    673              ts_delta_timeout   = OS_TS_GET() - ts_start;                /* Measure execution time of the update                 */
   \   000000F4   0x.... 0x....      BL       CPU_TS_TmrRd
   \   000000F8   0x1B00             SUBS     R0,R0,R4
    674          #endif
    675          
    676          #if (OS_CFG_TS_EN == DEF_ENABLED)
    677              return (ts_delta_timeout);
   \   000000FA   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   \                     ??OS_TickListUpdateTimeout_10: (+1)
   \   000000FE   0x88B0             LDRH     R0,[R6, #+4]
   \   00000100   0x1E40             SUBS     R0,R0,#+1
   \   00000102   0x80B0             STRH     R0,[R6, #+4]
   \   00000104   0x2000             MOVS     R0,#+0
   \   00000106   0x61F8             STR      R0,[R7, #+28]
   \   00000108   0x6DB8             LDR      R0,[R7, #+88]
   \   0000010A   0x4580             CMP      R8,R0
   \   0000010C   0xD291             BCS.N    ??OS_TickListUpdateTimeout_3
   \   0000010E   0x6DB8             LDR      R0,[R7, #+88]
   \   00000110   0xEBB0 0x0008      SUBS     R0,R0,R8
   \   00000114   0x65B8             STR      R0,[R7, #+88]
   \   00000116   0xE791             B.N      ??OS_TickListUpdateTimeout_2
    678          #else
    679              return (0u);
    680          #endif
    681          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     OSTickCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x........         DC32     OSTickTaskTimeMax

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x........         DC32     OSTickListDly

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x........         DC32     OSTickListTimeout

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x........         DC32     OSCfg_TickTaskStkBasePtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x........         DC32     OSCfg_TickTaskStkSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   0x........         DC32     OSCfg_StkSizeMin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \   00000000   0x........         DC32     OSCfg_TickTaskPrio

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_8:
   \   00000000   0x........         DC32     OSCfg_TickTaskStkLimit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_9:
   \   00000000   0x........         DC32     OS_TickTask

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_10:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_11:
   \   00000000   0x........         DC32     OSTickTaskTCB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_12:
   \   00000000   0xFFFF0001         DC32     0xffff0001

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x75 0x43          DC8 "uC/OS-III Tick Task"
   \              0x2F 0x4F    
   \              0x53 0x2D    
   \              0x49 0x49    
   \              0x49 0x20    
   \              0x54 0x69    
   \              0x63 0x6B    
   \              0x20 0x54    
   \              0x61 0x73    
   \              0x6B 0x00    
    682          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   OS_TickListInsert
      16   OS_TickListInsertDly
        16   -> OS_TickListInsert
       4   OS_TickListRemove
      24   OS_TickListUpdateDly
        24   -> CPU_TS_TmrRd
        24   -> OS_RdyListInsert
      32   OS_TickListUpdateTimeout
        32   -> CPU_TS_TmrRd
        32   -> OS_MutexGrpPrioFindHighest
        32   -> OS_PendListRemove
        32   -> OS_RdyListInsert
        32   -> OS_TaskChangePrio
      24   OS_TickTask
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OSTaskSemPend
        24   -> OS_TickListUpdateDly
        24   -> OS_TickListUpdateTimeout
      40   OS_TickTaskInit
        40   -> OSTaskCreate


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_10
       4  ??DataTable4_11
       4  ??DataTable4_12
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
      20  ?_0
     136  OS_TickListInsert
     142  OS_TickListInsertDly
     110  OS_TickListRemove
     156  OS_TickListUpdateDly
     280  OS_TickListUpdateTimeout
      96  OS_TickTask
     184  OS_TickTaskInit

 
    20 bytes in section .rodata
 1 156 bytes in section .text
 
 1 156 bytes of CODE  memory
    20 bytes of CONST memory

Errors: none
Warnings: none
