###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       15/Jul/2018  10:36:23
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC210\NC210-200处理板\source\Software\uC-MB\Cfg\Template\MB_DATA.C
#    Command line =  
#        F:\iar\NC210\NC210-200处理板\source\Software\uC-MB\Cfg\Template\MB_DATA.C
#        -D USE_STDPERIPH_DRIVER -D APP_RELEASE -lCN
#        F:\iar\NC210\NC210-200处理板\project\app_release\List -o
#        F:\iar\NC210\NC210-200处理板\project\app_release\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC210\NC210-200处理板\project\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\config\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\task\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\user\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\OS\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\Ports\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\driver\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-LIB\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Source\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\ST\STM32\inc\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Ports\STM32\STM32F103\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Source\
#        -Ol --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC210\NC210-200处理板\project\app_release\List\MB_DATA.lst
#    Object file  =  
#        F:\iar\NC210\NC210-200处理板\project\app_release\Obj\MB_DATA.o
#
###############################################################################

F:\iar\NC210\NC210-200处理板\source\Software\uC-MB\Cfg\Template\MB_DATA.C
      1          /*
      2          *********************************************************************************************************
      3          *                                              uC/Modbus
      4          *                                       The Embedded Modbus Stack
      5          *
      6          *                          (c) Copyright 2003-2009; Micrium, Inc.; Weston, FL
      7          *
      8          *               All rights reserved.  Protected by international copyright laws.
      9          *               Knowledge of the source code may NOT be used to develop a similar product.
     10          *               Please help us continue to provide the Embedded community with the finest
     11          *               software available.  Your honesty is greatly appreciated.
     12          *********************************************************************************************************
     13          */
     14          
     15          /*
     16          *********************************************************************************************************
     17          *
     18          *                         uC/MODBUS TARGET SPECIFIC DATA ACCESS FUNCTIONS (Template)
     19          *
     20          * Filename      : mb_data.c
     21          * Version       : V2.12
     22          * Programmer(s) : JJL
     23          *********************************************************************************************************
     24          * Note(s)       :
     25          *********************************************************************************************************
     26          */
     27          
     28          
     29          #include <mb.h>
     30          #include "includes.h"
     31          
     32          
     33          						 
     34          
     35          
     36          /*$PAGE*/
     37          /*
     38          *********************************************************************************************************
     39          *                                     GET THE VALUE OF A SINGLE COIL
     40          *
     41          * Description: This function returns the value of a single coil.
     42          *              It is called by 'MBS_FC01_CoilRd()'.
     43          *              You must 'map' the 'coil' to the actual application's coil.
     44          *
     45          * Arguments  : coil     is the coil number that is being requested.
     46          *
     47          *              perr     is a pointer to an error code variable.  You must either return:
     48          *
     49          *                       MODBUS_ERR_NONE     the specified coil is valid and you are returning its value.
     50          *                       MODBUS_ERR_RANGE    the specified coil is an invalid coil number in your
     51          *                                           application (i.e. product).  YOUR product defines what the
     52          *                                           valid range of values is for the 'coil' argument.
     53          *
     54          * Note(s)    : 1) You can perform the mapping of coil number to application coils directly in this
     55          *                 function or via a table lookup.  A table lookup would make sense if you had a lot of
     56          *                 coils in your product.
     57          *********************************************************************************************************
     58          */
     59          
     60          #if (MODBUS_CFG_FC01_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
     61          CPU_BOOLEAN  MB_CoilRd (CPU_INT16U   coil,
     62                                  CPU_INT16U  *perr)
     63          {
   \                     MB_CoilRd: (+1)
   \   00000000   0xB410             PUSH     {R4}
     64              /***********************************************
     65              * 描述： 密码确认，通讯前先将MB_DATA_ACC_PASSWORD写入reg0
     66              */
     67          //    if ( Ctrl.Para.dat.Password != MB_DATA_ACC_PASSWORD ) {
     68          //    if ( Ctrl.buf.Password != MB_DATA_ACC_PASSWORD ) {
     69          //        *perr = MODBUS_ERR_ILLEGAL_DATA_ADDR;
     70          //        return 0;
     71          //    }
     72              
     73              CPU_BOOLEAN     coil_val;
     74              CPU_INT16U      reg         = coil / 16;        // 获取当前寄存器
   \   00000002   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000004   0x2210             MOVS     R2,#+16
   \   00000006   0xFB90 0xF2F2      SDIV     R2,R0,R2
     75              CPU_INT08U      bit         = coil % 16;        // 获取当前寄存器的位
   \   0000000A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000000C   0x2410             MOVS     R4,#+16
   \   0000000E   0xFB90 0xF3F4      SDIV     R3,R0,R4
   \   00000012   0xFB03 0x0314      MLS      R3,R3,R4,R0
     76              CPU_INT16U      reg_val;
     77              //CPU_INT16U      *preg       = (CPU_INT16U *) Ctrl.Para.buf2;
     78              //CPU_INT16U *preg       = (CPU_INT16U *)& Ctrl.Para.buf2[0];
     79              
     80              CPU_INT16U *preg       = (CPU_INT16U *)& Ctrl.buf;
   \   00000016   0x....             LDR.N    R0,??DataTable3
     81              /***********************************************
     82              * 描述： 获取值
     83              */
     84              if ( reg < sizeof(Ctrl.buf) / 2 ) {
   \   00000018   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000001A   0xF5B2 0x7F00      CMP      R2,#+512
   \   0000001E   0xD205             BCS.N    ??MB_CoilRd_0
     85                  reg_val = preg[reg];
   \   00000020   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000022   0xF830 0x0012      LDRH     R0,[R0, R2, LSL #+1]
     86                  *perr = MODBUS_ERR_NONE;
   \   00000026   0x2200             MOVS     R2,#+0
   \   00000028   0x800A             STRH     R2,[R1, #+0]
   \   0000002A   0xE002             B.N      ??MB_CoilRd_1
     87              } else {
     88                  reg_val = 0;
   \                     ??MB_CoilRd_0: (+1)
   \   0000002C   0x2000             MOVS     R0,#+0
     89                  *perr = MODBUS_ERR_ILLEGAL_DATA_ADDR;
   \   0000002E   0x2202             MOVS     R2,#+2
   \   00000030   0x800A             STRH     R2,[R1, #+0]
     90              }
     91                  
     92              /***********************************************
     93              * 描述： 获取当前位的值
     94              */
     95              coil_val    = (CPU_BOOLEAN)(reg_val & ( 1 << bit ) );
   \                     ??MB_CoilRd_1: (+1)
   \   00000032   0x2101             MOVS     R1,#+1
   \   00000034   0x4099             LSLS     R1,R1,R3
   \   00000036   0x4008             ANDS     R0,R1,R0
     96          
     97              return (coil_val);
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0xBC10             POP      {R4}
   \   0000003C   0x4770             BX       LR               ;; return
     98          }
     99          #endif
    100          
    101          /*
    102          *********************************************************************************************************
    103          *                                     SET THE VALUE OF A SINGLE COIL
    104          *
    105          * Description: This function changes the value of a single coil.
    106          *              It is called by 'MBS_FC05_CoilWr()' and 'MBS_FC15_CoilWrMultiple()'.
    107          *              You must 'map' the 'coil' to the actual application's coil.
    108          *
    109          * Arguments  : coil      is the coil number that needs to be changed.
    110          *
    111          *              coil_val  is the desired value of the coil.  This value can be either DEF_TRUE or DEF_FALSE with
    112          *                        DEF_TRUE indicating an energized coil.
    113          *
    114          *              perr      is a pointer to an error code variable.  You must either return:
    115          *
    116          *                        MODBUS_ERR_NONE     the specified coil is valid and your code changed the value
    117          *                                            of the coil.
    118          *                        MODBUS_ERR_RANGE    the specified coil is an invalid coil number in your
    119          *                                            application (i.e. product).  YOUR product defines what the
    120          *                                            valid range of values is for the 'coil' argument.
    121          *                        MODBUS_ERR_WR       if the device is not able to write or accept the value
    122          *
    123          * Note(s)    : 1) You can perform the mapping of coil number to application coils directly in this
    124          *                 function or via a table lookup.  A table lookup would make sense if you had a lot of
    125          *                 coils in your product.
    126          *********************************************************************************************************
    127          */
    128          
    129          #if (MODBUS_CFG_FC05_EN == DEF_ENABLED) || \
    130              (MODBUS_CFG_FC15_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    131          void  MB_CoilWr (CPU_INT16U    coil,
    132                           CPU_BOOLEAN    coil_val,
    133                           CPU_INT16U     *perr)
    134          {
   \                     MB_CoilWr: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    135          
    136              (void)coil;
    137              (void)coil_val;
    138              //CPU_SR          cpu_sr;
    139              CPU_INT16U      reg         = coil / 16;
   \   00000002   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000004   0x2310             MOVS     R3,#+16
   \   00000006   0xFB90 0xF3F3      SDIV     R3,R0,R3
    140              CPU_INT08U      bit         = coil % 16;
   \   0000000A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000000C   0x2510             MOVS     R5,#+16
   \   0000000E   0xFB90 0xF4F5      SDIV     R4,R0,R5
   \   00000012   0xFB04 0x0415      MLS      R4,R4,R5,R0
    141              CPU_INT16U      reg_val     = 0;
   \   00000016   0x2000             MOVS     R0,#+0
    142              CPU_INT16U      temp;
    143          
    144              /***********************************************
    145              * 描述： 获取当前位
    146              */
    147              reg_val         |= coil_val << bit;
   \   00000018   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001A   0x40A1             LSLS     R1,R1,R4
   \   0000001C   0x4308             ORRS     R0,R1,R0
    148              
    149              //CPU_INT16U      *preg       = (CPU_INT16U *) Ctrl.Para.buf2;
    150              CPU_INT16U *preg       = (CPU_INT16U *)& Ctrl.buf; //首地址
   \   0000001E   0x....             LDR.N    R4,??DataTable3
    151              /***********************************************
    152              * 描述： 获取值
    153              */
    154              if ( reg < sizeof(Ctrl.buf) / 2 ) {
   \   00000020   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000022   0xF5B3 0x7F00      CMP      R3,#+512
   \   00000026   0xD213             BCS.N    ??MB_CoilWr_0
    155                  /***********************************************
    156                  * 描述：
    157                  */
    158                  if ( reg < 127 ) {
   \   00000028   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000002A   0x2B7F             CMP      R3,#+127
   \   0000002C   0xDA0D             BGE.N    ??MB_CoilWr_1
    159                      int idx = reg - 0;
   \   0000002E   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
    160                      
    161                      //CPU_CRITICAL_ENTER();
    162                      temp          = preg[idx];
   \   00000030   0xF834 0x1013      LDRH     R1,[R4, R3, LSL #+1]
    163                      ( reg_val )   ? ( reg_val = reg_val | temp )
    164                          : ( reg_val =~reg_val & temp );
   \   00000034   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD002             BEQ.N    ??MB_CoilWr_2
   \   0000003A   0x4308             ORRS     R0,R1,R0
   \   0000003C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000003E   0xE002             B.N      ??MB_CoilWr_3
   \                     ??MB_CoilWr_2: (+1)
   \   00000040   0xEA31 0x0000      BICS     R0,R1,R0
   \   00000044   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
    165                          preg[idx]       = reg_val;
   \                     ??MB_CoilWr_3: (+1)
   \   00000046   0xF824 0x0013      STRH     R0,[R4, R3, LSL #+1]
    166                          //CPU_CRITICAL_EXIT();
    167                  }
    168                  *perr = MODBUS_ERR_NONE;
   \                     ??MB_CoilWr_1: (+1)
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x8010             STRH     R0,[R2, #+0]
   \   0000004E   0xE002             B.N      ??MB_CoilWr_4
    169              } else {
    170                  reg_val = 0;
   \                     ??MB_CoilWr_0: (+1)
   \   00000050   0x2000             MOVS     R0,#+0
    171                  *perr = MODBUS_ERR_ILLEGAL_DATA_ADDR;
   \   00000052   0x2002             MOVS     R0,#+2
   \   00000054   0x8010             STRH     R0,[R2, #+0]
    172              }
    173          }
   \                     ??MB_CoilWr_4: (+1)
   \   00000056   0xBC30             POP      {R4,R5}
   \   00000058   0x4770             BX       LR               ;; return
    174          #endif
    175          
    176          /*$PAGE*/
    177          /*
    178          *********************************************************************************************************
    179          *                                GET THE VALUE OF A SINGLE DISCRETE INPUT
    180          *
    181          * Description: This function reads the value of a single DI (DI means Discrete Input).
    182          *              It is called by 'MBS_FC02_DIRd()'.
    183          *              You must 'map' the 'di'  to the actual application's DI.
    184          *
    185          * Arguments  : di        is the Discrete Input number that needs to be read.
    186          *
    187          *              perr      is a pointer to an error code variable.  You must either return:
    188          *
    189          *                        MODBUS_ERR_NONE     the specified DI is valid and your code is returning its
    190          *                                            current value.
    191          *                        MODBUS_ERR_RANGE    the specified DI is an invalid Discrete Input number in your
    192          *                                            application (i.e. product).  YOUR product defines what the
    193          *                                            valid range of values is for the 'di' argument.
    194          *
    195          * Note(s)    : 1) You can perform the mapping of DI number to the application DIs directly in this function
    196          *                 or via a table lookup.  A table lookup would make sense if you had a lot of Discrete
    197          *                 Inputs in your product.
    198          *********************************************************************************************************
    199          */
    200          
    201          #if (MODBUS_CFG_FC02_EN == DEF_ENABLED)
    202          CPU_BOOLEAN  MB_DIRd (CPU_INT16U   di,
    203                                CPU_INT16U  *perr)
    204          {
    205              (void)di;
    206              *perr = MODBUS_ERR_NONE;
    207              return (DEF_FALSE);
    208          }
    209          #endif
    210          
    211          /*$PAGE*/
    212          /*
    213          *********************************************************************************************************
    214          *                               GET THE VALUE OF A SINGLE INPUT REGISTER
    215          *
    216          * Description: This function reads the value of a single Input Register.
    217          *              It is called by 'MBS_FC04_InRegRd()' when the argument 'reg' is BELOW the value set by
    218          *              the configuration constant MODBUS_CFG_FP_START_IX (see MB_CFG.H).
    219          *              You must 'map' the Input Register to the actual application's corresponding integer register.
    220          *
    221          * Arguments  : reg       is the Input Register number that needs to be read.
    222          *
    223          *              perr      is a pointer to an error code variable.  You must either return:
    224          *
    225          *                        MODBUS_ERR_NONE     the specified input register is valid and your code is
    226          *                                            returning its current value.
    227          *                        MODBUS_ERR_RANGE    the specified input register is an invalid number in your
    228          *                                            application (i.e. product).  YOUR product defines what the
    229          *                                            valid range of values is for the 'reg' argument.
    230          *
    231          * Note(s)    : 1) You can perform the mapping of input register number to the application's input registers
    232          *                 directly in this function or via a table lookup.  A table lookup would make sense if you
    233          *                 had a lot of Input Registers in your product.
    234          *              2) If your product doesn't have input registers, you could simply set '*err' to
    235          *                 MODBUS_ERR_NONE and return 0.
    236          *********************************************************************************************************
    237          */
    238          
    239          #if (MODBUS_CFG_FC04_EN == DEF_ENABLED)
    240          CPU_INT16U  MB_InRegRd (CPU_INT16U   reg,
    241                                  CPU_INT16U  *perr)
    242          {
    243              CPU_INT16U  val;
    244              //CPU_SR      cpu_sr;
    245          
    246              switch (reg) {
    247                  case 10:
    248                       //CPU_CRITICAL_ENTER();
    249                       //val = (CPU_INT16U)OSCPUUsage;
    250                       //CPU_CRITICAL_EXIT();
    251                       break;
    252          
    253                  case 11:
    254                       //CPU_CRITICAL_ENTER();
    255                       //val = (CPU_INT16U)OSCtxSwCtr;
    256                       //CPU_CRITICAL_EXIT();
    257                       break;
    258          
    259                  case 12:
    260                       //CPU_CRITICAL_ENTER();
    261                       //val = (CPU_INT16U)(OSTime >> 16);
    262                       //CPU_CRITICAL_EXIT();
    263                       break;
    264          
    265                  case 13:
    266                       //CPU_CRITICAL_ENTER();
    267                       //val = (CPU_INT16U)(OSTime & 0x0000FFFF);
    268                       //CPU_CRITICAL_EXIT();
    269                       break;
    270          
    271                  case 14:
    272                       //CPU_CRITICAL_ENTER();
    273                       //val = (CPU_INT16U)MB_ChSize;
    274                       //CPU_CRITICAL_EXIT();
    275                       break;
    276          
    277                  case 15:
    278                       //CPU_CRITICAL_ENTER();
    279                       //val = (CPU_INT16U)(MB_TotalRAMSize & 0x0000FFFF);
    280                       //CPU_CRITICAL_EXIT();
    281                       break;
    282          
    283                  default:
    284                       val = 0;
    285                       break;
    286              }
    287              *perr = MODBUS_ERR_NONE;
    288              return (val);
    289          }
    290          #endif
    291          
    292          /*
    293          *********************************************************************************************************
    294          *                     GET THE VALUE OF A SINGLE 'FLOATING-POINT' INPUT REGISTER
    295          *
    296          * Description: This function reads the value of a single Input Register.
    297          *              It is called by 'MBS_FC04_InRegRd()' when the argument 'reg' is ABOVE or equal to the
    298          *              value set the configuration constant MODBUS_CFG_FP_START_IX (see MB_CFG.H).
    299          *              You must 'map' the Input Register to the actual application's corresponding floating-point
    300          *              register.
    301          *
    302          * Arguments  : reg       is the Input Register number that needs to be read.
    303          *
    304          *              perr      is a pointer to an error code variable.  You must either return:
    305          *
    306          *                        MODBUS_ERR_NONE     the specified input register is valid and your code is
    307          *                                            returning its current value.
    308          *                        MODBUS_ERR_RANGE    the specified input register is an invalid number in your
    309          *                                            application (i.e. product).  YOUR product defines what the
    310          *                                            valid range of values is for the 'reg' argument.
    311          *
    312          * Note(s)    : 1) You can perform the mapping of input register number to the application's input registers
    313          *                 directly in this function or via a table lookup.  A table lookup would make sense if you
    314          *                 had a lot of Input Registers in your product.
    315          *              2) If your product doesn't have input registers, you could simply set '*err' to
    316          *                 MODBUS_ERR_NONE and return (CPU_FP32)0.
    317          *********************************************************************************************************
    318          */
    319          
    320          #if (MODBUS_CFG_FP_EN   == DEF_ENABLED)
    321          #if (MODBUS_CFG_FC04_EN == DEF_ENABLED)
    322          CPU_FP32  MB_InRegRdFP (CPU_INT16U   reg,
    323                                  CPU_INT16U  *perr)
    324          {
    325              (void)reg;
    326              *perr = MODBUS_ERR_NONE;
    327              return ((CPU_FP32)0);
    328          }
    329          #endif
    330          #endif
    331          
    332          /*$PAGE*/
    333          /*
    334          *********************************************************************************************************
    335          *                             GET THE VALUE OF A SINGLE HOLDING REGISTER
    336          *
    337          * Description: This function reads the value of a single Holding Register.
    338          *              It is called by 'MBS_FC03_HoldingRegRd()' when the argument 'reg' is BELOW the value set
    339          *              by the configuration constant MODBUS_CFG_FP_START_IX (see MB_CFG.H).
    340          *              You must 'map' the Holding Register to the actual application's corresponding integer register.
    341          *
    342          * Arguments  : reg       is the Holding Register number that needs to be read.
    343          *
    344          *              perr      is a pointer to an error code variable.  You must either return:
    345          *
    346          *                        MODBUS_ERR_NONE     the specified holding register is valid and your code is
    347          *                                            returning its current value.
    348          *                        MODBUS_ERR_RANGE    the specified holding register is an invalid number in your
    349          *                                            application (i.e. product).  YOUR product defines what the
    350          *                                            valid range of values is for the 'reg' argument.
    351          *
    352          * Note(s)    : 1) You can perform the mapping of holding register number to the application's holding
    353          *                 registers directly in this function or via a table lookup.  A table lookup would make
    354          *                 sense if you had a lot of Holding Registers in your product.
    355          *              2) If your product doesn't have holding registers, you could simply set '*err' to
    356          *                 MODBUS_ERR_NONE and return 0.
    357          *********************************************************************************************************
    358          */
    359          
    360          #if (MODBUS_CFG_FC03_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    361          CPU_INT16U  MB_HoldingRegRd (CPU_INT16U   reg,
    362                                       CPU_INT16U  *perr)
    363          {
    364              CPU_INT16U  reg_val;
    365              //CPU_SR      cpu_sr;
    366          
    367          
    368          //        
    369          //    CPU_INT16U *preg       = (CPU_INT16U *)& Ctrl.Para.buf2[0];
    370              CPU_INT16U *preg   	= (CPU_INT16U *)&Ctrl.buf[0];
   \                     MB_HoldingRegRd: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable3
    371              /***********************************************
    372              * 描述： 获取值
    373              */
    374              if ( reg < sizeof(Ctrl.buf) / 2 ) {
   \   00000002   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000004   0xF5B0 0x7F00      CMP      R0,#+512
   \   00000008   0xD205             BCS.N    ??MB_HoldingRegRd_0
    375                  //CPU_CRITICAL_ENTER();
    376                  reg_val = preg[reg];
   \   0000000A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000000C   0xF832 0x0010      LDRH     R0,[R2, R0, LSL #+1]
    377                  //CPU_CRITICAL_EXIT();
    378                  *perr = MODBUS_ERR_NONE;
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x800A             STRH     R2,[R1, #+0]
   \   00000014   0xE002             B.N      ??MB_HoldingRegRd_1
    379              } else {
    380                  reg_val = 0;
   \                     ??MB_HoldingRegRd_0: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
    381                  *perr = MODBUS_ERR_ILLEGAL_DATA_ADDR;
   \   00000018   0x2202             MOVS     R2,#+2
   \   0000001A   0x800A             STRH     R2,[R1, #+0]
    382              }
    383              
    384              return (reg_val);
   \                     ??MB_HoldingRegRd_1: (+1)
   \   0000001C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000001E   0x4770             BX       LR               ;; return
    385          }
    386          #endif
    387          
    388          /*$PAGE*/
    389          /*
    390          *********************************************************************************************************
    391          *                     GET THE VALUE OF A SINGLE 'FLOATING-POINT' HOLDING REGISTER
    392          *
    393          * Description: This function reads the value of a single Floating-Point Holding Register.
    394          *              It is called by 'MBS_FC03_HoldingRegRd()' when the argument 'reg' is ABOVE or equal to the
    395          *              value set by the configuration constant MODBUS_CFG_FP_START_IX (see MB_CFG.H).
    396          *              You must 'map' the Holding Register to the actual application's corresponding floating-point
    397          *              register.
    398          *
    399          * Arguments  : reg       is the Holding Register number that needs to be read.
    400          *
    401          *              perr      is a pointer to an error code variable.  You must either return:
    402          *
    403          *                        MODBUS_ERR_NONE     the specified holding register is valid and your code is
    404          *                                            returning its current value.
    405          *                        MODBUS_ERR_RANGE    the specified holding register is an invalid number in your
    406          *                                            application (i.e. product).  YOUR product defines what the
    407          *                                            valid range of values is for the 'reg' argument.
    408          *
    409          * Note(s)    : 1) You can perform the mapping of holding register number to the application's holding
    410          *                 registers directly in this function or via a table lookup.  A table lookup would make
    411          *                 sense if you had a lot of Holding Registers in your product.
    412          *              2) If your product doesn't have holding registers, you could simply set '*err' to
    413          *                 MODBUS_ERR_NONE and return 0.
    414          *********************************************************************************************************
    415          */
    416          
    417          #if (MODBUS_CFG_FP_EN   == DEF_ENABLED)
    418          #if (MODBUS_CFG_FC03_EN == DEF_ENABLED)
    419          CPU_FP32  MB_HoldingRegRdFP (CPU_INT16U   reg,
    420                                       CPU_INT16U  *perr)
    421          {
    422              (void)reg;    
    423              
    424          
    425              /***********************************************
    426              * 描述： 浮点寄存器
    427              */
    428          //    CPU_FP32   *preg        = (CPU_FP32 *)&Ctrl.Sen.Para.buf3[0];
    429              CPU_FP32   *preg        = (CPU_FP32 *)&Ctrl.buf;   //取首地址
    430              
    431              reg        = reg - MODBUS_CFG_FP_START_IX;
    432              CPU_FP32   reg_val      = 0;
    433              
    434              /***********************************************
    435              * 描述： 获取值
    436              */
    437              if ( reg < sizeof(Ctrl.buf) / 4 ) {
    438                  preg    += reg;
    439                  //CPU_SR_ALLOC();
    440                  //CPU_CRITICAL_ENTER();
    441                  reg_val     = *preg;
    442                  //CPU_CRITICAL_EXIT();
    443                  *perr = MODBUS_ERR_NONE;
    444              } else {
    445                  *perr = MODBUS_ERR_RANGE;
    446              }
    447              
    448              return ((CPU_FP32)reg_val);
    449          }
    450          #endif
    451          #endif
    452          
    453          /*$PAGE*/
    454          /*
    455          *********************************************************************************************************
    456          *                            SET THE VALUE OF A SINGLE HOLDING REGISTER
    457          *
    458          * Description: This function is called to change the value of a single Integer Holding Register.
    459          *              It is called by 'MBS_FC06_HoldingRegWr()' and 'MBS_FC16_HoldingRegWrMultiple()' when the argument
    460          *              'reg' is BELOW to the value set by the configuration constant MODBUS_CFG_FP_START_IX (see MB_CFG.H).
    461          *              You must 'map' the Holding Register to the actual application's corresponding integer register.
    462          *
    463          * Arguments  : reg       is the Holding Register number that needs to be read.
    464          *
    465          *              reg_val   is the desired value of the holding register.
    466          *                        The value is specified as an unsigned integer even though it could actually be
    467          *                        represented by a signed integer.
    468          *
    469          *              perr      is a pointer to an error code variable.  You must either return:
    470          *
    471          *                        MODBUS_ERR_NONE     the specified holding register is valid and your code is
    472          *                                            returning its current value.
    473          *                        MODBUS_ERR_RANGE    the specified holding register is an invalid number in your
    474          *                                            application (i.e. product).  YOUR product defines what the
    475          *                                            valid range of values is for the 'reg' argument.
    476          *                        MODBUS_ERR_WR       if the device is not able to write or accept the value
    477          *
    478          * Note(s)    : 1) You can perform the mapping of holding register number to the application's holding
    479          *                 registers directly in this function or via a table lookup.  A table lookup would make
    480          *                 sense if you had a lot of Holding Registers in your product.
    481          *              2) If your product doesn't have holding registers, you could simply set '*err' to
    482          *                 MODBUS_ERR_NONE and return 0.
    483          *********************************************************************************************************
    484          */
    485          #if (MODBUS_CFG_FC06_EN == DEF_ENABLED) || \
    486              (MODBUS_CFG_FC16_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    487          void  MB_HoldingRegWr (CPU_INT16U   reg,
    488                                 CPU_INT16U   reg_val,
    489                                 CPU_INT16U  *perr)
    490          {
    491              /* Access to your variable here! */
    492              (void)reg;
    493              (void)reg_val;
    494              
    495          //    CPU_INT16U *preg       = (CPU_INT16U *)& Ctrl.Para.buf2[0];
    496              CPU_INT16U *preg       = (CPU_INT16U *)&Ctrl.buf;             //取首地址
   \                     MB_HoldingRegWr: (+1)
   \   00000000   0x....             LDR.N    R3,??DataTable3
    497              
    498              /***********************************************
    499              * 描述： 在指定地址写入数据
    500              */
    501              if ( reg < sizeof(Ctrl.buf) / 2 ) {
   \   00000002   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000004   0xF5B0 0x7F00      CMP      R0,#+512
   \   00000008   0xD206             BCS.N    ??MB_HoldingRegWr_0
    502                  preg    += reg;
   \   0000000A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000000C   0xEB13 0x0340      ADDS     R3,R3,R0, LSL #+1
    503                  /***********************************************
    504                  * 描述： 写入测量模块校准参数
    505                  */    
    506                  //CPU_SR_ALLOC();
    507                  //CPU_CRITICAL_ENTER();
    508                  *preg       = reg_val;
   \   00000010   0x8019             STRH     R1,[R3, #+0]
    509                  //CPU_CRITICAL_EXIT();
    510                  *perr = MODBUS_ERR_NONE;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x8010             STRH     R0,[R2, #+0]
   \   00000016   0xE001             B.N      ??MB_HoldingRegWr_1
    511              } else {
    512                  *perr = MODBUS_ERR_ILLEGAL_DATA_ADDR;
   \                     ??MB_HoldingRegWr_0: (+1)
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0x8010             STRH     R0,[R2, #+0]
    513              }    
    514          }
   \                     ??MB_HoldingRegWr_1: (+1)
   \   0000001C   0x4770             BX       LR               ;; return
    515          #endif
    516          
    517          /*$PAGE*/
    518          /*
    519          *********************************************************************************************************
    520          *                     SET THE VALUE OF A SINGLE 'FLOATING-POINT' HOLDING REGISTER
    521          *
    522          * Description: This function is called to change the value of a single Floating-Point Holding Register.
    523          *              It is called by 'MBS_FC06_HoldingRegWr()' and 'MBS_FC16_HoldingRegWrMultiple()' when the argument
    524          *              'reg' is ABOVE or equal to the value set by the configuration constant MODBUS_CFG_FP_START_IX
    525          *              (see MB_CFG.H).
    526          *              You must 'map' the Holding Register to the actual application's corresponding floating-point
    527          *              register.
    528          *
    529          * Arguments  : reg       is the Holding Register number that needs to be read.
    530          *
    531          *              reg_val   is the desired value of the holding register.
    532          *                        The value is specified as an unsigned integer even though it could actually be
    533          *                        represented by a signed integer.
    534          *
    535          *              perr      is a pointer to an error code variable.  You must either return:
    536          *
    537          *                        MODBUS_ERR_NONE     the specified holding register is valid and your code is
    538          *                                            returning its current value.
    539          *                        MODBUS_ERR_RANGE    the specified holding register is an invalid number in your
    540          *                                            application (i.e. product).  YOUR product defines what the
    541          *                                            valid range of values is for the 'reg' argument.
    542          *                        MODBUS_ERR_WR       if the device is not able to write or accept the value
    543          *
    544          * Note(s)    : 1) You can perform the mapping of holding register number to the application's holding
    545          *                 registers directly in this function or via a table lookup.  A table lookup would make
    546          *                 sense if you had a lot of Holding Registers in your product.
    547          *              2) If your product doesn't have holding registers, you could simply set '*err' to
    548          *                 MODBUS_ERR_NONE and return 0.
    549          *********************************************************************************************************
    550          */
    551          
    552          #if (MODBUS_CFG_FP_EN    == DEF_ENABLED)
    553          #if (MODBUS_CFG_FC06_EN == DEF_ENABLED) || \
    554              (MODBUS_CFG_FC16_EN == DEF_ENABLED)
    555          void  MB_HoldingRegWrFP (CPU_INT16U   reg,
    556                                   CPU_FP32     reg_val_fp,
    557                                   CPU_INT16U  *perr)
    558          {
    559              (void)reg;
    560              (void)reg_val_fp;
    561          
    562              /***********************************************
    563              * 描述： 浮点寄存器
    564              */
    565          //    CPU_FP32   *preg      = (CPU_FP32 *)&Ctrl.Sen.Para.buf3[0];
    566              CPU_FP32   *preg       = (CPU_FP32 *)&Ctrl.buf;   //取首地址
    567          
    568              reg        = reg - MODBUS_CFG_FP_START_IX;
    569              /***********************************************
    570              * 描述： 获取值
    571              */
    572              if ( reg < sizeof(Ctrl.buf) / 4 ) {
    573                  preg    += reg;
    574                  //CPU_SR_ALLOC();
    575                  //CPU_CRITICAL_ENTER();
    576                  *preg    = reg_val_fp;
    577                  //CPU_CRITICAL_EXIT();
    578                  *perr = MODBUS_ERR_NONE;
    579              } else {
    580                  *perr = MODBUS_ERR_RANGE;
    581              }
    582          }
    583          #endif
    584          #endif
    585          
    586          /*$PAGE*/
    587          /*
    588          *********************************************************************************************************
    589          *                              GET A SINGLE ENTRY FROM A RECORD IN A FILE
    590          *
    591          * Description: This function is called to read a single integer from a file.
    592          *              As mentionned in the Modbus specifications, a file is an organization of records.
    593          *              Each file can contain up to 10,000 records (addressed from 0 to 9999).
    594          *              You must 'map' the File/Record/Ix to the actual application's corresponding data.
    595          *
    596          * Arguments  : file_nbr    is the number of the desired file.
    597          *
    598          *              record_nbr  is the desired record within the file
    599          *
    600          *              ix          is the desired entry in the specified record.
    601          *
    602          *              record_len  is the desired length of the record.  Note that this parameter is passed to
    603          *                          this function to provide the 'requested' requested length from the MODBUS command.
    604          *
    605          *              perr        is a pointer to an error code variable.  You must either return:
    606          *
    607          *                          MODBUS_ERR_NONE     the specified file/record/entry is valid and your code is
    608          *                                              returning its current value.
    609          *                          MODBUS_ERR_FILE     if the specified 'file_nbr' is not a valid file number in
    610          *                                              your product.
    611          *                          MODBUS_ERR_RECORD   if the specified 'record_nbr' is not a valid record in the
    612          *                                              specified file.
    613          *                          MODBUS_ERR_IX       if the specified 'ix' is not a valid index into the specified
    614          *                                              record.
    615          *
    616          * Note(s)    : 1) You can perform the mapping of file/record/ix to the application's data directly in
    617          *                 this function or via a table lookup.  A table lookup would make sense if you had a lot
    618          *                 data in your files.
    619          *********************************************************************************************************
    620          */
    621          
    622          #if (MODBUS_CFG_FC20_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    623          CPU_INT16U  MB_FileRd (CPU_INT16U   file_nbr,
    624                                 CPU_INT16U   record_nbr,
    625                                 CPU_INT16U   ix,
    626                                 CPU_INT08U   record_len,
    627                                 CPU_INT16U  *perr)
    628          {
    629              (void)file_nbr;
    630              (void)record_nbr;
    631              (void)ix;
    632              (void)record_len;
    633              *perr  = MODBUS_ERR_NONE;
   \                     MB_FileRd: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x9900             LDR      R1,[SP, #+0]
   \   00000004   0x8008             STRH     R0,[R1, #+0]
    634              return (0);
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x4770             BX       LR               ;; return
    635          }
    636          #endif
    637          
    638          /*$PAGE*/
    639          /*
    640          *********************************************************************************************************
    641          *                               SET A SINGLE ENTRY OF A RECORD IN A FILE
    642          *
    643          * Description: This function is called to change a single integer value in a file.
    644          *              As mentionned in the Modbus specifications, a file is an organization of records.
    645          *              Each file can contain up to 10,000 records (addressed from 0 to 9999).
    646          *              You must 'map' the File/Record/Ix to the actual application's corresponding data.
    647          *
    648          * Arguments  : file_nbr    is the number of the desired file.
    649          *
    650          *              record_nbr  is the desired record within the file
    651          *
    652          *              ix          is the desired entry in the specified record.
    653          *
    654          *              record_len  is the desired length of the record.  Note that this parameter is passed to
    655          *                          this function to provide the 'requested' requested length from the MODBUS command.
    656          *
    657          *              val         is the new value to place in the file.
    658          *
    659          *              perr        is a pointer to an error code variable.  You must either return:
    660          *
    661          *                          MODBUS_ERR_NONE     the specified file/record/entry is valid and your code is
    662          *                                              returning its current value.
    663          *                          MODBUS_ERR_FILE     if the specified 'file_nbr' is not a valid file number in
    664          *                                              your product.
    665          *                          MODBUS_ERR_RECORD   if the specified 'record_nbr' is not a valid record in the
    666          *                                              specified file.
    667          *                          MODBUS_ERR_IX       if the specified 'ix' is not a valid index into the specified
    668          *                                              record.
    669          *
    670          * Note(s)    : 1) You can perform the mapping of file/record/ix to the application's data directly in
    671          *                 this function or via a table lookup.  A table lookup would make sense if you had a lot
    672          *                 data in your files.
    673          *********************************************************************************************************
    674          */
    675          
    676          #if (MODBUS_CFG_FC21_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    677          void  MB_FileWr (CPU_INT16U   file_nbr,
    678                           CPU_INT16U   record_nbr,
    679                           CPU_INT16U   ix,
    680                           CPU_INT08U   record_len,
    681                           CPU_INT16U   val,
    682                           CPU_INT16U  *perr)
    683          {
    684              (void)file_nbr;
    685              (void)record_nbr;
    686              (void)ix;
    687              (void)record_len;
    688              (void)val;
    689              *perr = MODBUS_ERR_NONE;
   \                     MB_FileWr: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x9901             LDR      R1,[SP, #+4]
   \   00000004   0x8008             STRH     R0,[R1, #+0]
    690          }
   \   00000006   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     Ctrl
    691          #endif
    692          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   MB_CoilRd
       8   MB_CoilWr
       0   MB_FileRd
       0   MB_FileWr
       0   MB_HoldingRegRd
       0   MB_HoldingRegWr


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
      62  MB_CoilRd
      90  MB_CoilWr
      10  MB_FileRd
       8  MB_FileWr
      32  MB_HoldingRegRd
      30  MB_HoldingRegWr

 
 236 bytes in section .text
 
 236 bytes of CODE memory

Errors: none
Warnings: none
