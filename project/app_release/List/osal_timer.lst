###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       11/Jul/2018  11:13:11
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC210\NC210-200处理板\source\Software\OSAL\OS\osal_timer.c
#    Command line =  
#        F:\iar\NC210\NC210-200处理板\source\Software\OSAL\OS\osal_timer.c -D
#        USE_STDPERIPH_DRIVER -D APP_RELEASE -lCN
#        F:\iar\NC210\NC210-200处理板\project\app_release\List -o
#        F:\iar\NC210\NC210-200处理板\project\app_release\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC210\NC210-200处理板\project\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\config\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\task\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\user\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\OS\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\Ports\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\driver\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-LIB\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Source\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\ST\STM32\inc\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Ports\STM32\STM32F103\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Source\
#        -Ol --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC210\NC210-200处理板\project\app_release\List\osal_timer.lst
#    Object file  =  
#        F:\iar\NC210\NC210-200处理板\project\app_release\Obj\osal_timer.o
#
###############################################################################

F:\iar\NC210\NC210-200处理板\source\Software\OSAL\OS\osal_timer.c
      1          
      2          
      3          /*******************************************************************************
      4           *   Filename:       osal.h
      5           *   Revised:        $Date: 2013-04-17 $
      6           *   Revision:       $
      7           *   Writer:         Wuming Shen.
      8           *
      9           *   Description:
     10           *
     11           *   Notes:
     12           *
     13           *
     14           *   All copyrights reserved to Wuming Shen.
     15           *
     16           *******************************************************************************/
     17          /*******************************************************************************
     18           * INCLUDES
     19           */
     20          #include <osal.h>
     21          #include <osal_timer.h>
     22          #include <osal_event.h>
     23          #include <osal_memory.h>
     24          
     25          //#include <bsp_timer.h>
     26          
     27          #if (UCOS_EN == DEF_ENABLED ) && ( OS_VERSION > 30000U )
     28          #include <os.h>
     29          #endif
     30          
     31          #if OSAL_TIMER_EN > 0
     32          
     33          /*******************************************************************************
     34           * CONSTANTS
     35           */
     36          
     37          /*******************************************************************************
     38           * TYPEDEFS
     39           */
     40          
     41          /*******************************************************************************
     42           * MACROS
     43           */
     44          
     45          /*******************************************************************************
     46           * LOCAL VARIABLES
     47           */

   \                                 In section .bss, align 4
     48          osalTimerRec_t *timerHead;
   \                     timerHead:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
     49          byte            timerActive;                            // Flag if hw timer active
   \                     timerActive:
   \   00000000                      DS8 1
     50          #if OSAL_MEM_EN == 0

   \                                 In section .bss, align 4
     51              osalTimerRec_t osalTimer[OSAL_MAX_TIMERS];
   \                     osalTimer:
   \   00000000                      DS8 400
     52          #endif
     53          /*******************************************************************************
     54           * GLOBAL VARIABLES
     55           */
     56               
     57          /*******************************************************************************
     58           * LOCAL FUNCTIONS
     59           */
     60          void            osal_timer_activate         ( byte turn_on );
     61          osalTimerRec_t *osalFindTimer               ( osalTid task_id, osalEvt event_flag );
     62          void            osal_timer_hw_setup         ( byte turn_on );
     63          
     64          /*******************************************************************************
     65           * GLOBAL FUNCTIONS
     66           */

   \                                 In section .bss, align 4
     67          osalTime        osal_system_clock;
   \                     osal_system_clock:
   \   00000000                      DS8 4
     68          
     69          /*******************************************************************************
     70           * EXTERN VARIABLES
     71           */
     72          
     73          /******************************************************************************/
     74          
     75          /*******************************************************************************
     76           * @fn      osalTimerInit
     77           *
     78           * @brief   Initialization for the OSAL Timer System.
     79           *
     80           * @param   none
     81           *
     82           * @return
     83           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     84          void osalTimerInit( void )
     85          {
   \                     osalTimerInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     86          #if OSAL_MEM_EN == 0
     87              byte   idx;
     88              for ( idx = 0; idx < OSAL_MAX_TIMERS; idx++ ) {
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0xE023             B.N      ??osalTimerInit_0
     89                  osalTimer[idx].next         = (void *)NULL;
   \                     ??osalTimerInit_1: (+1)
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x....             LDR.N    R2,??DataTable7
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x2314             MOVS     R3,#+20
   \   0000000E   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   00000012   0x6011             STR      R1,[R2, #+0]
     90                  osalTimer[idx].task_id      = 0;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x....             LDR.N    R2,??DataTable7
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0x2314             MOVS     R3,#+20
   \   0000001C   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   00000020   0x60D1             STR      R1,[R2, #+12]
     91                  osalTimer[idx].event_flag   = 0;
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0x....             LDR.N    R2,??DataTable7
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x2314             MOVS     R3,#+20
   \   0000002A   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   0000002E   0x6051             STR      R1,[R2, #+4]
     92                  osalTimer[idx].timeout      = 0;
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0x....             LDR.N    R2,??DataTable7
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0x2314             MOVS     R3,#+20
   \   00000038   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   0000003C   0x6091             STR      R1,[R2, #+8]
     93                  osalTimer[idx].reload      = 0;
   \   0000003E   0x2100             MOVS     R1,#+0
   \   00000040   0x....             LDR.N    R2,??DataTable7
   \   00000042   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   0x2314             MOVS     R3,#+20
   \   00000046   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   0000004A   0x6111             STR      R1,[R2, #+16]
     94              }
   \   0000004C   0x1C40             ADDS     R0,R0,#+1
   \                     ??osalTimerInit_0: (+1)
   \   0000004E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000050   0x2814             CMP      R0,#+20
   \   00000052   0xDBD8             BLT.N    ??osalTimerInit_1
     95          #endif
     96              timerHead   = (void *)NULL;
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x....             LDR.N    R1,??DataTable7_1
   \   00000058   0x6008             STR      R0,[R1, #+0]
     97              // Initialize the system timer
     98              osal_timer_activate( FALSE );
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x.... 0x....      BL       osal_timer_activate
     99              timerActive = FALSE;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x....             LDR.N    R1,??DataTable7_2
   \   00000064   0x7008             STRB     R0,[R1, #+0]
    100          
    101              osal_system_clock  = 0;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x....             LDR.N    R1,??DataTable7_3
   \   0000006A   0x6008             STR      R0,[R1, #+0]
    102          }
   \   0000006C   0xBD01             POP      {R0,PC}          ;; return
    103          
    104          /*******************************************************************************
    105           * @fn      osalAddTimer
    106           *
    107           * @brief   Add a timer to the timer list.
    108           *          Ints must be disabled.
    109           *
    110           * @param   task_id
    111           * @param   event_flag
    112           * @param   timeout
    113           *
    114           * @return  osalTimerRec_t * - pointer to newly created timer
    115           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    116          osalTimerRec_t *osalAddTimer( osalTid task_id, osalFlg event_flag, osalTime timeout )
    117          {
   \                     osalAddTimer: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    118              osalTimerRec_t  *newTimer;
    119              osalTimerRec_t  *srchTimer;
    120              // Look for an existing timer first
    121              newTimer = osalFindTimer( task_id, event_flag );
   \   00000008   0x0029             MOVS     R1,R5
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       osalFindTimer
    122              if ( newTimer ) {
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD001             BEQ.N    ??osalAddTimer_0
    123                  // Timer is found - update it.
    124                  newTimer->timeout = timeout;
   \   00000014   0x6086             STR      R6,[R0, #+8]
    125          
    126                  return ( newTimer );
   \   00000016   0xE02A             B.N      ??osalAddTimer_1
    127              } else {
    128                  // New Timer
    129          #if OSAL_MEM_EN > 0
    130                  newTimer = osal_mem_alloc( sizeof( osalTimerRec_t ) );
    131          #else
    132                  byte           idx;
    133                  for ( idx = 0; idx < OSAL_MAX_TIMERS; idx++ ) {
   \                     ??osalAddTimer_0: (+1)
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0xE000             B.N      ??osalAddTimer_2
   \                     ??osalAddTimer_3: (+1)
   \   0000001C   0x1C49             ADDS     R1,R1,#+1
   \                     ??osalAddTimer_2: (+1)
   \   0000001E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000020   0x2914             CMP      R1,#+20
   \   00000022   0xDA0C             BGE.N    ??osalAddTimer_4
    134                      if ( !osalTimer[idx].event_flag ) {
   \   00000024   0x....             LDR.N    R2,??DataTable7
   \   00000026   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000028   0x2314             MOVS     R3,#+20
   \   0000002A   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   0000002E   0x6852             LDR      R2,[R2, #+4]
   \   00000030   0x2A00             CMP      R2,#+0
   \   00000032   0xD1F3             BNE.N    ??osalAddTimer_3
    135                          newTimer    = &osalTimer[idx];
   \   00000034   0x....             LDR.N    R0,??DataTable7
   \   00000036   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000038   0x2214             MOVS     R2,#+20
   \   0000003A   0xFB02 0x0001      MLA      R0,R2,R1,R0
    136                          break;
    137                      }
    138                  }
    139          #endif
    140                  if ( newTimer ) {
   \                     ??osalAddTimer_4: (+1)
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD014             BEQ.N    ??osalAddTimer_5
    141                      // Fill in new timer
    142                      newTimer->task_id       = task_id;
   \   00000042   0x60C4             STR      R4,[R0, #+12]
    143                      newTimer->event_flag    = event_flag;
   \   00000044   0x6045             STR      R5,[R0, #+4]
    144                      newTimer->timeout       = timeout;
   \   00000046   0x6086             STR      R6,[R0, #+8]
    145                      newTimer->next          = (void *)NULL;
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0x6001             STR      R1,[R0, #+0]
    146          
    147                      // Does the timer list already exist
    148                      if ( timerHead == NULL ) {
   \   0000004C   0x....             LDR.N    R1,??DataTable7_1
   \   0000004E   0x6809             LDR      R1,[R1, #+0]
   \   00000050   0x2900             CMP      R1,#+0
   \   00000052   0xD102             BNE.N    ??osalAddTimer_6
    149                          // Start task list
    150                          timerHead = newTimer;
   \   00000054   0x....             LDR.N    R1,??DataTable7_1
   \   00000056   0x6008             STR      R0,[R1, #+0]
   \   00000058   0xE007             B.N      ??osalAddTimer_7
    151                      } else {
    152                          // Add it to the end of the timer list
    153                          srchTimer = timerHead;
   \                     ??osalAddTimer_6: (+1)
   \   0000005A   0x....             LDR.N    R1,??DataTable7_1
   \   0000005C   0x6809             LDR      R1,[R1, #+0]
   \   0000005E   0xE000             B.N      ??osalAddTimer_8
    154          
    155                          // Stop at the last record
    156                          while ( srchTimer->next )
    157                              srchTimer = srchTimer->next;
   \                     ??osalAddTimer_9: (+1)
   \   00000060   0x6809             LDR      R1,[R1, #+0]
   \                     ??osalAddTimer_8: (+1)
   \   00000062   0x680A             LDR      R2,[R1, #+0]
   \   00000064   0x2A00             CMP      R2,#+0
   \   00000066   0xD1FB             BNE.N    ??osalAddTimer_9
    158          
    159                          // Add to the list
    160                          srchTimer->next = newTimer;
   \   00000068   0x6008             STR      R0,[R1, #+0]
    161                      }
    162          
    163                      return ( newTimer );
   \                     ??osalAddTimer_7: (+1)
   \   0000006A   0xE000             B.N      ??osalAddTimer_1
    164                  } else
    165                      return ( (osalTimerRec_t *)NULL );
   \                     ??osalAddTimer_5: (+1)
   \   0000006C   0x2000             MOVS     R0,#+0
   \                     ??osalAddTimer_1: (+1)
   \   0000006E   0xBD70             POP      {R4-R6,PC}       ;; return
    166              }
    167          }
    168          
    169          /*******************************************************************************
    170           * @fn      osalFindTimer
    171           *
    172           * @brief   Find a timer in a timer list.
    173           *          Ints must be disabled.
    174           *
    175           * @param   task_id
    176           * @param   event_flag
    177           *
    178           * @return  osalTimerRec_t *
    179           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    180          osalTimerRec_t *osalFindTimer( osalTid task_id, osalFlg event_flag )
    181          {
    182              osalTimerRec_t  *srchTimer;
    183          
    184              // Head of the timer list
    185              srchTimer = timerHead;
   \                     osalFindTimer: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable7_1
   \   00000002   0x6812             LDR      R2,[R2, #+0]
   \   00000004   0xE000             B.N      ??osalFindTimer_0
    186          
    187              // Stop when found or at the end
    188              while ( srchTimer ) {
    189                  if ( srchTimer->event_flag == event_flag &&
    190                      srchTimer->task_id == task_id )
    191                      break;
    192                  // Not this one, check another
    193                  srchTimer = srchTimer->next;
   \                     ??osalFindTimer_1: (+1)
   \   00000006   0x6812             LDR      R2,[R2, #+0]
   \                     ??osalFindTimer_0: (+1)
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xD005             BEQ.N    ??osalFindTimer_2
   \   0000000C   0x6853             LDR      R3,[R2, #+4]
   \   0000000E   0x428B             CMP      R3,R1
   \   00000010   0xD1F9             BNE.N    ??osalFindTimer_1
   \   00000012   0x68D3             LDR      R3,[R2, #+12]
   \   00000014   0x4283             CMP      R3,R0
   \   00000016   0xD1F6             BNE.N    ??osalFindTimer_1
    194              }
    195              return ( srchTimer );
   \                     ??osalFindTimer_2: (+1)
   \   00000018   0x0010             MOVS     R0,R2
   \   0000001A   0x4770             BX       LR               ;; return
    196          }
    197          
    198          /*******************************************************************************
    199           * @fn      osalDeleteTimer
    200           *
    201           * @brief   Delete a timer from a timer list.
    202           *          Ints must be disabled.
    203           *
    204           * @param   table
    205           * @param   rmTimer
    206           *
    207           * @return  none
    208           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    209          void osalDeleteTimer( osalTimerRec_t *rmTimer )
    210          {
    211              osalTimerRec_t  *srchTimer;
    212          
    213              // Does the timer list really exist
    214              if ( (timerHead != NULL) && rmTimer ) {
   \                     osalDeleteTimer: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable7_1
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD023             BEQ.N    ??osalDeleteTimer_0
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD021             BEQ.N    ??osalDeleteTimer_0
    215                  // Add it to the end of the timer list
    216                  srchTimer = timerHead;
   \   0000000C   0x....             LDR.N    R1,??DataTable7_1
   \   0000000E   0x6809             LDR      R1,[R1, #+0]
    217          
    218                  // First element?
    219                  if ( srchTimer == rmTimer )  {
   \   00000010   0x4281             CMP      R1,R0
   \   00000012   0xD10A             BNE.N    ??osalDeleteTimer_1
    220                      timerHead = rmTimer->next;
   \   00000014   0x6801             LDR      R1,[R0, #+0]
   \   00000016   0x....             LDR.N    R2,??DataTable7_1
   \   00000018   0x6011             STR      R1,[R2, #+0]
    221          
    222          #if OSAL_MEM_EN > 0
    223                          osal_mem_free( rmTimer );
    224          #else
    225                          rmTimer->event_flag   = 0;
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x6041             STR      R1,[R0, #+4]
    226                          rmTimer->next         = (void *)NULL;
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x6001             STR      R1,[R0, #+0]
    227                          rmTimer->task_id      = 0;
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0x60C1             STR      R1,[R0, #+12]
   \   00000026   0xE013             B.N      ??osalDeleteTimer_0
    228          #endif
    229                  } else {
    230                      // Stop when found or at the end
    231                      while ( srchTimer->next && srchTimer->next != rmTimer ) {
    232                          srchTimer = srchTimer->next;
   \                     ??osalDeleteTimer_2: (+1)
   \   00000028   0x6809             LDR      R1,[R1, #+0]
    233                      }
   \                     ??osalDeleteTimer_1: (+1)
   \   0000002A   0x680A             LDR      R2,[R1, #+0]
   \   0000002C   0x2A00             CMP      R2,#+0
   \   0000002E   0xD002             BEQ.N    ??osalDeleteTimer_3
   \   00000030   0x680A             LDR      R2,[R1, #+0]
   \   00000032   0x4282             CMP      R2,R0
   \   00000034   0xD1F8             BNE.N    ??osalDeleteTimer_2
    234                      // Found?
    235                      if ( srchTimer->next == rmTimer ) {
   \                     ??osalDeleteTimer_3: (+1)
   \   00000036   0x680A             LDR      R2,[R1, #+0]
   \   00000038   0x4282             CMP      R2,R0
   \   0000003A   0xD109             BNE.N    ??osalDeleteTimer_0
    236                          // Fix pointers
    237                          srchTimer->next = rmTimer->next;
   \   0000003C   0x6802             LDR      R2,[R0, #+0]
   \   0000003E   0x600A             STR      R2,[R1, #+0]
    238                          // Deallocate the timer struct memory
    239          #if OSAL_MEM_EN > 0
    240                          osal_mem_free( rmTimer );
    241          #else
    242                          rmTimer->event_flag   = 0;
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0x6041             STR      R1,[R0, #+4]
    243                          rmTimer->next         = (void *)NULL;
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0x6001             STR      R1,[R0, #+0]
    244                          rmTimer->task_id      = 0;
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0x60C1             STR      R1,[R0, #+12]
    245                          rmTimer->reload       = 0;
   \   0000004C   0x2100             MOVS     R1,#+0
   \   0000004E   0x6101             STR      R1,[R0, #+16]
    246          #endif
    247                      }
    248                  }
    249              }
    250          }
   \                     ??osalDeleteTimer_0: (+1)
   \   00000050   0x4770             BX       LR               ;; return
    251          
    252          /*******************************************************************************
    253           * @fn      osal_timer_activate
    254           *
    255           * @brief
    256           *
    257           *   Turns the hardware timer on or off
    258           *
    259           * @param  byte turn_on - false - turn off, true - turn on
    260           *
    261           * @return  none
    262           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    263          void osal_timer_activate( byte turn_on )
    264          {
   \                     osal_timer_activate: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    265              osal_timer_hw_setup( turn_on );
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x.... 0x....      BL       osal_timer_hw_setup
    266              timerActive = turn_on;
   \   0000000C   0x....             LDR.N    R0,??DataTable7_2
   \   0000000E   0x7004             STRB     R4,[R0, #+0]
    267          }
   \   00000010   0xBD10             POP      {R4,PC}          ;; return
    268          
    269          /*******************************************************************************
    270           * @fn      osal_timer_hw_setup
    271           *
    272           * @brief
    273           *
    274           *   Setup the timer hardware.
    275           *
    276           * @param  byte turn_on
    277           *
    278           * @return  void
    279           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    280          void osal_timer_hw_setup( byte turn_on )
    281          {
    282              if (turn_on) {
    283                  //OSAL_TIMER_TICKSTART( ) ;
    284              } else {
    285                  //OSAL_TIMER_TICKSTOP( );
    286              }
    287          }
   \                     osal_timer_hw_setup: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    288          
    289          /*******************************************************************************
    290           * @fn      osal_start_timerEx
    291           *
    292           * @brief
    293           *
    294           *   This function is called to start a timer to expire in n mSecs.
    295           *   When the timer expires, the calling task will get the specified event.
    296           *
    297           * @param   byte taskID - task id to set timer for
    298           * @param   INT16U event_id - event to be notified with
    299           * @param   UNINT16 timeout_value - in milliseconds.
    300           *
    301           * @return  ZSUCCESS, or NO_TIMER_AVAIL.
    302           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    303          byte osal_start_timerEx( osalTid taskID, osalEvt event_id, osalTime timeout_value )
    304          {
   \                     osal_start_timerEx: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    305              halIntState_t     cpu_sr;
    306              osalTimerRec_t   *newTimer;
    307              CPU_CRITICAL_ENTER();  // Hold off interrupts.
   \   00000008   0x.... 0x....      BL       CPU_SR_Save
   \   0000000C   0x0007             MOVS     R7,R0
   \   0000000E   0x.... 0x....      BL       CPU_IntDisMeasStart
    308          
    309              // Add timer
    310              newTimer = osalAddTimer( taskID, event_id, timeout_value );
   \   00000012   0x0032             MOVS     R2,R6
   \   00000014   0x0029             MOVS     R1,R5
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x.... 0x....      BL       osalAddTimer
   \   0000001C   0x0004             MOVS     R4,R0
    311              if ( newTimer ) {
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD006             BEQ.N    ??osal_start_timerEx_0
    312                  // Does the timer need to be started?
    313                  if ( timerActive == FALSE ) {
   \   00000022   0x....             LDR.N    R0,??DataTable7_2
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD102             BNE.N    ??osal_start_timerEx_0
    314                      osal_timer_activate( TRUE );
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0x.... 0x....      BL       osal_timer_activate
    315                  }
    316              }
    317          
    318              CPU_CRITICAL_EXIT();   // Re-enable interrupts.
   \                     ??osal_start_timerEx_0: (+1)
   \   00000030   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000034   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000036   0x0038             MOVS     R0,R7
   \   00000038   0x.... 0x....      BL       CPU_SR_Restore
    319          
    320              return ( (newTimer != NULL) ? ZSUCCESS : NO_TIMER_AVAIL );
   \   0000003C   0x2C00             CMP      R4,#+0
   \   0000003E   0xD001             BEQ.N    ??osal_start_timerEx_1
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xE000             B.N      ??osal_start_timerEx_2
   \                     ??osal_start_timerEx_1: (+1)
   \   00000044   0x200C             MOVS     R0,#+12
   \                     ??osal_start_timerEx_2: (+1)
   \   00000046   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000048   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    321          }
    322          /*******************************************************************************
    323           * @fn      osal_start_timerRl
    324           *
    325           * @brief
    326           *
    327           *   This function is called to start a timer to expire in n mSecs.
    328           *   When the timer expires, the calling task will get the specified event.
    329           *
    330           * @param   byte taskID - task id to set timer for
    331           * @param   INT16U event_id - event to be notified with
    332           * @param   UNINT16 timeout_value - in milliseconds.
    333           *
    334           * @return  ZSUCCESS, or NO_TIMER_AVAIL.
    335           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    336          byte osal_start_timerRl( osalTid taskID, osalEvt event_id, osalTime timeout_value )
    337          {
   \                     osal_start_timerRl: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    338              halIntState_t     cpu_sr;
    339              osalTimerRec_t   *newTimer;
    340              // Hold off interrupts.
    341              CPU_CRITICAL_ENTER();
   \   00000008   0x.... 0x....      BL       CPU_SR_Save
   \   0000000C   0x0007             MOVS     R7,R0
   \   0000000E   0x.... 0x....      BL       CPU_IntDisMeasStart
    342          
    343              // Add timer
    344              newTimer = osalAddTimer( taskID, event_id, timeout_value );
   \   00000012   0x0032             MOVS     R2,R6
   \   00000014   0x0029             MOVS     R1,R5
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x.... 0x....      BL       osalAddTimer
   \   0000001C   0x0004             MOVS     R4,R0
    345              if ( newTimer ) {
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD008             BEQ.N    ??osal_start_timerRl_0
    346                  newTimer->reload    = newTimer->timeout;
   \   00000022   0x68A0             LDR      R0,[R4, #+8]
   \   00000024   0x6120             STR      R0,[R4, #+16]
    347                  // Does the timer need to be started?
    348                  if ( timerActive == FALSE ) {
   \   00000026   0x....             LDR.N    R0,??DataTable7_2
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD102             BNE.N    ??osal_start_timerRl_0
    349                      osal_timer_activate( TRUE );
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0x.... 0x....      BL       osal_timer_activate
    350                  }
    351              }
    352          
    353              CPU_CRITICAL_EXIT();   // Re-enable interrupts.
   \                     ??osal_start_timerRl_0: (+1)
   \   00000034   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000038   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000003A   0x0038             MOVS     R0,R7
   \   0000003C   0x.... 0x....      BL       CPU_SR_Restore
    354          
    355              return ( (newTimer != NULL) ? ZSUCCESS : NO_TIMER_AVAIL );
   \   00000040   0x2C00             CMP      R4,#+0
   \   00000042   0xD001             BEQ.N    ??osal_start_timerRl_1
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xE000             B.N      ??osal_start_timerRl_2
   \                     ??osal_start_timerRl_1: (+1)
   \   00000048   0x200C             MOVS     R0,#+12
   \                     ??osal_start_timerRl_2: (+1)
   \   0000004A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    356          }
    357          /*******************************************************************************
    358           * @fn      osal_stop_timerEx
    359           *
    360           * @brief
    361           *
    362           *   This function is called to stop a timer that has already been started.
    363           *   If ZSUCCESS, the function will cancel the timer and prevent the event
    364           *   associated with the timer from being set for the calling task.
    365           *
    366           * @param   byte task_id - task id of timer to stop
    367           * @param   INT16U event_id - identifier of the timer that is to be stopped
    368           *
    369           * @return  ZSUCCESS or INVALID_EVENT_ID
    370           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    371          byte osal_stop_timerEx( osalTid task_id, osalEvt event_id )
    372          {
   \                     osal_stop_timerEx: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    373              halIntState_t     cpu_sr;
    374              osalTimerRec_t   *foundTimer;
    375          
    376              CPU_CRITICAL_ENTER();  // Hold off interrupts.
   \   00000006   0x.... 0x....      BL       CPU_SR_Save
   \   0000000A   0x0006             MOVS     R6,R0
   \   0000000C   0x.... 0x....      BL       CPU_IntDisMeasStart
    377          
    378              // Find the timer to stop
    379              foundTimer = osalFindTimer( task_id, event_id );
   \   00000010   0x0029             MOVS     R1,R5
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       osalFindTimer
   \   00000018   0x0004             MOVS     R4,R0
    380              if ( foundTimer ) {
   \   0000001A   0x2C00             CMP      R4,#+0
   \   0000001C   0xD002             BEQ.N    ??osal_stop_timerEx_0
    381                  osalDeleteTimer( foundTimer );
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       osalDeleteTimer
    382              }
    383          
    384              CPU_CRITICAL_EXIT();   // Re-enable interrupts.
   \                     ??osal_stop_timerEx_0: (+1)
   \   00000024   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000028   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000002A   0x0030             MOVS     R0,R6
   \   0000002C   0x.... 0x....      BL       CPU_SR_Restore
    385          
    386              return ( (foundTimer != NULL) ? ZSUCCESS : INVALID_EVENT_ID );
   \   00000030   0x2C00             CMP      R4,#+0
   \   00000032   0xD001             BEQ.N    ??osal_stop_timerEx_1
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xE000             B.N      ??osal_stop_timerEx_2
   \                     ??osal_stop_timerEx_1: (+1)
   \   00000038   0x2007             MOVS     R0,#+7
   \                     ??osal_stop_timerEx_2: (+1)
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   0xBD70             POP      {R4-R6,PC}       ;; return
    387          }
    388          
    389          /*******************************************************************************
    390           * @fn      osalTimerUpdate
    391           *
    392           * @brief   Update the timer structures for a timer tick.
    393           *
    394           * @param   none
    395           *
    396           * @return  none
    397           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    398          void osalTimerUpdate( void )
    399          {
   \                     osalTimerUpdate: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    400              osalTimerRec_t  *srchTimer;
    401              osalTimerRec_t  *prevTimer;
    402              osalTimerRec_t  *saveTimer;
    403          
    404              // Update the system time
    405              osal_system_clock += OSAL_TICK_TIME_MS;
   \   00000002   0x....             LDR.N    R0,??DataTable7_3
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x1C40             ADDS     R0,R0,#+1
   \   00000008   0x....             LDR.N    R1,??DataTable7_3
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    406          
    407              // Look for open timer slot
    408              if ( timerHead != NULL ) {
   \   0000000C   0x....             LDR.N    R0,??DataTable7_1
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD032             BEQ.N    ??osalTimerUpdate_0
    409                  // Add it to the end of the timer list
    410                  srchTimer = timerHead;
   \   00000014   0x....             LDR.N    R0,??DataTable7_1
   \   00000016   0x6804             LDR      R4,[R0, #+0]
    411                  prevTimer = (void *)NULL;
   \   00000018   0x2500             MOVS     R5,#+0
   \   0000001A   0xE003             B.N      ??osalTimerUpdate_1
    412          
    413                  // Look for open timer slot
    414                  while ( srchTimer ) {
    415                      // Decrease the correct amount of time
    416                      if (srchTimer->timeout <= OSAL_TICK_TIME_MS)
    417                          srchTimer->timeout = 0;
    418                      else
    419                          srchTimer->timeout = srchTimer->timeout - OSAL_TICK_TIME_MS;
    420          
    421                      // When timeout, execute the task
    422                      if ( srchTimer->timeout == 0 ) {
    423                          osal_set_event( srchTimer->task_id, srchTimer->event_flag );
    424                          if ( srchTimer->reload ) {
    425                            // Restart srchTimer
    426                            srchTimer->timeout    = srchTimer->reload;
   \                     ??osalTimerUpdate_2: (+1)
   \   0000001C   0x6920             LDR      R0,[R4, #+16]
   \   0000001E   0x60A0             STR      R0,[R4, #+8]
    427                            prevTimer = srchTimer;
   \   00000020   0x0025             MOVS     R5,R4
    428                            // Get next
    429                            srchTimer = srchTimer->next;
   \   00000022   0x6824             LDR      R4,[R4, #+0]
    430                            continue;
    431                          }
   \                     ??osalTimerUpdate_1: (+1)
   \   00000024   0x2C00             CMP      R4,#+0
   \   00000026   0xD028             BEQ.N    ??osalTimerUpdate_0
   \   00000028   0x68A0             LDR      R0,[R4, #+8]
   \   0000002A   0x2802             CMP      R0,#+2
   \   0000002C   0xD202             BCS.N    ??osalTimerUpdate_3
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x60A0             STR      R0,[R4, #+8]
   \   00000032   0xE002             B.N      ??osalTimerUpdate_4
   \                     ??osalTimerUpdate_3: (+1)
   \   00000034   0x68A0             LDR      R0,[R4, #+8]
   \   00000036   0x1E40             SUBS     R0,R0,#+1
   \   00000038   0x60A0             STR      R0,[R4, #+8]
   \                     ??osalTimerUpdate_4: (+1)
   \   0000003A   0x68A0             LDR      R0,[R4, #+8]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD119             BNE.N    ??osalTimerUpdate_5
   \   00000040   0x6861             LDR      R1,[R4, #+4]
   \   00000042   0x68E0             LDR      R0,[R4, #+12]
   \   00000044   0x.... 0x....      BL       osal_set_event
   \   00000048   0x6920             LDR      R0,[R4, #+16]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD1E6             BNE.N    ??osalTimerUpdate_2
    432                          // Take out of list
    433                          if ( prevTimer == NULL )
   \   0000004E   0x2D00             CMP      R5,#+0
   \   00000050   0xD103             BNE.N    ??osalTimerUpdate_6
    434                              timerHead = srchTimer->next;
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x....             LDR.N    R1,??DataTable7_1
   \   00000056   0x6008             STR      R0,[R1, #+0]
   \   00000058   0xE001             B.N      ??osalTimerUpdate_7
    435                          else
    436                              prevTimer->next = srchTimer->next;
   \                     ??osalTimerUpdate_6: (+1)
   \   0000005A   0x6820             LDR      R0,[R4, #+0]
   \   0000005C   0x6028             STR      R0,[R5, #+0]
    437                          // Next
    438                          saveTimer = srchTimer->next;
   \                     ??osalTimerUpdate_7: (+1)
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
    439                          // Free memory
    440          #if OSAL_MEM_EN > 0
    441                          osal_mem_free( srchTimer );
    442          #else
    443                          srchTimer->event_flag   = 0;
   \   00000060   0x2100             MOVS     R1,#+0
   \   00000062   0x6061             STR      R1,[R4, #+4]
    444                          srchTimer->next         = (void *)NULL;
   \   00000064   0x2100             MOVS     R1,#+0
   \   00000066   0x6021             STR      R1,[R4, #+0]
    445                          srchTimer->task_id      = 0;
   \   00000068   0x2100             MOVS     R1,#+0
   \   0000006A   0x60E1             STR      R1,[R4, #+12]
    446                          srchTimer->reload       = 0;
   \   0000006C   0x2100             MOVS     R1,#+0
   \   0000006E   0x6121             STR      R1,[R4, #+16]
    447          #endif
    448                          srchTimer = saveTimer;
   \   00000070   0x0004             MOVS     R4,R0
   \   00000072   0xE7D7             B.N      ??osalTimerUpdate_1
    449                      } else {
    450                          // Get next
    451                          prevTimer = srchTimer;
   \                     ??osalTimerUpdate_5: (+1)
   \   00000074   0x0025             MOVS     R5,R4
    452                          srchTimer = srchTimer->next;
   \   00000076   0x6824             LDR      R4,[R4, #+0]
   \   00000078   0xE7D4             B.N      ??osalTimerUpdate_1
    453                      }
    454                  }
    455              }
    456          }
   \                     ??osalTimerUpdate_0: (+1)
   \   0000007A   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x........         DC32     osalTimer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x........         DC32     timerHead

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x........         DC32     timerActive

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0x........         DC32     osal_system_clock
    457          
    458          /*******************************************************************************
    459           * 				     end of file                               *
    460           *******************************************************************************/
    461          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   osalAddTimer
        16   -> osalFindTimer
       0   osalDeleteTimer
       0   osalFindTimer
       8   osalTimerInit
         8   -> osal_timer_activate
      16   osalTimerUpdate
        16   -> osal_set_event
      24   osal_start_timerEx
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> osalAddTimer
        24   -> osal_timer_activate
      24   osal_start_timerRl
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> osalAddTimer
        24   -> osal_timer_activate
      16   osal_stop_timerEx
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> osalDeleteTimer
        16   -> osalFindTimer
       8   osal_timer_activate
         8   -> osal_timer_hw_setup
       0   osal_timer_hw_setup


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
     112  osalAddTimer
      82  osalDeleteTimer
      28  osalFindTimer
     400  osalTimer
     110  osalTimerInit
     124  osalTimerUpdate
      74  osal_start_timerEx
      78  osal_start_timerRl
      62  osal_stop_timerEx
       4  osal_system_clock
      18  osal_timer_activate
       2  osal_timer_hw_setup
       1  timerActive
       4  timerHead

 
 409 bytes in section .bss
 706 bytes in section .text
 
 706 bytes of CODE memory
 409 bytes of DATA memory

Errors: none
Warnings: none
