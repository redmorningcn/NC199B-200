###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       11/Jul/2018  11:13:10
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC210\NC210-200处理板\source\Software\uCOS-III\Source\os_mutex.c
#    Command line =  
#        F:\iar\NC210\NC210-200处理板\source\Software\uCOS-III\Source\os_mutex.c
#        -D USE_STDPERIPH_DRIVER -D APP_RELEASE -lCN
#        F:\iar\NC210\NC210-200处理板\project\app_release\List -o
#        F:\iar\NC210\NC210-200处理板\project\app_release\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC210\NC210-200处理板\project\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\config\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\task\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\user\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\OS\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\Ports\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\driver\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-LIB\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Source\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\ST\STM32\inc\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Ports\STM32\STM32F103\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Source\
#        -Ol --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC210\NC210-200处理板\project\app_release\List\os_mutex.lst
#    Object file  =  
#        F:\iar\NC210\NC210-200处理板\project\app_release\Obj\os_mutex.o
#
###############################################################################

F:\iar\NC210\NC210-200处理板\source\Software\uCOS-III\Source\os_mutex.c
      1          /*
      2          ************************************************************************************************************************
      3          *                                                      uC/OS-III
      4          *                                                 The Real-Time Kernel
      5          *
      6          *                                  (c) Copyright 2009-2016; Micrium, Inc.; Weston, FL
      7          *                           All rights reserved.  Protected by international copyright laws.
      8          *
      9          *                                                   MUTEX MANAGEMENT
     10          *
     11          * File    : OS_MUTEX.C
     12          * By      : JJL
     13          * Version : V3.06.00
     14          *
     15          * LICENSING TERMS:
     16          * ---------------
     17          *           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or
     18          *           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
     19          *           product then, you need to contact Micrium to properly license uC/OS-III for its use in your
     20          *           application/product.   We provide ALL the source code for your convenience and to help you
     21          *           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use
     22          *           it commercially without paying a licensing fee.
     23          *
     24          *           Knowledge of the source code may NOT be used to develop a similar product.
     25          *
     26          *           Please help us continue to provide the embedded community with the finest software available.
     27          *           Your honesty is greatly appreciated.
     28          *
     29          *           You can find our product's user manual, API reference, release notes and
     30          *           more information at https://doc.micrium.com.
     31          *           You can contact us at www.micrium.com.
     32          ************************************************************************************************************************
     33          */
     34          
     35          #define  MICRIUM_SOURCE
     36          #include "os.h"
     37          
     38          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     39          const  CPU_CHAR  *os_mutex__c = "$Id: $";
     40          #endif
     41          
     42          
     43          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
     44          /*
     45          ************************************************************************************************************************
     46          *                                                   CREATE A MUTEX
     47          *
     48          * Description: This function creates a mutex.
     49          *
     50          * Arguments  : p_mutex       is a pointer to the mutex to initialize.  Your application is responsible for allocating
     51          *                            storage for the mutex.
     52          *
     53          *              p_name        is a pointer to the name you would like to give the mutex.
     54          *
     55          *              p_err         is a pointer to a variable that will contain an error code returned by this function.
     56          *
     57          *                                OS_ERR_NONE                    If the call was successful
     58          *                                OS_ERR_CREATE_ISR              If you called this function from an ISR
     59          *                                OS_ERR_ILLEGAL_CREATE_RUN_TIME If you are trying to create the mutex after you called
     60          *                                                                 OSSafetyCriticalStart()
     61          *                                OS_ERR_OBJ_PTR_NULL            If 'p_mutex' is a NULL pointer
     62          *
     63          * Returns    : none
     64          *
     65          * Note(s)    : none
     66          ************************************************************************************************************************
     67          */
     68          

   \                                 In section .text, align 2, keep-with-next
     69          void  OSMutexCreate (OS_MUTEX  *p_mutex,
     70                               CPU_CHAR  *p_name,
     71                               OS_ERR    *p_err)
     72          {
   \                     OSMutexCreate: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000F             MOVS     R7,R1
   \   00000006   0x0014             MOVS     R4,R2
     73              CPU_SR_ALLOC();
   \   00000008   0x2600             MOVS     R6,#+0
     74          
     75          
     76          #ifdef OS_SAFETY_CRITICAL
     77              if (p_err == DEF_NULL) {
     78                  OS_SAFETY_CRITICAL_EXCEPTION();
     79                  return;
     80              }
     81          #endif
     82          
     83          #ifdef OS_SAFETY_CRITICAL_IEC61508
     84              if (OSSafetyCriticalStartFlag == DEF_TRUE) {
     85                 *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
     86                  return;
     87              }
     88          #endif
     89          
     90          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
     91              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to be called from an ISR                 */
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable7_1
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD003             BEQ.N    ??OSMutexCreate_0
     92                 *p_err = OS_ERR_CREATE_ISR;
   \   00000014   0xF642 0x60E1      MOVW     R0,#+12001
   \   00000018   0x8020             STRH     R0,[R4, #+0]
     93                  return;
   \   0000001A   0xE02C             B.N      ??OSMutexCreate_1
     94              }
     95          #endif
     96          
     97          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
     98              if (p_mutex == DEF_NULL) {                                  /* Validate 'p_mutex'                                   */
   \                     ??OSMutexCreate_0: (+1)
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD103             BNE.N    ??OSMutexCreate_2
     99                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000020   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000024   0x8020             STRH     R0,[R4, #+0]
    100                  return;
   \   00000026   0xE026             B.N      ??OSMutexCreate_1
    101              }
    102          #endif
    103          
    104              CPU_CRITICAL_ENTER();
   \                     ??OSMutexCreate_2: (+1)
   \   00000028   0x.... 0x....      BL       CPU_SR_Save
   \   0000002C   0x0006             MOVS     R6,R0
   \   0000002E   0x.... 0x....      BL       CPU_IntDisMeasStart
    105          #if (OS_OBJ_TYPE_REQ == DEF_ENABLED)
    106              p_mutex->Type              =  OS_OBJ_TYPE_MUTEX;            /* Mark the data structure as a mutex                   */
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable7_2  ;; 0x5854554d
   \   00000036   0x6028             STR      R0,[R5, #+0]
    107          #endif
    108          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    109              p_mutex->NamePtr           =  p_name;
   \   00000038   0x606F             STR      R7,[R5, #+4]
    110          #else
    111              (void)p_name;
    112          #endif
    113              p_mutex->MutexGrpNextPtr   = DEF_NULL;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x6228             STR      R0,[R5, #+32]
    114              p_mutex->OwnerTCBPtr       = DEF_NULL;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x6268             STR      R0,[R5, #+36]
    115              p_mutex->OwnerNestingCtr   = 0u;                            /* Mutex is available                                   */
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xF885 0x0028      STRB     R0,[R5, #+40]
    116          #if (OS_CFG_TS_EN == DEF_ENABLED)
    117              p_mutex->TS                = 0u;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x62E8             STR      R0,[R5, #+44]
    118          #endif
    119              OS_PendListInit(&p_mutex->PendList);                        /* Initialize the waiting list                          */
   \   0000004C   0xF115 0x0008      ADDS     R0,R5,#+8
   \   00000050   0x.... 0x....      BL       OS_PendListInit
    120          
    121          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    122              OS_MutexDbgListAdd(p_mutex);
   \   00000054   0x0028             MOVS     R0,R5
   \   00000056   0x.... 0x....      BL       OS_MutexDbgListAdd
    123              OSMutexQty++;
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable7_3
   \   0000005E   0x8800             LDRH     R0,[R0, #+0]
   \   00000060   0x1C40             ADDS     R0,R0,#+1
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable7_3
   \   00000066   0x8008             STRH     R0,[R1, #+0]
    124          #endif
    125          
    126              OS_TRACE_MUTEX_CREATE(p_mutex, p_name);
    127              CPU_CRITICAL_EXIT();
   \   00000068   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000006C   0x0030             MOVS     R0,R6
   \   0000006E   0x.... 0x....      BL       CPU_SR_Restore
    128             *p_err = OS_ERR_NONE;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x8020             STRH     R0,[R4, #+0]
    129          }
   \                     ??OSMutexCreate_1: (+1)
   \   00000076   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    130          
    131          
    132          /*
    133          ************************************************************************************************************************
    134          *                                                   DELETE A MUTEX
    135          *
    136          * Description: This function deletes a mutex and readies all tasks pending on the mutex.
    137          *
    138          * Arguments  : p_mutex       is a pointer to the mutex to delete
    139          *
    140          *              opt           determines delete options as follows:
    141          *
    142          *                                OS_OPT_DEL_NO_PEND          Delete mutex ONLY if no task pending
    143          *                                OS_OPT_DEL_ALWAYS           Deletes the mutex even if tasks are waiting.
    144          *                                                            In this case, all the tasks pending will be readied.
    145          *
    146          *              p_err         is a pointer to a variable that will contain an error code returned by this function.
    147          *
    148          *                                OS_ERR_NONE                    The call was successful and the mutex was deleted
    149          *                                OS_ERR_DEL_ISR                 If you attempted to delete the mutex from an ISR
    150          *                                OS_ERR_ILLEGAL_DEL_RUN_TIME    If you are trying to delete the mutex after you called
    151          *                                                                 OSStart()
    152          *                                OS_ERR_OBJ_PTR_NULL            If 'p_mutex' is a NULL pointer
    153          *                                OS_ERR_OBJ_TYPE                If 'p_mutex' is not pointing to a mutex
    154          *                                OS_ERR_OPT_INVALID             An invalid option was specified
    155          *                                OS_ERR_OS_NOT_RUNNING          If uC/OS-III is not running yet
    156          *                                OS_ERR_TASK_WAITING            One or more tasks were waiting on the mutex
    157          *
    158          * Returns    : == 0          if no tasks were waiting on the mutex, or upon error.
    159          *              >  0          if one or more tasks waiting on the mutex are now readied and informed.
    160          *
    161          * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of the mutex MUST
    162          *                 check the return code of OSMutexPend().
    163          *
    164          *              2) Because ALL tasks pending on the mutex will be readied, you MUST be careful in applications where the
    165          *                 mutex is used for mutual exclusion because the resource(s) will no longer be guarded by the mutex.
    166          ************************************************************************************************************************
    167          */
    168          
    169          #if (OS_CFG_MUTEX_DEL_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    170          OS_OBJ_QTY  OSMutexDel (OS_MUTEX  *p_mutex,
    171                                  OS_OPT     opt,
    172                                  OS_ERR    *p_err)
    173          {
   \                     OSMutexDel: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0015             MOVS     R5,R2
    174              OS_OBJ_QTY     nbr_tasks;
    175              OS_PEND_LIST  *p_pend_list;
    176              OS_TCB        *p_tcb;
    177              OS_TCB        *p_tcb_owner;
    178              CPU_TS         ts;
    179          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
    180              OS_PRIO        prio_new;
    181          #endif
    182              CPU_SR_ALLOC();
   \   0000000A   0x2700             MOVS     R7,#+0
    183          
    184          
    185          #ifdef OS_SAFETY_CRITICAL
    186              if (p_err == DEF_NULL) {
    187                  OS_SAFETY_CRITICAL_EXCEPTION();
    188                  return (0u);
    189              }
    190          #endif
    191          
    192              OS_TRACE_MUTEX_DEL_ENTER(p_mutex, opt);
    193          
    194          #ifdef OS_SAFETY_CRITICAL_IEC61508
    195              if (OSSafetyCriticalStartFlag == DEF_TRUE) {
    196                  OS_TRACE_MUTEX_DEL_EXIT(OS_ERR_ILLEGAL_DEL_RUN_TIME);
    197                 *p_err = OS_ERR_ILLEGAL_DEL_RUN_TIME;
    198                  return (0u);
    199              }
    200          #endif
    201          
    202          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
    203              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to delete a mutex from an ISR            */
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable7_1
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD004             BEQ.N    ??OSMutexDel_0
    204                  OS_TRACE_MUTEX_DEL_EXIT(OS_ERR_DEL_ISR);
    205                 *p_err = OS_ERR_DEL_ISR;
   \   00000016   0xF243 0x20C9      MOVW     R0,#+13001
   \   0000001A   0x8028             STRH     R0,[R5, #+0]
    206                  return (0u);
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE098             B.N      ??OSMutexDel_1
    207              }
    208          #endif
    209          
    210          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
    211              if (OSRunning != OS_STATE_OS_RUNNING) {
    212                  OS_TRACE_MUTEX_DEL_EXIT(OS_ERR_OS_NOT_RUNNING);
    213                 *p_err = OS_ERR_OS_NOT_RUNNING;
    214                  return (0u);
    215              }
    216          #endif
    217          
    218          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
    219              if (p_mutex == DEF_NULL) {                                  /* Validate 'p_mutex'                                   */
   \                     ??OSMutexDel_0: (+1)
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD104             BNE.N    ??OSMutexDel_2
    220                  OS_TRACE_MUTEX_DEL_EXIT(OS_ERR_OBJ_PTR_NULL);
    221                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000024   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000028   0x8028             STRH     R0,[R5, #+0]
    222                  return (0u);
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xE091             B.N      ??OSMutexDel_1
    223              }
    224          #endif
    225          
    226          #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
    227              if (p_mutex->Type != OS_OBJ_TYPE_MUTEX) {                   /* Make sure mutex was created                          */
   \                     ??OSMutexDel_2: (+1)
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable7_2  ;; 0x5854554d
   \   00000034   0x4288             CMP      R0,R1
   \   00000036   0xD004             BEQ.N    ??OSMutexDel_3
    228                  OS_TRACE_MUTEX_DEL_EXIT(OS_ERR_OBJ_TYPE);
    229                 *p_err = OS_ERR_OBJ_TYPE;
   \   00000038   0xF645 0x50C4      MOVW     R0,#+24004
   \   0000003C   0x8028             STRH     R0,[R5, #+0]
    230                  return (0u);
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xE087             B.N      ??OSMutexDel_1
    231              }
    232          #endif
    233          
    234              CPU_CRITICAL_ENTER();
   \                     ??OSMutexDel_3: (+1)
   \   00000042   0x.... 0x....      BL       CPU_SR_Save
   \   00000046   0x0007             MOVS     R7,R0
   \   00000048   0x.... 0x....      BL       CPU_IntDisMeasStart
    235              p_pend_list = &p_mutex->PendList;
   \   0000004C   0xF114 0x0908      ADDS     R9,R4,#+8
    236              nbr_tasks   = 0u;
   \   00000050   0xF05F 0x0800      MOVS     R8,#+0
    237              switch (opt) {
   \   00000054   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000056   0x2E00             CMP      R6,#+0
   \   00000058   0xD002             BEQ.N    ??OSMutexDel_4
   \   0000005A   0x2E01             CMP      R6,#+1
   \   0000005C   0xD029             BEQ.N    ??OSMutexDel_5
   \   0000005E   0xE06E             B.N      ??OSMutexDel_6
    238                  case OS_OPT_DEL_NO_PEND:                                /* Delete mutex only if no task waiting                 */
    239                       if (p_pend_list->HeadPtr == DEF_NULL) {
   \                     ??OSMutexDel_4: (+1)
   \   00000060   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD11B             BNE.N    ??OSMutexDel_7
    240          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    241                           OS_MutexDbgListRemove(p_mutex);
   \   00000068   0x0020             MOVS     R0,R4
   \   0000006A   0x.... 0x....      BL       OS_MutexDbgListRemove
    242                           OSMutexQty--;
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable7_3
   \   00000072   0x8800             LDRH     R0,[R0, #+0]
   \   00000074   0x1E40             SUBS     R0,R0,#+1
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable7_3
   \   0000007A   0x8008             STRH     R0,[R1, #+0]
    243          #endif
    244                           OS_TRACE_MUTEX_DEL(p_mutex);
    245                           if (p_mutex->OwnerTCBPtr != DEF_NULL) {        /* Does the mutex belong to a task?                     */
   \   0000007C   0x6A60             LDR      R0,[R4, #+36]
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD003             BEQ.N    ??OSMutexDel_8
    246                               OS_MutexGrpRemove(p_mutex->OwnerTCBPtr, p_mutex); /* yes, remove it from the task group.           */
   \   00000082   0x0021             MOVS     R1,R4
   \   00000084   0x6A60             LDR      R0,[R4, #+36]
   \   00000086   0x.... 0x....      BL       OS_MutexGrpRemove
    247                           }
    248                           OS_MutexClr(p_mutex);
   \                     ??OSMutexDel_8: (+1)
   \   0000008A   0x0020             MOVS     R0,R4
   \   0000008C   0x.... 0x....      BL       OS_MutexClr
    249                           CPU_CRITICAL_EXIT();
   \   00000090   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000094   0x0038             MOVS     R0,R7
   \   00000096   0x.... 0x....      BL       CPU_SR_Restore
    250                          *p_err = OS_ERR_NONE;
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0x8028             STRH     R0,[R5, #+0]
   \   0000009E   0xE007             B.N      ??OSMutexDel_9
    251                       } else {
    252                           CPU_CRITICAL_EXIT();
   \                     ??OSMutexDel_7: (+1)
   \   000000A0   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000A4   0x0038             MOVS     R0,R7
   \   000000A6   0x.... 0x....      BL       CPU_SR_Restore
    253                          *p_err = OS_ERR_TASK_WAITING;
   \   000000AA   0xF247 0x105F      MOVW     R0,#+29023
   \   000000AE   0x8028             STRH     R0,[R5, #+0]
    254                       }
    255                       break;
   \                     ??OSMutexDel_9: (+1)
   \   000000B0   0xE04D             B.N      ??OSMutexDel_10
    256          
    257                  case OS_OPT_DEL_ALWAYS:                                 /* Always delete the mutex                              */
    258          #if (OS_CFG_TS_EN == DEF_ENABLED)
    259                       ts = OS_TS_GET();                                  /* Get timestamp                                        */
   \                     ??OSMutexDel_5: (+1)
   \   000000B2   0x.... 0x....      BL       CPU_TS_TmrRd
   \   000000B6   0x0006             MOVS     R6,R0
   \   000000B8   0xE007             B.N      ??OSMutexDel_11
    260          #else
    261                       ts = 0u;
    262          #endif
    263                       while (p_pend_list->HeadPtr != DEF_NULL) {         /* Remove all tasks from the pend list                  */
    264                           p_tcb = p_pend_list->HeadPtr;
   \                     ??OSMutexDel_12: (+1)
   \   000000BA   0xF8D9 0x0000      LDR      R0,[R9, #+0]
    265                           OS_PendAbort(p_tcb,
    266                                        ts,
    267                                        OS_STATUS_PEND_DEL);
   \   000000BE   0x2202             MOVS     R2,#+2
   \   000000C0   0x0031             MOVS     R1,R6
   \   000000C2   0x.... 0x....      BL       OS_PendAbort
    268                           nbr_tasks++;
   \   000000C6   0xF118 0x0801      ADDS     R8,R8,#+1
    269                       }
   \                     ??OSMutexDel_11: (+1)
   \   000000CA   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   000000CE   0x2800             CMP      R0,#+0
   \   000000D0   0xD1F3             BNE.N    ??OSMutexDel_12
    270          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    271                       OS_MutexDbgListRemove(p_mutex);
   \   000000D2   0x0020             MOVS     R0,R4
   \   000000D4   0x.... 0x....      BL       OS_MutexDbgListRemove
    272                       OSMutexQty--;
   \   000000D8   0x.... 0x....      LDR.W    R0,??DataTable7_3
   \   000000DC   0x8800             LDRH     R0,[R0, #+0]
   \   000000DE   0x1E40             SUBS     R0,R0,#+1
   \   000000E0   0x.... 0x....      LDR.W    R1,??DataTable7_3
   \   000000E4   0x8008             STRH     R0,[R1, #+0]
    273          #endif
    274                       OS_TRACE_MUTEX_DEL(p_mutex);
    275                       p_tcb_owner = p_mutex->OwnerTCBPtr;
   \   000000E6   0x6A66             LDR      R6,[R4, #+36]
    276                       if (p_tcb_owner != DEF_NULL) {                     /* Does the mutex belong to a task?                     */
   \   000000E8   0x2E00             CMP      R6,#+0
   \   000000EA   0xD003             BEQ.N    ??OSMutexDel_13
    277                           OS_MutexGrpRemove(p_tcb_owner, p_mutex);       /* yes, remove it from the task group.                  */
   \   000000EC   0x0021             MOVS     R1,R4
   \   000000EE   0x0030             MOVS     R0,R6
   \   000000F0   0x.... 0x....      BL       OS_MutexGrpRemove
    278                       }
    279          
    280          
    281                       if (p_tcb_owner != DEF_NULL) {                     /* Did we had to change the prio of owner?              */
   \                     ??OSMutexDel_13: (+1)
   \   000000F4   0x2E00             CMP      R6,#+0
   \   000000F6   0xD015             BEQ.N    ??OSMutexDel_14
    282                           if (p_tcb_owner->Prio != p_tcb_owner->BasePrio) {
   \   000000F8   0xF896 0x003F      LDRB     R0,[R6, #+63]
   \   000000FC   0xF896 0x1040      LDRB     R1,[R6, #+64]
   \   00000100   0x4288             CMP      R0,R1
   \   00000102   0xD00F             BEQ.N    ??OSMutexDel_14
    283                               prio_new = OS_MutexGrpPrioFindHighest(p_tcb_owner);
   \   00000104   0x0030             MOVS     R0,R6
   \   00000106   0x.... 0x....      BL       OS_MutexGrpPrioFindHighest
   \   0000010A   0x0001             MOVS     R1,R0
    284                               prio_new = (prio_new > p_tcb_owner->BasePrio) ? p_tcb_owner->BasePrio : prio_new;
   \   0000010C   0xF896 0x0040      LDRB     R0,[R6, #+64]
   \   00000110   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000112   0x4288             CMP      R0,R1
   \   00000114   0xD202             BCS.N    ??OSMutexDel_15
   \   00000116   0xF896 0x1040      LDRB     R1,[R6, #+64]
   \   0000011A   0xE7FF             B.N      ??OSMutexDel_16
    285                               OS_TaskChangePrio(p_tcb_owner, prio_new);
   \                     ??OSMutexDel_15: (+1)
   \                     ??OSMutexDel_16: (+1)
   \   0000011C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000011E   0x0030             MOVS     R0,R6
   \   00000120   0x.... 0x....      BL       OS_TaskChangePrio
    286                               OS_TRACE_MUTEX_TASK_PRIO_DISINHERIT(p_tcb_owner, p_tcb_owner->Prio);
    287                           }
    288                       }
    289          
    290                       OS_MutexClr(p_mutex);
   \                     ??OSMutexDel_14: (+1)
   \   00000124   0x0020             MOVS     R0,R4
   \   00000126   0x.... 0x....      BL       OS_MutexClr
    291                       CPU_CRITICAL_EXIT();
   \   0000012A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000012E   0x0038             MOVS     R0,R7
   \   00000130   0x.... 0x....      BL       CPU_SR_Restore
    292                       OSSched();                                         /* Find highest priority task ready to run              */
   \   00000134   0x.... 0x....      BL       OSSched
    293                      *p_err = OS_ERR_NONE;
   \   00000138   0x2000             MOVS     R0,#+0
   \   0000013A   0x8028             STRH     R0,[R5, #+0]
    294                       break;
   \   0000013C   0xE007             B.N      ??OSMutexDel_10
    295          
    296                  default:
    297                       CPU_CRITICAL_EXIT();
   \                     ??OSMutexDel_6: (+1)
   \   0000013E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000142   0x0038             MOVS     R0,R7
   \   00000144   0x.... 0x....      BL       CPU_SR_Restore
    298                      *p_err = OS_ERR_OPT_INVALID;
   \   00000148   0xF645 0x6025      MOVW     R0,#+24101
   \   0000014C   0x8028             STRH     R0,[R5, #+0]
    299                       break;
    300              }
    301              OS_TRACE_MUTEX_DEL_EXIT(*p_err);
    302              return (nbr_tasks);
   \                     ??OSMutexDel_10: (+1)
   \   0000014E   0x4640             MOV      R0,R8
   \   00000150   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSMutexDel_1: (+1)
   \   00000152   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    303          }
    304          #endif
    305          
    306          
    307          /*
    308          ************************************************************************************************************************
    309          *                                                    PEND ON MUTEX
    310          *
    311          * Description: This function waits for a mutex.
    312          *
    313          * Arguments  : p_mutex       is a pointer to the mutex
    314          *
    315          *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will wait for the
    316          *                            resource up to the amount of time (in 'ticks') specified by this argument.  If you specify
    317          *                            0, however, your task will wait forever at the specified mutex or, until the resource
    318          *                            becomes available.
    319          *
    320          *              opt           determines whether the user wants to block if the mutex is not available or not:
    321          *
    322          *                                OS_OPT_PEND_BLOCKING
    323          *                                OS_OPT_PEND_NON_BLOCKING
    324          *
    325          *              p_ts          is a pointer to a variable that will receive the timestamp of when the mutex was posted or
    326          *                            pend aborted or the mutex deleted.  If you pass a NULL pointer (i.e. (CPU_TS *)0) then you
    327          *                            will not get the timestamp.  In other words, passing a NULL pointer is valid and indicates
    328          *                            that you don't need the timestamp.
    329          *
    330          *              p_err         is a pointer to a variable that will contain an error code returned by this function.
    331          *
    332          *                                OS_ERR_NONE               The call was successful and your task owns the resource
    333          *                                OS_ERR_MUTEX_OWNER        If calling task already owns the mutex
    334          *                                OS_ERR_MUTEX_OVF          Mutex nesting counter overflowed
    335          *                                OS_ERR_OBJ_DEL            If 'p_mutex' was deleted
    336          *                                OS_ERR_OBJ_PTR_NULL       If 'p_mutex' is a NULL pointer
    337          *                                OS_ERR_OBJ_TYPE           If 'p_mutex' is not pointing at a mutex
    338          *                                OS_ERR_OPT_INVALID        If you didn't specify a valid option
    339          *                                OS_ERR_OS_NOT_RUNNING     If uC/OS-III is not running yet
    340          *                                OS_ERR_PEND_ABORT         If the pend was aborted by another task
    341          *                                OS_ERR_PEND_ISR           If you called this function from an ISR and the result
    342          *                                                          would lead to a suspension
    343          *                                OS_ERR_PEND_WOULD_BLOCK   If you specified non-blocking but the mutex was not
    344          *                                                          available
    345          *                                OS_ERR_SCHED_LOCKED       If you called this function when the scheduler is locked
    346          *                                OS_ERR_STATUS_INVALID     If the pend status has an invalid value
    347          *                                OS_ERR_TIMEOUT            The mutex was not received within the specified timeout
    348          *
    349          * Returns    : none
    350          *
    351          * Note(s)    : none
    352          ************************************************************************************************************************
    353          */
    354          

   \                                 In section .text, align 2, keep-with-next
    355          void  OSMutexPend (OS_MUTEX  *p_mutex,
    356                             OS_TICK    timeout,
    357                             OS_OPT     opt,
    358                             CPU_TS    *p_ts,
    359                             OS_ERR    *p_err)
    360          {
   \                     OSMutexPend: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x4690             MOV      R8,R2
   \   0000000A   0x001F             MOVS     R7,R3
    361              OS_TCB  *p_tcb;
    362              CPU_SR_ALLOC();
   \   0000000C   0xF05F 0x0900      MOVS     R9,#+0
   \   00000010   0x9C08             LDR      R4,[SP, #+32]
    363          
    364          
    365          #if (OS_CFG_TS_EN == DEF_DISABLED)
    366              (void)p_ts;                                                 /* Prevent compiler warning for not using 'ts'          */
    367          #endif
    368          
    369          #ifdef OS_SAFETY_CRITICAL
    370              if (p_err == DEF_NULL) {
    371                  OS_SAFETY_CRITICAL_EXCEPTION();
    372                  return;
    373              }
    374          #endif
    375          
    376              OS_TRACE_MUTEX_PEND_ENTER(p_mutex, timeout, opt, p_ts);
    377          
    378          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
    379              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable7_1
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD003             BEQ.N    ??OSMutexPend_0
    380                  OS_TRACE_MUTEX_PEND_FAILED(p_mutex);
    381                  OS_TRACE_MUTEX_PEND_EXIT(OS_ERR_PEND_ISR);
    382                 *p_err = OS_ERR_PEND_ISR;
   \   0000001C   0xF246 0x10AE      MOVW     R0,#+25006
   \   00000020   0x8020             STRH     R0,[R4, #+0]
    383                  return;
   \   00000022   0xE0E4             B.N      ??OSMutexPend_1
    384              }
    385          #endif
    386          
    387          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
    388              if (OSRunning != OS_STATE_OS_RUNNING) {
    389                  OS_TRACE_MUTEX_PEND_EXIT(OS_ERR_OS_NOT_RUNNING);
    390                 *p_err = OS_ERR_OS_NOT_RUNNING;
    391                  return;
    392              }
    393          #endif
    394          
    395          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
    396              if (p_mutex == DEF_NULL) {                                  /* Validate arguments                                   */
   \                     ??OSMutexPend_0: (+1)
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD103             BNE.N    ??OSMutexPend_2
    397                  OS_TRACE_MUTEX_PEND_FAILED(p_mutex);
    398                  OS_TRACE_MUTEX_PEND_EXIT(OS_ERR_OBJ_PTR_NULL);
    399                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000028   0xF645 0x50C3      MOVW     R0,#+24003
   \   0000002C   0x8020             STRH     R0,[R4, #+0]
    400                  return;
   \   0000002E   0xE0DE             B.N      ??OSMutexPend_1
    401              }
    402              switch (opt) {                                              /* Validate 'opt'                                       */
   \                     ??OSMutexPend_2: (+1)
   \   00000030   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000034   0x4640             MOV      R0,R8
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD002             BEQ.N    ??OSMutexPend_3
   \   0000003A   0xF5B0 0x4F00      CMP      R0,#+32768
   \   0000003E   0xD126             BNE.N    ??OSMutexPend_4
    403                  case OS_OPT_PEND_BLOCKING:
    404                  case OS_OPT_PEND_NON_BLOCKING:
    405                       break;
    406          
    407                  default:
    408                       OS_TRACE_MUTEX_PEND_FAILED(p_mutex);
    409                       OS_TRACE_MUTEX_PEND_EXIT(OS_ERR_OPT_INVALID);
    410                      *p_err = OS_ERR_OPT_INVALID;
    411                       return;
    412              }
    413          #endif
    414          
    415          #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
    416              if (p_mutex->Type != OS_OBJ_TYPE_MUTEX) {                   /* Make sure mutex was created                          */
   \                     ??OSMutexPend_3: (+1)
   \   00000040   0x6828             LDR      R0,[R5, #+0]
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable7_2  ;; 0x5854554d
   \   00000046   0x4288             CMP      R0,R1
   \   00000048   0xD125             BNE.N    ??OSMutexPend_5
    417                  OS_TRACE_MUTEX_PEND_FAILED(p_mutex);
    418                  OS_TRACE_MUTEX_PEND_EXIT(OS_ERR_OBJ_TYPE);
    419                 *p_err = OS_ERR_OBJ_TYPE;
    420                  return;
    421              }
    422          #endif
    423          
    424              CPU_CRITICAL_ENTER();
   \   0000004A   0x.... 0x....      BL       CPU_SR_Save
   \   0000004E   0x4681             MOV      R9,R0
   \   00000050   0x.... 0x....      BL       CPU_IntDisMeasStart
    425              if (p_mutex->OwnerNestingCtr == 0u) {                       /* Resource available?                                  */
   \   00000054   0xF895 0x0028      LDRB     R0,[R5, #+40]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD120             BNE.N    ??OSMutexPend_6
    426                  p_mutex->OwnerTCBPtr     = OSTCBCurPtr;                 /* Yes, caller may proceed                              */
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable7_4
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0x6268             STR      R0,[R5, #+36]
    427                  p_mutex->OwnerNestingCtr = 1u;
   \   00000064   0x2001             MOVS     R0,#+1
   \   00000066   0xF885 0x0028      STRB     R0,[R5, #+40]
    428          #if (OS_CFG_TS_EN == DEF_ENABLED)
    429                  if (p_ts != DEF_NULL) {
   \   0000006A   0x2F00             CMP      R7,#+0
   \   0000006C   0xD001             BEQ.N    ??OSMutexPend_7
    430                     *p_ts = p_mutex->TS;
   \   0000006E   0x6AE8             LDR      R0,[R5, #+44]
   \   00000070   0x6038             STR      R0,[R7, #+0]
    431                  }
    432          #endif
    433                  OS_MutexGrpAdd(OSTCBCurPtr, p_mutex);                   /* Add mutex to owner's group                           */
   \                     ??OSMutexPend_7: (+1)
   \   00000072   0x0029             MOVS     R1,R5
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable7_4
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0x.... 0x....      BL       OS_MutexGrpAdd
    434                  CPU_CRITICAL_EXIT();
   \   0000007E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000082   0x4648             MOV      R0,R9
   \   00000084   0x.... 0x....      BL       CPU_SR_Restore
    435                  OS_TRACE_MUTEX_PEND(p_mutex);
    436                  OS_TRACE_MUTEX_PEND_EXIT(OS_ERR_NONE);
    437                 *p_err = OS_ERR_NONE;
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0x8020             STRH     R0,[R4, #+0]
    438                  return;
   \   0000008C   0xE0AF             B.N      ??OSMutexPend_1
    439              }
   \                     ??OSMutexPend_4: (+1)
   \   0000008E   0xF645 0x6025      MOVW     R0,#+24101
   \   00000092   0x8020             STRH     R0,[R4, #+0]
   \   00000094   0xE0AB             B.N      ??OSMutexPend_1
   \                     ??OSMutexPend_5: (+1)
   \   00000096   0xF645 0x50C4      MOVW     R0,#+24004
   \   0000009A   0x8020             STRH     R0,[R4, #+0]
   \   0000009C   0xE0A7             B.N      ??OSMutexPend_1
    440          
    441              if (OSTCBCurPtr == p_mutex->OwnerTCBPtr) {                  /* See if current task is already the owner of the mutex*/
   \                     ??OSMutexPend_6: (+1)
   \   0000009E   0x.... 0x....      LDR.W    R0,??DataTable7_4
   \   000000A2   0x6800             LDR      R0,[R0, #+0]
   \   000000A4   0x6A69             LDR      R1,[R5, #+36]
   \   000000A6   0x4288             CMP      R0,R1
   \   000000A8   0xD11E             BNE.N    ??OSMutexPend_8
    442                  if (p_mutex->OwnerNestingCtr == (OS_NESTING_CTR)-1) {
   \   000000AA   0xF895 0x0028      LDRB     R0,[R5, #+40]
   \   000000AE   0x28FF             CMP      R0,#+255
   \   000000B0   0xD108             BNE.N    ??OSMutexPend_9
    443                      CPU_CRITICAL_EXIT();
   \   000000B2   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000B6   0x4648             MOV      R0,R9
   \   000000B8   0x.... 0x....      BL       CPU_SR_Restore
    444                      OS_TRACE_MUTEX_PEND_FAILED(p_mutex);
    445                      OS_TRACE_MUTEX_PEND_EXIT(OS_ERR_MUTEX_OVF);
    446                     *p_err = OS_ERR_MUTEX_OVF;
   \   000000BC   0xF245 0x7084      MOVW     R0,#+22404
   \   000000C0   0x8020             STRH     R0,[R4, #+0]
    447                      return;
   \   000000C2   0xE094             B.N      ??OSMutexPend_1
    448                  }
    449                  p_mutex->OwnerNestingCtr++;
   \                     ??OSMutexPend_9: (+1)
   \   000000C4   0xF895 0x0028      LDRB     R0,[R5, #+40]
   \   000000C8   0x1C40             ADDS     R0,R0,#+1
   \   000000CA   0xF885 0x0028      STRB     R0,[R5, #+40]
    450          #if (OS_CFG_TS_EN == DEF_ENABLED)
    451                  if (p_ts != DEF_NULL) {
   \   000000CE   0x2F00             CMP      R7,#+0
   \   000000D0   0xD001             BEQ.N    ??OSMutexPend_10
    452                     *p_ts = p_mutex->TS;
   \   000000D2   0x6AE8             LDR      R0,[R5, #+44]
   \   000000D4   0x6038             STR      R0,[R7, #+0]
    453                  }
    454          #endif
    455                  CPU_CRITICAL_EXIT();
   \                     ??OSMutexPend_10: (+1)
   \   000000D6   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000DA   0x4648             MOV      R0,R9
   \   000000DC   0x.... 0x....      BL       CPU_SR_Restore
    456                  OS_TRACE_MUTEX_PEND_FAILED(p_mutex);
    457                  OS_TRACE_MUTEX_PEND_EXIT(OS_ERR_MUTEX_OWNER);
    458                 *p_err = OS_ERR_MUTEX_OWNER;                             /* Indicate that current task already owns the mutex    */
   \   000000E0   0xF245 0x7082      MOVW     R0,#+22402
   \   000000E4   0x8020             STRH     R0,[R4, #+0]
    459                  return;
   \   000000E6   0xE082             B.N      ??OSMutexPend_1
    460              }
    461          
    462              if ((opt & OS_OPT_PEND_NON_BLOCKING) != 0u) {               /* Caller wants to block if not available?              */
   \                     ??OSMutexPend_8: (+1)
   \   000000E8   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000000EC   0xEA5F 0x4008      LSLS     R0,R8,#+16
   \   000000F0   0xD50C             BPL.N    ??OSMutexPend_11
    463                  CPU_CRITICAL_EXIT();
   \   000000F2   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000F6   0x4648             MOV      R0,R9
   \   000000F8   0x.... 0x....      BL       CPU_SR_Restore
    464          #if (OS_CFG_TS_EN == DEF_ENABLED)
    465                  if (p_ts != DEF_NULL) {
   \   000000FC   0x2F00             CMP      R7,#+0
   \   000000FE   0xD001             BEQ.N    ??OSMutexPend_12
    466                     *p_ts = 0u;
   \   00000100   0x2000             MOVS     R0,#+0
   \   00000102   0x6038             STR      R0,[R7, #+0]
    467                  }
    468          #endif
    469                  OS_TRACE_MUTEX_PEND_FAILED(p_mutex);
    470                  OS_TRACE_MUTEX_PEND_EXIT(OS_ERR_PEND_WOULD_BLOCK);
    471                 *p_err = OS_ERR_PEND_WOULD_BLOCK;                        /* No                                                   */
   \                     ??OSMutexPend_12: (+1)
   \   00000104   0xF246 0x10B0      MOVW     R0,#+25008
   \   00000108   0x8020             STRH     R0,[R4, #+0]
    472                  return;
   \   0000010A   0xE070             B.N      ??OSMutexPend_1
    473              } else {
    474                  if (OSSchedLockNestingCtr > 0u) {                       /* Can't pend when the scheduler is locked              */
   \                     ??OSMutexPend_11: (+1)
   \   0000010C   0x.... 0x....      LDR.W    R0,??DataTable7_5
   \   00000110   0x7800             LDRB     R0,[R0, #+0]
   \   00000112   0x2800             CMP      R0,#+0
   \   00000114   0xD00C             BEQ.N    ??OSMutexPend_13
    475                      CPU_CRITICAL_EXIT();
   \   00000116   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000011A   0x4648             MOV      R0,R9
   \   0000011C   0x.... 0x....      BL       CPU_SR_Restore
    476          #if (OS_CFG_TS_EN == DEF_ENABLED)
    477                      if (p_ts != DEF_NULL) {
   \   00000120   0x2F00             CMP      R7,#+0
   \   00000122   0xD001             BEQ.N    ??OSMutexPend_14
    478                         *p_ts = 0u;
   \   00000124   0x2000             MOVS     R0,#+0
   \   00000126   0x6038             STR      R0,[R7, #+0]
    479                      }
    480          #endif
    481                      OS_TRACE_MUTEX_PEND_FAILED(p_mutex);
    482                      OS_TRACE_MUTEX_PEND_EXIT(OS_ERR_SCHED_LOCKED);
    483                     *p_err = OS_ERR_SCHED_LOCKED;
   \                     ??OSMutexPend_14: (+1)
   \   00000128   0xF646 0x5063      MOVW     R0,#+28003
   \   0000012C   0x8020             STRH     R0,[R4, #+0]
    484                      return;
   \   0000012E   0xE05E             B.N      ??OSMutexPend_1
    485                  }
    486              }
    487          
    488              p_tcb = p_mutex->OwnerTCBPtr;                               /* Point to the TCB of the Mutex owner                  */
   \                     ??OSMutexPend_13: (+1)
   \   00000130   0x6A68             LDR      R0,[R5, #+36]
    489              if (p_tcb->Prio > OSTCBCurPtr->Prio) {                      /* See if mutex owner has a lower priority than current */
   \   00000132   0x.... 0x....      LDR.W    R1,??DataTable7_4
   \   00000136   0x6809             LDR      R1,[R1, #+0]
   \   00000138   0xF891 0x103F      LDRB     R1,[R1, #+63]
   \   0000013C   0xF890 0x203F      LDRB     R2,[R0, #+63]
   \   00000140   0x4291             CMP      R1,R2
   \   00000142   0xD206             BCS.N    ??OSMutexPend_15
    490                  OS_TaskChangePrio(p_tcb, OSTCBCurPtr->Prio);
   \   00000144   0x.... 0x....      LDR.W    R1,??DataTable7_4
   \   00000148   0x6809             LDR      R1,[R1, #+0]
   \   0000014A   0xF891 0x103F      LDRB     R1,[R1, #+63]
   \   0000014E   0x.... 0x....      BL       OS_TaskChangePrio
    491                  OS_TRACE_MUTEX_TASK_PRIO_INHERIT(p_tcb, p_tcb->Prio);
    492              }
    493          
    494              OS_Pend((OS_PEND_OBJ *)((void *)p_mutex),                   /* Block task pending on Mutex                          */
    495                       OS_TASK_PEND_ON_MUTEX,
    496                       timeout);
   \                     ??OSMutexPend_15: (+1)
   \   00000152   0x0032             MOVS     R2,R6
   \   00000154   0x2104             MOVS     R1,#+4
   \   00000156   0x0028             MOVS     R0,R5
   \   00000158   0x.... 0x....      BL       OS_Pend
    497          
    498              CPU_CRITICAL_EXIT();
   \   0000015C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000160   0x4648             MOV      R0,R9
   \   00000162   0x.... 0x....      BL       CPU_SR_Restore
    499              OS_TRACE_MUTEX_PEND_BLOCK(p_mutex);
    500              OSSched();                                                  /* Find the next highest priority task ready to run     */
   \   00000166   0x.... 0x....      BL       OSSched
    501          
    502              CPU_CRITICAL_ENTER();
   \   0000016A   0x.... 0x....      BL       CPU_SR_Save
   \   0000016E   0x4681             MOV      R9,R0
   \   00000170   0x.... 0x....      BL       CPU_IntDisMeasStart
    503              switch (OSTCBCurPtr->PendStatus) {
   \   00000174   0x.... 0x....      LDR.W    R0,??DataTable7_4
   \   00000178   0x6800             LDR      R0,[R0, #+0]
   \   0000017A   0xF890 0x003D      LDRB     R0,[R0, #+61]
   \   0000017E   0x2800             CMP      R0,#+0
   \   00000180   0xD005             BEQ.N    ??OSMutexPend_16
   \   00000182   0x2802             CMP      R0,#+2
   \   00000184   0xD020             BEQ.N    ??OSMutexPend_17
   \   00000186   0xD30C             BCC.N    ??OSMutexPend_18
   \   00000188   0x2803             CMP      R0,#+3
   \   0000018A   0xD015             BEQ.N    ??OSMutexPend_19
   \   0000018C   0xE027             B.N      ??OSMutexPend_20
    504                  case OS_STATUS_PEND_OK:                                 /* We got the mutex                                     */
    505          #if (OS_CFG_TS_EN == DEF_ENABLED)
    506                       if (p_ts != DEF_NULL) {
   \                     ??OSMutexPend_16: (+1)
   \   0000018E   0x2F00             CMP      R7,#+0
   \   00000190   0xD004             BEQ.N    ??OSMutexPend_21
    507                          *p_ts = OSTCBCurPtr->TS;
   \   00000192   0x.... 0x....      LDR.W    R0,??DataTable7_4
   \   00000196   0x6800             LDR      R0,[R0, #+0]
   \   00000198   0x6D00             LDR      R0,[R0, #+80]
   \   0000019A   0x6038             STR      R0,[R7, #+0]
    508                       }
    509          #endif
    510                       OS_TRACE_MUTEX_PEND(p_mutex);
    511                      *p_err = OS_ERR_NONE;
   \                     ??OSMutexPend_21: (+1)
   \   0000019C   0x2000             MOVS     R0,#+0
   \   0000019E   0x8020             STRH     R0,[R4, #+0]
    512                       break;
   \   000001A0   0xE020             B.N      ??OSMutexPend_22
    513          
    514                  case OS_STATUS_PEND_ABORT:                              /* Indicate that we aborted                             */
    515          #if (OS_CFG_TS_EN == DEF_ENABLED)
    516                       if (p_ts != DEF_NULL) {
   \                     ??OSMutexPend_18: (+1)
   \   000001A2   0x2F00             CMP      R7,#+0
   \   000001A4   0xD004             BEQ.N    ??OSMutexPend_23
    517                          *p_ts = OSTCBCurPtr->TS;
   \   000001A6   0x.... 0x....      LDR.W    R0,??DataTable7_4
   \   000001AA   0x6800             LDR      R0,[R0, #+0]
   \   000001AC   0x6D00             LDR      R0,[R0, #+80]
   \   000001AE   0x6038             STR      R0,[R7, #+0]
    518                       }
    519          #endif
    520                       OS_TRACE_MUTEX_PEND_FAILED(p_mutex);
    521                      *p_err = OS_ERR_PEND_ABORT;
   \                     ??OSMutexPend_23: (+1)
   \   000001B0   0xF246 0x10A9      MOVW     R0,#+25001
   \   000001B4   0x8020             STRH     R0,[R4, #+0]
    522                       break;
   \   000001B6   0xE015             B.N      ??OSMutexPend_22
    523          
    524                  case OS_STATUS_PEND_TIMEOUT:                            /* Indicate that we didn't get mutex within timeout     */
    525          #if (OS_CFG_TS_EN == DEF_ENABLED)
    526                       if (p_ts != DEF_NULL) {
   \                     ??OSMutexPend_19: (+1)
   \   000001B8   0x2F00             CMP      R7,#+0
   \   000001BA   0xD001             BEQ.N    ??OSMutexPend_24
    527                          *p_ts = 0u;
   \   000001BC   0x2000             MOVS     R0,#+0
   \   000001BE   0x6038             STR      R0,[R7, #+0]
    528                       }
    529          #endif
    530                       OS_TRACE_MUTEX_PEND_FAILED(p_mutex);
    531                      *p_err = OS_ERR_TIMEOUT;
   \                     ??OSMutexPend_24: (+1)
   \   000001C0   0xF247 0x20D9      MOVW     R0,#+29401
   \   000001C4   0x8020             STRH     R0,[R4, #+0]
    532                       break;
   \   000001C6   0xE00D             B.N      ??OSMutexPend_22
    533          
    534                  case OS_STATUS_PEND_DEL:                                /* Indicate that object pended on has been deleted      */
    535          #if (OS_CFG_TS_EN == DEF_ENABLED)
    536                       if (p_ts != DEF_NULL) {
   \                     ??OSMutexPend_17: (+1)
   \   000001C8   0x2F00             CMP      R7,#+0
   \   000001CA   0xD004             BEQ.N    ??OSMutexPend_25
    537                          *p_ts = OSTCBCurPtr->TS;
   \   000001CC   0x.... 0x....      LDR.W    R0,??DataTable7_4
   \   000001D0   0x6800             LDR      R0,[R0, #+0]
   \   000001D2   0x6D00             LDR      R0,[R0, #+80]
   \   000001D4   0x6038             STR      R0,[R7, #+0]
    538                       }
    539          #endif
    540                       OS_TRACE_MUTEX_PEND_FAILED(p_mutex);
    541                      *p_err = OS_ERR_OBJ_DEL;
   \                     ??OSMutexPend_25: (+1)
   \   000001D6   0xF645 0x50C2      MOVW     R0,#+24002
   \   000001DA   0x8020             STRH     R0,[R4, #+0]
    542                       break;
   \   000001DC   0xE002             B.N      ??OSMutexPend_22
    543          
    544                  default:
    545                       OS_TRACE_MUTEX_PEND_FAILED(p_mutex);
    546                      *p_err = OS_ERR_STATUS_INVALID;
   \                     ??OSMutexPend_20: (+1)
   \   000001DE   0xF646 0x602E      MOVW     R0,#+28206
   \   000001E2   0x8020             STRH     R0,[R4, #+0]
    547                       break;
    548              }
    549              CPU_CRITICAL_EXIT();
   \                     ??OSMutexPend_22: (+1)
   \   000001E4   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000001E8   0x4648             MOV      R0,R9
   \   000001EA   0x.... 0x....      BL       CPU_SR_Restore
    550              OS_TRACE_MUTEX_PEND_EXIT(*p_err);
    551          }
   \                     ??OSMutexPend_1: (+1)
   \   000001EE   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    552          
    553          
    554          /*
    555          ************************************************************************************************************************
    556          *                                               ABORT WAITING ON A MUTEX
    557          *
    558          * Description: This function aborts & readies any tasks currently waiting on a mutex.  This function should be used
    559          *              to fault-abort the wait on the mutex, rather than to normally signal the mutex via OSMutexPost().
    560          *
    561          * Arguments  : p_mutex       is a pointer to the mutex
    562          *
    563          *              opt           determines the type of ABORT performed:
    564          *
    565          *                                OS_OPT_PEND_ABORT_1          ABORT wait for a single task (HPT) waiting on the mutex
    566          *                                OS_OPT_PEND_ABORT_ALL        ABORT wait for ALL tasks that are  waiting on the mutex
    567          *                                OS_OPT_POST_NO_SCHED         Do not call the scheduler
    568          *
    569          *              p_err         is a pointer to a variable that will contain an error code returned by this function.
    570          *
    571          *                                OS_ERR_NONE               At least one task waiting on the mutex was readied and
    572          *                                                          informed of the aborted wait; check return value for the
    573          *                                                          number of tasks whose wait on the mutex was aborted
    574          *                                OS_ERR_OBJ_PTR_NULL       If 'p_mutex' is a NULL pointer
    575          *                                OS_ERR_OBJ_TYPE           If 'p_mutex' is not pointing at a mutex
    576          *                                OS_ERR_OPT_INVALID        If you specified an invalid option
    577          *                                OS_ERR_OS_NOT_RUNNING     If uC/OS-III is not running yet
    578          *                                OS_ERR_PEND_ABORT_ISR     If you attempted to call this function from an ISR
    579          *                                OS_ERR_PEND_ABORT_NONE    No task were pending
    580          *
    581          * Returns    : == 0          if no tasks were waiting on the mutex, or upon error.
    582          *              >  0          if one or more tasks waiting on the mutex are now readied and informed.
    583          *
    584          * Note(s)    : none
    585          ************************************************************************************************************************
    586          */
    587          
    588          #if (OS_CFG_MUTEX_PEND_ABORT_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    589          OS_OBJ_QTY  OSMutexPendAbort (OS_MUTEX  *p_mutex,
    590                                        OS_OPT     opt,
    591                                        OS_ERR    *p_err)
    592          {
   \                     OSMutexPendAbort: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    593              OS_PEND_LIST  *p_pend_list;
    594              OS_TCB        *p_tcb;
    595              OS_TCB        *p_tcb_owner;
    596              CPU_TS         ts;
    597              OS_OBJ_QTY     nbr_tasks;
    598              OS_PRIO        prio_new;
    599              CPU_SR_ALLOC();
   \   0000000A   0x2700             MOVS     R7,#+0
    600          
    601          
    602          #ifdef OS_SAFETY_CRITICAL
    603              if (p_err == DEF_NULL) {
    604                  OS_SAFETY_CRITICAL_EXCEPTION();
    605                  return ((OS_OBJ_QTY)0u);
    606              }
    607          #endif
    608          
    609          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
    610              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to Pend Abort from an ISR                */
   \   0000000C   0x....             LDR.N    R0,??DataTable7_1
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD004             BEQ.N    ??OSMutexPendAbort_0
    611                 *p_err =  OS_ERR_PEND_ABORT_ISR;
   \   00000014   0xF246 0x10AA      MOVW     R0,#+25002
   \   00000018   0x8030             STRH     R0,[R6, #+0]
    612                  return (0u);
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE081             B.N      ??OSMutexPendAbort_1
    613              }
    614          #endif
    615          
    616          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
    617              if (OSRunning != OS_STATE_OS_RUNNING) {
    618                 *p_err = OS_ERR_OS_NOT_RUNNING;
    619                  return (0u);
    620              }
    621          #endif
    622          
    623          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
    624              if (p_mutex == DEF_NULL) {                                  /* Validate 'p_mutex'                                   */
   \                     ??OSMutexPendAbort_0: (+1)
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD104             BNE.N    ??OSMutexPendAbort_2
    625                 *p_err =  OS_ERR_OBJ_PTR_NULL;
   \   00000022   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000026   0x8030             STRH     R0,[R6, #+0]
    626                  return (0u);
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xE07A             B.N      ??OSMutexPendAbort_1
    627              }
    628              switch (opt) {                                              /* Validate 'opt'                                       */
   \                     ??OSMutexPendAbort_2: (+1)
   \   0000002C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002E   0x0028             MOVS     R0,R5
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD008             BEQ.N    ??OSMutexPendAbort_3
   \   00000034   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000038   0xD005             BEQ.N    ??OSMutexPendAbort_3
   \   0000003A   0xF5B0 0x4F00      CMP      R0,#+32768
   \   0000003E   0xD002             BEQ.N    ??OSMutexPendAbort_3
   \   00000040   0xF5B0 0x4F01      CMP      R0,#+33024
   \   00000044   0xD119             BNE.N    ??OSMutexPendAbort_4
    629                  case OS_OPT_PEND_ABORT_1:
    630                  case OS_OPT_PEND_ABORT_ALL:
    631                  case OS_OPT_PEND_ABORT_1   | OS_OPT_POST_NO_SCHED:
    632                  case OS_OPT_PEND_ABORT_ALL | OS_OPT_POST_NO_SCHED:
    633                       break;
    634          
    635                  default:
    636                      *p_err =  OS_ERR_OPT_INVALID;
    637                       return (0u);
    638              }
    639          #endif
    640          
    641          #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
    642              if (p_mutex->Type != OS_OBJ_TYPE_MUTEX) {                   /* Make sure mutex was created                          */
   \                     ??OSMutexPendAbort_3: (+1)
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x....             LDR.N    R1,??DataTable7_2  ;; 0x5854554d
   \   0000004A   0x4288             CMP      R0,R1
   \   0000004C   0xD11A             BNE.N    ??OSMutexPendAbort_5
    643                 *p_err =  OS_ERR_OBJ_TYPE;
    644                  return (0u);
    645              }
    646          #endif
    647          
    648              CPU_CRITICAL_ENTER();
   \   0000004E   0x.... 0x....      BL       CPU_SR_Save
   \   00000052   0x0007             MOVS     R7,R0
   \   00000054   0x.... 0x....      BL       CPU_IntDisMeasStart
    649              p_pend_list = &p_mutex->PendList;
   \   00000058   0xF114 0x0008      ADDS     R0,R4,#+8
   \   0000005C   0x9000             STR      R0,[SP, #+0]
    650              if (p_pend_list->HeadPtr == DEF_NULL) {                     /* Any task waiting on mutex?                           */
   \   0000005E   0x9800             LDR      R0,[SP, #+0]
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD113             BNE.N    ??OSMutexPendAbort_6
    651                  CPU_CRITICAL_EXIT();                                    /* No                                                   */
   \   00000066   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000006A   0x0038             MOVS     R0,R7
   \   0000006C   0x.... 0x....      BL       CPU_SR_Restore
    652                 *p_err =  OS_ERR_PEND_ABORT_NONE;
   \   00000070   0xF246 0x10AB      MOVW     R0,#+25003
   \   00000074   0x8030             STRH     R0,[R6, #+0]
    653                  return (0u);
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xE053             B.N      ??OSMutexPendAbort_1
    654              }
   \                     ??OSMutexPendAbort_4: (+1)
   \   0000007A   0xF645 0x6025      MOVW     R0,#+24101
   \   0000007E   0x8030             STRH     R0,[R6, #+0]
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xE04E             B.N      ??OSMutexPendAbort_1
   \                     ??OSMutexPendAbort_5: (+1)
   \   00000084   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000088   0x8030             STRH     R0,[R6, #+0]
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0xE049             B.N      ??OSMutexPendAbort_1
    655          
    656              nbr_tasks = 0u;
   \                     ??OSMutexPendAbort_6: (+1)
   \   0000008E   0xF05F 0x0800      MOVS     R8,#+0
    657          #if (OS_CFG_TS_EN == DEF_ENABLED)
    658              ts        = OS_TS_GET();                                    /* Get local time stamp so all tasks get the same time  */
   \   00000092   0x.... 0x....      BL       CPU_TS_TmrRd
   \   00000096   0x4681             MOV      R9,R0
    659          #else
    660              ts        = 0u;
    661          #endif
    662              while (p_pend_list->HeadPtr != DEF_NULL) {
   \                     ??OSMutexPendAbort_7: (+1)
   \   00000098   0x9800             LDR      R0,[SP, #+0]
   \   0000009A   0x6800             LDR      R0,[R0, #+0]
   \   0000009C   0x2800             CMP      R0,#+0
   \   0000009E   0xD032             BEQ.N    ??OSMutexPendAbort_8
    663                  p_tcb = p_pend_list->HeadPtr;
   \   000000A0   0x9800             LDR      R0,[SP, #+0]
   \   000000A2   0xF8D0 0xA000      LDR      R10,[R0, #+0]
    664          
    665                  OS_PendAbort(p_tcb,
    666                               ts,
    667                               OS_STATUS_PEND_ABORT);
   \   000000A6   0x2201             MOVS     R2,#+1
   \   000000A8   0x4649             MOV      R1,R9
   \   000000AA   0x4650             MOV      R0,R10
   \   000000AC   0x.... 0x....      BL       OS_PendAbort
    668                  p_tcb_owner = p_mutex->OwnerTCBPtr;
   \   000000B0   0xF8D4 0xB024      LDR      R11,[R4, #+36]
    669                  prio_new    = p_tcb_owner->Prio;
   \   000000B4   0xF89B 0x003F      LDRB     R0,[R11, #+63]
    670                  if ((p_tcb_owner->Prio != p_tcb_owner->BasePrio) &&
    671                      (p_tcb_owner->Prio == p_tcb->Prio)) {               /* Has the owner inherited a priority?                  */
   \   000000B8   0xF89B 0x103F      LDRB     R1,[R11, #+63]
   \   000000BC   0xF89B 0x2040      LDRB     R2,[R11, #+64]
   \   000000C0   0x4291             CMP      R1,R2
   \   000000C2   0xD010             BEQ.N    ??OSMutexPendAbort_9
   \   000000C4   0xF89B 0x103F      LDRB     R1,[R11, #+63]
   \   000000C8   0xF89A 0x203F      LDRB     R2,[R10, #+63]
   \   000000CC   0x4291             CMP      R1,R2
   \   000000CE   0xD10A             BNE.N    ??OSMutexPendAbort_9
    672                      prio_new = OS_MutexGrpPrioFindHighest(p_tcb_owner);
   \   000000D0   0x4658             MOV      R0,R11
   \   000000D2   0x.... 0x....      BL       OS_MutexGrpPrioFindHighest
    673                      prio_new = (prio_new > p_tcb_owner->BasePrio) ? p_tcb_owner->BasePrio : prio_new;
   \   000000D6   0xF89B 0x1040      LDRB     R1,[R11, #+64]
   \   000000DA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000DC   0x4281             CMP      R1,R0
   \   000000DE   0xD202             BCS.N    ??OSMutexPendAbort_10
   \   000000E0   0xF89B 0x0040      LDRB     R0,[R11, #+64]
   \   000000E4   0xE7FF             B.N      ??OSMutexPendAbort_9
    674                  }
    675          
    676                  if(prio_new != p_tcb_owner->Prio) {
   \                     ??OSMutexPendAbort_10: (+1)
   \                     ??OSMutexPendAbort_9: (+1)
   \   000000E6   0xF89B 0x103F      LDRB     R1,[R11, #+63]
   \   000000EA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000EC   0x4288             CMP      R0,R1
   \   000000EE   0xD004             BEQ.N    ??OSMutexPendAbort_11
    677                      OS_TaskChangePrio(p_tcb_owner, prio_new);
   \   000000F0   0x0001             MOVS     R1,R0
   \   000000F2   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000F4   0x4658             MOV      R0,R11
   \   000000F6   0x.... 0x....      BL       OS_TaskChangePrio
    678                      OS_TRACE_MUTEX_TASK_PRIO_DISINHERIT(p_tcb_owner, p_tcb_owner->Prio);
    679                  }
    680          
    681                  nbr_tasks++;
   \                     ??OSMutexPendAbort_11: (+1)
   \   000000FA   0xF118 0x0801      ADDS     R8,R8,#+1
    682                  if (opt != OS_OPT_PEND_ABORT_ALL) {                     /* Pend abort all tasks waiting?                        */
   \   000000FE   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000100   0xF5B5 0x7F80      CMP      R5,#+256
   \   00000104   0xD0C8             BEQ.N    ??OSMutexPendAbort_7
    683                      break;                                              /* No                                                   */
    684                  }
    685              }
    686              CPU_CRITICAL_EXIT();
   \                     ??OSMutexPendAbort_8: (+1)
   \   00000106   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000010A   0x0038             MOVS     R0,R7
   \   0000010C   0x.... 0x....      BL       CPU_SR_Restore
    687          
    688              if ((opt & OS_OPT_POST_NO_SCHED) == 0u) {
   \   00000110   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000112   0x0428             LSLS     R0,R5,#+16
   \   00000114   0xD401             BMI.N    ??OSMutexPendAbort_12
    689                  OSSched();                                              /* Run the scheduler                                    */
   \   00000116   0x.... 0x....      BL       OSSched
    690              }
    691          
    692             *p_err = OS_ERR_NONE;
   \                     ??OSMutexPendAbort_12: (+1)
   \   0000011A   0x2000             MOVS     R0,#+0
   \   0000011C   0x8030             STRH     R0,[R6, #+0]
    693              return (nbr_tasks);
   \   0000011E   0x4640             MOV      R0,R8
   \   00000120   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSMutexPendAbort_1: (+1)
   \   00000122   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    694          }
    695          #endif
    696          
    697          
    698          /*
    699          ************************************************************************************************************************
    700          *                                                   POST TO A MUTEX
    701          *
    702          * Description: This function signals a mutex.
    703          *
    704          * Arguments  : p_mutex       is a pointer to the mutex
    705          *
    706          *              opt           is an option you can specify to alter the behavior of the post.  The choices are:
    707          *
    708          *                                OS_OPT_POST_NONE        No special option selected
    709          *                                OS_OPT_POST_NO_SCHED    If you don't want the scheduler to be called after the post.
    710          *
    711          *              p_err         is a pointer to a variable that will contain an error code returned by this function.
    712          *
    713          *                                OS_ERR_NONE               The call was successful and the mutex was signaled
    714          *                                OS_ERR_MUTEX_NESTING      Mutex owner nested its use of the mutex
    715          *                                OS_ERR_MUTEX_NOT_OWNER    If the task posting is not the Mutex owner
    716          *                                OS_ERR_OBJ_PTR_NULL       If 'p_mutex' is a NULL pointer
    717          *                                OS_ERR_OBJ_TYPE           If 'p_mutex' is not pointing at a mutex
    718          *                                OS_ERR_OPT_INVALID        If you specified an invalid option
    719          *                                OS_ERR_OS_NOT_RUNNING     If uC/OS-III is not running yet
    720          *                                OS_ERR_POST_ISR           If you attempted to post from an ISR
    721          *
    722          * Returns    : none
    723          *
    724          * Note(s)    : none
    725          ************************************************************************************************************************
    726          */
    727          

   \                                 In section .text, align 2, keep-with-next
    728          void  OSMutexPost (OS_MUTEX  *p_mutex,
    729                             OS_OPT     opt,
    730                             OS_ERR    *p_err)
    731          {
   \                     OSMutexPost: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
    732              OS_PEND_LIST  *p_pend_list;
    733              OS_TCB        *p_tcb;
    734              CPU_TS         ts;
    735              OS_PRIO        prio_new;
    736              CPU_SR_ALLOC();
   \   0000000C   0x2700             MOVS     R7,#+0
    737          
    738          
    739          #ifdef OS_SAFETY_CRITICAL
    740              if (p_err == DEF_NULL) {
    741                  OS_SAFETY_CRITICAL_EXCEPTION();
    742                  return;
    743              }
    744          #endif
    745          
    746              OS_TRACE_MUTEX_POST_ENTER(p_mutex, opt);
    747          
    748          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
    749              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
   \   0000000E   0x....             LDR.N    R0,??DataTable7_1
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD003             BEQ.N    ??OSMutexPost_0
    750                  OS_TRACE_MUTEX_POST_FAILED(p_mutex);
    751                  OS_TRACE_MUTEX_POST_EXIT(OS_ERR_POST_ISR);
    752                 *p_err = OS_ERR_POST_ISR;
   \   00000016   0xF246 0x200E      MOVW     R0,#+25102
   \   0000001A   0x8030             STRH     R0,[R6, #+0]
    753                  return;
   \   0000001C   0xE0B0             B.N      ??OSMutexPost_1
    754              }
    755          #endif
    756          
    757          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
    758              if (OSRunning != OS_STATE_OS_RUNNING) {
    759                  OS_TRACE_MUTEX_POST_EXIT(OS_ERR_OS_NOT_RUNNING);
    760                 *p_err = OS_ERR_OS_NOT_RUNNING;
    761                  return;
    762              }
    763          #endif
    764          
    765          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
    766              if (p_mutex == DEF_NULL) {                                  /* Validate 'p_mutex'                                   */
   \                     ??OSMutexPost_0: (+1)
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD103             BNE.N    ??OSMutexPost_2
    767                  OS_TRACE_MUTEX_POST_FAILED(p_mutex);
    768                  OS_TRACE_MUTEX_POST_EXIT(OS_ERR_OBJ_PTR_NULL);
    769                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000022   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000026   0x8030             STRH     R0,[R6, #+0]
    770                  return;
   \   00000028   0xE0AA             B.N      ??OSMutexPost_1
    771              }
    772              switch (opt) {                                              /* Validate 'opt'                                       */
   \                     ??OSMutexPost_2: (+1)
   \   0000002A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002C   0x0028             MOVS     R0,R5
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD002             BEQ.N    ??OSMutexPost_3
   \   00000032   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000036   0xD116             BNE.N    ??OSMutexPost_4
    773                  case OS_OPT_POST_NONE:
    774                  case OS_OPT_POST_NO_SCHED:
    775                       break;
    776          
    777                  default:
    778                       OS_TRACE_MUTEX_POST_FAILED(p_mutex);
    779                       OS_TRACE_MUTEX_POST_EXIT(OS_ERR_OPT_INVALID);
    780                      *p_err =  OS_ERR_OPT_INVALID;
    781                       return;
    782              }
    783          #endif
    784          
    785          #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
    786              if (p_mutex->Type != OS_OBJ_TYPE_MUTEX) {                   /* Make sure mutex was created                          */
   \                     ??OSMutexPost_3: (+1)
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0x....             LDR.N    R1,??DataTable7_2  ;; 0x5854554d
   \   0000003C   0x4288             CMP      R0,R1
   \   0000003E   0xD116             BNE.N    ??OSMutexPost_5
    787                  OS_TRACE_MUTEX_POST_FAILED(p_mutex);
    788                  OS_TRACE_MUTEX_POST_EXIT(OS_ERR_OBJ_TYPE);
    789                 *p_err = OS_ERR_OBJ_TYPE;
    790                  return;
    791              }
    792          #endif
    793          
    794              CPU_CRITICAL_ENTER();
   \   00000040   0x.... 0x....      BL       CPU_SR_Save
   \   00000044   0x0007             MOVS     R7,R0
   \   00000046   0x.... 0x....      BL       CPU_IntDisMeasStart
    795              if (OSTCBCurPtr != p_mutex->OwnerTCBPtr) {                  /* Make sure the mutex owner is releasing the mutex     */
   \   0000004A   0x....             LDR.N    R0,??DataTable7_4
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x6A61             LDR      R1,[R4, #+36]
   \   00000050   0x4288             CMP      R0,R1
   \   00000052   0xD010             BEQ.N    ??OSMutexPost_6
    796                  CPU_CRITICAL_EXIT();
   \   00000054   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000058   0x0038             MOVS     R0,R7
   \   0000005A   0x.... 0x....      BL       CPU_SR_Restore
    797                  OS_TRACE_MUTEX_POST_FAILED(p_mutex);
    798                  OS_TRACE_MUTEX_POST_EXIT(OS_ERR_MUTEX_NOT_OWNER);
    799                 *p_err = OS_ERR_MUTEX_NOT_OWNER;
   \   0000005E   0xF245 0x7081      MOVW     R0,#+22401
   \   00000062   0x8030             STRH     R0,[R6, #+0]
    800                  return;
   \   00000064   0xE08C             B.N      ??OSMutexPost_1
    801              }
   \                     ??OSMutexPost_4: (+1)
   \   00000066   0xF645 0x6025      MOVW     R0,#+24101
   \   0000006A   0x8030             STRH     R0,[R6, #+0]
   \   0000006C   0xE088             B.N      ??OSMutexPost_1
   \                     ??OSMutexPost_5: (+1)
   \   0000006E   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000072   0x8030             STRH     R0,[R6, #+0]
   \   00000074   0xE084             B.N      ??OSMutexPost_1
    802          
    803              OS_TRACE_MUTEX_POST(p_mutex);
    804          
    805          #if (OS_CFG_TS_EN == DEF_ENABLED)
    806              ts          = OS_TS_GET();                                  /* Get timestamp                                        */
   \                     ??OSMutexPost_6: (+1)
   \   00000076   0x.... 0x....      BL       CPU_TS_TmrRd
   \   0000007A   0x4680             MOV      R8,R0
    807              p_mutex->TS = ts;
   \   0000007C   0xF8C4 0x802C      STR      R8,[R4, #+44]
    808          #else
    809              ts          = 0u;
    810          #endif
    811              p_mutex->OwnerNestingCtr--;                                 /* Decrement owner's nesting counter                    */
   \   00000080   0xF894 0x0028      LDRB     R0,[R4, #+40]
   \   00000084   0x1E40             SUBS     R0,R0,#+1
   \   00000086   0xF884 0x0028      STRB     R0,[R4, #+40]
    812              if (p_mutex->OwnerNestingCtr > 0u) {                        /* Are we done with all nestings?                       */
   \   0000008A   0xF894 0x0028      LDRB     R0,[R4, #+40]
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD008             BEQ.N    ??OSMutexPost_7
    813                  CPU_CRITICAL_EXIT();                                     /* No                                                   */
   \   00000092   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000096   0x0038             MOVS     R0,R7
   \   00000098   0x.... 0x....      BL       CPU_SR_Restore
    814                  OS_TRACE_MUTEX_POST_EXIT(OS_ERR_MUTEX_NESTING);
    815                 *p_err = OS_ERR_MUTEX_NESTING;
   \   0000009C   0xF245 0x7083      MOVW     R0,#+22403
   \   000000A0   0x8030             STRH     R0,[R6, #+0]
    816                  return;
   \   000000A2   0xE06D             B.N      ??OSMutexPost_1
    817              }
    818          
    819              OS_MutexGrpRemove(OSTCBCurPtr, p_mutex);                    /* Remove mutex from owner's group                      */
   \                     ??OSMutexPost_7: (+1)
   \   000000A4   0x0021             MOVS     R1,R4
   \   000000A6   0x....             LDR.N    R0,??DataTable7_4
   \   000000A8   0x6800             LDR      R0,[R0, #+0]
   \   000000AA   0x.... 0x....      BL       OS_MutexGrpRemove
    820          
    821              p_pend_list = &p_mutex->PendList;
   \   000000AE   0xF114 0x0908      ADDS     R9,R4,#+8
    822              if (p_pend_list->HeadPtr == DEF_NULL) {                     /* Any task waiting on mutex?                           */
   \   000000B2   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   000000B6   0x2800             CMP      R0,#+0
   \   000000B8   0xD10C             BNE.N    ??OSMutexPost_8
    823                  p_mutex->OwnerTCBPtr     = DEF_NULL;                    /* No                                                   */
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0x6260             STR      R0,[R4, #+36]
    824                  p_mutex->OwnerNestingCtr = 0u;
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0xF884 0x0028      STRB     R0,[R4, #+40]
    825                  CPU_CRITICAL_EXIT();
   \   000000C4   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000C8   0x0038             MOVS     R0,R7
   \   000000CA   0x.... 0x....      BL       CPU_SR_Restore
    826                  OS_TRACE_MUTEX_POST_EXIT(OS_ERR_NONE);
    827                 *p_err = OS_ERR_NONE;
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0x8030             STRH     R0,[R6, #+0]
    828                  return;
   \   000000D2   0xE055             B.N      ??OSMutexPost_1
    829              }
    830                                                                          /* Yes                                                  */
    831              if (OSTCBCurPtr->Prio != OSTCBCurPtr->BasePrio) {           /* Has owner inherited a priority?                      */
   \                     ??OSMutexPost_8: (+1)
   \   000000D4   0x....             LDR.N    R0,??DataTable7_4
   \   000000D6   0x6800             LDR      R0,[R0, #+0]
   \   000000D8   0xF890 0x003F      LDRB     R0,[R0, #+63]
   \   000000DC   0x....             LDR.N    R1,??DataTable7_4
   \   000000DE   0x6809             LDR      R1,[R1, #+0]
   \   000000E0   0xF891 0x1040      LDRB     R1,[R1, #+64]
   \   000000E4   0x4288             CMP      R0,R1
   \   000000E6   0xD02C             BEQ.N    ??OSMutexPost_9
    832                  prio_new = OS_MutexGrpPrioFindHighest(OSTCBCurPtr);     /* Yes, find highest priority pending                   */
   \   000000E8   0x....             LDR.N    R0,??DataTable7_4
   \   000000EA   0x6800             LDR      R0,[R0, #+0]
   \   000000EC   0x.... 0x....      BL       OS_MutexGrpPrioFindHighest
   \   000000F0   0x4682             MOV      R10,R0
    833                  prio_new = (prio_new > OSTCBCurPtr->BasePrio) ? OSTCBCurPtr->BasePrio : prio_new;
   \   000000F2   0x....             LDR.N    R0,??DataTable7_4
   \   000000F4   0x6800             LDR      R0,[R0, #+0]
   \   000000F6   0xF890 0x0040      LDRB     R0,[R0, #+64]
   \   000000FA   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000FE   0x4550             CMP      R0,R10
   \   00000100   0xD204             BCS.N    ??OSMutexPost_10
   \   00000102   0x....             LDR.N    R0,??DataTable7_4
   \   00000104   0x6800             LDR      R0,[R0, #+0]
   \   00000106   0xF890 0xA040      LDRB     R10,[R0, #+64]
   \   0000010A   0xE7FF             B.N      ??OSMutexPost_11
    834                  if (prio_new > OSTCBCurPtr->Prio) {
   \                     ??OSMutexPost_10: (+1)
   \                     ??OSMutexPost_11: (+1)
   \   0000010C   0x....             LDR.N    R0,??DataTable7_4
   \   0000010E   0x6800             LDR      R0,[R0, #+0]
   \   00000110   0xF890 0x003F      LDRB     R0,[R0, #+63]
   \   00000114   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000118   0x4550             CMP      R0,R10
   \   0000011A   0xD212             BCS.N    ??OSMutexPost_9
    835                      OS_RdyListRemove(OSTCBCurPtr);
   \   0000011C   0x....             LDR.N    R0,??DataTable7_4
   \   0000011E   0x6800             LDR      R0,[R0, #+0]
   \   00000120   0x.... 0x....      BL       OS_RdyListRemove
    836                      OSTCBCurPtr->Prio = prio_new;                       /* Lower owner's priority back to its original one      */
   \   00000124   0x....             LDR.N    R0,??DataTable7_4
   \   00000126   0x6800             LDR      R0,[R0, #+0]
   \   00000128   0xF880 0xA03F      STRB     R10,[R0, #+63]
    837                      OS_TRACE_MUTEX_TASK_PRIO_DISINHERIT(OSTCBCurPtr, prio_new);
    838                      OS_PrioInsert(prio_new);
   \   0000012C   0x4650             MOV      R0,R10
   \   0000012E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000130   0x.... 0x....      BL       OS_PrioInsert
    839                      OS_RdyListInsertTail(OSTCBCurPtr);                  /* Insert owner in ready list at new priority           */
   \   00000134   0x....             LDR.N    R0,??DataTable7_4
   \   00000136   0x6800             LDR      R0,[R0, #+0]
   \   00000138   0x.... 0x....      BL       OS_RdyListInsertTail
    840                      OSPrioCur         = prio_new;
   \   0000013C   0x....             LDR.N    R0,??DataTable7_6
   \   0000013E   0xF880 0xA000      STRB     R10,[R0, #+0]
    841                  }
    842              }
    843                                                                          /* Get TCB from head of pend list                       */
    844              p_tcb                    = p_pend_list->HeadPtr;
   \                     ??OSMutexPost_9: (+1)
   \   00000142   0xF8D9 0x9000      LDR      R9,[R9, #+0]
    845              p_mutex->OwnerTCBPtr     = p_tcb;                           /* Give mutex to new owner                              */
   \   00000146   0xF8C4 0x9024      STR      R9,[R4, #+36]
    846              p_mutex->OwnerNestingCtr = 1u;
   \   0000014A   0x2001             MOVS     R0,#+1
   \   0000014C   0xF884 0x0028      STRB     R0,[R4, #+40]
    847              OS_MutexGrpAdd(p_tcb, p_mutex);
   \   00000150   0x0021             MOVS     R1,R4
   \   00000152   0x4648             MOV      R0,R9
   \   00000154   0x.... 0x....      BL       OS_MutexGrpAdd
    848                                                                          /* Post to mutex                                        */
    849              OS_Post((OS_PEND_OBJ *)p_mutex,
    850                                     p_tcb,
    851                                     DEF_NULL,
    852                                     0u,
    853                                     ts);
   \   00000158   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   0000015C   0x2300             MOVS     R3,#+0
   \   0000015E   0x2200             MOVS     R2,#+0
   \   00000160   0x4649             MOV      R1,R9
   \   00000162   0x0020             MOVS     R0,R4
   \   00000164   0x.... 0x....      BL       OS_Post
    854          
    855              CPU_CRITICAL_EXIT();
   \   00000168   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000016C   0x0038             MOVS     R0,R7
   \   0000016E   0x.... 0x....      BL       CPU_SR_Restore
    856          
    857              if ((opt & OS_OPT_POST_NO_SCHED) == 0u) {
   \   00000172   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000174   0x0428             LSLS     R0,R5,#+16
   \   00000176   0xD401             BMI.N    ??OSMutexPost_12
    858                  OSSched();                                              /* Run the scheduler                                    */
   \   00000178   0x.... 0x....      BL       OSSched
    859              }
    860              OS_TRACE_MUTEX_POST_EXIT(OS_ERR_NONE);
    861             *p_err = OS_ERR_NONE;
   \                     ??OSMutexPost_12: (+1)
   \   0000017C   0x2000             MOVS     R0,#+0
   \   0000017E   0x8030             STRH     R0,[R6, #+0]
    862          }
   \                     ??OSMutexPost_1: (+1)
   \   00000180   0xE8BD 0x87F3      POP      {R0,R1,R4-R10,PC}  ;; return
    863          
    864          
    865          /*
    866          ************************************************************************************************************************
    867          *                                            CLEAR THE CONTENTS OF A MUTEX
    868          *
    869          * Description: This function is called by OSMutexDel() to clear the contents of a mutex
    870          *
    871          
    872          * Argument(s): p_mutex      is a pointer to the mutex to clear
    873          *              -------
    874          *
    875          * Returns    : none
    876          *
    877          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
    878          ************************************************************************************************************************
    879          */
    880          

   \                                 In section .text, align 2, keep-with-next
    881          void  OS_MutexClr (OS_MUTEX  *p_mutex)
    882          {
   \                     OS_MutexClr: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    883          #if (OS_OBJ_TYPE_REQ == DEF_ENABLED)
    884              p_mutex->Type              =  OS_OBJ_TYPE_NONE;             /* Mark the data structure as a NONE                    */
   \   00000002   0x....             LDR.N    R1,??DataTable7_7  ;; 0x454e4f4e
   \   00000004   0x6001             STR      R1,[R0, #+0]
    885          #endif
    886          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    887              p_mutex->NamePtr           = (CPU_CHAR *)((void *)"?MUTEX");
   \   00000006   0x....             LDR.N    R1,??DataTable7_8
   \   00000008   0x6041             STR      R1,[R0, #+4]
    888          #endif
    889              p_mutex->MutexGrpNextPtr   = DEF_NULL;
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x6201             STR      R1,[R0, #+32]
    890              p_mutex->OwnerTCBPtr       = DEF_NULL;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x6241             STR      R1,[R0, #+36]
    891              p_mutex->OwnerNestingCtr   = 0u;
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0xF880 0x1028      STRB     R1,[R0, #+40]
    892          #if (OS_CFG_TS_EN == DEF_ENABLED)
    893              p_mutex->TS                = 0u;
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x62C1             STR      R1,[R0, #+44]
    894          #endif
    895              OS_PendListInit(&p_mutex->PendList);                        /* Initialize the waiting list                          */
   \   0000001C   0x3008             ADDS     R0,R0,#+8
   \   0000001E   0x.... 0x....      BL       OS_PendListInit
    896          }
   \   00000022   0xBD01             POP      {R0,PC}          ;; return
    897          
    898          
    899          /*
    900          ************************************************************************************************************************
    901          *                                          ADD/REMOVE MUTEX TO/FROM DEBUG LIST
    902          *
    903          * Description: These functions are called by uC/OS-III to add or remove a mutex to/from the debug list.
    904          *
    905          * Arguments  : p_mutex     is a pointer to the mutex to add/remove
    906          *
    907          * Returns    : none
    908          *
    909          * Note(s)    : These functions are INTERNAL to uC/OS-III and your application should not call it.
    910          ************************************************************************************************************************
    911          */
    912          
    913          #if (OS_CFG_DBG_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    914          void  OS_MutexDbgListAdd (OS_MUTEX  *p_mutex)
    915          {
    916              p_mutex->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
   \                     OS_MutexDbgListAdd: (+1)
   \   00000000   0x....             ADR.N    R1,??DataTable7  ;; " "
   \   00000002   0x61C1             STR      R1,[R0, #+28]
    917              p_mutex->DbgPrevPtr               = DEF_NULL;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6141             STR      R1,[R0, #+20]
    918              if (OSMutexDbgListPtr == DEF_NULL) {
   \   00000008   0x....             LDR.N    R1,??DataTable7_9
   \   0000000A   0x6809             LDR      R1,[R1, #+0]
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD102             BNE.N    ??OS_MutexDbgListAdd_0
    919                  p_mutex->DbgNextPtr           = DEF_NULL;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6181             STR      R1,[R0, #+24]
   \   00000014   0xE005             B.N      ??OS_MutexDbgListAdd_1
    920              } else {
    921                  p_mutex->DbgNextPtr           =  OSMutexDbgListPtr;
   \                     ??OS_MutexDbgListAdd_0: (+1)
   \   00000016   0x....             LDR.N    R1,??DataTable7_9
   \   00000018   0x6809             LDR      R1,[R1, #+0]
   \   0000001A   0x6181             STR      R1,[R0, #+24]
    922                  OSMutexDbgListPtr->DbgPrevPtr =  p_mutex;
   \   0000001C   0x....             LDR.N    R1,??DataTable7_9
   \   0000001E   0x6809             LDR      R1,[R1, #+0]
   \   00000020   0x6148             STR      R0,[R1, #+20]
    923              }
    924              OSMutexDbgListPtr                 =  p_mutex;
   \                     ??OS_MutexDbgListAdd_1: (+1)
   \   00000022   0x....             LDR.N    R1,??DataTable7_9
   \   00000024   0x6008             STR      R0,[R1, #+0]
    925          }
   \   00000026   0x4770             BX       LR               ;; return
    926          
    927          

   \                                 In section .text, align 2, keep-with-next
    928          void  OS_MutexDbgListRemove (OS_MUTEX  *p_mutex)
    929          {
    930              OS_MUTEX  *p_mutex_next;
    931              OS_MUTEX  *p_mutex_prev;
    932          
    933          
    934              p_mutex_prev = p_mutex->DbgPrevPtr;
   \                     OS_MutexDbgListRemove: (+1)
   \   00000000   0x6942             LDR      R2,[R0, #+20]
    935              p_mutex_next = p_mutex->DbgNextPtr;
   \   00000002   0x6981             LDR      R1,[R0, #+24]
    936          
    937              if (p_mutex_prev == DEF_NULL) {
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD108             BNE.N    ??OS_MutexDbgListRemove_0
    938                  OSMutexDbgListPtr = p_mutex_next;
   \   00000008   0x....             LDR.N    R2,??DataTable7_9
   \   0000000A   0x6011             STR      R1,[R2, #+0]
    939                  if (p_mutex_next != DEF_NULL) {
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD001             BEQ.N    ??OS_MutexDbgListRemove_1
    940                      p_mutex_next->DbgPrevPtr = DEF_NULL;
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x614A             STR      R2,[R1, #+20]
    941                  }
    942                  p_mutex->DbgNextPtr = DEF_NULL;
   \                     ??OS_MutexDbgListRemove_1: (+1)
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x6181             STR      R1,[R0, #+24]
   \   00000018   0xE00C             B.N      ??OS_MutexDbgListRemove_2
    943          
    944              } else if (p_mutex_next == DEF_NULL) {
   \                     ??OS_MutexDbgListRemove_0: (+1)
   \   0000001A   0x2900             CMP      R1,#+0
   \   0000001C   0xD104             BNE.N    ??OS_MutexDbgListRemove_3
    945                  p_mutex_prev->DbgNextPtr = DEF_NULL;
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x6191             STR      R1,[R2, #+24]
    946                  p_mutex->DbgPrevPtr      = DEF_NULL;
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0x6141             STR      R1,[R0, #+20]
   \   00000026   0xE005             B.N      ??OS_MutexDbgListRemove_2
    947          
    948              } else {
    949                  p_mutex_prev->DbgNextPtr =  p_mutex_next;
   \                     ??OS_MutexDbgListRemove_3: (+1)
   \   00000028   0x6191             STR      R1,[R2, #+24]
    950                  p_mutex_next->DbgPrevPtr =  p_mutex_prev;
   \   0000002A   0x614A             STR      R2,[R1, #+20]
    951                  p_mutex->DbgNextPtr      = DEF_NULL;
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x6181             STR      R1,[R0, #+24]
    952                  p_mutex->DbgPrevPtr      = DEF_NULL;
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0x6141             STR      R1,[R0, #+20]
    953              }
    954          }
   \                     ??OS_MutexDbgListRemove_2: (+1)
   \   00000034   0x4770             BX       LR               ;; return
    955          #endif
    956          
    957          
    958          /*
    959          ************************************************************************************************************************
    960          *                                               MUTEX GROUP ADD
    961          *
    962          * Description: This function is called by the kernel to add a mutex to a task's mutex group.
    963          *
    964          
    965          * Argument(s): p_tcb        is a pointer to the tcb of the task to give the mutex to.
    966          *
    967          *              p_mutex      is a point to the mutex to add to the group.
    968          *
    969          *
    970          * Returns    : none
    971          *
    972          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    973          ************************************************************************************************************************
    974          */
    975          

   \                                 In section .text, align 2, keep-with-next
    976          void  OS_MutexGrpAdd (OS_TCB  *p_tcb, OS_MUTEX  *p_mutex)
    977          {
    978              p_mutex->MutexGrpNextPtr = p_tcb->MutexGrpHeadPtr;      /* The mutex grp is not sorted add to head of list.       */
   \                     OS_MutexGrpAdd: (+1)
   \   00000000   0x6C42             LDR      R2,[R0, #+68]
   \   00000002   0x620A             STR      R2,[R1, #+32]
    979              p_tcb->MutexGrpHeadPtr   = p_mutex;
   \   00000004   0x6441             STR      R1,[R0, #+68]
    980          }
   \   00000006   0x4770             BX       LR               ;; return
    981          
    982          
    983          /*
    984          ************************************************************************************************************************
    985          *                                              MUTEX GROUP REMOVE
    986          *
    987          * Description: This function is called by the kernel to remove a mutex to a task's mutex group.
    988          *
    989          
    990          * Argument(s): p_tcb        is a pointer to the tcb of the task to remove the mutex from.
    991          *
    992          *              p_mutex      is a point to the mutex to remove from the group.
    993          *
    994          *
    995          * Returns    : none
    996          *
    997          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    998          ************************************************************************************************************************
    999          */
   1000          

   \                                 In section .text, align 2, keep-with-next
   1001          void  OS_MutexGrpRemove (OS_TCB  *p_tcb, OS_MUTEX  *p_mutex)
   1002          {
   1003              OS_MUTEX  **pp_mutex;
   1004          
   1005              pp_mutex = &p_tcb->MutexGrpHeadPtr;
   \                     OS_MutexGrpRemove: (+1)
   \   00000000   0x3044             ADDS     R0,R0,#+68
   \   00000002   0xE001             B.N      ??OS_MutexGrpRemove_0
   1006          
   1007              while(*pp_mutex != p_mutex) {
   1008                  pp_mutex = &(*pp_mutex)->MutexGrpNextPtr;
   \                     ??OS_MutexGrpRemove_1: (+1)
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x3020             ADDS     R0,R0,#+32
   1009              }
   \                     ??OS_MutexGrpRemove_0: (+1)
   \   00000008   0x6802             LDR      R2,[R0, #+0]
   \   0000000A   0x428A             CMP      R2,R1
   \   0000000C   0xD1FA             BNE.N    ??OS_MutexGrpRemove_1
   1010          
   1011              *pp_mutex = (*pp_mutex)->MutexGrpNextPtr;
   \   0000000E   0x6801             LDR      R1,[R0, #+0]
   \   00000010   0x6A09             LDR      R1,[R1, #+32]
   \   00000012   0x6001             STR      R1,[R0, #+0]
   1012          }
   \   00000014   0x4770             BX       LR               ;; return
   1013          
   1014          
   1015          /*
   1016          ************************************************************************************************************************
   1017          *                                              MUTEX FIND HIGHEST PENDING
   1018          *
   1019          * Description: This function is called by the kernel to find the highest task pending on any mutex from a group.
   1020          *
   1021          
   1022          * Argument(s): p_tcb        is a pointer to the tcb of the task to process.
   1023          *
   1024          *
   1025          * Returns    : Highest priority pending or OS_CFG_PRIO_MAX - 1u if none found.
   1026          *
   1027          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1028          ************************************************************************************************************************
   1029          */
   1030          

   \                                 In section .text, align 2, keep-with-next
   1031          OS_PRIO  OS_MutexGrpPrioFindHighest (OS_TCB  *p_tcb)
   1032          {
   1033              OS_MUTEX  **pp_mutex;
   1034              OS_PRIO     highest_prio;
   1035              OS_PRIO     prio;
   1036              OS_TCB     *p_head;
   1037          
   1038          
   1039              highest_prio = (OS_PRIO)(OS_CFG_PRIO_MAX - 1u);
   \                     OS_MutexGrpPrioFindHighest: (+1)
   \   00000000   0x213F             MOVS     R1,#+63
   1040              pp_mutex = &p_tcb->MutexGrpHeadPtr;
   \   00000002   0x3044             ADDS     R0,R0,#+68
   \   00000004   0xE00C             B.N      ??OS_MutexGrpPrioFindHighest_0
   1041          
   1042              while(*pp_mutex != DEF_NULL) {
   1043                  p_head = (*pp_mutex)->PendList.HeadPtr;
   \                     ??OS_MutexGrpPrioFindHighest_1: (+1)
   \   00000006   0x6802             LDR      R2,[R0, #+0]
   \   00000008   0x6892             LDR      R2,[R2, #+8]
   1044                  if (p_head != DEF_NULL) {
   \   0000000A   0x2A00             CMP      R2,#+0
   \   0000000C   0xD006             BEQ.N    ??OS_MutexGrpPrioFindHighest_2
   1045                      prio = p_head->Prio;
   \   0000000E   0xF892 0x203F      LDRB     R2,[R2, #+63]
   1046                      if(prio < highest_prio) {
   \   00000012   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000014   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000016   0x428A             CMP      R2,R1
   \   00000018   0xD200             BCS.N    ??OS_MutexGrpPrioFindHighest_2
   1047                          highest_prio = prio;
   \   0000001A   0x0011             MOVS     R1,R2
   1048                      }
   1049                  }
   1050                  pp_mutex = &(*pp_mutex)->MutexGrpNextPtr;
   \                     ??OS_MutexGrpPrioFindHighest_2: (+1)
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x3020             ADDS     R0,R0,#+32
   1051              }
   \                     ??OS_MutexGrpPrioFindHighest_0: (+1)
   \   00000020   0x6802             LDR      R2,[R0, #+0]
   \   00000022   0x2A00             CMP      R2,#+0
   \   00000024   0xD1EF             BNE.N    ??OS_MutexGrpPrioFindHighest_1
   1052          
   1053              return (highest_prio);
   \   00000026   0x0008             MOVS     R0,R1
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0x4770             BX       LR               ;; return
   1054          }
   1055          
   1056          
   1057          /*
   1058          ************************************************************************************************************************
   1059          *                                               MUTEX GROUP POST ALL
   1060          *
   1061          * Description: This function is called by the kernel to post (release) all the mutex from a group. Used when deleting
   1062          *              a task.
   1063          *
   1064          
   1065          * Argument(s): p_tcb        is a pointer to the tcb of the task to process.
   1066          *
   1067          *
   1068          * Returns    : none.
   1069          *
   1070          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1071          ************************************************************************************************************************
   1072          */
   1073          

   \                                 In section .text, align 2, keep-with-next
   1074          void  OS_MutexGrpPostAll (OS_TCB  *p_tcb)
   1075          {
   \                     OS_MutexGrpPostAll: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   1076              OS_MUTEX      *p_mutex;
   1077              OS_MUTEX      *p_mutex_next;
   1078              CPU_TS         ts;
   1079              OS_PEND_LIST  *p_pend_list;
   1080              OS_TCB        *p_tcb_new;
   1081          
   1082          
   1083              p_mutex = p_tcb->MutexGrpHeadPtr;
   \   00000008   0x6C65             LDR      R5,[R4, #+68]
   \   0000000A   0xE011             B.N      ??OS_MutexGrpPostAll_0
   1084          
   1085              while(p_mutex != DEF_NULL) {
   1086          
   1087                  OS_TRACE_MUTEX_POST(p_mutex);
   1088          
   1089                  p_mutex_next = p_mutex->MutexGrpNextPtr;
   1090          #if (OS_CFG_TS_EN == DEF_ENABLED)
   1091                  ts           = OS_TS_GET();                             /* Get timestamp                                        */
   1092                  p_mutex->TS  = ts;
   1093          #else
   1094                  ts           = 0u;
   1095          #endif
   1096                  OS_MutexGrpRemove(p_tcb,  p_mutex);                     /* Remove mutex from owner's group                      */
   1097          
   1098                  p_pend_list = &p_mutex->PendList;
   1099                  if (p_pend_list->HeadPtr == DEF_NULL) {                 /* Any task waiting on mutex?                           */
   1100                      p_mutex->OwnerNestingCtr = 0u;                      /* Decrement owner's nesting counter                    */
   1101                      p_mutex->OwnerTCBPtr     = DEF_NULL;                /* No                                                   */
   1102                  } else {
   1103                                                                          /* Get TCB from head of pend list                       */
   1104                      p_tcb_new                = p_pend_list->HeadPtr;
   \                     ??OS_MutexGrpPostAll_1: (+1)
   \   0000000C   0xF8D0 0x8000      LDR      R8,[R0, #+0]
   1105                      p_mutex->OwnerTCBPtr     = p_tcb;                   /* Give mutex to new owner                              */
   \   00000010   0x626C             STR      R4,[R5, #+36]
   1106                      p_mutex->OwnerNestingCtr = 1u;
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xF885 0x0028      STRB     R0,[R5, #+40]
   1107                      OS_MutexGrpAdd(p_tcb_new, p_mutex);
   \   00000018   0x0029             MOVS     R1,R5
   \   0000001A   0x4640             MOV      R0,R8
   \   0000001C   0x.... 0x....      BL       OS_MutexGrpAdd
   1108                                                                          /* Post to mutex                                        */
   1109                      OS_Post((OS_PEND_OBJ *)p_mutex,
   1110                                             p_tcb_new,
   1111                                             DEF_NULL,
   1112                                             0u,
   1113                                             ts);
   \   00000020   0x9700             STR      R7,[SP, #+0]
   \   00000022   0x2300             MOVS     R3,#+0
   \   00000024   0x2200             MOVS     R2,#+0
   \   00000026   0x4641             MOV      R1,R8
   \   00000028   0x0028             MOVS     R0,R5
   \   0000002A   0x.... 0x....      BL       OS_Post
   1114                  }
   1115          
   1116                  p_mutex = p_mutex_next;
   \                     ??OS_MutexGrpPostAll_2: (+1)
   \   0000002E   0x0035             MOVS     R5,R6
   \                     ??OS_MutexGrpPostAll_0: (+1)
   \   00000030   0x2D00             CMP      R5,#+0
   \   00000032   0xD013             BEQ.N    ??OS_MutexGrpPostAll_3
   \   00000034   0x6A2E             LDR      R6,[R5, #+32]
   \   00000036   0x.... 0x....      BL       CPU_TS_TmrRd
   \   0000003A   0x0007             MOVS     R7,R0
   \   0000003C   0x62EF             STR      R7,[R5, #+44]
   \   0000003E   0x0029             MOVS     R1,R5
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0x.... 0x....      BL       OS_MutexGrpRemove
   \   00000046   0xF115 0x0008      ADDS     R0,R5,#+8
   \   0000004A   0x6801             LDR      R1,[R0, #+0]
   \   0000004C   0x2900             CMP      R1,#+0
   \   0000004E   0xD1DD             BNE.N    ??OS_MutexGrpPostAll_1
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xF885 0x0028      STRB     R0,[R5, #+40]
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x6268             STR      R0,[R5, #+36]
   \   0000005A   0xE7E8             B.N      ??OS_MutexGrpPostAll_2
   1117              }
   1118          
   1119          }
   \                     ??OS_MutexGrpPostAll_3: (+1)
   \   0000005C   0xE8BD 0x81F3      POP      {R0,R1,R4-R8,PC}  ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x20 0x00          DC8      " ",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x........         DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x5854554D         DC32     0x5854554d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0x........         DC32     OSMutexQty

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \   00000000   0x........         DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \   00000000   0x........         DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_6:
   \   00000000   0x........         DC32     OSPrioCur

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_7:
   \   00000000   0x454E4F4E         DC32     0x454e4f4e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_8:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_9:
   \   00000000   0x........         DC32     OSMutexDbgListPtr

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x3F 0x4D          DC8 "?MUTEX"
   \              0x55 0x54    
   \              0x45 0x58    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .rodata, align 2
   \   00000000   0x20 0x00          DC8 " "
   1120          
   1121          #endif /* OS_CFG_MUTEX_EN */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   OSMutexCreate
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OS_MutexDbgListAdd
        24   -> OS_PendListInit
      32   OSMutexDel
        32   -> CPU_IntDisMeasStart
        32   -> CPU_IntDisMeasStop
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> CPU_TS_TmrRd
        32   -> OSSched
        32   -> OS_MutexClr
        32   -> OS_MutexDbgListRemove
        32   -> OS_MutexGrpPrioFindHighest
        32   -> OS_MutexGrpRemove
        32   -> OS_PendAbort
        32   -> OS_TaskChangePrio
      32   OSMutexPend
        32   -> CPU_IntDisMeasStart
        32   -> CPU_IntDisMeasStop
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> OSSched
        32   -> OS_MutexGrpAdd
        32   -> OS_Pend
        32   -> OS_TaskChangePrio
      40   OSMutexPendAbort
        40   -> CPU_IntDisMeasStart
        40   -> CPU_IntDisMeasStop
        40   -> CPU_SR_Restore
        40   -> CPU_SR_Save
        40   -> CPU_TS_TmrRd
        40   -> OSSched
        40   -> OS_MutexGrpPrioFindHighest
        40   -> OS_PendAbort
        40   -> OS_TaskChangePrio
      40   OSMutexPost
        40   -> CPU_IntDisMeasStart
        40   -> CPU_IntDisMeasStop
        40   -> CPU_SR_Restore
        40   -> CPU_SR_Save
        40   -> CPU_TS_TmrRd
        40   -> OSSched
        40   -> OS_MutexGrpAdd
        40   -> OS_MutexGrpPrioFindHighest
        40   -> OS_MutexGrpRemove
        40   -> OS_Post
        40   -> OS_PrioInsert
        40   -> OS_RdyListInsertTail
        40   -> OS_RdyListRemove
       8   OS_MutexClr
         8   -> OS_PendListInit
       0   OS_MutexDbgListAdd
       0   OS_MutexDbgListRemove
       0   OS_MutexGrpAdd
      32   OS_MutexGrpPostAll
        32   -> CPU_TS_TmrRd
        32   -> OS_MutexGrpAdd
        32   -> OS_MutexGrpRemove
        32   -> OS_Post
       0   OS_MutexGrpPrioFindHighest
       0   OS_MutexGrpRemove


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       4  ??DataTable7_7
       4  ??DataTable7_8
       4  ??DataTable7_9
       8  ?_0
       2  ?_1
     120  OSMutexCreate
     342  OSMutexDel
     498  OSMutexPend
     294  OSMutexPendAbort
     388  OSMutexPost
      36  OS_MutexClr
      40  OS_MutexDbgListAdd
      54  OS_MutexDbgListRemove
       8  OS_MutexGrpAdd
      96  OS_MutexGrpPostAll
      44  OS_MutexGrpPrioFindHighest
      22  OS_MutexGrpRemove

 
    10 bytes in section .rodata
 1 982 bytes in section .text
 
 1 982 bytes of CODE  memory
    10 bytes of CONST memory

Errors: none
Warnings: none
