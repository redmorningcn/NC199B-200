###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       15/Jul/2018  10:36:17
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC210\NC210-200处理板\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\bsp.c
#    Command line =  
#        F:\iar\NC210\NC210-200处理板\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\bsp.c
#        -D USE_STDPERIPH_DRIVER -D APP_RELEASE -lCN
#        F:\iar\NC210\NC210-200处理板\project\app_release\List -o
#        F:\iar\NC210\NC210-200处理板\project\app_release\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC210\NC210-200处理板\project\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\config\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\task\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\user\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\OS\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\Ports\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\driver\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-LIB\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Source\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\ST\STM32\inc\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Ports\STM32\STM32F103\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Source\
#        -Ol --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC210\NC210-200处理板\project\app_release\List\bsp.lst
#    Object file  =  F:\iar\NC210\NC210-200处理板\project\app_release\Obj\bsp.o
#
###############################################################################

F:\iar\NC210\NC210-200处理板\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\bsp.c
      1          /*
      2          *********************************************************************************************************
      3          *                                     MICIRUM BOARD SUPPORT PACKAGE
      4          *
      5          *                             (c) Copyright 2013; Micrium, Inc.; Weston, FL
      6          *
      7          *               All rights reserved.  Protected by international copyright laws.
      8          *               Knowledge of the source code may NOT be used to develop a similar product.
      9          *               Please help us continue to provide the Embedded community with the finest
     10          *               software available.  Your honesty is greatly appreciated.
     11          *********************************************************************************************************
     12          */
     13          
     14          /*
     15          *********************************************************************************************************
     16          *
     17          *                                        BOARD SUPPORT PACKAGE
     18          *
     19          *                                     ST Microelectronics STM32
     20          *                                              on the
     21          *
     22          *                                     Micrium uC-Eval-STM32F107
     23          *                                        Evaluation Board
     24          *
     25          * Filename      : bsp.c
     26          * Version       : V1.00
     27          * Programmer(s) : EHS
     28          *********************************************************************************************************
     29          */
     30          
     31          /*
     32          *********************************************************************************************************
     33          *                                             INCLUDE FILES
     34          *********************************************************************************************************
     35          */
     36          
     37          #define  BSP_MODULE
     38          #include <bsp.h>
     39          
     40          
     41          /*
     42          *********************************************************************************************************
     43          *                                            LOCAL DEFINES
     44          *********************************************************************************************************
     45          */
     46          
     47          
     48          /*
     49          *********************************************************************************************************
     50          *                                           LOCAL CONSTANTS
     51          *********************************************************************************************************
     52          */
     53          
     54          #define  BSP_LED_START_BIT  (13 - 1)                            /* LEDs[3:1] are sequentially connected to PTD[15:13].  */
     55          
     56          
     57          /*
     58          *********************************************************************************************************
     59          *                                          LOCAL DATA TYPES
     60          *********************************************************************************************************
     61          */
     62          
     63          
     64          /*
     65          *********************************************************************************************************
     66          *                                            LOCAL TABLES
     67          *********************************************************************************************************
     68          */
     69          
     70          
     71          /*
     72          *********************************************************************************************************
     73          *                                       LOCAL GLOBAL VARIABLES
     74          *********************************************************************************************************
     75          */
     76          

   \                                 In section .bss, align 4
     77          CPU_INT32U  BSP_CPU_ClkFreq_MHz;
   \                     BSP_CPU_ClkFreq_MHz:
   \   00000000                      DS8 4
     78          
     79          
     80          /*
     81          *********************************************************************************************************
     82          *                                      LOCAL FUNCTION PROTOTYPES
     83          *********************************************************************************************************
     84          */
     85          
     86          static  void  BSP_LED_Init   (void);
     87          static  void  BSP_StatusInit (void);
     88          
     89          /*
     90          *********************************************************************************************************
     91          *                                             REGISTERS
     92          *********************************************************************************************************
     93          */
     94          
     95          #define  DWT_CR      *(CPU_REG32 *)0xE0001000
     96          #define  DWT_CYCCNT  *(CPU_REG32 *)0xE0001004
     97          #define  DEM_CR      *(CPU_REG32 *)0xE000EDFC
     98          #define  DBGMCU_CR   *(CPU_REG32 *)0xE0042004
     99          
    100          
    101          /*
    102          *********************************************************************************************************
    103          *                                            REGISTER BITS
    104          *********************************************************************************************************
    105          */
    106          
    107          #define  DBGMCU_CR_TRACE_IOEN_MASK       0x10
    108          #define  DBGMCU_CR_TRACE_MODE_ASYNC      0x00
    109          #define  DBGMCU_CR_TRACE_MODE_SYNC_01    0x40
    110          #define  DBGMCU_CR_TRACE_MODE_SYNC_02    0x80
    111          #define  DBGMCU_CR_TRACE_MODE_SYNC_04    0xC0
    112          #define  DBGMCU_CR_TRACE_MODE_MASK       0xC0
    113          
    114          #define  DEM_CR_TRCENA                   (1 << 24)
    115          
    116          #define  DWT_CR_CYCCNTENA                (1 <<  0)
    117          
    118          
    119          /*
    120          *********************************************************************************************************
    121          *                                     LOCAL CONFIGURATION ERRORS
    122          *********************************************************************************************************
    123          */
    124          /*
    125          #if ((CPU_CFG_TS_TMR_EN          != DEF_ENABLED) && \
    126               (APP_CFG_PROBE_OS_PLUGIN_EN == DEF_ENABLED) && \
    127               (OS_PROBE_HOOKS_EN          >  0u))
    128          #error  "CPU_CFG_TS_EN                  illegally #define'd in 'cpu.h'"
    129          #error  "                              [MUST be  DEF_ENABLED] when    "
    130          #error  "                               using uC/Probe COM modules    "
    131          #endif
    132          
    133          */
    134          
    135          /*******************************************************************************
    136          * Description  : 快速配置GPIO口
    137          * Author       : 2018/5/15 星期二, by redmorningcn
    138          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    139          void	GPIO_Config(u16 GpioNum,u8 FuncNum)
    140          {
   \                     GPIO_Config: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB090             SUB      SP,SP,#+64
   \   00000004   0x0006             MOVS     R6,R0
   \   00000006   0x000D             MOVS     R5,R1
    141              GPIO_InitTypeDef  gpio_init;
    142              u8		PortNum;
    143          	u8		IoNum;
    144              u32 RccBuf[] = {    RCC_APB2Periph_GPIOA,
    145                                  RCC_APB2Periph_GPIOB,
    146                                  RCC_APB2Periph_GPIOC,
    147                                  RCC_APB2Periph_GPIOD,
    148                                  RCC_APB2Periph_GPIOE,
    149                                  RCC_APB2Periph_GPIOF,
    150                                  RCC_APB2Periph_GPIOG
    151                              };
   \   00000008   0xA808             ADD      R0,SP,#+32
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable8
   \   0000000E   0x221C             MOVS     R2,#+28
   \   00000010   0x.... 0x....      BL       __aeabi_memcpy4
    152              
    153              GPIO_TypeDef* PortBuf[] = {   GPIOA,
    154                                  GPIOB,
    155                                  GPIOC,
    156                                  GPIOD,
    157                                  GPIOE,
    158                                  GPIOF,
    159                                  GPIOG
    160                              };
   \   00000014   0xA801             ADD      R0,SP,#+4
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable8_1
   \   0000001A   0x221C             MOVS     R2,#+28
   \   0000001C   0x.... 0x....      BL       __aeabi_memcpy4
    161              
    162              PortNum 	= GpioNum/100;
   \   00000020   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000022   0x2064             MOVS     R0,#+100
   \   00000024   0xFB96 0xF4F0      SDIV     R4,R6,R0
    163          	IoNum	    = GpioNum%100;
   \   00000028   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000002A   0x2064             MOVS     R0,#+100
   \   0000002C   0xFB96 0xF1F0      SDIV     R1,R6,R0
   \   00000030   0xFB00 0x6611      MLS      R6,R0,R1,R6
    164              
    165              RCC_APB2PeriphClockCmd(RccBuf[PortNum], ENABLE);
   \   00000034   0x2101             MOVS     R1,#+1
   \   00000036   0xA808             ADD      R0,SP,#+32
   \   00000038   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003A   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000003E   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    166          
    167              gpio_init.GPIO_Pin   = (0x01<<IoNum);
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0x40B0             LSLS     R0,R0,R6
   \   00000046   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    168              gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
   \   0000004A   0x2003             MOVS     R0,#+3
   \   0000004C   0xF88D 0x0002      STRB     R0,[SP, #+2]
    169              
    170              if(FuncNum == 0)
   \   00000050   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000052   0x2D00             CMP      R5,#+0
   \   00000054   0xD103             BNE.N    ??GPIO_Config_0
    171                  gpio_init.GPIO_Mode  = GPIO_Mode_Out_PP;        //推拉输出
   \   00000056   0x2010             MOVS     R0,#+16
   \   00000058   0xF88D 0x0003      STRB     R0,[SP, #+3]
   \   0000005C   0xE002             B.N      ??GPIO_Config_1
    172              else
    173                  gpio_init.GPIO_Mode  = GPIO_Mode_IPU;           //上拉输入
   \                     ??GPIO_Config_0: (+1)
   \   0000005E   0x2048             MOVS     R0,#+72
   \   00000060   0xF88D 0x0003      STRB     R0,[SP, #+3]
    174          
    175              GPIO_Init(PortBuf[PortNum], &gpio_init);
   \                     ??GPIO_Config_1: (+1)
   \   00000064   0x4669             MOV      R1,SP
   \   00000066   0xA801             ADD      R0,SP,#+4
   \   00000068   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000006A   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000006E   0x.... 0x....      BL       GPIO_Init
    176          }
   \   00000072   0xB010             ADD      SP,SP,#+64
   \   00000074   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x40010800         DC32 40010800H, 40010C00H, 40011000H, 40011400H, 40011800H, 40011C00H
   \              0x40010C00   
   \              0x40011000   
   \              0x40011400   
   \              0x40011800   
   \              0x40011C00   
   \   00000018   0x40012000         DC32 40012000H
    177          
    178          /*******************************************************************************
    179          * Description  : GPIO端口设值（pb01=101）
    180          * Author       : 2018/5/15 星期二, by redmorningcn
    181          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    182          void	GPIO_Set(u32 GpioNum,u8 Val)
    183          {
   \                     GPIO_Set: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000E             MOVS     R6,R1
    184              GPIO_TypeDef* PortBuf[] = {   GPIOA,
    185                                  GPIOB,
    186                                  GPIOC,
    187                                  GPIOD,
    188                                  GPIOE,
    189                                  GPIOF,
    190                                  GPIOG
    191                              };
   \   00000008   0x4668             MOV      R0,SP
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable8_2
   \   0000000E   0x221C             MOVS     R2,#+28
   \   00000010   0x.... 0x....      BL       __aeabi_memcpy4
    192          	u8		PortNum;
    193          	u8		IoNum;
    194          
    195          	PortNum 	= GpioNum/100;
   \   00000014   0x2064             MOVS     R0,#+100
   \   00000016   0xFBB5 0xF4F0      UDIV     R4,R5,R0
    196          	IoNum	    = GpioNum%100;
   \   0000001A   0x2064             MOVS     R0,#+100
   \   0000001C   0xFBB5 0xF1F0      UDIV     R1,R5,R0
   \   00000020   0xFB00 0x5711      MLS      R7,R0,R1,R5
    197              
    198              GPIO_Config(GpioNum,0);                           //将端口置为输出
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0x0028             MOVS     R0,R5
   \   00000028   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000002A   0x.... 0x....      BL       GPIO_Config
    199              
    200              if(Val)
   \   0000002E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000030   0x2E00             CMP      R6,#+0
   \   00000032   0xD00A             BEQ.N    ??GPIO_Set_0
    201                  GPIO_SetBits(  PortBuf[PortNum],(0x01<<IoNum));     //将端口置1 
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0x40B8             LSLS     R0,R0,R7
   \   00000038   0x0001             MOVS     R1,R0
   \   0000003A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000003C   0x4668             MOV      R0,SP
   \   0000003E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000040   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000044   0x.... 0x....      BL       GPIO_SetBits
   \   00000048   0xE009             B.N      ??GPIO_Set_1
    202              else
    203                  GPIO_ResetBits(PortBuf[PortNum],(0x01<<IoNum));     //将端口置0
   \                     ??GPIO_Set_0: (+1)
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0x40B8             LSLS     R0,R0,R7
   \   0000004E   0x0001             MOVS     R1,R0
   \   00000050   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000052   0x4668             MOV      R0,SP
   \   00000054   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000056   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000005A   0x.... 0x....      BL       GPIO_ResetBits
    204          }
   \                     ??GPIO_Set_1: (+1)
   \   0000005E   0xB007             ADD      SP,SP,#+28
   \   00000060   0xBDF0             POP      {R4-R7,PC}       ;; return

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x40010800         DC32 40010800H, 40010C00H, 40011000H, 40011400H, 40011800H, 40011C00H
   \              0x40010C00   
   \              0x40011000   
   \              0x40011400   
   \              0x40011800   
   \              0x40011C00   
   \   00000018   0x40012000         DC32 40012000H
    205          
    206          /*******************************************************************************
    207          * Description  : 返回IO端口值
    208          * Author       : 2018/5/15 星期二, by redmorningcn
    209          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    210          u8	GPIO_Read(u32 GpioNum)
    211          {
   \                     GPIO_Read: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   \   00000004   0x0004             MOVS     R4,R0
    212              GPIO_TypeDef* PortBuf[] = {   GPIOA,
    213                                  GPIOB,
    214                                  GPIOC,
    215                                  GPIOD,
    216                                  GPIOE,
    217                                  GPIOF,
    218                                  GPIOG
    219                              };
   \   00000006   0x4668             MOV      R0,SP
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable8_3
   \   0000000C   0x221C             MOVS     R2,#+28
   \   0000000E   0x.... 0x....      BL       __aeabi_memcpy4
    220          	u8		PortNum;
    221          	u8		IoNum;
    222          
    223          	PortNum 	= GpioNum/100;
   \   00000012   0x2064             MOVS     R0,#+100
   \   00000014   0xFBB4 0xF5F0      UDIV     R5,R4,R0
    224          	IoNum	    = GpioNum%100;
   \   00000018   0x2064             MOVS     R0,#+100
   \   0000001A   0xFBB4 0xF1F0      UDIV     R1,R4,R0
   \   0000001E   0xFB00 0x4611      MLS      R6,R0,R1,R4
    225              
    226              GPIO_Config(GpioNum,1);                           //将端口置为输入
   \   00000022   0x2101             MOVS     R1,#+1
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000028   0x.... 0x....      BL       GPIO_Config
    227          
    228              return GPIO_ReadInputDataBit(PortBuf[PortNum], (0x01<<IoNum));
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x40B0             LSLS     R0,R0,R6
   \   00000030   0x0001             MOVS     R1,R0
   \   00000032   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000034   0x4668             MOV      R0,SP
   \   00000036   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000038   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   0000003C   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \   00000040   0xB008             ADD      SP,SP,#+32
   \   00000042   0xBD70             POP      {R4-R6,PC}       ;; return
    229          }

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x40010800         DC32 40010800H, 40010C00H, 40011000H, 40011400H, 40011800H, 40011C00H
   \              0x40010C00   
   \              0x40011000   
   \              0x40011400   
   \              0x40011800   
   \              0x40011C00   
   \   00000018   0x40012000         DC32 40012000H
    230          
    231          /*******************************************************************************
    232          * Description  : GPIO端口设值（pb01=101）
    233          * Author       : 2018/5/15 星期二, by redmorningcn
    234          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    235          void	GPIO_Toggle(u32 GpioNum)
    236          {
   \                     GPIO_Toggle: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   \   00000004   0x0004             MOVS     R4,R0
    237              GPIO_TypeDef* PortBuf[] = {   
    238                                  GPIOA,
    239                                  GPIOB,
    240                                  GPIOC,
    241                                  GPIOD,
    242                                  GPIOE,
    243                                  GPIOF,
    244                                  GPIOG
    245                              };
   \   00000006   0x4668             MOV      R0,SP
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable8_4
   \   0000000C   0x221C             MOVS     R2,#+28
   \   0000000E   0x.... 0x....      BL       __aeabi_memcpy4
    246          	u8		PortNum;
    247          	u8		IoNum;
    248              
    249              PortNum 	= GpioNum/100;
   \   00000012   0x2064             MOVS     R0,#+100
   \   00000014   0xFBB4 0xF5F0      UDIV     R5,R4,R0
    250          	IoNum	    = GpioNum%100;
   \   00000018   0x2064             MOVS     R0,#+100
   \   0000001A   0xFBB4 0xF1F0      UDIV     R1,R4,R0
   \   0000001E   0xFB00 0x4611      MLS      R6,R0,R1,R4
    251              
    252              GPIO_Config(GpioNum,0);                     //将端口置为输出
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000028   0x.... 0x....      BL       GPIO_Config
    253              
    254              if(GPIO_ReadOutputDataBit(PortBuf[PortNum], (0x01<<IoNum)))
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x40B0             LSLS     R0,R0,R6
   \   00000030   0x0001             MOVS     R1,R0
   \   00000032   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000034   0x4668             MOV      R0,SP
   \   00000036   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000038   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   0000003C   0x.... 0x....      BL       GPIO_ReadOutputDataBit
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD004             BEQ.N    ??GPIO_Toggle_0
    255                  GPIO_Set(GpioNum,0);                    //如果端口为1，则将端口该写为0
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0x.... 0x....      BL       GPIO_Set
   \   0000004C   0xE003             B.N      ??GPIO_Toggle_1
    256              else
    257                  GPIO_Set(GpioNum,1);
   \                     ??GPIO_Toggle_0: (+1)
   \   0000004E   0x2101             MOVS     R1,#+1
   \   00000050   0x0020             MOVS     R0,R4
   \   00000052   0x.... 0x....      BL       GPIO_Set
    258          }
   \                     ??GPIO_Toggle_1: (+1)
   \   00000056   0xB008             ADD      SP,SP,#+32
   \   00000058   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .rodata, align 4
   \                     ?_4:
   \   00000000   0x40010800         DC32 40010800H, 40010C00H, 40011000H, 40011400H, 40011800H, 40011C00H
   \              0x40010C00   
   \              0x40011000   
   \              0x40011400   
   \              0x40011800   
   \              0x40011C00   
   \   00000018   0x40012000         DC32 40012000H
    259          
    260          
    261          /*
    262          *********************************************************************************************************
    263          *                                               BSP_Init()
    264          *
    265          * Description : Initialize the Board Support Package (BSP).
    266          *
    267          * Argument(s) : none.
    268          *
    269          * Return(s)   : none.
    270          *
    271          * Caller(s)   : Application.
    272          *
    273          * Note(s)     : (1) This function SHOULD be called before any other BSP function is called.
    274          *
    275          *               (2) CPU instruction / data tracing requires the use of the following pins :
    276          *                   (a) (1) Aysynchronous     :  PB[3]
    277          *                       (2) Synchronous 1-bit :  PE[3:2]
    278          *                       (3) Synchronous 2-bit :  PE[4:2]
    279          *                       (4) Synchronous 4-bit :  PE[6:2]
    280          *
    281          *                   (b) The uC-Eval board MAY utilize the following pins depending on the application :
    282          *                       (1) PE[5], MII_INT
    283          *                       (1) PE[6], SDCard_Detection
    284          *
    285          *                   (c) The application may wish to adjust the trace bus width depending on I/O
    286          *                       requirements.
    287          *********************************************************************************************************
    288          */

   \                                 In section .text, align 2, keep-with-next
    289          void  BSP_Init (void)
    290          {
   \                     BSP_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    291              BSP_IntInit();
   \   00000002   0x.... 0x....      BL       BSP_IntInit
    292          
    293              RCC_DeInit();
   \   00000006   0x.... 0x....      BL       RCC_DeInit
    294              RCC_HSEConfig(RCC_HSE_ON);                                  /* HSE = 25MHz ext. crystal.                            */
   \   0000000A   0xF45F 0x3080      MOVS     R0,#+65536
   \   0000000E   0x.... 0x....      BL       RCC_HSEConfig
    295              RCC_WaitForHSEStartUp();
   \   00000012   0x.... 0x....      BL       RCC_WaitForHSEStartUp
    296          
    297          
    298              RCC_PREDIV2Config(RCC_PREDIV2_Div5);                        /* Fprediv2 = HSE      /  5 =  5MHz.                    */
   \   00000016   0x2040             MOVS     R0,#+64
   \   00000018   0x.... 0x....      BL       RCC_PREDIV2Config
    299              RCC_PLL2Config(RCC_PLL2Mul_8);                              /* PLL2     = Fprediv2 *  8 = 40MHz.                    */
   \   0000001C   0xF44F 0x60C0      MOV      R0,#+1536
   \   00000020   0x.... 0x....      BL       RCC_PLL2Config
    300              RCC_PLL2Cmd(ENABLE);
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x.... 0x....      BL       RCC_PLL2Cmd
    301              RCC_PLL3Config(RCC_PLL3Mul_10);                             /* PLL3     = Fprediv2 * 10 = 50MHz.                    */
   \   0000002A   0xF44F 0x4000      MOV      R0,#+32768
   \   0000002E   0x.... 0x....      BL       RCC_PLL3Config
    302              RCC_PLL3Cmd(ENABLE);
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x.... 0x....      BL       RCC_PLL3Cmd
    303          
    304              RCC_HCLKConfig(RCC_SYSCLK_Div1);                            /* HCLK    = AHBCLK  = PLL1 / AHBPRES(1) = 72MHz.       */
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x.... 0x....      BL       RCC_HCLKConfig
    305              RCC_PCLK2Config(RCC_HCLK_Div1);                             /* APB2CLK = AHBCLK  / APB2DIV(1)  = 72MHz.             */
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x.... 0x....      BL       RCC_PCLK2Config
    306              RCC_PCLK1Config(RCC_HCLK_Div2);                             /* APB1CLK = AHBCLK  / APB1DIV(2)  = 36MHz (max).       */
   \   00000044   0xF44F 0x6080      MOV      R0,#+1024
   \   00000048   0x.... 0x....      BL       RCC_PCLK1Config
    307              RCC_ADCCLKConfig(RCC_PCLK2_Div6);                           /* ADCCLK  = AHBCLK  / APB2DIV / 6 = 12MHz.             */
   \   0000004C   0xF44F 0x4000      MOV      R0,#+32768
   \   00000050   0x.... 0x....      BL       RCC_ADCCLKConfig
    308              RCC_OTGFSCLKConfig(RCC_OTGFSCLKSource_PLL1VCO_Div3);        /* OTGCLK  = PLL1VCO / USBPRES(3)  = 144MHz / 3 = 48MHz */
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x.... 0x....      BL       RCC_OTGFSCLKConfig
    309          
    310              FLASH_SetLatency(FLASH_Latency_2);                          /* 2 Flash wait states when HCLK > 48MHz.               */
   \   0000005A   0x2002             MOVS     R0,#+2
   \   0000005C   0x.... 0x....      BL       FLASH_SetLatency
    311              FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
   \   00000060   0x2010             MOVS     R0,#+16
   \   00000062   0x.... 0x....      BL       FLASH_PrefetchBufferCmd
    312          
    313              int time = 10000;       //redmorningcn 180530 防止卡死              
   \   00000066   0xF242 0x7410      MOVW     R4,#+10000
    314              while (RCC_GetFlagStatus(RCC_FLAG_PLL2RDY) == RESET) {      /* Wait for PLL2 to lock.                               */
   \                     ??BSP_Init_0: (+1)
   \   0000006A   0x203B             MOVS     R0,#+59
   \   0000006C   0x.... 0x....      BL       RCC_GetFlagStatus
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD102             BNE.N    ??BSP_Init_1
    315                  time--;
   \   00000074   0x1E64             SUBS     R4,R4,#+1
    316                  if(time == 0)
   \   00000076   0x2C00             CMP      R4,#+0
   \   00000078   0xD1F7             BNE.N    ??BSP_Init_0
    317                      break;
    318              }
    319          
    320              time = 10000;           //redmorningcn 180530 防止卡死              
   \                     ??BSP_Init_1: (+1)
   \   0000007A   0xF242 0x7410      MOVW     R4,#+10000
    321              while (RCC_GetFlagStatus(RCC_FLAG_PLL3RDY) == RESET) {      /* Wait for PLL3 to lock.                               */
   \                     ??BSP_Init_2: (+1)
   \   0000007E   0x203D             MOVS     R0,#+61
   \   00000080   0x.... 0x....      BL       RCC_GetFlagStatus
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD102             BNE.N    ??BSP_Init_3
    322                  time--;
   \   00000088   0x1E64             SUBS     R4,R4,#+1
    323                  if(time == 0)
   \   0000008A   0x2C00             CMP      R4,#+0
   \   0000008C   0xD1F7             BNE.N    ??BSP_Init_2
    324                      break;
    325              }
    326                                                                          /* Fprediv1 = PLL2 / 5 =  8MHz.                         */
    327              RCC_PREDIV1Config(RCC_PREDIV1_Source_PLL2, RCC_PREDIV1_Div5);
   \                     ??BSP_Init_3: (+1)
   \   0000008E   0x2104             MOVS     R1,#+4
   \   00000090   0xF45F 0x3080      MOVS     R0,#+65536
   \   00000094   0x.... 0x....      BL       RCC_PREDIV1Config
    328              RCC_PLL1Config(RCC_PLL1Source_PREDIV1, RCC_PLL1Mul_9);      /* PLL1 = Fprediv1 * 9 = 72Mhz.                         */
   \   00000098   0xF45F 0x11E0      MOVS     R1,#+1835008
   \   0000009C   0xF45F 0x3080      MOVS     R0,#+65536
   \   000000A0   0x.... 0x....      BL       RCC_PLL1Config
    329              RCC_PLL1Cmd(ENABLE);
   \   000000A4   0x2001             MOVS     R0,#+1
   \   000000A6   0x.... 0x....      BL       RCC_PLL1Cmd
    330              while (RCC_GetFlagStatus(RCC_FLAG_PLL1RDY) == RESET) {      /* Wait for PLL1 to lock.                               */
   \                     ??BSP_Init_4: (+1)
   \   000000AA   0x2039             MOVS     R0,#+57
   \   000000AC   0x.... 0x....      BL       RCC_GetFlagStatus
   \   000000B0   0x2800             CMP      R0,#+0
   \   000000B2   0xD0FA             BEQ.N    ??BSP_Init_4
    331                  ;
    332              }
    333          
    334          
    335              RCC_SYSCLKConfig(RCC_SYSCLKSource_PLL1CLK);                 /* HCLK = SYSCLK = PLL1 = 72MHz.                        */
   \   000000B4   0x2002             MOVS     R0,#+2
   \   000000B6   0x.... 0x....      BL       RCC_SYSCLKConfig
    336              while (RCC_GetSYSCLKSource() != 0x08) {
   \                     ??BSP_Init_5: (+1)
   \   000000BA   0x.... 0x....      BL       RCC_GetSYSCLKSource
   \   000000BE   0x2808             CMP      R0,#+8
   \   000000C0   0xD1FB             BNE.N    ??BSP_Init_5
    337                  ;
    338              }
    339          
    340              BSP_CPU_ClkFreq_MHz = BSP_CPU_ClkFreq() / (CPU_INT32U)1000000;
   \   000000C2   0x.... 0x....      BL       BSP_CPU_ClkFreq
   \   000000C6   0x.... 0x....      LDR.W    R1,??DataTable8_5  ;; 0xf4240
   \   000000CA   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000000CE   0x.... 0x....      LDR.W    R1,??DataTable8_6
   \   000000D2   0x6008             STR      R0,[R1, #+0]
    341          
    342              BSP_CPU_ClkFreq_MHz = BSP_CPU_ClkFreq_MHz;                  /* Surpress compiler warning BSP_CPU_ClkFreq_MHz    ... */
   \   000000D4   0x.... 0x....      LDR.W    R0,??DataTable8_6
   \   000000D8   0x6800             LDR      R0,[R0, #+0]
   \   000000DA   0x.... 0x....      LDR.W    R1,??DataTable8_6
   \   000000DE   0x6008             STR      R0,[R1, #+0]
    343                                                                          /* ... set and not used.                                */
    344          
    345              BSP_LED_Init();                                             /* Initialize the I/Os for the LED      controls.       */
   \   000000E0   0x.... 0x....      BL       BSP_LED_Init
    346          
    347              BSP_StatusInit();                                           /* Initialize the status input(s)                       */
   \   000000E4   0x.... 0x....      BL       BSP_StatusInit
    348          
    349              extern  void    BSP_Init_Hook(void);
    350              BSP_Init_Hook();                                            //redmorningcn  BSP初始化钩子函数，在任务开始前执行 
   \   000000E8   0x.... 0x....      BL       BSP_Init_Hook
    351              
    352          #ifdef TRACE_EN                                                 /* See project / compiler preprocessor options.         */
    353              DBGMCU_CR |=  DBGMCU_CR_TRACE_IOEN_MASK;                    /* Enable tracing (see Note #2).                        */
    354              DBGMCU_CR &= ~DBGMCU_CR_TRACE_MODE_MASK;                    /* Clr trace mode sel bits.                             */
    355              DBGMCU_CR |=  DBGMCU_CR_TRACE_MODE_SYNC_04;                 /* Cfg trace mode to synch 4-bit.                       */
    356          #endif
    357          }
   \   000000EC   0xBD10             POP      {R4,PC}          ;; return
    358          
    359          
    360          /*
    361          *********************************************************************************************************
    362          *                                            BSP_CPU_ClkFreq()
    363          *
    364          * Description : Read CPU registers to determine the CPU clock frequency of the chip.
    365          *
    366          * Argument(s) : none.
    367          *
    368          * Return(s)   : The CPU clock frequency, in Hz.
    369          *
    370          * Caller(s)   : Application.
    371          *
    372          * Note(s)     : none.
    373          *********************************************************************************************************
    374          */
    375          

   \                                 In section .text, align 2, keep-with-next
    376          CPU_INT32U  BSP_CPU_ClkFreq (void)
    377          {
   \                     BSP_CPU_ClkFreq: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
    378              RCC_ClocksTypeDef  rcc_clocks;
    379          
    380          
    381              RCC_GetClocksFreq(&rcc_clocks);
   \   00000004   0x4668             MOV      R0,SP
   \   00000006   0x.... 0x....      BL       RCC_GetClocksFreq
    382          
    383              return ((CPU_INT32U)rcc_clocks.HCLK_Frequency);
   \   0000000A   0x9801             LDR      R0,[SP, #+4]
   \   0000000C   0xB005             ADD      SP,SP,#+20
   \   0000000E   0xBD00             POP      {PC}             ;; return
    384          }
    385          
    386          
    387          /*
    388          *********************************************************************************************************
    389          *********************************************************************************************************
    390          *                                              LED FUNCTIONS
    391          *********************************************************************************************************
    392          *********************************************************************************************************
    393          */
    394          
    395          /*
    396          *********************************************************************************************************
    397          *                                             BSP_LED_Init()
    398          *
    399          * Description : Initialize the I/O for the LEDs
    400          *
    401          * Argument(s) : none.
    402          *
    403          * Return(s)   : none.
    404          *
    405          * Caller(s)   : BSP_Init().
    406          *
    407          * Note(s)     : none.
    408          *********************************************************************************************************
    409          */
    410          

   \                                 In section .text, align 2, keep-with-next
    411          static  void  BSP_LED_Init (void)
    412          {
   \                     BSP_LED_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    413              GPIO_Config(BSP_GPIO_LED0,0);           //端口配置为输出
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0xF44F 0x709D      MOV      R0,#+314
   \   00000008   0x.... 0x....      BL       GPIO_Config
    414              GPIO_Config(BSP_GPIO_LED1,0);           //端口配置为输出
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0xF240 0x103B      MOVW     R0,#+315
   \   00000012   0x.... 0x....      BL       GPIO_Config
    415              GPIO_Config(BSP_GPIO_LED2,0);           //端口配置为输出
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0xF44F 0x7096      MOV      R0,#+300
   \   0000001C   0x.... 0x....      BL       GPIO_Config
    416              GPIO_Config(BSP_GPIO_LED3,0);           //端口配置为输出
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0xF240 0x102D      MOVW     R0,#+301
   \   00000026   0x.... 0x....      BL       GPIO_Config
    417              GPIO_Config(BSP_GPIO_LED4,0);           //端口配置为输出
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0xF240 0x1097      MOVW     R0,#+407
   \   00000030   0x.... 0x....      BL       GPIO_Config
    418              GPIO_Config(BSP_GPIO_LED5,0);           //端口配置为输出
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0xF44F 0x70CC      MOV      R0,#+408
   \   0000003A   0x.... 0x....      BL       GPIO_Config
    419              GPIO_Config(BSP_GPIO_LED6,0);           //端口配置为输出
   \   0000003E   0x2100             MOVS     R1,#+0
   \   00000040   0xF240 0x1099      MOVW     R0,#+409
   \   00000044   0x.... 0x....      BL       GPIO_Config
    420              GPIO_Config(BSP_GPIO_LED7,0);           //端口配置为输出
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0xF44F 0x70CD      MOV      R0,#+410
   \   0000004E   0x.... 0x....      BL       GPIO_Config
    421          }
   \   00000052   0xBD01             POP      {R0,PC}          ;; return
    422          
    423          
    424          /*
    425          *********************************************************************************************************
    426          *                                             BSP_LED_On()
    427          *
    428          * Description : Turn ON any or all the LEDs on the board.
    429          *
    430          * Argument(s) : led     The ID of the LED to control:
    431          *
    432          *                       0    turns ON ALL the LEDs
    433          *                       1    turns ON user LED1  on the board
    434          *                       2    turns ON user LED2  on the board
    435          *                       3    turns ON user LED3  on the board
    436          *
    437          * Return(s)   : none.
    438          *
    439          * Caller(s)   : Application.
    440          *
    441          * Note(s)     : none.
    442          *********************************************************************************************************
    443          */
    444          

   \                                 In section .text, align 2, keep-with-next
    445          void  BSP_LED_On (CPU_INT08U led)
    446          {
   \                     BSP_LED_On: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    447              switch (led) {
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD00C             BEQ.N    ??BSP_LED_On_0
   \   00000008   0x2802             CMP      R0,#+2
   \   0000000A   0xD039             BEQ.N    ??BSP_LED_On_1
   \   0000000C   0xD332             BCC.N    ??BSP_LED_On_2
   \   0000000E   0x2804             CMP      R0,#+4
   \   00000010   0xD042             BEQ.N    ??BSP_LED_On_3
   \   00000012   0xD33B             BCC.N    ??BSP_LED_On_4
   \   00000014   0x2806             CMP      R0,#+6
   \   00000016   0xD04B             BEQ.N    ??BSP_LED_On_5
   \   00000018   0xD344             BCC.N    ??BSP_LED_On_6
   \   0000001A   0x2808             CMP      R0,#+8
   \   0000001C   0xD054             BEQ.N    ??BSP_LED_On_7
   \   0000001E   0xD34D             BCC.N    ??BSP_LED_On_8
   \   00000020   0xE058             B.N      ??BSP_LED_On_9
    448                  case 0:
    449                          GPIO_Set(BSP_GPIO_LED0,0);                  //端口置ON
   \                     ??BSP_LED_On_0: (+1)
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0xF44F 0x709D      MOV      R0,#+314
   \   00000028   0x.... 0x....      BL       GPIO_Set
    450                          GPIO_Set(BSP_GPIO_LED1,0);                  //端口置ON
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0xF240 0x103B      MOVW     R0,#+315
   \   00000032   0x.... 0x....      BL       GPIO_Set
    451                          GPIO_Set(BSP_GPIO_LED2,0);                  //端口置ON
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0xF44F 0x7096      MOV      R0,#+300
   \   0000003C   0x.... 0x....      BL       GPIO_Set
    452                          GPIO_Set(BSP_GPIO_LED3,0);                  //端口置ON
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0xF240 0x102D      MOVW     R0,#+301
   \   00000046   0x.... 0x....      BL       GPIO_Set
    453                          GPIO_Set(BSP_GPIO_LED4,0);                  //端口置ON
   \   0000004A   0x2100             MOVS     R1,#+0
   \   0000004C   0xF240 0x1097      MOVW     R0,#+407
   \   00000050   0x.... 0x....      BL       GPIO_Set
    454                          GPIO_Set(BSP_GPIO_LED5,0);                  //端口置ON
   \   00000054   0x2100             MOVS     R1,#+0
   \   00000056   0xF44F 0x70CC      MOV      R0,#+408
   \   0000005A   0x.... 0x....      BL       GPIO_Set
    455                          GPIO_Set(BSP_GPIO_LED6,0);                  //端口置ON
   \   0000005E   0x2100             MOVS     R1,#+0
   \   00000060   0xF240 0x1099      MOVW     R0,#+409
   \   00000064   0x.... 0x....      BL       GPIO_Set
    456                          GPIO_Set(BSP_GPIO_LED7,0);                  //端口置ON
   \   00000068   0x2100             MOVS     R1,#+0
   \   0000006A   0xF44F 0x70CD      MOV      R0,#+410
   \   0000006E   0x.... 0x....      BL       GPIO_Set
    457                       break;
   \   00000072   0xE02F             B.N      ??BSP_LED_On_10
    458          
    459                  case 1:
    460                          GPIO_Set(BSP_GPIO_LED0,0);                  //端口置ON
   \                     ??BSP_LED_On_2: (+1)
   \   00000074   0x2100             MOVS     R1,#+0
   \   00000076   0xF44F 0x709D      MOV      R0,#+314
   \   0000007A   0x.... 0x....      BL       GPIO_Set
    461                       break;
   \   0000007E   0xE029             B.N      ??BSP_LED_On_10
    462          
    463                  case 2:
    464                          GPIO_Set(BSP_GPIO_LED1,0);                  //端口置ON
   \                     ??BSP_LED_On_1: (+1)
   \   00000080   0x2100             MOVS     R1,#+0
   \   00000082   0xF240 0x103B      MOVW     R0,#+315
   \   00000086   0x.... 0x....      BL       GPIO_Set
    465                       break;
   \   0000008A   0xE023             B.N      ??BSP_LED_On_10
    466          
    467                  case 3:
    468                          GPIO_Set(BSP_GPIO_LED2,0);                  //端口置ON
   \                     ??BSP_LED_On_4: (+1)
   \   0000008C   0x2100             MOVS     R1,#+0
   \   0000008E   0xF44F 0x7096      MOV      R0,#+300
   \   00000092   0x.... 0x....      BL       GPIO_Set
    469                       break;
   \   00000096   0xE01D             B.N      ??BSP_LED_On_10
    470                       
    471                  case 4:
    472                          GPIO_Set(BSP_GPIO_LED3,0);                  //端口置ON
   \                     ??BSP_LED_On_3: (+1)
   \   00000098   0x2100             MOVS     R1,#+0
   \   0000009A   0xF240 0x102D      MOVW     R0,#+301
   \   0000009E   0x.... 0x....      BL       GPIO_Set
    473                       break;     
   \   000000A2   0xE017             B.N      ??BSP_LED_On_10
    474                       
    475                  case 5:
    476                          GPIO_Set(BSP_GPIO_LED4,0);                  //端口置ON
   \                     ??BSP_LED_On_6: (+1)
   \   000000A4   0x2100             MOVS     R1,#+0
   \   000000A6   0xF240 0x1097      MOVW     R0,#+407
   \   000000AA   0x.... 0x....      BL       GPIO_Set
    477                       break;   
   \   000000AE   0xE011             B.N      ??BSP_LED_On_10
    478                       
    479                  case 6:
    480                          GPIO_Set(BSP_GPIO_LED5,0);                  //端口置ON
   \                     ??BSP_LED_On_5: (+1)
   \   000000B0   0x2100             MOVS     R1,#+0
   \   000000B2   0xF44F 0x70CC      MOV      R0,#+408
   \   000000B6   0x.... 0x....      BL       GPIO_Set
    481                       break;
   \   000000BA   0xE00B             B.N      ??BSP_LED_On_10
    482                       
    483                  case 7:
    484                          GPIO_Set(BSP_GPIO_LED6,0);                  //端口置ON
   \                     ??BSP_LED_On_8: (+1)
   \   000000BC   0x2100             MOVS     R1,#+0
   \   000000BE   0xF240 0x1099      MOVW     R0,#+409
   \   000000C2   0x.... 0x....      BL       GPIO_Set
    485                       break;
   \   000000C6   0xE005             B.N      ??BSP_LED_On_10
    486                  case 8:
    487                          GPIO_Set(BSP_GPIO_LED7,0);                  //端口置ON
   \                     ??BSP_LED_On_7: (+1)
   \   000000C8   0x2100             MOVS     R1,#+0
   \   000000CA   0xF44F 0x70CD      MOV      R0,#+410
   \   000000CE   0x.... 0x....      BL       GPIO_Set
    488                       break;
   \   000000D2   0xE7FF             B.N      ??BSP_LED_On_10
    489                       
    490                  default:
    491                       break;
    492              }
    493          }
   \                     ??BSP_LED_On_9: (+1)
   \                     ??BSP_LED_On_10: (+1)
   \   000000D4   0xBD01             POP      {R0,PC}          ;; return
    494          
    495          
    496          /*
    497          *********************************************************************************************************
    498          *                                              BSP_LED_Off()
    499          *
    500          * Description : Turn OFF any or all the LEDs on the board.
    501          *
    502          * Argument(s) : led     The ID of the LED to control:
    503          *
    504          *                       0    turns OFF ALL the LEDs
    505          *                       1    turns OFF user LED1  on the board
    506          *                       2    turns OFF user LED2  on the board
    507          *                       3    turns OFF user LED3  on the board
    508          *
    509          * Return(s)   : none.
    510          *
    511          * Caller(s)   : Application.
    512          *
    513          * Note(s)     : none.
    514          *********************************************************************************************************
    515          */

   \                                 In section .text, align 2, keep-with-next
    516          void  BSP_LED_Off (CPU_INT08U led)
    517          {
   \                     BSP_LED_Off: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    518              switch (led) {
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD00C             BEQ.N    ??BSP_LED_Off_0
   \   00000008   0x2802             CMP      R0,#+2
   \   0000000A   0xD039             BEQ.N    ??BSP_LED_Off_1
   \   0000000C   0xD332             BCC.N    ??BSP_LED_Off_2
   \   0000000E   0x2804             CMP      R0,#+4
   \   00000010   0xD042             BEQ.N    ??BSP_LED_Off_3
   \   00000012   0xD33B             BCC.N    ??BSP_LED_Off_4
   \   00000014   0x2806             CMP      R0,#+6
   \   00000016   0xD04B             BEQ.N    ??BSP_LED_Off_5
   \   00000018   0xD344             BCC.N    ??BSP_LED_Off_6
   \   0000001A   0x2808             CMP      R0,#+8
   \   0000001C   0xD054             BEQ.N    ??BSP_LED_Off_7
   \   0000001E   0xD34D             BCC.N    ??BSP_LED_Off_8
   \   00000020   0xE058             B.N      ??BSP_LED_Off_9
    519                  case 0:
    520                          GPIO_Set(BSP_GPIO_LED0,1);                  //端口置OFF
   \                     ??BSP_LED_Off_0: (+1)
   \   00000022   0x2101             MOVS     R1,#+1
   \   00000024   0xF44F 0x709D      MOV      R0,#+314
   \   00000028   0x.... 0x....      BL       GPIO_Set
    521                          GPIO_Set(BSP_GPIO_LED1,1);                  //端口置OFF
   \   0000002C   0x2101             MOVS     R1,#+1
   \   0000002E   0xF240 0x103B      MOVW     R0,#+315
   \   00000032   0x.... 0x....      BL       GPIO_Set
    522                          GPIO_Set(BSP_GPIO_LED2,1);                  //端口置OFF
   \   00000036   0x2101             MOVS     R1,#+1
   \   00000038   0xF44F 0x7096      MOV      R0,#+300
   \   0000003C   0x.... 0x....      BL       GPIO_Set
    523                          GPIO_Set(BSP_GPIO_LED3,1);                  //端口置OFF
   \   00000040   0x2101             MOVS     R1,#+1
   \   00000042   0xF240 0x102D      MOVW     R0,#+301
   \   00000046   0x.... 0x....      BL       GPIO_Set
    524                          GPIO_Set(BSP_GPIO_LED4,1);                  //端口置OFF
   \   0000004A   0x2101             MOVS     R1,#+1
   \   0000004C   0xF240 0x1097      MOVW     R0,#+407
   \   00000050   0x.... 0x....      BL       GPIO_Set
    525                          GPIO_Set(BSP_GPIO_LED5,1);                  //端口置OFF
   \   00000054   0x2101             MOVS     R1,#+1
   \   00000056   0xF44F 0x70CC      MOV      R0,#+408
   \   0000005A   0x.... 0x....      BL       GPIO_Set
    526                          GPIO_Set(BSP_GPIO_LED6,1);                  //端口置OFF
   \   0000005E   0x2101             MOVS     R1,#+1
   \   00000060   0xF240 0x1099      MOVW     R0,#+409
   \   00000064   0x.... 0x....      BL       GPIO_Set
    527                          GPIO_Set(BSP_GPIO_LED7,1);                  //端口置OFF
   \   00000068   0x2101             MOVS     R1,#+1
   \   0000006A   0xF44F 0x70CD      MOV      R0,#+410
   \   0000006E   0x.... 0x....      BL       GPIO_Set
    528                       break;
   \   00000072   0xE02F             B.N      ??BSP_LED_Off_10
    529          
    530                  case 1:
    531                          GPIO_Set(BSP_GPIO_LED0,1);                  //端口置OFF
   \                     ??BSP_LED_Off_2: (+1)
   \   00000074   0x2101             MOVS     R1,#+1
   \   00000076   0xF44F 0x709D      MOV      R0,#+314
   \   0000007A   0x.... 0x....      BL       GPIO_Set
    532                       break;
   \   0000007E   0xE029             B.N      ??BSP_LED_Off_10
    533          
    534                  case 2:
    535                          GPIO_Set(BSP_GPIO_LED1,1);                  //端口置OFF
   \                     ??BSP_LED_Off_1: (+1)
   \   00000080   0x2101             MOVS     R1,#+1
   \   00000082   0xF240 0x103B      MOVW     R0,#+315
   \   00000086   0x.... 0x....      BL       GPIO_Set
    536                       break;
   \   0000008A   0xE023             B.N      ??BSP_LED_Off_10
    537          
    538                  case 3:
    539                          GPIO_Set(BSP_GPIO_LED2,1);                  //端口置OFF
   \                     ??BSP_LED_Off_4: (+1)
   \   0000008C   0x2101             MOVS     R1,#+1
   \   0000008E   0xF44F 0x7096      MOV      R0,#+300
   \   00000092   0x.... 0x....      BL       GPIO_Set
    540                       break;
   \   00000096   0xE01D             B.N      ??BSP_LED_Off_10
    541                       
    542                  case 4:
    543                          GPIO_Set(BSP_GPIO_LED3,1);                  //端口置OFF
   \                     ??BSP_LED_Off_3: (+1)
   \   00000098   0x2101             MOVS     R1,#+1
   \   0000009A   0xF240 0x102D      MOVW     R0,#+301
   \   0000009E   0x.... 0x....      BL       GPIO_Set
    544                       break;     
   \   000000A2   0xE017             B.N      ??BSP_LED_Off_10
    545                       
    546                  case 5:
    547                          GPIO_Set(BSP_GPIO_LED4,1);                  //端口置OFF
   \                     ??BSP_LED_Off_6: (+1)
   \   000000A4   0x2101             MOVS     R1,#+1
   \   000000A6   0xF240 0x1097      MOVW     R0,#+407
   \   000000AA   0x.... 0x....      BL       GPIO_Set
    548                       break;   
   \   000000AE   0xE011             B.N      ??BSP_LED_Off_10
    549                       
    550                  case 6:
    551                          GPIO_Set(BSP_GPIO_LED5,1);                  //端口置OFF
   \                     ??BSP_LED_Off_5: (+1)
   \   000000B0   0x2101             MOVS     R1,#+1
   \   000000B2   0xF44F 0x70CC      MOV      R0,#+408
   \   000000B6   0x.... 0x....      BL       GPIO_Set
    552                       break;
   \   000000BA   0xE00B             B.N      ??BSP_LED_Off_10
    553                       
    554                  case 7:
    555                          GPIO_Set(BSP_GPIO_LED6,1);                  //端口置OFF
   \                     ??BSP_LED_Off_8: (+1)
   \   000000BC   0x2101             MOVS     R1,#+1
   \   000000BE   0xF240 0x1099      MOVW     R0,#+409
   \   000000C2   0x.... 0x....      BL       GPIO_Set
    556                       break;
   \   000000C6   0xE005             B.N      ??BSP_LED_Off_10
    557                  case 8:
    558                          GPIO_Set(BSP_GPIO_LED7,1);                  //端口置OFF
   \                     ??BSP_LED_Off_7: (+1)
   \   000000C8   0x2101             MOVS     R1,#+1
   \   000000CA   0xF44F 0x70CD      MOV      R0,#+410
   \   000000CE   0x.... 0x....      BL       GPIO_Set
    559                       break;
   \   000000D2   0xE7FF             B.N      ??BSP_LED_Off_10
    560                       
    561                  default:
    562                       break;
    563              }
    564          }
   \                     ??BSP_LED_Off_9: (+1)
   \                     ??BSP_LED_Off_10: (+1)
   \   000000D4   0xBD01             POP      {R0,PC}          ;; return
    565          
    566          
    567          /*
    568          *********************************************************************************************************
    569          *                                            BSP_LED_Toggle()
    570          *
    571          * Description : TOGGLE any or all the LEDs on the board.
    572          *
    573          * Argument(s) : led     The ID of the LED to control:
    574          *
    575          *                       0    TOGGLE ALL the LEDs
    576          *                       1    TOGGLE user LED1  on the board
    577          *                       2    TOGGLE user LED2  on the board
    578          *                       3    TOGGLE user LED3  on the board
    579          *
    580          * Return(s)   : none.
    581          *
    582          * Caller(s)   : Application.
    583          *
    584          * Note(s)     : none.
    585          *********************************************************************************************************
    586          */
    587          

   \                                 In section .text, align 2, keep-with-next
    588          void  BSP_LED_Toggle (CPU_INT08U led)
    589          {
   \                     BSP_LED_Toggle: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    590              switch (led) {
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD00C             BEQ.N    ??BSP_LED_Toggle_0
   \   00000008   0x2802             CMP      R0,#+2
   \   0000000A   0xD030             BEQ.N    ??BSP_LED_Toggle_1
   \   0000000C   0xD32A             BCC.N    ??BSP_LED_Toggle_2
   \   0000000E   0x2804             CMP      R0,#+4
   \   00000010   0xD037             BEQ.N    ??BSP_LED_Toggle_3
   \   00000012   0xD331             BCC.N    ??BSP_LED_Toggle_4
   \   00000014   0x2806             CMP      R0,#+6
   \   00000016   0xD03E             BEQ.N    ??BSP_LED_Toggle_5
   \   00000018   0xD338             BCC.N    ??BSP_LED_Toggle_6
   \   0000001A   0x2808             CMP      R0,#+8
   \   0000001C   0xD045             BEQ.N    ??BSP_LED_Toggle_7
   \   0000001E   0xD33F             BCC.N    ??BSP_LED_Toggle_8
   \   00000020   0xE048             B.N      ??BSP_LED_Toggle_9
    591                  case 0:
    592                          GPIO_Toggle(BSP_GPIO_LED0);                  //端口置0
   \                     ??BSP_LED_Toggle_0: (+1)
   \   00000022   0xF44F 0x709D      MOV      R0,#+314
   \   00000026   0x.... 0x....      BL       GPIO_Toggle
    593                          GPIO_Toggle(BSP_GPIO_LED1);                  //端口置0
   \   0000002A   0xF240 0x103B      MOVW     R0,#+315
   \   0000002E   0x.... 0x....      BL       GPIO_Toggle
    594                          GPIO_Toggle(BSP_GPIO_LED2);                  //端口置0
   \   00000032   0xF44F 0x7096      MOV      R0,#+300
   \   00000036   0x.... 0x....      BL       GPIO_Toggle
    595                          GPIO_Toggle(BSP_GPIO_LED3);                  //端口置0
   \   0000003A   0xF240 0x102D      MOVW     R0,#+301
   \   0000003E   0x.... 0x....      BL       GPIO_Toggle
    596                          GPIO_Toggle(BSP_GPIO_LED4);                  //端口置0
   \   00000042   0xF240 0x1097      MOVW     R0,#+407
   \   00000046   0x.... 0x....      BL       GPIO_Toggle
    597                          GPIO_Toggle(BSP_GPIO_LED5);                  //端口置0
   \   0000004A   0xF44F 0x70CC      MOV      R0,#+408
   \   0000004E   0x.... 0x....      BL       GPIO_Toggle
    598                          GPIO_Toggle(BSP_GPIO_LED6);                  //端口置0
   \   00000052   0xF240 0x1099      MOVW     R0,#+409
   \   00000056   0x.... 0x....      BL       GPIO_Toggle
    599                          GPIO_Toggle(BSP_GPIO_LED7);                  //端口置0
   \   0000005A   0xF44F 0x70CD      MOV      R0,#+410
   \   0000005E   0x.... 0x....      BL       GPIO_Toggle
    600                       break;
   \   00000062   0xE027             B.N      ??BSP_LED_Toggle_10
    601          
    602                  case 1:
    603                          GPIO_Toggle(BSP_GPIO_LED0);                  //端口置0
   \                     ??BSP_LED_Toggle_2: (+1)
   \   00000064   0xF44F 0x709D      MOV      R0,#+314
   \   00000068   0x.... 0x....      BL       GPIO_Toggle
    604                       break;
   \   0000006C   0xE022             B.N      ??BSP_LED_Toggle_10
    605          
    606                  case 2:
    607                          GPIO_Toggle(BSP_GPIO_LED1);                  //端口置0
   \                     ??BSP_LED_Toggle_1: (+1)
   \   0000006E   0xF240 0x103B      MOVW     R0,#+315
   \   00000072   0x.... 0x....      BL       GPIO_Toggle
    608                       break;
   \   00000076   0xE01D             B.N      ??BSP_LED_Toggle_10
    609          
    610                  case 3:
    611                          GPIO_Toggle(BSP_GPIO_LED2);                  //端口置0
   \                     ??BSP_LED_Toggle_4: (+1)
   \   00000078   0xF44F 0x7096      MOV      R0,#+300
   \   0000007C   0x.... 0x....      BL       GPIO_Toggle
    612                       break;
   \   00000080   0xE018             B.N      ??BSP_LED_Toggle_10
    613                       
    614                  case 4:
    615                          GPIO_Toggle(BSP_GPIO_LED3);                  //端口置0
   \                     ??BSP_LED_Toggle_3: (+1)
   \   00000082   0xF240 0x102D      MOVW     R0,#+301
   \   00000086   0x.... 0x....      BL       GPIO_Toggle
    616                       break;     
   \   0000008A   0xE013             B.N      ??BSP_LED_Toggle_10
    617                       
    618                  case 5:
    619                          GPIO_Toggle(BSP_GPIO_LED4);                  //端口置0
   \                     ??BSP_LED_Toggle_6: (+1)
   \   0000008C   0xF240 0x1097      MOVW     R0,#+407
   \   00000090   0x.... 0x....      BL       GPIO_Toggle
    620                       break;   
   \   00000094   0xE00E             B.N      ??BSP_LED_Toggle_10
    621                       
    622                  case 6:
    623                          GPIO_Toggle(BSP_GPIO_LED5);                  //端口置0
   \                     ??BSP_LED_Toggle_5: (+1)
   \   00000096   0xF44F 0x70CC      MOV      R0,#+408
   \   0000009A   0x.... 0x....      BL       GPIO_Toggle
    624                       break;
   \   0000009E   0xE009             B.N      ??BSP_LED_Toggle_10
    625                       
    626                  case 7:
    627                          GPIO_Toggle(BSP_GPIO_LED6);                  //端口置0
   \                     ??BSP_LED_Toggle_8: (+1)
   \   000000A0   0xF240 0x1099      MOVW     R0,#+409
   \   000000A4   0x.... 0x....      BL       GPIO_Toggle
    628                       break;
   \   000000A8   0xE004             B.N      ??BSP_LED_Toggle_10
    629                  case 8:
    630                          GPIO_Toggle(BSP_GPIO_LED7);                  //端口置0
   \                     ??BSP_LED_Toggle_7: (+1)
   \   000000AA   0xF44F 0x70CD      MOV      R0,#+410
   \   000000AE   0x.... 0x....      BL       GPIO_Toggle
    631                       break;
   \   000000B2   0xE7FF             B.N      ??BSP_LED_Toggle_10
    632                       
    633                  default:
    634                       break;
    635              }
    636          }
   \                     ??BSP_LED_Toggle_9: (+1)
   \                     ??BSP_LED_Toggle_10: (+1)
   \   000000B4   0xBD01             POP      {R0,PC}          ;; return
    637          
    638          
    639          /*
    640          *********************************************************************************************************
    641          *                                            BSP_LED_Flash()
    642          *
    643          * Description : Flash any or all the LEDs on the board.
    644          *
    645          * Argument(s) : led     The ID of the LED to control:
    646          *
    647          *                       0    TOGGLE all LEDs on the board
    648          *                       1    TOGGLE LED 1
    649          *                       2    TOGGLE LED 2
    650          *                       3    TOGGLE LED 3
    651          *                       4    TOGGLE LED 4
    652          *
    653          * Return(s)   : none.
    654          *
    655          * Caller(s)   : Application.
    656          *
    657          * Note(s)     : none.
    658          *********************************************************************************************************
    659          */

   \                                 In section .text, align 2, keep-with-next
    660          void BSP_LED_Flash( CPU_INT08U led, CPU_INT16U cnt, CPU_INT32U cycle, CPU_INT32U duty)
    661          {
   \                     BSP_LED_Flash: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x001E             MOVS     R6,R3
    662              CPU_INT32U  timeOn;
    663              CPU_INT32U  timeOff;
    664              CPU_INT32U  i;
    665          
    666              if ( cycle < duty )
   \   0000000A   0x42B2             CMP      R2,R6
   \   0000000C   0xD31D             BCC.N    ??BSP_LED_Flash_0
    667                return;
    668              if( duty == 0 )
   \                     ??BSP_LED_Flash_1: (+1)
   \   0000000E   0x2E00             CMP      R6,#+0
   \   00000010   0xD01B             BEQ.N    ??BSP_LED_Flash_0
    669                return;
    670          
    671              timeOn      = duty;
    672              timeOff     = cycle - duty;
   \                     ??BSP_LED_Flash_2: (+1)
   \   00000012   0x1B97             SUBS     R7,R2,R6
    673          
    674              /***********************************************
    675              * 描述： 声音提示
    676              */
    677              for ( i = 0; i < cnt; i++  ) {
   \   00000014   0xF05F 0x0800      MOVS     R8,#+0
   \   00000018   0xE004             B.N      ??BSP_LED_Flash_3
    678                BSP_LED_On(led);
    679                void   BSP_OS_TimeDlyMs (CPU_INT32U  dly_ms);
    680                BSP_OS_TimeDlyMs(timeOn);
    681                BSP_LED_Off(led);
    682                if ( i+1 == cnt)
    683                  break;
    684                BSP_OS_TimeDlyMs(timeOff);
   \                     ??BSP_LED_Flash_4: (+1)
   \   0000001A   0x0038             MOVS     R0,R7
   \   0000001C   0x.... 0x....      BL       BSP_OS_TimeDlyMs
   \   00000020   0xF118 0x0801      ADDS     R8,R8,#+1
   \                     ??BSP_LED_Flash_3: (+1)
   \   00000024   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000026   0x45A8             CMP      R8,R5
   \   00000028   0xD20F             BCS.N    ??BSP_LED_Flash_5
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0x.... 0x....      BL       BSP_LED_On
   \   00000032   0x0030             MOVS     R0,R6
   \   00000034   0x.... 0x....      BL       BSP_OS_TimeDlyMs
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   0x.... 0x....      BL       BSP_LED_Off
   \   00000040   0xF118 0x0001      ADDS     R0,R8,#+1
   \   00000044   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000046   0x42A8             CMP      R0,R5
   \   00000048   0xD1E7             BNE.N    ??BSP_LED_Flash_4
    685              }
    686          }
   \                     ??BSP_LED_Flash_5: (+1)
   \                     ??BSP_LED_Flash_0: (+1)
   \   0000004A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    687          
    688          /*
    689          *********************************************************************************************************
    690          *                                            BSP_StatusInit()
    691          *
    692          * Description : Initialize the status port(s)
    693          *
    694          * Argument(s) : none.
    695          *
    696          * Return(s)   : none.
    697          *
    698          * Caller(s)   : BSP_Init()
    699          *
    700          * Note(s)     : none.
    701          *********************************************************************************************************
    702          */

   \                                 In section .text, align 2, keep-with-next
    703          static  void  BSP_StatusInit (void)
    704          {
   \                     BSP_StatusInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    705              GPIO_InitTypeDef  GPIO_InitStructure;
    706          
    707              GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_5;             /* PB5 is used to read the status of the LM75 */
   \   00000002   0x2020             MOVS     R0,#+32
   \   00000004   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    708              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN_FLOATING;
   \   00000008   0x2004             MOVS     R0,#+4
   \   0000000A   0xF88D 0x0003      STRB     R0,[SP, #+3]
    709              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   0000000E   0x2003             MOVS     R0,#+3
   \   00000010   0xF88D 0x0002      STRB     R0,[SP, #+2]
    710              GPIO_Init(GPIOB, &GPIO_InitStructure);
   \   00000014   0x4669             MOV      R1,SP
   \   00000016   0x....             LDR.N    R0,??DataTable8_7  ;; 0x40010c00
   \   00000018   0x.... 0x....      BL       GPIO_Init
    711          }
   \   0000001C   0xBD01             POP      {R0,PC}          ;; return
    712          
    713          /*
    714          *********************************************************************************************************
    715          *                                            BSP_StatusRd()
    716          *
    717          * Description : Get the current status of a status input
    718          *
    719          * Argument(s) : id    is the status you want to get.
    720          *
    721          * Return(s)   : DEF_ON    if the status is asserted
    722          *               DEF_OFF   if the status is negated
    723          *
    724          * Caller(s)   : application
    725          *
    726          * Note(s)     : none.
    727          *********************************************************************************************************
    728          */
    729          

   \                                 In section .text, align 2, keep-with-next
    730          CPU_BOOLEAN  BSP_StatusRd (CPU_INT08U  id)
    731          {
   \                     BSP_StatusRd: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    732              CPU_BOOLEAN  bit_val;
    733          
    734          
    735              switch (id) {
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x2801             CMP      R0,#+1
   \   00000006   0xD105             BNE.N    ??BSP_StatusRd_0
    736                  case 1:
    737                       bit_val = GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_5);
   \   00000008   0x2120             MOVS     R1,#+32
   \   0000000A   0x....             LDR.N    R0,??DataTable8_7  ;; 0x40010c00
   \   0000000C   0x.... 0x....      BL       GPIO_ReadInputDataBit
    738                       return (bit_val);
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0xE000             B.N      ??BSP_StatusRd_1
    739          
    740                  default:
    741                       return ((CPU_BOOLEAN)DEF_OFF);
   \                     ??BSP_StatusRd_0: (+1)
   \   00000014   0x2000             MOVS     R0,#+0
   \                     ??BSP_StatusRd_1: (+1)
   \   00000016   0xBD02             POP      {R1,PC}          ;; return
    742              }
    743          }
    744          
    745          
    746          /*
    747          *********************************************************************************************************
    748          *********************************************************************************************************
    749          *                                           OS PROBE FUNCTIONS
    750          *********************************************************************************************************
    751          *********************************************************************************************************
    752          */
    753          
    754          /*
    755          *********************************************************************************************************
    756          *                                           OSProbe_TmrInit()
    757          *
    758          * Description : Select & initialize a timer for use with the uC/Probe Plug-In for uC/OS-II.
    759          *
    760          * Argument(s) : none.
    761          *
    762          * Return(s)   : none.
    763          *
    764          * Caller(s)   : OSProbe_Init().
    765          *
    766          * Note(s)     : none.
    767          *********************************************************************************************************
    768          */
    769          
    770          #if ((APP_CFG_PROBE_OS_PLUGIN_EN == DEF_ENABLED) && \
    771               (OS_PROBE_HOOKS_EN          == 1))
    772          void  OSProbe_TmrInit (void)
    773          {
    774          }
    775          #endif
    776          
    777          
    778          /*
    779          *********************************************************************************************************
    780          *                                            OSProbe_TmrRd()
    781          *
    782          * Description : Read the current counts of a free running timer.
    783          *
    784          * Argument(s) : none.
    785          *
    786          * Return(s)   : The 32-bit timer counts.
    787          *
    788          * Caller(s)   : OSProbe_TimeGetCycles().
    789          *
    790          * Note(s)     : none.
    791          *********************************************************************************************************
    792          */
    793          
    794          #if ((APP_CFG_PROBE_OS_PLUGIN_EN == DEF_ENABLED) && \
    795               (OS_PROBE_HOOKS_EN          == 1))
    796          CPU_INT32U  OSProbe_TmrRd (void)
    797          {
    798              return ((CPU_INT32U)DWT_CYCCNT);
    799          }
    800          #endif
    801          
    802          
    803          /*$PAGE*/
    804          /*
    805          *********************************************************************************************************
    806          *                                          CPU_TS_TmrInit()
    807          *
    808          * Description : Initialize & start CPU timestamp timer.
    809          *
    810          * Argument(s) : none.
    811          *
    812          * Return(s)   : none.
    813          *
    814          * Caller(s)   : CPU_TS_Init().
    815          *
    816          *               This function is an INTERNAL CPU module function & MUST be implemented by application/
    817          *               BSP function(s) [see Note #1] but MUST NOT be called by application function(s).
    818          *
    819          * Note(s)     : (1) CPU_TS_TmrInit() is an application/BSP function that MUST be defined by the developer
    820          *                   if either of the following CPU features is enabled :
    821          *
    822          *                   (a) CPU timestamps
    823          *                   (b) CPU interrupts disabled time measurements
    824          *
    825          *                   See 'cpu_cfg.h  CPU TIMESTAMP CONFIGURATION  Note #1'
    826          *                     & 'cpu_cfg.h  CPU INTERRUPTS DISABLED TIME MEASUREMENT CONFIGURATION  Note #1a'.
    827          *
    828          *               (2) (a) Timer count values MUST be returned via word-size-configurable 'CPU_TS_TMR'
    829          *                       data type.
    830          *
    831          *                       (1) If timer has more bits, truncate timer values' higher-order bits greater
    832          *                           than the configured 'CPU_TS_TMR' timestamp timer data type word size.
    833          *
    834          *                       (2) Since the timer MUST NOT have less bits than the configured 'CPU_TS_TMR'
    835          *                           timestamp timer data type word size; 'CPU_CFG_TS_TMR_SIZE' MUST be
    836          *                           configured so that ALL bits in 'CPU_TS_TMR' data type are significant.
    837          *
    838          *                           In other words, if timer size is not a binary-multiple of 8-bit octets
    839          *                           (e.g. 20-bits or even 24-bits), then the next lower, binary-multiple
    840          *                           octet word size SHOULD be configured (e.g. to 16-bits).  However, the
    841          *                           minimum supported word size for CPU timestamp timers is 8-bits.
    842          *
    843          *                       See also 'cpu_cfg.h   CPU TIMESTAMP CONFIGURATION  Note #2'
    844          *                              & 'cpu_core.h  CPU TIMESTAMP DATA TYPES     Note #1'.
    845          *
    846          *                   (b) Timer SHOULD be an 'up'  counter whose values increase with each time count.
    847          *
    848          *                   (c) When applicable, timer period SHOULD be less than the typical measured time
    849          *                       but MUST be less than the maximum measured time; otherwise, timer resolution
    850          *                       inadequate to measure desired times.
    851          *
    852          *                   See also 'CPU_TS_TmrRd()  Note #2'.
    853          *********************************************************************************************************
    854          */
    855          
    856          #if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    857          void  CPU_TS_TmrInit (void)
    858          {
   \                     CPU_TS_TmrInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    859              CPU_INT32U  cpu_clk_freq_hz;
    860          
    861          
    862              DEM_CR         |= (CPU_INT32U)DEM_CR_TRCENA;                /* Enable Cortex-M3's DWT CYCCNT reg.                   */
   \   00000002   0x....             LDR.N    R0,??DataTable8_8  ;; 0xe000edfc
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF050 0x7080      ORRS     R0,R0,#0x1000000
   \   0000000A   0x....             LDR.N    R1,??DataTable8_8  ;; 0xe000edfc
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    863              DWT_CYCCNT      = (CPU_INT32U)0u;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x....             LDR.N    R1,??DataTable8_9  ;; 0xe0001004
   \   00000012   0x6008             STR      R0,[R1, #+0]
    864              DWT_CR         |= (CPU_INT32U)DWT_CR_CYCCNTENA;
   \   00000014   0x....             LDR.N    R0,??DataTable8_10  ;; 0xe0001000
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000001C   0x....             LDR.N    R1,??DataTable8_10  ;; 0xe0001000
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    865          
    866              cpu_clk_freq_hz = BSP_CPU_ClkFreq();
   \   00000020   0x.... 0x....      BL       BSP_CPU_ClkFreq
    867              CPU_TS_TmrFreqSet(cpu_clk_freq_hz);
   \   00000024   0x.... 0x....      BL       CPU_TS_TmrFreqSet
    868          }
   \   00000028   0xBD01             POP      {R0,PC}          ;; return
    869          #endif
    870          
    871          
    872          /*$PAGE*/
    873          /*
    874          *********************************************************************************************************
    875          *                                           CPU_TS_TmrRd()
    876          *
    877          * Description : Get current CPU timestamp timer count value.
    878          *
    879          * Argument(s) : none.
    880          *
    881          * Return(s)   : Timestamp timer count (see Notes #2a & #2b).
    882          *
    883          * Caller(s)   : CPU_TS_Init(),
    884          *               CPU_TS_Get32(),
    885          *               CPU_TS_Get64(),
    886          *               CPU_IntDisMeasStart(),
    887          *               CPU_IntDisMeasStop().
    888          *
    889          *               This function is an INTERNAL CPU module function & MUST be implemented by application/
    890          *               BSP function(s) [see Note #1] but SHOULD NOT be called by application function(s).
    891          *
    892          * Note(s)     : (1) CPU_TS_TmrRd() is an application/BSP function that MUST be defined by the developer
    893          *                   if either of the following CPU features is enabled :
    894          *
    895          *                   (a) CPU timestamps
    896          *                   (b) CPU interrupts disabled time measurements
    897          *
    898          *                   See 'cpu_cfg.h  CPU TIMESTAMP CONFIGURATION  Note #1'
    899          *                     & 'cpu_cfg.h  CPU INTERRUPTS DISABLED TIME MEASUREMENT CONFIGURATION  Note #1a'.
    900          *
    901          *               (2) (a) Timer count values MUST be returned via word-size-configurable 'CPU_TS_TMR'
    902          *                       data type.
    903          *
    904          *                       (1) If timer has more bits, truncate timer values' higher-order bits greater
    905          *                           than the configured 'CPU_TS_TMR' timestamp timer data type word size.
    906          *
    907          *                       (2) Since the timer MUST NOT have less bits than the configured 'CPU_TS_TMR'
    908          *                           timestamp timer data type word size; 'CPU_CFG_TS_TMR_SIZE' MUST be
    909          *                           configured so that ALL bits in 'CPU_TS_TMR' data type are significant.
    910          *
    911          *                           In other words, if timer size is not a binary-multiple of 8-bit octets
    912          *                           (e.g. 20-bits or even 24-bits), then the next lower, binary-multiple
    913          *                           octet word size SHOULD be configured (e.g. to 16-bits).  However, the
    914          *                           minimum supported word size for CPU timestamp timers is 8-bits.
    915          *
    916          *                       See also 'cpu_cfg.h   CPU TIMESTAMP CONFIGURATION  Note #2'
    917          *                              & 'cpu_core.h  CPU TIMESTAMP DATA TYPES     Note #1'.
    918          *
    919          *                   (b) Timer SHOULD be an 'up'  counter whose values increase with each time count.
    920          *
    921          *                       (1) If timer is a 'down' counter whose values decrease with each time count,
    922          *                           then the returned timer value MUST be ones-complemented.
    923          *
    924          *                   (c) (1) When applicable, the amount of time measured by CPU timestamps is
    925          *                           calculated by either of the following equations :
    926          *
    927          *                           (A) Time measured  =  Number timer counts  *  Timer period
    928          *
    929          *                                   where
    930          *
    931          *                                       Number timer counts     Number of timer counts measured
    932          *                                       Timer period            Timer's period in some units of
    933          *                                                                   (fractional) seconds
    934          *                                       Time measured           Amount of time measured, in same
    935          *                                                                   units of (fractional) seconds
    936          *                                                                   as the Timer period
    937          *
    938          *                                                  Number timer counts
    939          *                           (B) Time measured  =  ---------------------
    940          *                                                    Timer frequency
    941          *
    942          *                                   where
    943          *
    944          *                                       Number timer counts     Number of timer counts measured
    945          *                                       Timer frequency         Timer's frequency in some units
    946          *                                                                   of counts per second
    947          *                                       Time measured           Amount of time measured, in seconds
    948          *
    949          *                       (2) Timer period SHOULD be less than the typical measured time but MUST be less
    950          *                           than the maximum measured time; otherwise, timer resolution inadequate to
    951          *                           measure desired times.
    952          *********************************************************************************************************
    953          */
    954          
    955          #if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    956          CPU_TS_TMR  CPU_TS_TmrRd (void)
    957          {
    958              return ((CPU_TS_TMR)DWT_CYCCNT);
   \                     CPU_TS_TmrRd: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable8_9  ;; 0xe0001004
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    959          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x........         DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x........         DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \   00000000   0x........         DC32     BSP_CPU_ClkFreq_MHz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \   00000000   0x40010C00         DC32     0x40010c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \   00000000   0xE000EDFC         DC32     0xe000edfc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_9:
   \   00000000   0xE0001004         DC32     0xe0001004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_10:
   \   00000000   0xE0001000         DC32     0xe0001000

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x00000004         DC32 4, 8, 16, 32, 64, 128, 256
   \              0x00000008   
   \              0x00000010   
   \              0x00000020   
   \              0x00000040   
   \              0x00000080   
   \              0x00000100   
    960          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   BSP_CPU_ClkFreq
        24   -> RCC_GetClocksFreq
       8   BSP_Init
         8   -> BSP_CPU_ClkFreq
         8   -> BSP_Init_Hook
         8   -> BSP_IntInit
         8   -> BSP_LED_Init
         8   -> BSP_StatusInit
         8   -> FLASH_PrefetchBufferCmd
         8   -> FLASH_SetLatency
         8   -> RCC_ADCCLKConfig
         8   -> RCC_DeInit
         8   -> RCC_GetFlagStatus
         8   -> RCC_GetSYSCLKSource
         8   -> RCC_HCLKConfig
         8   -> RCC_HSEConfig
         8   -> RCC_OTGFSCLKConfig
         8   -> RCC_PCLK1Config
         8   -> RCC_PCLK2Config
         8   -> RCC_PLL1Cmd
         8   -> RCC_PLL1Config
         8   -> RCC_PLL2Cmd
         8   -> RCC_PLL2Config
         8   -> RCC_PLL3Cmd
         8   -> RCC_PLL3Config
         8   -> RCC_PREDIV1Config
         8   -> RCC_PREDIV2Config
         8   -> RCC_SYSCLKConfig
         8   -> RCC_WaitForHSEStartUp
      24   BSP_LED_Flash
        24   -> BSP_LED_Off
        24   -> BSP_LED_On
        24   -> BSP_OS_TimeDlyMs
       8   BSP_LED_Init
         8   -> GPIO_Config
       8   BSP_LED_Off
         8   -> GPIO_Set
       8   BSP_LED_On
         8   -> GPIO_Set
       8   BSP_LED_Toggle
         8   -> GPIO_Toggle
       8   BSP_StatusInit
         8   -> GPIO_Init
       8   BSP_StatusRd
         8   -> GPIO_ReadInputDataBit
       8   CPU_TS_TmrInit
         8   -> BSP_CPU_ClkFreq
         8   -> CPU_TS_TmrFreqSet
       0   CPU_TS_TmrRd
      80   GPIO_Config
        80   -> GPIO_Init
        80   -> RCC_APB2PeriphClockCmd
        80   -> __aeabi_memcpy4
      48   GPIO_Read
        48   -> GPIO_Config
        48   -> GPIO_ReadInputDataBit
        48   -> __aeabi_memcpy4
      48   GPIO_Set
        48   -> GPIO_Config
        48   -> GPIO_ResetBits
        48   -> GPIO_SetBits
        48   -> __aeabi_memcpy4
      48   GPIO_Toggle
        48   -> GPIO_Config
        48   -> GPIO_ReadOutputDataBit
        48   -> GPIO_Set
        48   -> __aeabi_memcpy4


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_10
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
      28  ?_0
      28  ?_1
      28  ?_2
      28  ?_3
      28  ?_4
      16  BSP_CPU_ClkFreq
       4  BSP_CPU_ClkFreq_MHz
     238  BSP_Init
      78  BSP_LED_Flash
      84  BSP_LED_Init
     214  BSP_LED_Off
     214  BSP_LED_On
     182  BSP_LED_Toggle
      30  BSP_StatusInit
      24  BSP_StatusRd
      42  CPU_TS_TmrInit
       6  CPU_TS_TmrRd
     118  GPIO_Config
      68  GPIO_Read
      98  GPIO_Set
      90  GPIO_Toggle

 
     4 bytes in section .bss
   140 bytes in section .rodata
 1 546 bytes in section .text
 
 1 546 bytes of CODE  memory
   140 bytes of CONST memory
     4 bytes of DATA  memory

Errors: none
Warnings: none
