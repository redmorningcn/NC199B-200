###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       15/Jul/2018  10:36:17
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  F:\iar\NC210\NC210-200处理板\source\driver\bsp_flash.c
#    Command line =  
#        F:\iar\NC210\NC210-200处理板\source\driver\bsp_flash.c -D
#        USE_STDPERIPH_DRIVER -D APP_RELEASE -lCN
#        F:\iar\NC210\NC210-200处理板\project\app_release\List -o
#        F:\iar\NC210\NC210-200处理板\project\app_release\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC210\NC210-200处理板\project\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\config\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\task\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\user\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\OS\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\Ports\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\driver\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-LIB\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Source\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\ST\STM32\inc\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Ports\STM32\STM32F103\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Source\
#        -Ol --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC210\NC210-200处理板\project\app_release\List\bsp_flash.lst
#    Object file  =  
#        F:\iar\NC210\NC210-200处理板\project\app_release\Obj\bsp_flash.o
#
###############################################################################

F:\iar\NC210\NC210-200处理板\source\driver\bsp_flash.c
      1          /*******************************************************************************
      2           *   Filename:       bsp_flash.c
      3           *   Revised:        $Date: 2014-04-23
      4           *   Revision:       $
      5           *	 Writer:		 Wuming Shen.
      6           *
      7           *   Description:    
      8           *
      9           *   Notes:        
     10           *					   
     11           *			
     12           *   All copyrights reserved to Wuming Shen.
     13           *
     14           *******************************************************************************/
     15          
     16          #define BSP_FLASH_MODULE_EN 1
     17          #if BSP_FLASH_MODULE_EN > 0
     18          /*******************************************************************************
     19           * INCLUDES
     20           */
     21          #include "bsp_flash.h"
     22          #include  <stdio.h>
     23          #include  <string.h>
     24          #include  <ctype.h>
     25          #include  <stdlib.h>
     26          #include  <stdarg.h>
     27          

   \                                 In section .bss, align 4
     28          UnionFlashBuf   FlashBuf;
   \                     FlashBuf:
   \   00000000                      DS8 2048
     29          /*******************************************************************************
     30           * CONSTANTS
     31           */
     32          
     33          /*******************************************************************************
     34           * MACROS
     35           */
     36          
     37          /*******************************************************************************
     38           * TYPEDEFS
     39           */
     40          
     41          /*******************************************************************************
     42           * LOCAL VARIABLES
     43           */
     44          /***********************************************
     45          * 描述：
     46          */    
     47          
     48          /*******************************************************************************
     49           * GLOBAL VARIABLES
     50           */
     51          
     52          /*******************************************************************************
     53           * LOCAL FUNCTIONS
     54           */
     55          
     56          /*******************************************************************************
     57           * GLOBAL FUNCTIONS
     58           */
     59          
     60          /*******************************************************************************
     61           * EXTERN VARIABLES
     62           */
     63          
     64           /*******************************************************************************
     65           * EXTERN FUNCTIONS
     66           */
     67           
     68          /*******************************************************************************/
     69          
     70          
     71          /*******************************************************************************
     72           * 名    称： FlashReadHalfWord()
     73           * 功    能： 读取指定地址的16位数据
     74           * 入口参数：
     75           * 出口参数： 无
     76           * 作　　 者： 无名沈
     77           * 创建日期： 2014-04-23
     78           * 修    改： 
     79           * 修改日期： 
     80           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     81          u16  FlashReadHalfWord(u32 addr)
     82          {
     83          	return *(vu16 *)addr;
   \                     FlashReadHalfWord: (+1)
   \   00000000   0x8800             LDRH     R0,[R0, #+0]
   \   00000002   0x4770             BX       LR               ;; return
     84          }
     85          
     86          /*******************************************************************************
     87           * 名    称： BSP_FlashRead()
     88           * 功    能： 外部调用
     89           * 入口参数：
     90           * 出口参数： 无
     91           * 作　　 者： 无名沈
     92           * 创建日期： 2014-04-23
     93           * 修    改： 
     94           * 修改日期： 
     95           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     96          void  BSP_FlashRead(u32 addr,u16 *pbuffer,u16 num)   	
     97          {
   \                     BSP_FlashRead: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
     98          	u16 i;
     99              
    100              FLASH_Unlock();                             // 解锁
   \   00000008   0x.... 0x....      BL       FLASH_Unlock
    101          	for(i = 0;i < num;i++) {
   \   0000000C   0x2700             MOVS     R7,#+0
   \   0000000E   0xE006             B.N      ??BSP_FlashRead_0
    102          		*pbuffer++ = FlashReadHalfWord(addr);   //读取2个字节.
   \                     ??BSP_FlashRead_1: (+1)
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       FlashReadHalfWord
   \   00000016   0x8028             STRH     R0,[R5, #+0]
   \   00000018   0x1CAD             ADDS     R5,R5,#+2
    103          		addr += 2;                              //偏移2个字节.	
   \   0000001A   0x1CA4             ADDS     R4,R4,#+2
    104          	}
   \   0000001C   0x1C7F             ADDS     R7,R7,#+1
   \                     ??BSP_FlashRead_0: (+1)
   \   0000001E   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000020   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000022   0x42B7             CMP      R7,R6
   \   00000024   0xD3F4             BCC.N    ??BSP_FlashRead_1
    105          	FLASH_Lock();             				    // 上锁
   \   00000026   0x.... 0x....      BL       FLASH_Lock
    106          }
   \   0000002A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    107          
    108          /*******************************************************************************
    109           * 名    称： FlashRead()
    110           * 功    能： 
    111           * 入口参数：
    112           * 出口参数： 无
    113           * 作　　 者： 无名沈
    114           * 创建日期： 2014-04-23
    115           * 修    改： 
    116           * 修改日期： 
    117           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    118          void  FlashRead(u32 addr,u16 *pbuffer,u16 num)   	
    119          {
   \                     FlashRead: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    120          	u16 i;
    121              
    122          	for(i = 0;i < num;i++) {
   \   00000008   0x2700             MOVS     R7,#+0
   \   0000000A   0xE006             B.N      ??FlashRead_0
    123          		*pbuffer++ = FlashReadHalfWord(addr);   //读取2个字节.
   \                     ??FlashRead_1: (+1)
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       FlashReadHalfWord
   \   00000012   0x8028             STRH     R0,[R5, #+0]
   \   00000014   0x1CAD             ADDS     R5,R5,#+2
    124          		addr += 2;                              //偏移2个字节.	
   \   00000016   0x1CA4             ADDS     R4,R4,#+2
    125          	}
   \   00000018   0x1C7F             ADDS     R7,R7,#+1
   \                     ??FlashRead_0: (+1)
   \   0000001A   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000001C   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000001E   0x42B7             CMP      R7,R6
   \   00000020   0xD3F4             BCC.N    ??FlashRead_1
    126          }
   \   00000022   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    127          /*******************************************************************************
    128           * 名    称： FlashWriteNoCheck()
    129           * 功    能： 
    130           * 入口参数：
    131           * 出口参数： 无
    132           * 作　　 者： 无名沈
    133           * 创建日期： 2014-04-23
    134           * 修    改： 
    135           * 修改日期： 
    136           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    137          u8  FlashWriteNoCheck(u32 addr,u16 *pbuffer,u16 num)
    138          {
   \                     FlashWriteNoCheck: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    139          	u16 i;
    140              
    141          	for(i = 0;i < num;i++) {
   \   00000008   0x2700             MOVS     R7,#+0
   \   0000000A   0xE007             B.N      ??FlashWriteNoCheck_0
    142          		//if ( FLASH_COMPLETE != FLASH_ProgramHalfWord (addr,pbuffer[i]) ) {
    143                  //    return 0;
    144                  //}
    145                  FLASH_ProgramHalfWord (addr,pbuffer[i]);
   \                     ??FlashWriteNoCheck_1: (+1)
   \   0000000C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000000E   0xF835 0x1017      LDRH     R1,[R5, R7, LSL #+1]
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       FLASH_ProgramHalfWord
    146          		addr += 2;
   \   00000018   0x1CA4             ADDS     R4,R4,#+2
    147          	}
   \   0000001A   0x1C7F             ADDS     R7,R7,#+1
   \                     ??FlashWriteNoCheck_0: (+1)
   \   0000001C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000001E   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000020   0x42B7             CMP      R7,R6
   \   00000022   0xD3F3             BCC.N    ??FlashWriteNoCheck_1
    148              return 1;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    149          }
    150          
    151          /*******************************************************************************
    152           * 名    称： FlashWrite()
    153           * 功    能： 带擦除的写
    154           * 入口参数：
    155           * 出口参数： 无
    156           * 作　　 者： 无名沈
    157           * 创建日期： 2014-04-23
    158           * 修    改： 
    159           * 修改日期： 
    160           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    161          void  BSP_FlashWrite(u32 addr,u16 *pbuffer,u16 num)
    162          {
   \                     BSP_FlashWrite: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    163          //	u16  num_sector;  						        // 在第几页
    164          //	u16  offset_sector;  					        // 在一页的偏移量
    165          //	u16  num_last;    						        // 剩下的半字
    166          //	u16  i;
    167          //	/***********************************************
    168          //    * 描述：
    169          //    */
    170          //    num_sector      = (addr - STM32_FLASH_BASE) / STM_SECTOR_SIZE;	   			// 获取第几页
    171          //	offset_sector   = ((addr - STM32_FLASH_BASE) % STM_SECTOR_SIZE) / 2;  	    // 获取偏移量，16个字节为单位
    172          //	num_last        = STM_SECTOR_SIZE / 2 - offset_sector;                     	// 求出剩下的半字
    173          //	
    174          //    FLASH_Unlock();                                 // 解锁
    175          //	/***********************************************
    176          //    * 描述：
    177          //    */
    178          //    if(num <= num_last)  
    179          //      num_last      = num;		                    // 可以一次写完
    180          //    /***********************************************
    181          //    * 描述：
    182          //    */
    183          //	for(;;)	{									        // 开始不停的写
    184          //		FlashRead(num_sector * STM_SECTOR_SIZE + STM32_FLASH_BASE,FlashBuf.buf2,STM_SECTOR_SIZE / 2);  // 读出一页
    185          //		for(i = 0;i < num_last;i++) {
    186          //			if(FlashBuf.buf2[offset_sector + i] != 0xffff) break;	
    187          //		}
    188          //		if(i < num_last) {						        // 需要擦除
    189          //			FLASH_ErasePage (num_sector * STM_SECTOR_SIZE + STM32_FLASH_BASE);  // 擦除
    190          //			for(i = 0;i < num_last;i++) {
    191          //				FlashBuf.buf2[offset_sector + i] = pbuffer[i];	                // 把要写入的数据填入数组
    192          //			}
    193          //			FlashWriteNoCheck(num_sector * STM_SECTOR_SIZE + STM32_FLASH_BASE,FlashBuf.buf2,STM_SECTOR_SIZE / 2);               //写整个扇区		
    194          //		} else {								        // 不需要擦除
    195          //			FlashWriteNoCheck(addr,pbuffer,num_last);	// 直接将要写入的数据写入flash
    196          //		}
    197          //        /***********************************************
    198          //        * 描述：
    199          //        */
    200          //		if(num_last == num) { 
    201          //            break;                                      // 写完后就跳出
    202          //		} else {                                        // 没有写完继续
    203          //			num_sector     += 1;    				    // 页加一
    204          //			offset_sector   = 0;  				        // 偏移为0
    205          //			pbuffer        += num_last;
    206          //			addr           += num_last * 2;
    207          //			num            -= num_last;    				// 调整要写入的数量
    208          //            
    209          //			if(num > (STM_SECTOR_SIZE / 2))  
    210          //                num_last = STM_SECTOR_SIZE / 2;
    211          //			else  
    212          //              num_last = num;   			            // 调整num_last		
    213          //		}		
    214          //	}
    215          //    
    216          //	FLASH_Lock();             					        // 上锁
    217              
    218          	u16  num_sector;                                    //在第几页
    219          	u16  offset_sector;                                 //在一页的偏移量
    220          	u16  num_last;                                      //剩下的半字
    221          	u16  i;
    222          	num_sector      =  (addr - STM32_FLASH_BASE) / STM_SECTOR_SIZE;	        //获取第几页
   \   0000000A   0x0AE7             LSRS     R7,R4,#+11
    223          	offset_sector   =  ((addr - STM32_FLASH_BASE) % STM_SECTOR_SIZE) / 2;   //获取偏移量，16个字节为单位
   \   0000000C   0xF1B4 0x6000      SUBS     R0,R4,#+134217728
   \   00000010   0xF44F 0x6100      MOV      R1,#+2048
   \   00000014   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \   00000018   0xFB02 0x0211      MLS      R2,R2,R1,R0
   \   0000001C   0xEA5F 0x0852      LSRS     R8,R2,#+1
    224          	num_last        = 	STM_SECTOR_SIZE / 2 - offset_sector;                //求出剩下的半字
   \   00000020   0xF5D8 0x6980      RSBS     R9,R8,#+1024
    225          	FLASH_Unlock();                                     //解锁
   \   00000024   0x.... 0x....      BL       FLASH_Unlock
    226          	if(num <= num_last)  num_last = num;		        //可以一次写完
   \   00000028   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   0000002C   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000002E   0x45B1             CMP      R9,R6
   \   00000030   0xD303             BCC.N    ??BSP_FlashWrite_0
   \   00000032   0x46B1             MOV      R9,R6
   \   00000034   0xE001             B.N      ??BSP_FlashWrite_0
    227          	
    228              for(;;)	{									        //开始不停的写
    229          		FlashRead(num_sector * STM_SECTOR_SIZE + STM32_FLASH_BASE,FlashBuf.buf2,STM_SECTOR_SIZE / 2);  //读出一页
    230          		for(i = 0;i < num_last;i++) {
    231          			if(FlashBuf.buf2[offset_sector + i] != 0xffff) break;	
    232          		}
    233          		if(i < num_last) { 					//需要擦除
    234          			FLASH_ErasePage (num_sector * STM_SECTOR_SIZE + STM32_FLASH_BASE);                      //擦除
    235          			for(i = 0;i < num_last;i++) {
    236          				FlashBuf.buf2[offset_sector + i] = pbuffer[i];	               //把要写入的数据填入数组
    237          			}
    238          			FlashWriteNoCheck(num_sector * STM_SECTOR_SIZE + STM32_FLASH_BASE,FlashBuf.buf2,STM_SECTOR_SIZE / 2);               //写整个扇区		
    239          		} else {								    //不需要擦除
    240          		
    241          			FlashWriteNoCheck(addr,pbuffer,num_last);	//直接将要写入的数据写入flash
    242          		}
    243          		if(num_last == num)  
    244                      break;                                  //写完后就跳出
    245          		else  {                                     //没有写完继续
    246          			num_sector += 1;    //页加一
    247          			offset_sector = 0;  //偏移为0
    248          			pbuffer += num_last;
    249          			addr += num_last * 2;
    250          			num -= num_last;    //调整要写入的数量
    251          			if(num > (STM_SECTOR_SIZE / 2))  num_last = STM_SECTOR_SIZE / 2;
   \                     ??BSP_FlashWrite_1: (+1)
   \   00000036   0xF44F 0x6980      MOV      R9,#+1024
   \                     ??BSP_FlashWrite_0: (+1)
   \   0000003A   0xF44F 0x6280      MOV      R2,#+1024
   \   0000003E   0x....             LDR.N    R1,??DataTable2
   \   00000040   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000042   0xF44F 0x6000      MOV      R0,#+2048
   \   00000046   0xFB00 0xF007      MUL      R0,R0,R7
   \   0000004A   0xF110 0x6000      ADDS     R0,R0,#+134217728
   \   0000004E   0x.... 0x....      BL       FlashRead
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xE000             B.N      ??BSP_FlashWrite_2
   \                     ??BSP_FlashWrite_3: (+1)
   \   00000056   0x1C40             ADDS     R0,R0,#+1
   \                     ??BSP_FlashWrite_2: (+1)
   \   00000058   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000005A   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   0000005E   0x4548             CMP      R0,R9
   \   00000060   0xD20B             BCS.N    ??BSP_FlashWrite_4
   \   00000062   0x....             LDR.N    R1,??DataTable2
   \   00000064   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000068   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000006A   0xEB10 0x0208      ADDS     R2,R0,R8
   \   0000006E   0xF831 0x1012      LDRH     R1,[R1, R2, LSL #+1]
   \   00000072   0xF64F 0x72FF      MOVW     R2,#+65535
   \   00000076   0x4291             CMP      R1,R2
   \   00000078   0xD0ED             BEQ.N    ??BSP_FlashWrite_3
   \                     ??BSP_FlashWrite_4: (+1)
   \   0000007A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000007C   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000080   0x4548             CMP      R0,R9
   \   00000082   0xD228             BCS.N    ??BSP_FlashWrite_5
   \   00000084   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000086   0xF44F 0x6000      MOV      R0,#+2048
   \   0000008A   0xFB00 0xF007      MUL      R0,R0,R7
   \   0000008E   0xF110 0x6000      ADDS     R0,R0,#+134217728
   \   00000092   0x.... 0x....      BL       FLASH_ErasePage
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0xE00B             B.N      ??BSP_FlashWrite_6
   \                     ??BSP_FlashWrite_7: (+1)
   \   0000009A   0x....             LDR.N    R1,??DataTable2
   \   0000009C   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000000A0   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000A2   0xEB10 0x0208      ADDS     R2,R0,R8
   \   000000A6   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000A8   0xF835 0x3010      LDRH     R3,[R5, R0, LSL #+1]
   \   000000AC   0xF821 0x3012      STRH     R3,[R1, R2, LSL #+1]
   \   000000B0   0x1C40             ADDS     R0,R0,#+1
   \                     ??BSP_FlashWrite_6: (+1)
   \   000000B2   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000B4   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   000000B8   0x4548             CMP      R0,R9
   \   000000BA   0xD3EE             BCC.N    ??BSP_FlashWrite_7
   \   000000BC   0xF44F 0x6280      MOV      R2,#+1024
   \   000000C0   0x....             LDR.N    R1,??DataTable2
   \   000000C2   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000C4   0xF44F 0x6000      MOV      R0,#+2048
   \   000000C8   0xFB00 0xF007      MUL      R0,R0,R7
   \   000000CC   0xF110 0x6000      ADDS     R0,R0,#+134217728
   \   000000D0   0x.... 0x....      BL       FlashWriteNoCheck
   \   000000D4   0xE005             B.N      ??BSP_FlashWrite_8
   \                     ??BSP_FlashWrite_5: (+1)
   \   000000D6   0x464A             MOV      R2,R9
   \   000000D8   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000000DA   0x0029             MOVS     R1,R5
   \   000000DC   0x0020             MOVS     R0,R4
   \   000000DE   0x.... 0x....      BL       FlashWriteNoCheck
   \                     ??BSP_FlashWrite_8: (+1)
   \   000000E2   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   000000E6   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000E8   0x45B1             CMP      R9,R6
   \   000000EA   0xD103             BNE.N    ??BSP_FlashWrite_9
    252          			else  num_last = num;   //调整num_last		
    253          		}		
    254          	}
    255              
    256          	FLASH_Lock();             //上锁
   \   000000EC   0x.... 0x....      BL       FLASH_Lock
    257          }
   \   000000F0   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
   \                     ??BSP_FlashWrite_9: (+1)
   \   000000F4   0x1C7F             ADDS     R7,R7,#+1
   \   000000F6   0xF05F 0x0800      MOVS     R8,#+0
   \   000000FA   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   000000FE   0xEB15 0x0549      ADDS     R5,R5,R9, LSL #+1
   \   00000102   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000106   0xEB14 0x0449      ADDS     R4,R4,R9, LSL #+1
   \   0000010A   0xEBB6 0x0609      SUBS     R6,R6,R9
   \   0000010E   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000110   0xF5B6 0x6F80      CMP      R6,#+1024
   \   00000114   0xDC8F             BGT.N    ??BSP_FlashWrite_1
   \   00000116   0x46B1             MOV      R9,R6
   \   00000118   0xE78F             B.N      ??BSP_FlashWrite_0
    258          
    259          /*******************************************************************************
    260          * 名    称： BSP_FLASH_ReadPage
    261          * 功    能： 读一页数据，起始地址在页首
    262          * 入口参数： addr FLASH地址  pbuf ： 读取字节的数组 len : 数组的大小
    263          * 出口参数： 0（操作有误），1（操作成功）
    264          * 作　 　者： wumingshen
    265          * 创建日期： 2015-10-20
    266          * 修    改：
    267          * 修改日期：
    268          * 备    注：
    269          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    270          u8 BSP_FLASH_ReadPage( u32 addr , u8 *pbuf, u16 len )
    271          {
   \                     BSP_FLASH_ReadPage: (+1)
   \   00000000   0xB410             PUSH     {R4}
    272              u16    size   = 0;
   \   00000002   0x2300             MOVS     R3,#+0
    273          
    274              if ( len > STM_SECTOR_SIZE )
   \   00000004   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000006   0xF5B2 0x6F00      CMP      R2,#+2048
   \   0000000A   0xDD01             BLE.N    ??BSP_FLASH_ReadPage_0
    275                return 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xE00B             B.N      ??BSP_FLASH_ReadPage_1
    276          
    277              u16 *p      = (u16 *)pbuf;
   \                     ??BSP_FLASH_ReadPage_0: (+1)
   \   00000010   0xE004             B.N      ??BSP_FLASH_ReadPage_2
    278              
    279              for ( ; size < len ; size += 2 ) {
    280          		*p++     = *(vu16 *)addr;
   \                     ??BSP_FLASH_ReadPage_3: (+1)
   \   00000012   0x8804             LDRH     R4,[R0, #+0]
   \   00000014   0x800C             STRH     R4,[R1, #+0]
   \   00000016   0x1C89             ADDS     R1,R1,#+2
    281          		addr    += 2;	
   \   00000018   0x1C80             ADDS     R0,R0,#+2
    282          	}
   \   0000001A   0x1C9B             ADDS     R3,R3,#+2
   \                     ??BSP_FLASH_ReadPage_2: (+1)
   \   0000001C   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000001E   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000020   0x4293             CMP      R3,R2
   \   00000022   0xD3F6             BCC.N    ??BSP_FLASH_ReadPage_3
    283              
    284              return size;
   \   00000024   0x0018             MOVS     R0,R3
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??BSP_FLASH_ReadPage_1: (+1)
   \   00000028   0xBC10             POP      {R4}
   \   0000002A   0x4770             BX       LR               ;; return
    285          }
    286          
    287          /*******************************************************************************
    288          * 名    称： BSP_FLASH_WritePage
    289          * 功    能： 写一页数据，起始地址在页首
    290          * 入口参数： addr:  FLASH地址  pbuf: 写入字节的数组 len: 数组的大小
    291          * 出口参数： 0（操作有误），1（操作成功）
    292          * 作　 　者： wumingshen
    293          * 创建日期： 2015-10-20
    294          * 修    改：
    295          * 修改日期：
    296          * 备    注：
    297          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    298          u8 BSP_FLASH_WritePage( u32 addr , u8 *pbuf, u16 len )
    299          {
   \                     BSP_FLASH_WritePage: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    300              u16    size   = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
    301          
    302              if ( len > STM_SECTOR_SIZE )
   \   0000000C   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000000E   0xF5B6 0x6F00      CMP      R6,#+2048
   \   00000012   0xDD01             BLE.N    ??BSP_FLASH_WritePage_0
    303                return 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xE022             B.N      ??BSP_FLASH_WritePage_1
    304          
    305              u16 *p      = (u16 *)pbuf;
   \                     ??BSP_FLASH_WritePage_0: (+1)
   \   00000018   0xE009             B.N      ??BSP_FLASH_WritePage_2
    306              s8  retrys;
    307              
    308              for ( ; size < len ; size += 2 ) {
    309                  retrys  = 5;
    310                  do {
    311                      FLASH_ProgramHalfWord(addr,*(u16 *)p);
    312                      if (*(u16 *)addr == *(u16 *)p) {
    313                          break;
    314                      } else if ( 1 == retrys ) {
    315                          return size;
    316                      } 
    317                  } while ( --retrys );
   \                     ??BSP_FLASH_WritePage_3: (+1)
   \   0000001A   0xF1B8 0x0801      SUBS     R8,R8,#+1
   \   0000001E   0xFA4F 0xF888      SXTB     R8,R8            ;; SignExt  R8,R8,#+24,#+24
   \   00000022   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000026   0xD108             BNE.N    ??BSP_FLASH_WritePage_4
    318                  
    319          		addr    += 2;
   \                     ??BSP_FLASH_WritePage_5: (+1)
   \   00000028   0x1CA4             ADDS     R4,R4,#+2
    320                  p++;
   \   0000002A   0x1CAD             ADDS     R5,R5,#+2
   \   0000002C   0x1CBF             ADDS     R7,R7,#+2
   \                     ??BSP_FLASH_WritePage_2: (+1)
   \   0000002E   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000030   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000032   0x42B7             CMP      R7,R6
   \   00000034   0xD211             BCS.N    ??BSP_FLASH_WritePage_6
   \   00000036   0xF05F 0x0805      MOVS     R8,#+5
   \                     ??BSP_FLASH_WritePage_4: (+1)
   \   0000003A   0x8829             LDRH     R1,[R5, #+0]
   \   0000003C   0x0020             MOVS     R0,R4
   \   0000003E   0x.... 0x....      BL       FLASH_ProgramHalfWord
   \   00000042   0x8820             LDRH     R0,[R4, #+0]
   \   00000044   0x8829             LDRH     R1,[R5, #+0]
   \   00000046   0x4288             CMP      R0,R1
   \   00000048   0xD0EE             BEQ.N    ??BSP_FLASH_WritePage_5
   \                     ??BSP_FLASH_WritePage_7: (+1)
   \   0000004A   0xFA4F 0xF888      SXTB     R8,R8            ;; SignExt  R8,R8,#+24,#+24
   \   0000004E   0xF1B8 0x0F01      CMP      R8,#+1
   \   00000052   0xD1E2             BNE.N    ??BSP_FLASH_WritePage_3
   \   00000054   0x0038             MOVS     R0,R7
   \   00000056   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000058   0xE001             B.N      ??BSP_FLASH_WritePage_1
    321          	}
    322                      
    323              return size;
   \                     ??BSP_FLASH_WritePage_6: (+1)
   \   0000005A   0x0038             MOVS     R0,R7
   \   0000005C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??BSP_FLASH_WritePage_1: (+1)
   \   0000005E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    324          }
    325          
    326          /*******************************************************************************
    327          * 名    称： BSP_FlashWriteBytes
    328          * 功    能： 写多个字节
    329          * 入口参数： addr： FLASH地址  pbuf ：写入字节的数组 len : 数组的大小
    330          * 出口参数： 0（操作有误），1（操作成功）
    331          * 作　 　者： wumingshen
    332          * 创建日期： 2015-10-20
    333          * 修    改：
    334          * 修改日期：
    335          * 备    注：
    336          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    337          u16     BSP_FlashWriteBytes     (u32 addr, u8 *pbuf, u16 len)
    338          {
   \                     BSP_FlashWriteBytes: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0007             MOVS     R7,R0
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0x0015             MOVS     R5,R2
    339              u16      bytes   = 0;
   \   0000000A   0x2600             MOVS     R6,#+0
    340              /***********************************************
    341              * 描述： 检测地址是否会溢出，如果溢出则直接返回
    342              */
    343              if ( (addr + len) > (STM32_FLASH_BASE + FLASH_SIZE_EEP) )
   \   0000000C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000000E   0x19E8             ADDS     R0,R5,R7
   \   00000010   0x....             LDR.N    R1,??DataTable2_1  ;; 0x8040001
   \   00000012   0x4288             CMP      R0,R1
   \   00000014   0xD301             BCC.N    ??BSP_FlashWriteBytes_0
    344                  return 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE09D             B.N      ??BSP_FlashWriteBytes_1
    345          
    346              u16    copyLen;                                     // 要复制的长度
    347              u32    pageAddr;
    348              u16    size    = 0;                                 // 一次写入长度
   \                     ??BSP_FlashWriteBytes_0: (+1)
   \   0000001A   0xF05F 0x0800      MOVS     R8,#+0
    349              u32 page    =   addr / STM_SECTOR_SIZE;             // 写入地址所在页（相对）
   \   0000001E   0xEA5F 0x29D7      LSRS     R9,R7,#+11
    350                              addr    += PARAM_START_ADDR;        // 转换成绝对地址
    351              
    352          	FLASH_Unlock();             				        // 上锁
   \   00000022   0x.... 0x....      BL       FLASH_Unlock
    353              /***********************************************
    354              * 描述： 非页首开始，读取之前数据进行填充
    355              */
    356              if ( ( addr % STM_SECTOR_SIZE ) != 0 ) {
   \   00000026   0xF44F 0x6000      MOV      R0,#+2048
   \   0000002A   0xFBB7 0xF1F0      UDIV     R1,R7,R0
   \   0000002E   0xFB01 0x7110      MLS      R1,R1,R0,R7
   \   00000032   0x2900             CMP      R1,#+0
   \   00000034   0xD03A             BEQ.N    ??BSP_FlashWriteBytes_2
    357                  size        = STM_SECTOR_SIZE - ( addr % STM_SECTOR_SIZE );
   \   00000036   0xF44F 0x6000      MOV      R0,#+2048
   \   0000003A   0xFBB7 0xF1F0      UDIV     R1,R7,R0
   \   0000003E   0xFB01 0x7110      MLS      R1,R1,R0,R7
   \   00000042   0xF5D1 0x6800      RSBS     R8,R1,#+2048
    358                  copyLen     = STM_SECTOR_SIZE - size;
   \   00000046   0xF5D8 0x6A00      RSBS     R10,R8,#+2048
    359                  pageAddr    = PARAM_START_ADDR + page * STM_SECTOR_SIZE;
   \   0000004A   0xF44F 0x6000      MOV      R0,#+2048
   \   0000004E   0xFB00 0xF909      MUL      R9,R0,R9
    360                  // 读取当前页数据
    361                  BSP_FLASH_ReadPage(pageAddr, FlashBuf.buf1, STM_SECTOR_SIZE);
   \   00000052   0xF44F 0x6200      MOV      R2,#+2048
   \   00000056   0x....             LDR.N    R1,??DataTable2
   \   00000058   0x4648             MOV      R0,R9
   \   0000005A   0x.... 0x....      BL       BSP_FLASH_ReadPage
    362          
    363                  if ( size > len )
   \   0000005E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000060   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000064   0x4545             CMP      R5,R8
   \   00000066   0xD200             BCS.N    ??BSP_FlashWriteBytes_3
    364                      size = len;
   \   00000068   0x46A8             MOV      R8,R5
    365                  // 复制属于当前页的数据到缓冲区中
    366                  memcpy(&FlashBuf.buf1[copyLen], pbuf, size);
   \                     ??BSP_FlashWriteBytes_3: (+1)
   \   0000006A   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   0000006E   0x4642             MOV      R2,R8
   \   00000070   0x0021             MOVS     R1,R4
   \   00000072   0x....             LDR.N    R0,??DataTable2
   \   00000074   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   00000078   0xEB1A 0x0A00      ADDS     R10,R10,R0
   \   0000007C   0x4650             MOV      R0,R10
   \   0000007E   0x.... 0x....      BL       __aeabi_memcpy
    367                  // 整页探险当前页
    368          		FLASH_ErasePage ( pageAddr );
   \   00000082   0x4648             MOV      R0,R9
   \   00000084   0x.... 0x....      BL       FLASH_ErasePage
    369                  // 将缓冲区的数据写入当前页
    370                  BSP_FLASH_WritePage( pageAddr , FlashBuf.buf1 , STM_SECTOR_SIZE );
   \   00000088   0xF44F 0x6200      MOV      R2,#+2048
   \   0000008C   0x....             LDR.N    R1,??DataTable2
   \   0000008E   0x4648             MOV      R0,R9
   \   00000090   0x.... 0x....      BL       BSP_FLASH_WritePage
    371                  // 源数据地址、写入地址、写入字节数增加size，未写数据长度减少size
    372                  addr    += size;
   \   00000094   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000098   0xEB18 0x0707      ADDS     R7,R8,R7
    373                  pbuf    += size;
   \   0000009C   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000000A0   0xEB18 0x0404      ADDS     R4,R8,R4
    374                  bytes   += size;
   \   000000A4   0xEB18 0x0606      ADDS     R6,R8,R6
    375                  len     -= size;
   \   000000A8   0xEBB5 0x0508      SUBS     R5,R5,R8
    376              }
    377          
    378              /***********************************************
    379              * 描述： 页首开始，整页
    380              */
    381              size = len / STM_SECTOR_SIZE;
   \                     ??BSP_FlashWriteBytes_2: (+1)
   \   000000AC   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000AE   0xF44F 0x6000      MOV      R0,#+2048
   \   000000B2   0xFB95 0xF8F0      SDIV     R8,R5,R0
   \   000000B6   0xE012             B.N      ??BSP_FlashWriteBytes_4
    382              while ( size > 0 ) {
    383                  // 探险当前页
    384          		FLASH_ErasePage (addr);
   \                     ??BSP_FlashWriteBytes_5: (+1)
   \   000000B8   0x0038             MOVS     R0,R7
   \   000000BA   0x.... 0x....      BL       FLASH_ErasePage
    385                  // 写入当前数据页
    386                  BSP_FLASH_WritePage( addr , (u8 *)pbuf, STM_SECTOR_SIZE );
   \   000000BE   0xF44F 0x6200      MOV      R2,#+2048
   \   000000C2   0x0021             MOVS     R1,R4
   \   000000C4   0x0038             MOVS     R0,R7
   \   000000C6   0x.... 0x....      BL       BSP_FLASH_WritePage
    387                  // 源数据地址、写入地址、写入字节数增加STM_SECTOR_SIZE，未写数据长度减少STM_SECTOR_SIZE
    388                  addr    += STM_SECTOR_SIZE;
   \   000000CA   0xF517 0x6700      ADDS     R7,R7,#+2048
    389                  pbuf    += STM_SECTOR_SIZE;
   \   000000CE   0xF514 0x6400      ADDS     R4,R4,#+2048
    390                  bytes   += STM_SECTOR_SIZE;
   \   000000D2   0xF516 0x6600      ADDS     R6,R6,#+2048
    391                  len     -= STM_SECTOR_SIZE;
   \   000000D6   0xF5B5 0x6500      SUBS     R5,R5,#+2048
    392                  // 页数减1
    393                  size    -= 1;
   \   000000DA   0xF1B8 0x0801      SUBS     R8,R8,#+1
    394              }
   \                     ??BSP_FlashWriteBytes_4: (+1)
   \   000000DE   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000000E2   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000E6   0xD1E7             BNE.N    ??BSP_FlashWriteBytes_5
    395          
    396              /***********************************************
    397              * 描述： 页首开始，不足一页
    398              */
    399              if ( len > 0 ) {
   \   000000E8   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000EA   0x2D00             CMP      R5,#+0
   \   000000EC   0xD02F             BEQ.N    ??BSP_FlashWriteBytes_6
    400                  size        = STM_SECTOR_SIZE - ( addr % STM_SECTOR_SIZE );
   \   000000EE   0xF44F 0x6000      MOV      R0,#+2048
   \   000000F2   0xFBB7 0xF1F0      UDIV     R1,R7,R0
   \   000000F6   0xFB01 0x7110      MLS      R1,R1,R0,R7
   \   000000FA   0xF5D1 0x6800      RSBS     R8,R1,#+2048
    401                  copyLen     = STM_SECTOR_SIZE - size;
   \   000000FE   0xF5D8 0x6A00      RSBS     R10,R8,#+2048
    402                  pageAddr    = addr - copyLen;
   \   00000102   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   00000106   0xEBB7 0x090A      SUBS     R9,R7,R10
    403                  
    404                  BSP_FLASH_ReadPage(pageAddr, FlashBuf.buf1, STM_SECTOR_SIZE);
   \   0000010A   0xF44F 0x6200      MOV      R2,#+2048
   \   0000010E   0x....             LDR.N    R1,??DataTable2
   \   00000110   0x4648             MOV      R0,R9
   \   00000112   0x.... 0x....      BL       BSP_FLASH_ReadPage
    405          
    406                  if ( size > len )
   \   00000116   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000118   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   0000011C   0x4545             CMP      R5,R8
   \   0000011E   0xD200             BCS.N    ??BSP_FlashWriteBytes_7
    407                      size = len;
   \   00000120   0x46A8             MOV      R8,R5
    408                  // 复制属于当前页的数据到缓冲区中
    409                  memcpy(&FlashBuf.buf1[copyLen],pbuf,size);
   \                     ??BSP_FlashWriteBytes_7: (+1)
   \   00000122   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000126   0x....             LDR.N    R0,??DataTable2
   \   00000128   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   0000012C   0xEB1A 0x0700      ADDS     R7,R10,R0
   \   00000130   0x4642             MOV      R2,R8
   \   00000132   0x0021             MOVS     R1,R4
   \   00000134   0x0038             MOVS     R0,R7
   \   00000136   0x.... 0x....      BL       __aeabi_memcpy
    410          
    411                  // 整页探险当前页
    412          		FLASH_ErasePage (pageAddr);
   \   0000013A   0x4648             MOV      R0,R9
   \   0000013C   0x.... 0x....      BL       FLASH_ErasePage
    413                  // 将缓冲区的数据写入当前页
    414                  BSP_FLASH_WritePage( pageAddr , (u8 *)FlashBuf.buf1 , STM_SECTOR_SIZE );
   \   00000140   0xF44F 0x6200      MOV      R2,#+2048
   \   00000144   0x....             LDR.N    R1,??DataTable2
   \   00000146   0x4648             MOV      R0,R9
   \   00000148   0x.... 0x....      BL       BSP_FLASH_WritePage
    415                  bytes   += len;
   \   0000014C   0x19AE             ADDS     R6,R5,R6
    416              }
    417          
    418          	FLASH_Lock();             				    // 上锁
   \                     ??BSP_FlashWriteBytes_6: (+1)
   \   0000014E   0x.... 0x....      BL       FLASH_Lock
    419              return(bytes);
   \   00000152   0x0030             MOVS     R0,R6
   \   00000154   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??BSP_FlashWriteBytes_1: (+1)
   \   00000156   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    420          }
    421          
    422          
    423          /*******************************************************************************
    424          * 名    称： BSP_FlashWriteBytes
    425          * 功    能： 写多个字节
    426          * 入口参数： addr： FLASH地址  pbuf ：写入字节的数组 len : 数组的大小
    427          * 出口参数： 0（操作有误），1（操作成功）
    428          * 作　 　者： wumingshen
    429          * 创建日期： 2015-10-20
    430          * 修    改：
    431          * 修改日期：
    432          * 备    注：
    433          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    434          u16     BSP_FlashWriteBytes_Fast     (u32 addr, u8 *pbuf, u16 len)
    435          {
   \                     BSP_FlashWriteBytes_Fast: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0014             MOVS     R4,R2
    436              u16      bytes  = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
    437              u16      *p     = (u16 *)pbuf;
    438              u32      writeaddr;
    439              /***********************************************
    440              * 描述： 检测地址是否会溢出，如果溢出则直接返回
    441              */
    442              if ( (addr + len) > (STM32_FLASH_BASE + FLASH_SIZE_EEP) )
   \   0000000C   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000000E   0x1960             ADDS     R0,R4,R5
   \   00000010   0x....             LDR.N    R1,??DataTable2_1  ;; 0x8040001
   \   00000012   0x4288             CMP      R0,R1
   \   00000014   0xD301             BCC.N    ??BSP_FlashWriteBytes_Fast_0
    443                  return 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE02F             B.N      ??BSP_FlashWriteBytes_Fast_1
    444          
    445          	FLASH_Unlock();             				        // 上锁
   \                     ??BSP_FlashWriteBytes_Fast_0: (+1)
   \   0000001A   0x.... 0x....      BL       FLASH_Unlock
    446              u32     i = 0;
   \   0000001E   0x2700             MOVS     R7,#+0
    447              
    448              writeaddr = addr;
    449              /*******************************************************************************
    450              * Description  : 进入写操作前，判断数据是否跨扇区（跨越扇区需先擦除）
    451              * Author       : 2018/5/15 星期二, by redmorningcn
    452              *******************************************************************************/
    453              for(i = 0;i < len;i++,i++)                                       
   \   00000020   0x2700             MOVS     R7,#+0
   \   00000022   0xE00A             B.N      ??BSP_FlashWriteBytes_Fast_2
    454              {
    455                  if((writeaddr&(STM_SECTOR_SIZE -1))==0)        //在块边界，需要擦除块
    456                  {
    457                      FLASH_ErasePage (writeaddr);                                
    458                  }
    459                  
    460                  s8  retrys = 5;
    461              
    462                  do {
    463                      FLASH_ProgramHalfWord(writeaddr,*(u16 *)p);
    464                      if (*(u16 *)writeaddr == *(u16 *)p) {
    465                          break;
    466                      } else if ( 1 == retrys ) {
    467                          FLASH_Lock();             				                                // 上锁
    468                          return 0;
    469                      } 
    470                  } while ( --retrys );
   \                     ??BSP_FlashWriteBytes_Fast_3: (+1)
   \   00000024   0xF1B8 0x0801      SUBS     R8,R8,#+1
   \   00000028   0xFA4F 0xF888      SXTB     R8,R8            ;; SignExt  R8,R8,#+24,#+24
   \   0000002C   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000030   0xD10D             BNE.N    ??BSP_FlashWriteBytes_Fast_4
    471                  
    472                  writeaddr    += 2;
   \                     ??BSP_FlashWriteBytes_Fast_5: (+1)
   \   00000032   0x1CAD             ADDS     R5,R5,#+2
    473                  p++;
   \   00000034   0x1CB6             ADDS     R6,R6,#+2
   \   00000036   0x1C7F             ADDS     R7,R7,#+1
   \   00000038   0x1C7F             ADDS     R7,R7,#+1
   \                     ??BSP_FlashWriteBytes_Fast_2: (+1)
   \   0000003A   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000003C   0x42A7             CMP      R7,R4
   \   0000003E   0xD217             BCS.N    ??BSP_FlashWriteBytes_Fast_6
   \   00000040   0x0568             LSLS     R0,R5,#+21
   \   00000042   0xD102             BNE.N    ??BSP_FlashWriteBytes_Fast_7
   \   00000044   0x0028             MOVS     R0,R5
   \   00000046   0x.... 0x....      BL       FLASH_ErasePage
   \                     ??BSP_FlashWriteBytes_Fast_7: (+1)
   \   0000004A   0xF05F 0x0805      MOVS     R8,#+5
   \                     ??BSP_FlashWriteBytes_Fast_4: (+1)
   \   0000004E   0x8831             LDRH     R1,[R6, #+0]
   \   00000050   0x0028             MOVS     R0,R5
   \   00000052   0x.... 0x....      BL       FLASH_ProgramHalfWord
   \   00000056   0x8828             LDRH     R0,[R5, #+0]
   \   00000058   0x8831             LDRH     R1,[R6, #+0]
   \   0000005A   0x4288             CMP      R0,R1
   \   0000005C   0xD0E9             BEQ.N    ??BSP_FlashWriteBytes_Fast_5
   \                     ??BSP_FlashWriteBytes_Fast_8: (+1)
   \   0000005E   0xFA4F 0xF888      SXTB     R8,R8            ;; SignExt  R8,R8,#+24,#+24
   \   00000062   0xF1B8 0x0F01      CMP      R8,#+1
   \   00000066   0xD1DD             BNE.N    ??BSP_FlashWriteBytes_Fast_3
   \   00000068   0x.... 0x....      BL       FLASH_Lock
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xE004             B.N      ??BSP_FlashWriteBytes_Fast_1
    474              }   
    475          
    476              bytes = len;
   \                     ??BSP_FlashWriteBytes_Fast_6: (+1)
   \   00000070   0x0027             MOVS     R7,R4
    477              
    478          	FLASH_Lock(); // 上锁
   \   00000072   0x.... 0x....      BL       FLASH_Lock
    479                      				                                
    480              
    481              return(bytes);
   \   00000076   0x0038             MOVS     R0,R7
   \   00000078   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??BSP_FlashWriteBytes_Fast_1: (+1)
   \   0000007A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    482          }
    483          
    484          
    485          /*******************************************************************************
    486          * 名    称： BSP_FlashReadBytes
    487          * 功    能： 读多个字节（必须是2的倍数）
    488          * 入口参数： addr： FLASH地址  pbuf ：写入字节的数组 len : 数组的大小（2的倍数）
    489          * 出口参数： 0（操作有误），1（操作成功）
    490          * 作　 　者： wumingshen
    491          * 创建日期： 2015-10-20
    492          * 修    改：
    493          * 修改日期：
    494          * 备    注：
    495          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    496          u16     BSP_FlashReadBytes      (u32 addr, u8 *pbuf, u16 len)
    497          { 
   \                     BSP_FlashReadBytes: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    498              addr         = (PARAM_START_ADDR + addr);
    499              
    500          	FLASH_Unlock();             					        // 解锁
   \   00000008   0x.... 0x....      BL       FLASH_Unlock
    501          
    502              u16 *p      = (u16 *)pbuf;
    503              u16 size    = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xE004             B.N      ??BSP_FlashReadBytes_0
    504              
    505              for ( ; size < len ; size += 2 ) {
    506          		*p++     = *(vu16 *)addr;
   \                     ??BSP_FlashReadBytes_1: (+1)
   \   00000010   0x8821             LDRH     R1,[R4, #+0]
   \   00000012   0x8029             STRH     R1,[R5, #+0]
   \   00000014   0x1CAD             ADDS     R5,R5,#+2
    507          		addr    += 2;	
   \   00000016   0x1CA4             ADDS     R4,R4,#+2
    508          	}
   \   00000018   0x1C80             ADDS     R0,R0,#+2
   \                     ??BSP_FlashReadBytes_0: (+1)
   \   0000001A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000001C   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000001E   0x42B0             CMP      R0,R6
   \   00000020   0xD3F6             BCC.N    ??BSP_FlashReadBytes_1
    509              
    510          	FLASH_Lock();             					            // 上锁
   \   00000022   0x.... 0x....      BL       FLASH_Lock
    511              
    512              return len;
   \   00000026   0x0030             MOVS     R0,R6
   \   00000028   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000002A   0xBD70             POP      {R4-R6,PC}       ;; return
    513          } 

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x........         DC32     FlashBuf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x08040001         DC32     0x8040001
    514          
    515          /*******************************************************************************
    516           * 				end of file
    517           *******************************************************************************/ 
    518          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   BSP_FLASH_ReadPage
      24   BSP_FLASH_WritePage
        24   -> FLASH_ProgramHalfWord
      24   BSP_FlashRead
        24   -> FLASH_Lock
        24   -> FLASH_Unlock
        24   -> FlashReadHalfWord
      16   BSP_FlashReadBytes
        16   -> FLASH_Lock
        16   -> FLASH_Unlock
      32   BSP_FlashWrite
        32   -> FLASH_ErasePage
        32   -> FLASH_Lock
        32   -> FLASH_Unlock
        32   -> FlashRead
        32   -> FlashWriteNoCheck
      32   BSP_FlashWriteBytes
        32   -> BSP_FLASH_ReadPage
        32   -> BSP_FLASH_WritePage
        32   -> FLASH_ErasePage
        32   -> FLASH_Lock
        32   -> FLASH_Unlock
        32   -> __aeabi_memcpy
      24   BSP_FlashWriteBytes_Fast
        24   -> FLASH_ErasePage
        24   -> FLASH_Lock
        24   -> FLASH_ProgramHalfWord
        24   -> FLASH_Unlock
      24   FlashRead
        24   -> FlashReadHalfWord
       0   FlashReadHalfWord
      24   FlashWriteNoCheck
        24   -> FLASH_ProgramHalfWord


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
      44  BSP_FLASH_ReadPage
      98  BSP_FLASH_WritePage
      44  BSP_FlashRead
      44  BSP_FlashReadBytes
     282  BSP_FlashWrite
     346  BSP_FlashWriteBytes
     126  BSP_FlashWriteBytes_Fast
    2048  FlashBuf
      36  FlashRead
       4  FlashReadHalfWord
      40  FlashWriteNoCheck

 
 2 048 bytes in section .bss
 1 072 bytes in section .text
 
 1 072 bytes of CODE memory
 2 048 bytes of DATA memory

Errors: none
Warnings: none
