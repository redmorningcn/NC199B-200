###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       11/Jul/2018  11:13:09
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC210\NC210-200处理板\source\Software\uCOS-III\Source\os_core.c
#    Command line =  
#        F:\iar\NC210\NC210-200处理板\source\Software\uCOS-III\Source\os_core.c
#        -D USE_STDPERIPH_DRIVER -D APP_RELEASE -lCN
#        F:\iar\NC210\NC210-200处理板\project\app_release\List -o
#        F:\iar\NC210\NC210-200处理板\project\app_release\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC210\NC210-200处理板\project\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\config\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\task\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\user\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\OS\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\Ports\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\driver\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-LIB\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Source\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\ST\STM32\inc\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Ports\STM32\STM32F103\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Source\
#        -Ol --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC210\NC210-200处理板\project\app_release\List\os_core.lst
#    Object file  =  
#        F:\iar\NC210\NC210-200处理板\project\app_release\Obj\os_core.o
#
###############################################################################

F:\iar\NC210\NC210-200处理板\source\Software\uCOS-III\Source\os_core.c
      1          /*
      2          ************************************************************************************************************************
      3          *                                                      uC/OS-III
      4          *                                                 The Real-Time Kernel
      5          *
      6          *                                  (c) Copyright 2009-2016; Micrium, Inc.; Weston, FL
      7          *                           All rights reserved.  Protected by international copyright laws.
      8          *
      9          *                                                    CORE FUNCTIONS
     10          *
     11          * File    : OS_CORE.C
     12          * By      : JJL
     13          * Version : V3.06.00
     14          *
     15          * LICENSING TERMS:
     16          * ---------------
     17          *           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or
     18          *           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
     19          *           product then, you need to contact Micrium to properly license uC/OS-III for its use in your
     20          *           application/product.   We provide ALL the source code for your convenience and to help you
     21          *           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use
     22          *           it commercially without paying a licensing fee.
     23          *
     24          *           Knowledge of the source code may NOT be used to develop a similar product.
     25          *
     26          *           Please help us continue to provide the embedded community with the finest software available.
     27          *           Your honesty is greatly appreciated.
     28          *
     29          *           You can find our product's user manual, API reference, release notes and
     30          *           more information at https://doc.micrium.com.
     31          *           You can contact us at www.micrium.com.
     32          ************************************************************************************************************************
     33          */
     34          
     35          #define  MICRIUM_SOURCE
     36          #include "os.h"
     37          
     38          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     39          const  CPU_CHAR  *os_core__c = "$Id: $";
     40          #endif
     41          
     42          /*
     43          ************************************************************************************************************************
     44          *                                                    INITIALIZATION
     45          *
     46          * Description: This function is used to initialize the internals of uC/OS-III and MUST be called prior to
     47          *              creating any uC/OS-III object and, prior to calling OSStart().
     48          *
     49          * Arguments  : p_err         is a pointer to a variable that will contain an error code returned by this function.
     50          *
     51          *                                OS_ERR_NONE    Initialization was successful
     52          *                                Other          Other OS_ERR_xxx depending on the sub-functions called by OSInit().
     53          * Returns    : none
     54          ************************************************************************************************************************
     55          */
     56          

   \                                 In section .text, align 2, keep-with-next
     57          void  OSInit (OS_ERR  *p_err)
     58          {
   \                     OSInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     59          #if (OS_CFG_ISR_STK_SIZE > 0u)
     60              CPU_STK      *p_stk;
     61              CPU_STK_SIZE  size;
     62          #endif
     63          
     64          
     65          
     66          #ifdef OS_SAFETY_CRITICAL
     67              if (p_err == DEF_NULL) {
     68                  OS_SAFETY_CRITICAL_EXCEPTION();
     69                  return;
     70              }
     71          #endif
     72          
     73              OSInitHook();                                               /* Call port specific initialization code               */
   \   00000004   0x.... 0x....      BL       OSInitHook
     74          
     75              OSIntNestingCtr       = 0u;                                 /* Clear the interrupt nesting counter                  */
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable17
   \   0000000E   0x7008             STRB     R0,[R1, #+0]
     76          
     77              OSRunning             = OS_STATE_OS_STOPPED;                /* Indicate that multitasking has not started           */
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable17_1
   \   00000016   0x7008             STRB     R0,[R1, #+0]
     78          
     79              OSSchedLockNestingCtr = 0u;                                 /* Clear the scheduling lock counter                    */
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable17_2
   \   0000001E   0x7008             STRB     R0,[R1, #+0]
     80          
     81              OSTCBCurPtr           = DEF_NULL;                           /* Initialize OS_TCB pointers to a known state          */
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable17_3
   \   00000026   0x6008             STR      R0,[R1, #+0]
     82              OSTCBHighRdyPtr       = DEF_NULL;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable17_4
   \   0000002E   0x6008             STR      R0,[R1, #+0]
     83          
     84              OSPrioCur             = 0u;                                 /* Initialize priority variables to a known state       */
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable17_5
   \   00000036   0x7008             STRB     R0,[R1, #+0]
     85              OSPrioHighRdy         = 0u;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable17_6
   \   0000003E   0x7008             STRB     R0,[R1, #+0]
     86          
     87          #if (OS_CFG_SCHED_LOCK_TIME_MEAS_EN == DEF_ENABLED)
     88              OSSchedLockTimeBegin  = 0u;
     89              OSSchedLockTimeMax    = 0u;
     90              OSSchedLockTimeMaxCur = 0u;
     91          #endif
     92          
     93          #ifdef OS_SAFETY_CRITICAL_IEC61508
     94              OSSafetyCriticalStartFlag       =  DEF_FALSE;
     95          #endif
     96          
     97          #if (OS_CFG_SCHED_ROUND_ROBIN_EN == DEF_ENABLED)
     98              OSSchedRoundRobinEn             = DEF_FALSE;
     99              OSSchedRoundRobinDfltTimeQuanta = OSCfg_TickRate_Hz / 10u;
    100          #endif
    101          
    102          #if (OS_CFG_ISR_STK_SIZE > 0u)
    103              p_stk = OSCfg_ISRStkBasePtr;                                /* Clear exception stack for stack checking.            */
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable17_7
   \   00000044   0x6800             LDR      R0,[R0, #+0]
    104              if (p_stk != DEF_NULL) {
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD009             BEQ.N    ??OSInit_0
    105                  size  = OSCfg_ISRStkSize;
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable17_8
   \   0000004E   0x6809             LDR      R1,[R1, #+0]
   \   00000050   0xE003             B.N      ??OSInit_1
    106                  while (size > 0u) {
    107                      size--;
   \                     ??OSInit_2: (+1)
   \   00000052   0x1E49             SUBS     R1,R1,#+1
    108                     *p_stk = 0u;
   \   00000054   0x2200             MOVS     R2,#+0
   \   00000056   0x6002             STR      R2,[R0, #+0]
    109                      p_stk++;
   \   00000058   0x1D00             ADDS     R0,R0,#+4
    110                  }
   \                     ??OSInit_1: (+1)
   \   0000005A   0x2900             CMP      R1,#+0
   \   0000005C   0xD1F9             BNE.N    ??OSInit_2
    111              }
    112          #if (OS_CFG_TASK_STK_REDZONE_EN == DEF_ENABLED)                 /* Initialize Redzoned ISR stack                        */
    113              OS_TaskStkRedzoneInit(OSCfg_ISRStkBasePtr, OSCfg_ISRStkSize);
    114          #endif
    115          #endif
    116          
    117          #if (OS_CFG_APP_HOOKS_EN == DEF_ENABLED)                        /* Clear application hook pointers                      */
    118          #if (OS_CFG_TASK_STK_REDZONE_EN == DEF_ENABLED)
    119              OS_AppRedzoneHitHookPtr = DEF_NULL;
    120          #endif
    121              OS_AppTaskCreateHookPtr = DEF_NULL;
   \                     ??OSInit_0: (+1)
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x.... 0x....      LDR.W    R1,??DataTable17_9
   \   00000064   0x6008             STR      R0,[R1, #+0]
    122              OS_AppTaskDelHookPtr    = DEF_NULL;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x.... 0x....      LDR.W    R1,??DataTable17_10
   \   0000006C   0x6008             STR      R0,[R1, #+0]
    123              OS_AppTaskReturnHookPtr = DEF_NULL;
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable17_11
   \   00000074   0x6008             STR      R0,[R1, #+0]
    124          
    125              OS_AppIdleTaskHookPtr   = DEF_NULL;
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0x.... 0x....      LDR.W    R1,??DataTable17_12
   \   0000007C   0x6008             STR      R0,[R1, #+0]
    126              OS_AppStatTaskHookPtr   = DEF_NULL;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable17_13
   \   00000084   0x6008             STR      R0,[R1, #+0]
    127              OS_AppTaskSwHookPtr     = DEF_NULL;
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0x.... 0x....      LDR.W    R1,??DataTable17_14
   \   0000008C   0x6008             STR      R0,[R1, #+0]
    128              OS_AppTimeTickHookPtr   = DEF_NULL;
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0x.... 0x....      LDR.W    R1,??DataTable17_15
   \   00000094   0x6008             STR      R0,[R1, #+0]
    129          #endif
    130          
    131          #if (OS_CFG_TASK_REG_TBL_SIZE > 0u)
    132              OSTaskRegNextAvailID    = 0u;
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0x.... 0x....      LDR.W    R1,??DataTable17_16
   \   0000009C   0x7008             STRB     R0,[R1, #+0]
    133          #endif
    134          
    135              OS_PrioInit();                                              /* Initialize the priority bitmap table                 */
   \   0000009E   0x.... 0x....      BL       OS_PrioInit
    136          
    137              OS_RdyListInit();                                           /* Initialize the Ready List                            */
   \   000000A2   0x.... 0x....      BL       OS_RdyListInit
    138          
    139          
    140          #if (OS_CFG_FLAG_EN == DEF_ENABLED)                             /* Initialize the Event Flag module                     */
    141          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    142              OSFlagDbgListPtr = DEF_NULL;
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0x.... 0x....      LDR.W    R1,??DataTable17_17
   \   000000AC   0x6008             STR      R0,[R1, #+0]
    143              OSFlagQty        = 0u;
   \   000000AE   0x2000             MOVS     R0,#+0
   \   000000B0   0x.... 0x....      LDR.W    R1,??DataTable17_18
   \   000000B4   0x8008             STRH     R0,[R1, #+0]
    144          #endif
    145          #endif
    146          
    147          #if (OS_CFG_MEM_EN == DEF_ENABLED)                              /* Initialize the Memory Manager module                 */
    148              OS_MemInit(p_err);
   \   000000B6   0x0020             MOVS     R0,R4
   \   000000B8   0x.... 0x....      BL       OS_MemInit
    149              if (*p_err != OS_ERR_NONE) {
   \   000000BC   0x8820             LDRH     R0,[R4, #+0]
   \   000000BE   0x2800             CMP      R0,#+0
   \   000000C0   0xD137             BNE.N    ??OSInit_3
    150                  return;
    151              }
    152          #endif
    153          
    154          
    155          #if (OS_MSG_EN == DEF_ENABLED)                                  /* Initialize the free list of OS_MSGs                  */
    156              OS_MsgPoolInit(p_err);
   \                     ??OSInit_4: (+1)
   \   000000C2   0x0020             MOVS     R0,R4
   \   000000C4   0x.... 0x....      BL       OS_MsgPoolInit
    157              if (*p_err != OS_ERR_NONE) {
   \   000000C8   0x8820             LDRH     R0,[R4, #+0]
   \   000000CA   0x2800             CMP      R0,#+0
   \   000000CC   0xD131             BNE.N    ??OSInit_3
    158                  return;
    159              }
    160          #endif
    161          
    162          
    163          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)                            /* Initialize the Mutex Manager module                  */
    164          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    165              OSMutexDbgListPtr = DEF_NULL;
   \                     ??OSInit_5: (+1)
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0x.... 0x....      LDR.W    R1,??DataTable17_19
   \   000000D4   0x6008             STR      R0,[R1, #+0]
    166              OSMutexQty        = 0u;
   \   000000D6   0x2000             MOVS     R0,#+0
   \   000000D8   0x.... 0x....      LDR.W    R1,??DataTable17_20
   \   000000DC   0x8008             STRH     R0,[R1, #+0]
    167          #endif
    168          #endif
    169          
    170          
    171          #if (OS_CFG_Q_EN == DEF_ENABLED)                                /* Initialize the Message Queue Manager module          */
    172          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    173              OSQDbgListPtr = DEF_NULL;
   \   000000DE   0x2000             MOVS     R0,#+0
   \   000000E0   0x.... 0x....      LDR.W    R1,??DataTable17_21
   \   000000E4   0x6008             STR      R0,[R1, #+0]
    174              OSQQty        = 0u;
   \   000000E6   0x2000             MOVS     R0,#+0
   \   000000E8   0x.... 0x....      LDR.W    R1,??DataTable17_22
   \   000000EC   0x8008             STRH     R0,[R1, #+0]
    175          #endif
    176          #endif
    177          
    178          
    179          #if (OS_CFG_SEM_EN == DEF_ENABLED)                              /* Initialize the Semaphore Manager module              */
    180          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    181              OSSemDbgListPtr = DEF_NULL;
   \   000000EE   0x2000             MOVS     R0,#+0
   \   000000F0   0x.... 0x....      LDR.W    R1,??DataTable17_23
   \   000000F4   0x6008             STR      R0,[R1, #+0]
    182              OSSemQty        = 0u;
   \   000000F6   0x2000             MOVS     R0,#+0
   \   000000F8   0x.... 0x....      LDR.W    R1,??DataTable17_24
   \   000000FC   0x8008             STRH     R0,[R1, #+0]
    183          #endif
    184          #endif
    185          
    186          
    187          #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
    188              OS_TLS_Init(p_err);                                         /* Initialize Task Local Storage, before creating tasks */
    189              if (*p_err != OS_ERR_NONE) {
    190                  return;
    191              }
    192          #endif
    193          
    194          
    195              OS_TaskInit(p_err);                                         /* Initialize the task manager                          */
   \   000000FE   0x0020             MOVS     R0,R4
   \   00000100   0x.... 0x....      BL       OS_TaskInit
    196              if (*p_err != OS_ERR_NONE) {
   \   00000104   0x8820             LDRH     R0,[R4, #+0]
   \   00000106   0x2800             CMP      R0,#+0
   \   00000108   0xD113             BNE.N    ??OSInit_3
    197                  return;
    198              }
    199          
    200          
    201          #if (OS_CFG_TASK_IDLE_EN == DEF_ENABLED)
    202              OS_IdleTaskInit(p_err);                                     /* Initialize the Idle Task                             */
   \                     ??OSInit_6: (+1)
   \   0000010A   0x0020             MOVS     R0,R4
   \   0000010C   0x.... 0x....      BL       OS_IdleTaskInit
    203              if (*p_err != OS_ERR_NONE) {
   \   00000110   0x8820             LDRH     R0,[R4, #+0]
   \   00000112   0x2800             CMP      R0,#+0
   \   00000114   0xD10D             BNE.N    ??OSInit_3
    204                  return;
    205              }
    206          #endif
    207          
    208          
    209          #if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
    210              OS_TickTaskInit(p_err);                                     /* Initialize the Tick Task                             */
   \                     ??OSInit_7: (+1)
   \   00000116   0x0020             MOVS     R0,R4
   \   00000118   0x.... 0x....      BL       OS_TickTaskInit
    211              if (*p_err != OS_ERR_NONE) {
   \   0000011C   0x8820             LDRH     R0,[R4, #+0]
   \   0000011E   0x2800             CMP      R0,#+0
   \   00000120   0xD107             BNE.N    ??OSInit_3
    212                  return;
    213              }
    214          #endif
    215          
    216          
    217          #if (OS_CFG_STAT_TASK_EN == DEF_ENABLED)                        /* Initialize the Statistic Task                        */
    218              OS_StatTaskInit(p_err);
    219              if (*p_err != OS_ERR_NONE) {
    220                  return;
    221              }
    222          #endif
    223          
    224          
    225          #if (OS_CFG_TMR_EN == DEF_ENABLED)                              /* Initialize the Timer Manager module                  */
    226              OS_TmrInit(p_err);
    227              if (*p_err != OS_ERR_NONE) {
    228                  return;
    229              }
    230          #endif
    231          
    232          
    233          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    234              OS_Dbg_Init();
   \                     ??OSInit_8: (+1)
   \   00000122   0x.... 0x....      BL       OS_Dbg_Init
    235          #endif
    236          
    237          
    238              OSCfg_Init();
   \   00000126   0x.... 0x....      BL       OSCfg_Init
    239          
    240              OSInitialized = DEF_TRUE;                                   /* Kernel is initialized                                */
   \   0000012A   0x2001             MOVS     R0,#+1
   \   0000012C   0x.... 0x....      LDR.W    R1,??DataTable17_25
   \   00000130   0x7008             STRB     R0,[R1, #+0]
    241          }
   \                     ??OSInit_3: (+1)
   \   00000132   0xBD10             POP      {R4,PC}          ;; return
    242          
    243          
    244          /*
    245          ************************************************************************************************************************
    246          *                                                      ENTER ISR
    247          *
    248          * Description: This function is used to notify uC/OS-III that you are about to service an interrupt service routine
    249          *              (ISR).  This allows uC/OS-III to keep track of interrupt nesting and thus only perform rescheduling at
    250          *              the last nested ISR.
    251          *
    252          * Arguments  : none
    253          *
    254          * Returns    : none
    255          *
    256          * Note(s)    : 1) This function MUST be called with interrupts already disabled
    257          *
    258          *              2) Your ISR can directly increment 'OSIntNestingCtr' without calling this function because OSIntNestingCtr has
    259          *                 been declared 'global', the port is actually considered part of the OS and thus is allowed to access
    260          *                 uC/OS-III variables.
    261          *
    262          *              3) You MUST still call OSIntExit() even though you increment 'OSIntNestingCtr' directly.
    263          *
    264          *              4) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call to OSIntEnter()
    265          *                 (or direct increment to OSIntNestingCtr) at the beginning of the ISR you MUST have a call to OSIntExit()
    266          *                 at the end of the ISR.
    267          *
    268          *              5) You are allowed to nest interrupts up to 250 levels deep.
    269          ************************************************************************************************************************
    270          */
    271          

   \                                 In section .text, align 2, keep-with-next
    272          void  OSIntEnter (void)
    273          {
    274              OS_TRACE_ISR_ENTER();
    275          
    276              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Is OS running?                                       */
   \                     OSIntEnter: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD10B             BNE.N    ??OSIntEnter_0
    277                  return;                                                 /* No                                                   */
    278              }
    279          
    280              if (OSIntNestingCtr >= 250u) {                              /* Have we nested past 250 levels?                      */
   \                     ??OSIntEnter_1: (+1)
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable17
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x28FA             CMP      R0,#+250
   \   00000012   0xD206             BCS.N    ??OSIntEnter_0
    281                  return;                                                 /* Yes                                                  */
    282              }
    283          
    284              OSIntNestingCtr++;                                          /* Increment ISR nesting level                          */
   \                     ??OSIntEnter_2: (+1)
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x1C40             ADDS     R0,R0,#+1
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable17
   \   00000020   0x7008             STRB     R0,[R1, #+0]
    285          }
   \                     ??OSIntEnter_0: (+1)
   \   00000022   0x4770             BX       LR               ;; return
    286          
    287          
    288          /*
    289          ************************************************************************************************************************
    290          *                                                       EXIT ISR
    291          *
    292          * Description: This function is used to notify uC/OS-III that you have completed servicing an ISR.  When the last nested
    293          *              ISR has completed, uC/OS-III will call the scheduler to determine whether a new, high-priority task, is
    294          *              ready to run.
    295          *
    296          * Arguments  : none
    297          *
    298          * Returns    : none
    299          *
    300          * Note(s)    : 1) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call to OSIntEnter()
    301          *                 (or direct increment to OSIntNestingCtr) at the beginning of the ISR you MUST have a call to OSIntExit()
    302          *                 at the end of the ISR.
    303          *
    304          *              2) Rescheduling is prevented when the scheduler is locked (see OSSchedLock())
    305          ************************************************************************************************************************
    306          */
    307          

   \                                 In section .text, align 2, keep-with-next
    308          void  OSIntExit (void)
    309          {
   \                     OSIntExit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    310          #if (OS_CFG_TASK_STK_REDZONE_EN == DEF_ENABLED)
    311              CPU_BOOLEAN  stk_status;
    312          #endif
    313              CPU_SR_ALLOC();
   \   00000002   0x2400             MOVS     R4,#+0
    314          
    315          
    316          
    317              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Has the OS started?                                  */
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD150             BNE.N    ??OSIntExit_0
    318                  OS_TRACE_ISR_EXIT();
    319                  return;                                                 /* No                                                   */
    320              }
    321          
    322              CPU_INT_DIS();
   \                     ??OSIntExit_1: (+1)
   \   0000000E   0x.... 0x....      BL       CPU_SR_Save
   \   00000012   0x0004             MOVS     R4,R0
    323              if (OSIntNestingCtr == 0u) {                                /* Prevent OSIntNestingCtr from wrapping                */
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD103             BNE.N    ??OSIntExit_2
    324                  OS_TRACE_ISR_EXIT();
    325                  CPU_INT_EN();
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       CPU_SR_Restore
    326                  return;
   \   00000024   0xE044             B.N      ??OSIntExit_0
    327              }
    328              OSIntNestingCtr--;
   \                     ??OSIntExit_2: (+1)
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable17
   \   0000002A   0x7800             LDRB     R0,[R0, #+0]
   \   0000002C   0x1E40             SUBS     R0,R0,#+1
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable17
   \   00000032   0x7008             STRB     R0,[R1, #+0]
    329              if (OSIntNestingCtr > 0u) {                                 /* ISRs still nested?                                   */
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000038   0x7800             LDRB     R0,[R0, #+0]
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD003             BEQ.N    ??OSIntExit_3
    330                  OS_TRACE_ISR_EXIT();
    331                  CPU_INT_EN();                                           /* Yes                                                  */
   \   0000003E   0x0020             MOVS     R0,R4
   \   00000040   0x.... 0x....      BL       CPU_SR_Restore
    332                  return;
   \   00000044   0xE034             B.N      ??OSIntExit_0
    333              }
    334          
    335              if (OSSchedLockNestingCtr > 0u) {                           /* Scheduler still locked?                              */
   \                     ??OSIntExit_3: (+1)
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \   0000004A   0x7800             LDRB     R0,[R0, #+0]
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD003             BEQ.N    ??OSIntExit_4
    336                  OS_TRACE_ISR_EXIT();
    337                  CPU_INT_EN();                                           /* Yes                                                  */
   \   00000050   0x0020             MOVS     R0,R4
   \   00000052   0x.... 0x....      BL       CPU_SR_Restore
    338                  return;
   \   00000056   0xE02B             B.N      ??OSIntExit_0
    339              }
    340          
    341                                                                          /* Verify ISR Stack                                     */
    342          #if (OS_CFG_ISR_STK_SIZE > 0u)
    343          #if (OS_CFG_TASK_STK_REDZONE_EN == DEF_ENABLED)
    344              stk_status = OS_TaskStkRedzoneChk(OSCfg_ISRStkBasePtr, OSCfg_ISRStkSize);
    345              if (stk_status != DEF_OK) {
    346                  OSRedzoneHitHook(DEF_NULL);
    347              }
    348          #endif
    349          #endif
    350          
    351              OSPrioHighRdy   = OS_PrioGetHighest();                      /* Find highest priority                                */
   \                     ??OSIntExit_4: (+1)
   \   00000058   0x.... 0x....      BL       OS_PrioGetHighest
   \   0000005C   0x.... 0x....      LDR.W    R1,??DataTable17_6
   \   00000060   0x7008             STRB     R0,[R1, #+0]
    352          #if (OS_CFG_TASK_IDLE_EN == DEF_ENABLED)
    353              OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;         /* Get highest priority task ready-to-run               */
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable17_26
   \   00000066   0x.... 0x....      LDR.W    R1,??DataTable17_6
   \   0000006A   0x7809             LDRB     R1,[R1, #+0]
   \   0000006C   0x220C             MOVS     R2,#+12
   \   0000006E   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x.... 0x....      LDR.W    R1,??DataTable17_4
   \   00000078   0x6008             STR      R0,[R1, #+0]
    354              if (OSTCBHighRdyPtr == OSTCBCurPtr) {                       /* Current task still the highest priority?             */
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable17_3
   \   00000084   0x6809             LDR      R1,[R1, #+0]
   \   00000086   0x4288             CMP      R0,R1
   \   00000088   0xD103             BNE.N    ??OSIntExit_5
    355                                                                          /* Yes                                                  */
    356          #if (OS_CFG_TASK_STK_REDZONE_EN == DEF_ENABLED)
    357                  stk_status = OSTaskStkRedzoneChk(DEF_NULL);
    358                  if (stk_status != DEF_OK) {
    359                      OSRedzoneHitHook(OSTCBCurPtr);
    360                  }
    361          #endif
    362                  OS_TRACE_ISR_EXIT();
    363                  CPU_INT_EN();
   \   0000008A   0x0020             MOVS     R0,R4
   \   0000008C   0x.... 0x....      BL       CPU_SR_Restore
    364                  return;
   \   00000090   0xE00E             B.N      ??OSIntExit_0
    365              }
    366          #else
    367              if (OSPrioHighRdy != (OS_CFG_PRIO_MAX - 1u)) {              /* Are we returning to idle?                            */
    368                  OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;     /* No ... get highest priority task ready-to-run        */
    369                  if (OSTCBHighRdyPtr == OSTCBCurPtr) {                   /* Current task still the highest priority?             */
    370                                                                          /* Yes                                                  */
    371                      OS_TRACE_ISR_EXIT();
    372                      CPU_INT_EN();
    373                      return;
    374                  }
    375              }
    376          #endif
    377          
    378          #if (OS_CFG_TASK_PROFILE_EN == DEF_ENABLED)
    379              OSTCBHighRdyPtr->CtxSwCtr++;                                /* Inc. # of context switches for this new task         */
    380          #endif
    381          #if ((OS_CFG_TASK_PROFILE_EN == DEF_ENABLED) || (OS_CFG_DBG_EN == DEF_ENABLED))
    382              OSTaskCtxSwCtr++;                                           /* Keep track of the total number of ctx switches       */
   \                     ??OSIntExit_5: (+1)
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable17_27
   \   00000096   0x6800             LDR      R0,[R0, #+0]
   \   00000098   0x1C40             ADDS     R0,R0,#+1
   \   0000009A   0x.... 0x....      LDR.W    R1,??DataTable17_27
   \   0000009E   0x6008             STR      R0,[R1, #+0]
    383          #endif
    384          
    385          #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
    386              OS_TLS_TaskSw();
    387          #endif
    388          
    389              OS_TRACE_ISR_EXIT_TO_SCHEDULER();
    390          
    391              OSIntCtxSw();                                               /* Perform interrupt level ctx switch                   */
   \   000000A0   0xF05F 0x5080      MOVS     R0,#+268435456
   \   000000A4   0x.... 0x....      LDR.W    R1,??DataTable17_28  ;; 0xe000ed04
   \   000000A8   0x6008             STR      R0,[R1, #+0]
    392          
    393              CPU_INT_EN();
   \   000000AA   0x0020             MOVS     R0,R4
   \   000000AC   0x.... 0x....      BL       CPU_SR_Restore
    394          }
   \                     ??OSIntExit_0: (+1)
   \   000000B0   0xBD10             POP      {R4,PC}          ;; return
    395          
    396          
    397          /*
    398          ************************************************************************************************************************
    399          *                                    INDICATE THAT IT'S NO LONGER SAFE TO CREATE OBJECTS
    400          *
    401          * Description: This function is called by the application code to indicate that all initialization has been completed
    402          *              and that kernel objects are no longer allowed to be created.
    403          *
    404          * Arguments  : none
    405          *
    406          * Returns    : none
    407          *
    408          * Note(s)    : none
    409          ************************************************************************************************************************
    410          */
    411          
    412          #ifdef OS_SAFETY_CRITICAL_IEC61508
    413          void  OSSafetyCriticalStart (void)
    414          {
    415              OSSafetyCriticalStartFlag = DEF_TRUE;
    416          }
    417          
    418          #endif
    419          
    420          
    421          /*
    422          ************************************************************************************************************************
    423          *                                                      SCHEDULER
    424          *
    425          * Description: This function is called by other uC/OS-III services to determine whether a new, high priority task has
    426          *              been made ready to run.  This function is invoked by TASK level code and is not used to reschedule tasks
    427          *              from ISRs (see OSIntExit() for ISR rescheduling).
    428          *
    429          * Arguments  : none
    430          *
    431          * Returns    : none
    432          *
    433          * Note(s)    : 1) Rescheduling is prevented when the scheduler is locked (see OSSchedLock())
    434          ************************************************************************************************************************
    435          */
    436          

   \                                 In section .text, align 2, keep-with-next
    437          void  OSSched (void)
    438          {
   \                     OSSched: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    439              CPU_SR_ALLOC();
   \   00000002   0x2400             MOVS     R4,#+0
    440          
    441          
    442          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Can't schedule when the kernel is stopped.           */
    443              if (OSRunning != OS_STATE_OS_RUNNING) {
    444                  return;
    445              }
    446          #endif
    447          
    448              if (OSIntNestingCtr > 0u) {                                 /* ISRs still nested?                                   */
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD133             BNE.N    ??OSSched_0
    449                  return;                                                 /* Yes ... only schedule when no nested ISRs            */
    450              }
    451          
    452              if (OSSchedLockNestingCtr > 0u) {                           /* Scheduler locked?                                    */
   \                     ??OSSched_1: (+1)
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD12E             BNE.N    ??OSSched_0
    453                  return;                                                 /* Yes                                                  */
    454              }
    455          
    456              CPU_INT_DIS();
   \                     ??OSSched_2: (+1)
   \   00000018   0x.... 0x....      BL       CPU_SR_Save
   \   0000001C   0x0004             MOVS     R4,R0
    457              OSPrioHighRdy   = OS_PrioGetHighest();                      /* Find the highest priority ready                      */
   \   0000001E   0x.... 0x....      BL       OS_PrioGetHighest
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable17_6
   \   00000026   0x7008             STRB     R0,[R1, #+0]
    458          #if (OS_CFG_TASK_IDLE_EN == DEF_ENABLED)
    459              OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;         /* Get highest priority task ready-to-run               */
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable17_26
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable17_6
   \   00000030   0x7809             LDRB     R1,[R1, #+0]
   \   00000032   0x220C             MOVS     R2,#+12
   \   00000034   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable17_4
   \   0000003E   0x6008             STR      R0,[R1, #+0]
    460              if (OSTCBHighRdyPtr == OSTCBCurPtr) {                       /* Current task still the highest priority?             */
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable17_3
   \   0000004A   0x6809             LDR      R1,[R1, #+0]
   \   0000004C   0x4288             CMP      R0,R1
   \   0000004E   0xD103             BNE.N    ??OSSched_3
    461                  CPU_INT_EN();                                           /* Yes                                                  */
   \   00000050   0x0020             MOVS     R0,R4
   \   00000052   0x.... 0x....      BL       CPU_SR_Restore
    462                  return;
   \   00000056   0xE00E             B.N      ??OSSched_0
    463              }
    464          #else
    465              if (OSPrioHighRdy != (OS_CFG_PRIO_MAX - 1u)) {              /* Are we returning to idle?                              */
    466                  OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;     /* No ... get highest priority task ready-to-run          */
    467                  if (OSTCBHighRdyPtr == OSTCBCurPtr) {                   /* Current task still the highest priority?               */
    468                      CPU_INT_EN();                                       /* Yes                                                    */
    469                      return;
    470                  }
    471              }
    472          #endif
    473          
    474          
    475          #if (OS_CFG_TASK_PROFILE_EN == DEF_ENABLED)
    476              OSTCBHighRdyPtr->CtxSwCtr++;                                /* Inc. # of context switches to this task              */
    477          #endif
    478          
    479          #if ((OS_CFG_TASK_PROFILE_EN == DEF_ENABLED) || (OS_CFG_DBG_EN == DEF_ENABLED))
    480              OSTaskCtxSwCtr++;                                           /* Increment context switch counter                     */
   \                     ??OSSched_3: (+1)
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable17_27
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0x1C40             ADDS     R0,R0,#+1
   \   00000060   0x.... 0x....      LDR.W    R1,??DataTable17_27
   \   00000064   0x6008             STR      R0,[R1, #+0]
    481          #endif
    482          
    483          #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
    484              OS_TLS_TaskSw();
    485          #endif
    486          
    487          #if (OS_CFG_TASK_IDLE_EN == DEF_ENABLED)
    488              OS_TASK_SW();                                               /* Perform a task level context switch                  */
   \   00000066   0xF05F 0x5080      MOVS     R0,#+268435456
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable17_28  ;; 0xe000ed04
   \   0000006E   0x6008             STR      R0,[R1, #+0]
    489              CPU_INT_EN();
   \   00000070   0x0020             MOVS     R0,R4
   \   00000072   0x.... 0x....      BL       CPU_SR_Restore
    490          #else
    491              if ((OSPrioHighRdy != (OS_CFG_PRIO_MAX - 1u))) {
    492                  OS_TASK_SW();                                           /* Perform a task level context switch                  */
    493                  CPU_INT_EN();
    494              } else {
    495                  OSTCBHighRdyPtr = OSTCBCurPtr;
    496                  CPU_INT_EN();
    497                  for (;;) {
    498          #if ((OS_CFG_DBG_EN == DEF_ENABLED) || (OS_CFG_STAT_TASK_EN == DEF_ENABLED))
    499                      CPU_CRITICAL_ENTER();
    500          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    501                      OSIdleTaskCtr++;
    502          #endif
    503          #if (OS_CFG_STAT_TASK_EN == DEF_ENABLED)
    504                      OSStatTaskCtr++;
    505          #endif
    506                      CPU_CRITICAL_EXIT();
    507          #endif
    508          
    509          #if (OS_CFG_APP_HOOKS_EN == DEF_ENABLED)
    510                      OSIdleTaskHook();                                   /* Call user definable HOOK                             */
    511          #endif
    512                      if ((*((volatile OS_PRIO *)&OSPrioHighRdy) != (OS_CFG_PRIO_MAX - 1u))) {
    513                          break;
    514                      }
    515                  }
    516              }
    517          #endif
    518          
    519          #ifdef OS_TASK_SW_SYNC
    520              OS_TASK_SW_SYNC();
    521          #endif
    522          }
   \                     ??OSSched_0: (+1)
   \   00000076   0xBD10             POP      {R4,PC}          ;; return
    523          
    524          
    525          /*
    526          ************************************************************************************************************************
    527          *                                                 PREVENT SCHEDULING
    528          *
    529          * Description: This function is used to prevent rescheduling from taking place.  This allows your application to prevent
    530          *              context switches until you are ready to permit context switching.
    531          *
    532          * Arguments  : p_err     is a pointer to a variable that will receive an error code:
    533          *
    534          *                            OS_ERR_NONE                 The scheduler is locked
    535          *                            OS_ERR_LOCK_NESTING_OVF     If you attempted to nest call to this function > 250 levels
    536          *                            OS_ERR_OS_NOT_RUNNING       If uC/OS-III is not running yet
    537          *                            OS_ERR_SCHED_LOCK_ISR       If you called this function from an ISR
    538          *
    539          * Returns    : none
    540          *
    541          * Note(s)    : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
    542          *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
    543          ************************************************************************************************************************
    544          */
    545          

   \                                 In section .text, align 2, keep-with-next
    546          void  OSSchedLock (OS_ERR  *p_err)
    547          {
   \                     OSSchedLock: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    548              CPU_SR_ALLOC();
   \   00000004   0x2500             MOVS     R5,#+0
    549          
    550          
    551          
    552          #ifdef OS_SAFETY_CRITICAL
    553              if (p_err == DEF_NULL) {
    554                  OS_SAFETY_CRITICAL_EXCEPTION();
    555                  return;
    556              }
    557          #endif
    558          
    559          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
    560              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable17
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD003             BEQ.N    ??OSSchedLock_0
    561                 *p_err = OS_ERR_SCHED_LOCK_ISR;
   \   00000010   0xF646 0x5062      MOVW     R0,#+28002
   \   00000014   0x8020             STRH     R0,[R4, #+0]
    562                  return;
   \   00000016   0xE024             B.N      ??OSSchedLock_1
    563              }
    564          #endif
    565          
    566              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Make sure multitasking is running                    */
   \                     ??OSSchedLock_0: (+1)
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD003             BEQ.N    ??OSSchedLock_2
    567                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   00000022   0xF645 0x6089      MOVW     R0,#+24201
   \   00000026   0x8020             STRH     R0,[R4, #+0]
    568                  return;
   \   00000028   0xE01B             B.N      ??OSSchedLock_1
    569              }
    570          
    571              if (OSSchedLockNestingCtr >= 250u) {                        /* Prevent OSSchedLockNestingCtr overflowing            */
   \                     ??OSSchedLock_2: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0x28FA             CMP      R0,#+250
   \   00000032   0xD303             BCC.N    ??OSSchedLock_3
    572                 *p_err = OS_ERR_LOCK_NESTING_OVF;
   \   00000034   0xF245 0x2009      MOVW     R0,#+21001
   \   00000038   0x8020             STRH     R0,[R4, #+0]
    573                  return;
   \   0000003A   0xE012             B.N      ??OSSchedLock_1
    574              }
    575          
    576              CPU_CRITICAL_ENTER();
   \                     ??OSSchedLock_3: (+1)
   \   0000003C   0x.... 0x....      BL       CPU_SR_Save
   \   00000040   0x0005             MOVS     R5,R0
   \   00000042   0x.... 0x....      BL       CPU_IntDisMeasStart
    577              OSSchedLockNestingCtr++;                                    /* Increment lock nesting level                         */
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \   0000004A   0x7800             LDRB     R0,[R0, #+0]
   \   0000004C   0x1C40             ADDS     R0,R0,#+1
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable17_2
   \   00000052   0x7008             STRB     R0,[R1, #+0]
    578          #if (OS_CFG_SCHED_LOCK_TIME_MEAS_EN == DEF_ENABLED)
    579              OS_SchedLockTimeMeasStart();
    580          #endif
    581              CPU_CRITICAL_EXIT();
   \   00000054   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000058   0x0028             MOVS     R0,R5
   \   0000005A   0x.... 0x....      BL       CPU_SR_Restore
    582             *p_err = OS_ERR_NONE;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x8020             STRH     R0,[R4, #+0]
    583          }
   \                     ??OSSchedLock_1: (+1)
   \   00000062   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    584          
    585          
    586          /*
    587          ************************************************************************************************************************
    588          *                                                  ENABLE SCHEDULING
    589          *
    590          * Description: This function is used to re-allow rescheduling.
    591          *
    592          * Arguments  : p_err     is a pointer to a variable that will contain an error code returned by this function.
    593          *
    594          *                            OS_ERR_NONE                 The scheduler has been enabled
    595          *                            OS_ERR_OS_NOT_RUNNING       If uC/OS-III is not running yet
    596          *                            OS_ERR_SCHED_LOCKED         The scheduler is still locked, still nested
    597          *                            OS_ERR_SCHED_NOT_LOCKED     The scheduler was not locked
    598          *                            OS_ERR_SCHED_UNLOCK_ISR     If you called this function from an ISR
    599          *
    600          * Returns    : none
    601          *
    602          * Note(s)    : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every call to
    603          *                 OSSchedLock() you MUST have a call to OSSchedUnlock().
    604          ************************************************************************************************************************
    605          */
    606          

   \                                 In section .text, align 2, keep-with-next
    607          void  OSSchedUnlock (OS_ERR  *p_err)
    608          {
   \                     OSSchedUnlock: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    609              CPU_SR_ALLOC();
   \   00000004   0x2500             MOVS     R5,#+0
    610          
    611          
    612          
    613          #ifdef OS_SAFETY_CRITICAL
    614              if (p_err == DEF_NULL) {
    615                  OS_SAFETY_CRITICAL_EXCEPTION();
    616                  return;
    617              }
    618          #endif
    619          
    620          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
    621              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable17
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD003             BEQ.N    ??OSSchedUnlock_0
    622                 *p_err = OS_ERR_SCHED_UNLOCK_ISR;
   \   00000010   0xF646 0x5065      MOVW     R0,#+28005
   \   00000014   0x8020             STRH     R0,[R4, #+0]
    623                  return;
   \   00000016   0xE034             B.N      ??OSSchedUnlock_1
    624              }
    625          #endif
    626          
    627              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Make sure multitasking is running                    */
   \                     ??OSSchedUnlock_0: (+1)
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD003             BEQ.N    ??OSSchedUnlock_2
    628                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   00000022   0xF645 0x6089      MOVW     R0,#+24201
   \   00000026   0x8020             STRH     R0,[R4, #+0]
    629                  return;
   \   00000028   0xE02B             B.N      ??OSSchedUnlock_1
    630              }
    631          
    632              if (OSSchedLockNestingCtr == 0u) {                          /* See if the scheduler is locked                       */
   \                     ??OSSchedUnlock_2: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD103             BNE.N    ??OSSchedUnlock_3
    633                 *p_err = OS_ERR_SCHED_NOT_LOCKED;
   \   00000034   0xF646 0x5064      MOVW     R0,#+28004
   \   00000038   0x8020             STRH     R0,[R4, #+0]
    634                  return;
   \   0000003A   0xE022             B.N      ??OSSchedUnlock_1
    635              }
    636          
    637              CPU_CRITICAL_ENTER();
   \                     ??OSSchedUnlock_3: (+1)
   \   0000003C   0x.... 0x....      BL       CPU_SR_Save
   \   00000040   0x0005             MOVS     R5,R0
   \   00000042   0x.... 0x....      BL       CPU_IntDisMeasStart
    638              OSSchedLockNestingCtr--;                                    /* Decrement lock nesting level                         */
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \   0000004A   0x7800             LDRB     R0,[R0, #+0]
   \   0000004C   0x1E40             SUBS     R0,R0,#+1
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable17_2
   \   00000052   0x7008             STRB     R0,[R1, #+0]
    639              if (OSSchedLockNestingCtr > 0u) {
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \   00000058   0x7800             LDRB     R0,[R0, #+0]
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD008             BEQ.N    ??OSSchedUnlock_4
    640                  CPU_CRITICAL_EXIT();                                    /* Scheduler is still locked                            */
   \   0000005E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000062   0x0028             MOVS     R0,R5
   \   00000064   0x.... 0x....      BL       CPU_SR_Restore
    641                 *p_err = OS_ERR_SCHED_LOCKED;
   \   00000068   0xF646 0x5063      MOVW     R0,#+28003
   \   0000006C   0x8020             STRH     R0,[R4, #+0]
    642                  return;
   \   0000006E   0xE008             B.N      ??OSSchedUnlock_1
    643              }
    644          
    645          #if (OS_CFG_SCHED_LOCK_TIME_MEAS_EN == DEF_ENABLED)
    646              OS_SchedLockTimeMeasStop();
    647          #endif
    648          
    649              CPU_CRITICAL_EXIT();                                        /* Scheduler should be re-enabled                       */
   \                     ??OSSchedUnlock_4: (+1)
   \   00000070   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000074   0x0028             MOVS     R0,R5
   \   00000076   0x.... 0x....      BL       CPU_SR_Restore
    650              OSSched();                                                  /* Run the scheduler                                    */
   \   0000007A   0x.... 0x....      BL       OSSched
    651             *p_err = OS_ERR_NONE;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x8020             STRH     R0,[R4, #+0]
    652          }
   \                     ??OSSchedUnlock_1: (+1)
   \   00000082   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    653          
    654          
    655          /*
    656          ************************************************************************************************************************
    657          *                                      CONFIGURE ROUND-ROBIN SCHEDULING PARAMETERS
    658          *
    659          * Description: This function is called to change the round-robin scheduling parameters.
    660          *
    661          * Arguments  : en                determines whether round-robin will be enabled (when DEF_EN) or not (when DEF_DIS)
    662          *
    663          *              dflt_time_quanta  default number of ticks between time slices.  0 means OSCfg_TickRate_Hz / 10.
    664          *
    665          *              p_err             is a pointer to a variable that will contain an error code returned by this function.
    666          *
    667          *                                    OS_ERR_NONE    The call was successful
    668          *
    669          * Returns    : none
    670          *
    671          * Note(s)    : none
    672          ************************************************************************************************************************
    673          */
    674          
    675          #if (OS_CFG_SCHED_ROUND_ROBIN_EN == DEF_ENABLED)
    676          void  OSSchedRoundRobinCfg (CPU_BOOLEAN   en,
    677                                      OS_TICK       dflt_time_quanta,
    678                                      OS_ERR       *p_err)
    679          {
    680              CPU_SR_ALLOC();
    681          
    682          
    683          
    684          #ifdef OS_SAFETY_CRITICAL
    685              if (p_err == DEF_NULL) {
    686                  OS_SAFETY_CRITICAL_EXCEPTION();
    687                  return;
    688              }
    689          #endif
    690          
    691              CPU_CRITICAL_ENTER();
    692              if (en != DEF_ENABLED) {
    693                  OSSchedRoundRobinEn = DEF_FALSE;
    694              } else {
    695                  OSSchedRoundRobinEn = DEF_TRUE;
    696              }
    697          
    698              if (dflt_time_quanta > 0u) {
    699                  OSSchedRoundRobinDfltTimeQuanta = dflt_time_quanta;
    700              } else {
    701                  OSSchedRoundRobinDfltTimeQuanta = (OS_TICK)(OSCfg_TickRate_Hz / 10u);
    702              }
    703              CPU_CRITICAL_EXIT();
    704             *p_err = OS_ERR_NONE;
    705          }
    706          #endif
    707          
    708          
    709          /*
    710          ************************************************************************************************************************
    711          *                                    YIELD CPU WHEN TASK NO LONGER NEEDS THE TIME SLICE
    712          *
    713          * Description: This function is called to give up the CPU when a task is done executing before its time slice expires.
    714          *
    715          * Argument(s): p_err      is a pointer to a variable that will contain an error code returned by this function.
    716          *
    717          *                             OS_ERR_NONE                   The call was successful
    718          *                             OS_ERR_ROUND_ROBIN_1          Only 1 task at this priority, nothing to yield to
    719          *                             OS_ERR_ROUND_ROBIN_DISABLED   Round Robin is not enabled
    720          *                             OS_ERR_SCHED_LOCKED           The scheduler has been locked
    721          *                             OS_ERR_YIELD_ISR              Can't be called from an ISR
    722          *
    723          * Returns    : none
    724          *
    725          * Note(s)    : 1) This function MUST be called from a task.
    726          ************************************************************************************************************************
    727          */
    728          
    729          #if (OS_CFG_SCHED_ROUND_ROBIN_EN == DEF_ENABLED)
    730          void  OSSchedRoundRobinYield (OS_ERR  *p_err)
    731          {
    732              OS_RDY_LIST  *p_rdy_list;
    733              OS_TCB       *p_tcb;
    734              CPU_SR_ALLOC();
    735          
    736          
    737          
    738          #ifdef OS_SAFETY_CRITICAL
    739              if (p_err == DEF_NULL) {
    740                  OS_SAFETY_CRITICAL_EXCEPTION();
    741                  return;
    742              }
    743          #endif
    744          
    745          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
    746              if (OSIntNestingCtr > 0u) {                                 /* Can't call this function from an ISR                 */
    747                 *p_err = OS_ERR_YIELD_ISR;
    748                  return;
    749              }
    750          #endif
    751          
    752              if (OSSchedLockNestingCtr > 0u) {                           /* Can't yield if the scheduler is locked               */
    753                 *p_err = OS_ERR_SCHED_LOCKED;
    754                  return;
    755              }
    756          
    757              if (OSSchedRoundRobinEn != DEF_TRUE) {                      /* Make sure round-robin has been enabled               */
    758                 *p_err = OS_ERR_ROUND_ROBIN_DISABLED;
    759                  return;
    760              }
    761          
    762              CPU_CRITICAL_ENTER();
    763              p_rdy_list = &OSRdyList[OSPrioCur];                         /* Can't yield if it's the only task at that priority   */
    764              if (p_rdy_list->HeadPtr == p_rdy_list->TailPtr) {
    765                  CPU_CRITICAL_EXIT();
    766                 *p_err = OS_ERR_ROUND_ROBIN_1;
    767                  return;
    768              }
    769          
    770              OS_RdyListMoveHeadToTail(p_rdy_list);                       /* Move current OS_TCB to the end of the list           */
    771              p_tcb = p_rdy_list->HeadPtr;                                /* Point to new OS_TCB at head of the list              */
    772              if (p_tcb->TimeQuanta == 0u) {                              /* See if we need to use the default time slice         */
    773                  p_tcb->TimeQuantaCtr = OSSchedRoundRobinDfltTimeQuanta;
    774              } else {
    775                  p_tcb->TimeQuantaCtr = p_tcb->TimeQuanta;               /* Load time slice counter with new time                */
    776              }
    777          
    778              CPU_CRITICAL_EXIT();
    779          
    780              OSSched();                                                  /* Run new task                                         */
    781             *p_err = OS_ERR_NONE;
    782          }
    783          #endif
    784          
    785          
    786          /*
    787          ************************************************************************************************************************
    788          *                                                 START MULTITASKING
    789          *
    790          * Description: This function is used to start the multitasking process which lets uC/OS-III manage the task that you
    791          *              created.  Before you can call OSStart(), you MUST have called OSInit() and you MUST have created at least
    792          *              one application task.
    793          *
    794          * Argument(s): p_err      is a pointer to a variable that will contain an error code returned by this function.
    795          *
    796          *                             OS_ERR_FATAL_RETURN    OS was running and OSStart() returned
    797          *                             OS_ERR_OS_NOT_INIT     OS is not initialized, OSStart() has no effect
    798          *                             OS_ERR_OS_NO_APP_TASK  No application task created, OSStart() has no effect
    799          *                             OS_ERR_OS_RUNNING      OS is already running, OSStart() has no effect
    800          *
    801          * Returns    : none
    802          *
    803          * Note(s)    : 1) OSStartHighRdy() MUST:
    804          *                 a) Call OSTaskSwHook() then,
    805          *                 b) Load the context of the task pointed to by OSTCBHighRdyPtr.
    806          *                 c) Execute the task.
    807          *
    808          *              2) OSStart() is not supposed to return.  If it does, that would be considered a fatal error.
    809          ************************************************************************************************************************
    810          */
    811          

   \                                 In section .text, align 2, keep-with-next
    812          void  OSStart (OS_ERR  *p_err)
    813          {
   \                     OSStart: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    814              OS_OBJ_QTY  kernel_task_cnt;
    815          
    816          
    817          #ifdef OS_SAFETY_CRITICAL
    818              if (p_err == DEF_NULL) {
    819                  OS_SAFETY_CRITICAL_EXCEPTION();
    820                  return;
    821              }
    822          #endif
    823          
    824              if (OSInitialized != DEF_TRUE) {
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable17_25
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD003             BEQ.N    ??OSStart_0
    825                 *p_err = OS_ERR_OS_NOT_INIT;
   \   0000000E   0xF645 0x608B      MOVW     R0,#+24203
   \   00000012   0x8020             STRH     R0,[R4, #+0]
    826                  return;
   \   00000014   0xE03B             B.N      ??OSStart_1
    827              }
    828          
    829              kernel_task_cnt = 0u;                                       /* Calculate the number of kernel tasks                 */
   \                     ??OSStart_0: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
    830          #if (OS_CFG_STAT_TASK_EN == DEF_ENABLED)
    831              kernel_task_cnt++;
    832          #endif
    833          #if (OS_CFG_TASK_TICK_EN  == DEF_ENABLED)
    834              kernel_task_cnt++;
   \   00000018   0x1C40             ADDS     R0,R0,#+1
    835          #endif
    836          #if (OS_CFG_TMR_EN == DEF_ENABLED)
    837              kernel_task_cnt++;
    838          #endif
    839          #if (OS_CFG_TASK_IDLE_EN == DEF_ENABLED)
    840              kernel_task_cnt++;
   \   0000001A   0x1C40             ADDS     R0,R0,#+1
    841          #endif
    842          
    843              if (OSTaskQty <= kernel_task_cnt) {                         /* No application task created                          */
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable17_29
   \   00000020   0x8809             LDRH     R1,[R1, #+0]
   \   00000022   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000024   0x4288             CMP      R0,R1
   \   00000026   0xD303             BCC.N    ??OSStart_2
    844                  *p_err = OS_ERR_OS_NO_APP_TASK;
   \   00000028   0xF645 0x608C      MOVW     R0,#+24204
   \   0000002C   0x8020             STRH     R0,[R4, #+0]
    845                   return;
   \   0000002E   0xE02E             B.N      ??OSStart_1
    846              }
    847          
    848              if (OSRunning == OS_STATE_OS_STOPPED) {
   \                     ??OSStart_2: (+1)
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000034   0x7800             LDRB     R0,[R0, #+0]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD126             BNE.N    ??OSStart_3
    849                  OSPrioHighRdy   = OS_PrioGetHighest();                  /* Find the highest priority                            */
   \   0000003A   0x.... 0x....      BL       OS_PrioGetHighest
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable17_6
   \   00000042   0x7008             STRB     R0,[R1, #+0]
    850                  OSPrioCur       = OSPrioHighRdy;
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable17_6
   \   00000048   0x7800             LDRB     R0,[R0, #+0]
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable17_5
   \   0000004E   0x7008             STRB     R0,[R1, #+0]
    851                  OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable17_26
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable17_6
   \   00000058   0x7809             LDRB     R1,[R1, #+0]
   \   0000005A   0x220C             MOVS     R2,#+12
   \   0000005C   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable17_4
   \   00000066   0x6008             STR      R0,[R1, #+0]
    852                  OSTCBCurPtr     = OSTCBHighRdyPtr;
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable17_3
   \   00000072   0x6008             STR      R0,[R1, #+0]
    853                  OSRunning       = OS_STATE_OS_RUNNING;
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable17_1
   \   0000007A   0x7008             STRB     R0,[R1, #+0]
    854                  OSStartHighRdy();                                       /* Execute target specific code to start task           */
   \   0000007C   0x.... 0x....      BL       OSStartHighRdy
    855                  
    856                  
    857                 *p_err           = OS_ERR_FATAL_RETURN;                  /* OSStart() is not supposed to return                  */
   \   00000080   0xF643 0x2099      MOVW     R0,#+15001
   \   00000084   0x8020             STRH     R0,[R4, #+0]
   \   00000086   0xE002             B.N      ??OSStart_4
    858              } else {
    859                 *p_err           = OS_ERR_OS_RUNNING;                    /* OS is already running                                */
   \                     ??OSStart_3: (+1)
   \   00000088   0xF645 0x608A      MOVW     R0,#+24202
   \   0000008C   0x8020             STRH     R0,[R4, #+0]
    860              }
    861          }
   \                     ??OSStart_4: (+1)
   \                     ??OSStart_1: (+1)
   \   0000008E   0xBD10             POP      {R4,PC}          ;; return
    862          
    863          
    864          /*
    865          ************************************************************************************************************************
    866          *                                                    GET VERSION
    867          *
    868          * Description: This function is used to return the version number of uC/OS-III.  The returned value corresponds to
    869          *              uC/OS-III's version number multiplied by 10000.  In other words, version 3.01.02 would be returned as 30102.
    870          *
    871          * Arguments  : p_err   is a pointer to a variable that will receive an error code.  However, OSVersion() set this
    872          *                      variable to
    873          *
    874          *                         OS_ERR_NONE
    875          *
    876          * Returns    : The version number of uC/OS-III multiplied by 10000.
    877          *
    878          * Note(s)    : none
    879          ************************************************************************************************************************
    880          */
    881          

   \                                 In section .text, align 2, keep-with-next
    882          CPU_INT16U  OSVersion (OS_ERR  *p_err)
    883          {
    884          #ifdef OS_SAFETY_CRITICAL
    885              if (p_err == DEF_NULL) {
    886                  OS_SAFETY_CRITICAL_EXCEPTION();
    887                  return (0u);
    888              }
    889          #endif
    890          
    891             *p_err = OS_ERR_NONE;
   \                     OSVersion: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x8001             STRH     R1,[R0, #+0]
    892              return (OS_VERSION);
   \   00000004   0xF247 0x7088      MOVW     R0,#+30600
   \   00000008   0x4770             BX       LR               ;; return
    893          }
    894          
    895          
    896          /*
    897          ************************************************************************************************************************
    898          *                                                      IDLE TASK
    899          *
    900          * Description: This task is internal to uC/OS-III and executes whenever no other higher priority tasks executes because
    901          *              they are ALL waiting for event(s) to occur.
    902          *
    903          * Arguments  : p_arg    is an argument passed to the task when the task is created.
    904          *
    905          * Returns    : none
    906          *
    907          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    908          *
    909          *              2) OSIdleTaskHook() is called after the critical section to ensure that interrupts will be enabled for at
    910          *                 least a few instructions.  On some processors (ex. Philips XA), enabling and then disabling interrupts
    911          *                 doesn't allow the processor enough time to have interrupts enabled before they were disabled again.
    912          *                 uC/OS-III would thus never recognize interrupts.
    913          *
    914          *              3) This hook has been added to allow you to do such things as STOP the CPU to conserve power.
    915          ************************************************************************************************************************
    916          */
    917          #if (OS_CFG_TASK_IDLE_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    918          void  OS_IdleTask (void  *p_arg)
    919          {
   \                     OS_IdleTask: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    920          #if ((OS_CFG_DBG_EN == DEF_ENABLED) || (OS_CFG_STAT_TASK_EN == DEF_ENABLED))
    921              CPU_SR_ALLOC();
   \   00000002   0x2400             MOVS     R4,#+0
    922          #endif
    923          
    924          
    925              (void)p_arg;                                                /* Prevent compiler warning for not using 'p_arg'       */
    926          
    927              for (;;) {
    928          #if ((OS_CFG_DBG_EN == DEF_ENABLED) || (OS_CFG_STAT_TASK_EN == DEF_ENABLED))
    929                  CPU_CRITICAL_ENTER();
   \                     ??OS_IdleTask_0: (+1)
   \   00000004   0x.... 0x....      BL       CPU_SR_Save
   \   00000008   0x0004             MOVS     R4,R0
   \   0000000A   0x.... 0x....      BL       CPU_IntDisMeasStart
    930          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    931                  OSIdleTaskCtr++;
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable17_30
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x1C40             ADDS     R0,R0,#+1
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable17_30
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    932          #endif
    933          #if (OS_CFG_STAT_TASK_EN == DEF_ENABLED)
    934                  OSStatTaskCtr++;
    935          #endif
    936                  CPU_CRITICAL_EXIT();
   \   0000001C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       CPU_SR_Restore
    937          #endif
    938          
    939          #if (OS_CFG_APP_HOOKS_EN == DEF_ENABLED)
    940                  OSIdleTaskHook();                                       /* Call user definable HOOK                             */
   \   00000026   0x.... 0x....      BL       OSIdleTaskHook
   \   0000002A   0xE7EB             B.N      ??OS_IdleTask_0
    941          #endif
    942              }
    943          }
    944          #endif
    945          
    946          /*
    947          ************************************************************************************************************************
    948          *                                               INITIALIZE THE IDLE TASK
    949          *
    950          * Description: This function initializes the idle task
    951          *
    952          * Arguments  : p_err    is a pointer to a variable that will contain an error code returned by this function.
    953          *
    954          * Returns    : none
    955          *
    956          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    957          ************************************************************************************************************************
    958          */
    959          #if (OS_CFG_TASK_IDLE_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    960          void  OS_IdleTaskInit (OS_ERR  *p_err)
    961          {
   \                     OS_IdleTaskInit: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
    962          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    963              OSIdleTaskCtr = 0u;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x.... 0x....      LDR.W    R2,??DataTable17_30
   \   0000000A   0x6011             STR      R1,[R2, #+0]
    964          #endif
    965                                                                          /* --------------- CREATE THE IDLE TASK --------------- */
    966              OSTaskCreate(&OSIdleTaskTCB,
    967                           (CPU_CHAR   *)"uC/OS-III Idle Task",
    968                            OS_IdleTask,
    969                            DEF_NULL,
    970                           (OS_PRIO)(OS_CFG_PRIO_MAX - 1u),
    971                            OSCfg_IdleTaskStkBasePtr,
    972                            OSCfg_IdleTaskStkLimit,
    973                            OSCfg_IdleTaskStkSize,
    974                            0u,
    975                            0u,
    976                            DEF_NULL,
    977                           (OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR | OS_OPT_TASK_NO_TLS),
    978                            p_err);
   \   0000000C   0x9008             STR      R0,[SP, #+32]
   \   0000000E   0x200B             MOVS     R0,#+11
   \   00000010   0x9007             STR      R0,[SP, #+28]
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x9006             STR      R0,[SP, #+24]
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x9005             STR      R0,[SP, #+20]
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x9004             STR      R0,[SP, #+16]
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable17_31
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x9003             STR      R0,[SP, #+12]
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable17_32
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x9002             STR      R0,[SP, #+8]
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable17_33
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0x9001             STR      R0,[SP, #+4]
   \   00000036   0x203F             MOVS     R0,#+63
   \   00000038   0x9000             STR      R0,[SP, #+0]
   \   0000003A   0x2300             MOVS     R3,#+0
   \   0000003C   0x.... 0x....      LDR.W    R2,??DataTable17_34
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable17_35
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable17_36
   \   00000048   0x.... 0x....      BL       OSTaskCreate
    979          }
   \   0000004C   0xB009             ADD      SP,SP,#+36
   \   0000004E   0xBD00             POP      {PC}             ;; return
    980          #endif
    981          
    982          /*
    983          ************************************************************************************************************************
    984          *                                             BLOCK A TASK PENDING ON EVENT
    985          *
    986          * Description: This function is called to place a task in the blocked state waiting for an event to occur. This function
    987          *              exists because it is common to a number of OSxxxPend() services.
    988          *
    989          * Arguments  : p_obj          is a pointer to the object to pend on.  If there are no object used to pend on then
    990          *              -----          the caller must pass a NULL pointer.
    991          *
    992          *              pending_on     Specifies what the task will be pending on:
    993          *
    994          *                                 OS_TASK_PEND_ON_FLAG
    995          *                                 OS_TASK_PEND_ON_TASK_Q     <- No object (pending for a message sent to the task)
    996          *                                 OS_TASK_PEND_ON_MUTEX
    997          *                                 OS_TASK_PEND_ON_Q
    998          *                                 OS_TASK_PEND_ON_SEM
    999          *                                 OS_TASK_PEND_ON_TASK_SEM   <- No object (pending on a signal sent to the task)
   1000          *
   1001          *              timeout        Is the amount of time the task will wait for the event to occur.
   1002          *
   1003          * Returns    : none
   1004          *
   1005          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1006          ************************************************************************************************************************
   1007          */
   1008          

   \                                 In section .text, align 2, keep-with-next
   1009          void  OS_Pend (OS_PEND_OBJ  *p_obj,
   1010                         OS_STATE      pending_on,
   1011                         OS_TICK       timeout)
   1012          {
   \                     OS_Pend: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1013              OS_PEND_LIST  *p_pend_list;
   1014          
   1015          
   1016              OSTCBCurPtr->PendOn     = pending_on;                       /* Resource not available, wait until it is             */
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable17_3
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0xF880 0x103C      STRB     R1,[R0, #+60]
   1017              OSTCBCurPtr->PendStatus = OS_STATUS_PEND_OK;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable17_3
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0xF881 0x003D      STRB     R0,[R1, #+61]
   1018          
   1019              OS_TaskBlock(OSTCBCurPtr,                                   /* Block the task and add it to the tick list if needed */
   1020                           timeout);
   \   0000001A   0x0011             MOVS     R1,R2
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable17_3
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x.... 0x....      BL       OS_TaskBlock
   1021          
   1022              if (p_obj != DEF_NULL) {                                    /* Add the current task to the pend list ...            */
   \   00000026   0x2C00             CMP      R4,#+0
   \   00000028   0xD00B             BEQ.N    ??OS_Pend_0
   1023                  p_pend_list             = &p_obj->PendList;             /* ... if there is an object to pend on                 */
   \   0000002A   0xF114 0x0008      ADDS     R0,R4,#+8
   1024                  OSTCBCurPtr->PendObjPtr =  p_obj;                       /* Save the pointer to the object pending on            */
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable17_3
   \   00000032   0x6809             LDR      R1,[R1, #+0]
   \   00000034   0x638C             STR      R4,[R1, #+56]
   1025                  OS_PendListInsertPrio(p_pend_list,                      /* Insert in the pend list in priority order            */
   1026                                        OSTCBCurPtr);
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable17_3
   \   0000003A   0x6809             LDR      R1,[R1, #+0]
   \   0000003C   0x.... 0x....      BL       OS_PendListInsertPrio
   \   00000040   0xE004             B.N      ??OS_Pend_1
   1027          
   1028              } else {
   1029                  OSTCBCurPtr->PendObjPtr =  DEF_NULL;                    /* If no object being pended on, clear the pend object  */
   \                     ??OS_Pend_0: (+1)
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable17_3
   \   00000048   0x6809             LDR      R1,[R1, #+0]
   \   0000004A   0x6388             STR      R0,[R1, #+56]
   1030              }
   1031          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   1032              OS_PendDbgNameAdd(p_obj,
   1033                                OSTCBCurPtr);
   \                     ??OS_Pend_1: (+1)
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable17_3
   \   00000050   0x6801             LDR      R1,[R0, #+0]
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0x.... 0x....      BL       OS_PendDbgNameAdd
   1034          #endif
   1035          }
   \   00000058   0xBD10             POP      {R4,PC}          ;; return
   1036          
   1037          
   1038          /*
   1039          ************************************************************************************************************************
   1040          *                                                    CANCEL PENDING
   1041          *
   1042          * Description: This function is called by the OSxxxPendAbort() and OSxxxDel() functions to cancel pending on an event.
   1043          *
   1044          * Arguments  : p_tcb          Is a pointer to the OS_TCB of the task that we'll abort the pend for
   1045          *              -----
   1046          *
   1047          *              ts             Is a timestamp as to when the pend was cancelled
   1048          *
   1049          *              reason         Indicates how the task was readied:
   1050          *
   1051          *                                 OS_STATUS_PEND_DEL       Object pended on was deleted.
   1052          *                                 OS_STATUS_PEND_ABORT     Pend was aborted.
   1053          *
   1054          * Returns    : none
   1055          *
   1056          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1057          ************************************************************************************************************************
   1058          */
   1059          

   \                                 In section .text, align 2, keep-with-next
   1060          void  OS_PendAbort (OS_TCB     *p_tcb,
   1061                              CPU_TS      ts,
   1062                              OS_STATUS   reason)
   1063          {
   \                     OS_PendAbort: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0015             MOVS     R5,R2
   1064          #if (OS_CFG_TS_EN == DEF_DISABLED)
   1065              (void)ts;                                                   /* Prevent compiler warning for not using 'ts'          */
   1066          #endif
   1067          
   1068              switch (p_tcb->TaskState) {
   \   00000006   0xF894 0x003E      LDRB     R0,[R4, #+62]
   \   0000000A   0x1E80             SUBS     R0,R0,#+2
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD903             BLS.N    ??OS_PendAbort_0
   \   00000010   0x1F00             SUBS     R0,R0,#+4
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD91C             BLS.N    ??OS_PendAbort_1
   \   00000016   0xE034             B.N      ??OS_PendAbort_2
   1069                  case OS_TASK_STATE_PEND:
   1070                  case OS_TASK_STATE_PEND_TIMEOUT:
   1071          #if (OS_MSG_EN == DEF_ENABLED)
   1072                       p_tcb->MsgPtr     = DEF_NULL;
   \                     ??OS_PendAbort_0: (+1)
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x6620             STR      R0,[R4, #+96]
   1073                       p_tcb->MsgSize    = 0u;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF8A4 0x0064      STRH     R0,[R4, #+100]
   1074          #endif
   1075          #if (OS_CFG_TS_EN == DEF_ENABLED)
   1076                       p_tcb->TS         = ts;
   \   00000022   0x6521             STR      R1,[R4, #+80]
   1077          #endif
   1078                       OS_PendListRemove(p_tcb);                          /* Remove task from the pend list                       */
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0x.... 0x....      BL       OS_PendListRemove
   1079          
   1080          #if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
   1081                       if (p_tcb->TaskState == OS_TASK_STATE_PEND_TIMEOUT) {
   \   0000002A   0xF894 0x003E      LDRB     R0,[R4, #+62]
   \   0000002E   0x2803             CMP      R0,#+3
   \   00000030   0xD102             BNE.N    ??OS_PendAbort_3
   1082                           OS_TickListRemove(p_tcb);                      /* Cancel the timeout                                   */
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       OS_TickListRemove
   1083                       }
   1084          #endif
   1085                       OS_RdyListInsert(p_tcb);                           /* Insert the task in the ready list                    */
   \                     ??OS_PendAbort_3: (+1)
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0x.... 0x....      BL       OS_RdyListInsert
   1086                       p_tcb->TaskState  = OS_TASK_STATE_RDY;             /* Task will be ready                                   */
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xF884 0x003E      STRB     R0,[R4, #+62]
   1087                       p_tcb->PendStatus = reason;                        /* Indicate how the task became ready                   */
   \   00000044   0xF884 0x503D      STRB     R5,[R4, #+61]
   1088                       p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;       /* Indicate no longer pending                           */
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xF884 0x003C      STRB     R0,[R4, #+60]
   1089                       break;
   \   0000004E   0xE018             B.N      ??OS_PendAbort_4
   1090          
   1091                  case OS_TASK_STATE_PEND_SUSPENDED:
   1092                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
   1093          #if (OS_MSG_EN == DEF_ENABLED)
   1094                       p_tcb->MsgPtr     = DEF_NULL;
   \                     ??OS_PendAbort_1: (+1)
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x6620             STR      R0,[R4, #+96]
   1095                       p_tcb->MsgSize    = 0u;
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xF8A4 0x0064      STRH     R0,[R4, #+100]
   1096          #endif
   1097          #if (OS_CFG_TS_EN == DEF_ENABLED)
   1098                       p_tcb->TS         = ts;
   \   0000005A   0x6521             STR      R1,[R4, #+80]
   1099          #endif
   1100                       OS_PendListRemove(p_tcb);                          /* Remove task from the pend list                       */
   \   0000005C   0x0020             MOVS     R0,R4
   \   0000005E   0x.... 0x....      BL       OS_PendListRemove
   1101          
   1102          #if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
   1103                       if (p_tcb->TaskState == OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED) {
   \   00000062   0xF894 0x003E      LDRB     R0,[R4, #+62]
   \   00000066   0x2807             CMP      R0,#+7
   \   00000068   0xD102             BNE.N    ??OS_PendAbort_5
   1104                           OS_TickListRemove(p_tcb);                      /* Cancel the timeout                                   */
   \   0000006A   0x0020             MOVS     R0,R4
   \   0000006C   0x.... 0x....      BL       OS_TickListRemove
   1105                       }
   1106          #endif
   1107                       p_tcb->TaskState  = OS_TASK_STATE_SUSPENDED;       /* Task needs to remain suspended                       */
   \                     ??OS_PendAbort_5: (+1)
   \   00000070   0x2004             MOVS     R0,#+4
   \   00000072   0xF884 0x003E      STRB     R0,[R4, #+62]
   1108                       p_tcb->PendStatus = reason;                        /* Indicate how the task became ready                   */
   \   00000076   0xF884 0x503D      STRB     R5,[R4, #+61]
   1109                       p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;       /* Indicate no longer pending                           */
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0xF884 0x003C      STRB     R0,[R4, #+60]
   1110                       break;
   \   00000080   0xE7FF             B.N      ??OS_PendAbort_4
   1111          
   1112                  case OS_TASK_STATE_RDY:                                 /* Cannot cancel a pend when a task is in these states. */
   1113                  case OS_TASK_STATE_DLY:
   1114                  case OS_TASK_STATE_SUSPENDED:
   1115                  case OS_TASK_STATE_DLY_SUSPENDED:
   1116                  default:
   1117                       break;
   1118              }
   1119          }
   \                     ??OS_PendAbort_2: (+1)
   \                     ??OS_PendAbort_4: (+1)
   \   00000082   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1120          
   1121          
   1122          /*
   1123          ************************************************************************************************************************
   1124          *                                     ADD/REMOVE DEBUG NAMES TO PENDED OBJECT AND OS_TCB
   1125          *
   1126          * Description: These functions are used to add pointers to ASCII 'names' of objects so they can easily be displayed
   1127          *              using a kernel aware tool.
   1128          *
   1129          * Arguments  : p_obj              is a pointer to the object being pended on
   1130          *
   1131          *              p_tcb              is a pointer to the OS_TCB of the task pending on the object
   1132          *
   1133          * Returns    : none
   1134          *
   1135          * Note(s)    : 1) These functions are INTERNAL to uC/OS-III and your application must not call it.
   1136          ************************************************************************************************************************
   1137          */
   1138          
   1139          #if (OS_CFG_DBG_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   1140          void  OS_PendDbgNameAdd (OS_PEND_OBJ  *p_obj,
   1141                                   OS_TCB       *p_tcb)
   1142          {
   1143              OS_PEND_LIST  *p_pend_list;
   1144              OS_TCB        *p_tcb1;
   1145          
   1146          
   1147              if (p_obj != DEF_NULL) {
   \                     OS_PendDbgNameAdd: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD008             BEQ.N    ??OS_PendDbgNameAdd_0
   1148                  p_tcb->DbgNamePtr =  p_obj->NamePtr;                    /* Task pending on this object ... save name in TCB     */
   \   00000004   0x6842             LDR      R2,[R0, #+4]
   \   00000006   0xF8C1 0x209C      STR      R2,[R1, #+156]
   1149                  p_pend_list       = &p_obj->PendList;                   /* Find name of HP task pending on this object ...      */
   \   0000000A   0xF110 0x0108      ADDS     R1,R0,#+8
   1150                  p_tcb1            =  p_pend_list->HeadPtr;
   \   0000000E   0x6809             LDR      R1,[R1, #+0]
   1151                  p_obj->DbgNamePtr =  p_tcb1->NamePtr;                   /* ... Save in object                                   */
   \   00000010   0x6889             LDR      R1,[R1, #+8]
   \   00000012   0x61C1             STR      R1,[R0, #+28]
   \   00000014   0xE013             B.N      ??OS_PendDbgNameAdd_1
   1152              } else {
   1153                  switch (p_tcb->PendOn) {
   \                     ??OS_PendDbgNameAdd_0: (+1)
   \   00000016   0xF891 0x003C      LDRB     R0,[R1, #+60]
   \   0000001A   0x2802             CMP      R0,#+2
   \   0000001C   0xD002             BEQ.N    ??OS_PendDbgNameAdd_2
   \   0000001E   0x2807             CMP      R0,#+7
   \   00000020   0xD005             BEQ.N    ??OS_PendDbgNameAdd_3
   \   00000022   0xE009             B.N      ??OS_PendDbgNameAdd_4
   1154                      case OS_TASK_PEND_ON_TASK_Q:
   1155                           p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)"Task Q");
   \                     ??OS_PendDbgNameAdd_2: (+1)
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable17_37
   \   00000028   0xF8C1 0x009C      STR      R0,[R1, #+156]
   1156                           break;
   \   0000002C   0xE007             B.N      ??OS_PendDbgNameAdd_1
   1157          
   1158                      case OS_TASK_PEND_ON_TASK_SEM:
   1159                           p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)"Task Sem");
   \                     ??OS_PendDbgNameAdd_3: (+1)
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable17_38
   \   00000032   0xF8C1 0x009C      STR      R0,[R1, #+156]
   1160                           break;
   \   00000036   0xE002             B.N      ??OS_PendDbgNameAdd_1
   1161          
   1162                      default:
   1163                           p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)" ");
   \                     ??OS_PendDbgNameAdd_4: (+1)
   \   00000038   0x....             ADR.N    R0,??DataTable16  ;; " "
   \   0000003A   0xF8C1 0x009C      STR      R0,[R1, #+156]
   1164                           break;
   1165                  }
   1166              }
   1167          }
   \                     ??OS_PendDbgNameAdd_1: (+1)
   \   0000003E   0x4770             BX       LR               ;; return
   1168          
   1169          

   \                                 In section .text, align 2, keep-with-next
   1170          void  OS_PendDbgNameRemove (OS_PEND_OBJ  *p_obj,
   1171                                      OS_TCB       *p_tcb)
   1172          {
   1173              OS_PEND_LIST  *p_pend_list;
   1174              OS_TCB        *p_tcb1;
   1175          
   1176          
   1177              p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)" ");              /* Remove name of object pended on for readied task     */
   \                     OS_PendDbgNameRemove: (+1)
   \   00000000   0x....             ADR.N    R2,??DataTable16  ;; " "
   \   00000002   0xF8C1 0x209C      STR      R2,[R1, #+156]
   1178          
   1179              if (p_obj != DEF_NULL) {
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD009             BEQ.N    ??OS_PendDbgNameRemove_0
   1180                  p_pend_list = &p_obj->PendList;
   \   0000000A   0xF110 0x0108      ADDS     R1,R0,#+8
   1181                  p_tcb1      =  p_pend_list->HeadPtr;
   \   0000000E   0x6809             LDR      R1,[R1, #+0]
   1182                  if (p_tcb1 != DEF_NULL) {                               /* Find name of HP task pending on this object ...      */
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD002             BEQ.N    ??OS_PendDbgNameRemove_1
   1183                      p_obj->DbgNamePtr = p_tcb1->NamePtr;                /* ... Save in object                                   */
   \   00000014   0x6889             LDR      R1,[R1, #+8]
   \   00000016   0x61C1             STR      R1,[R0, #+28]
   \   00000018   0xE001             B.N      ??OS_PendDbgNameRemove_0
   1184                  } else {
   1185                      p_obj->DbgNamePtr = (CPU_CHAR *)((void *)" ");      /* Or no other task is pending on object                */
   \                     ??OS_PendDbgNameRemove_1: (+1)
   \   0000001A   0x....             ADR.N    R1,??DataTable16  ;; " "
   \   0000001C   0x61C1             STR      R1,[R0, #+28]
   1186                  }
   1187              }
   1188          }
   \                     ??OS_PendDbgNameRemove_0: (+1)
   \   0000001E   0x4770             BX       LR               ;; return
   1189          #endif
   1190          
   1191          
   1192          /*
   1193          ************************************************************************************************************************
   1194          *                                 CHANGE THE PRIORITY OF A TASK WAITING IN A PEND LIST
   1195          *
   1196          * Description: This function is called to change the position of a task waiting in a pend list. The strategy used is to
   1197          *              remove the task from the pend list and add it again using its changed priority.
   1198          *
   1199          * Arguments  : p_tcb       is a pointer to the TCB of the task to move
   1200          *              -----
   1201          *
   1202          * Returns    : none
   1203          *
   1204          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1205          *
   1206          *              2) It's assumed that the TCB contains the NEW priority in its .Prio field.
   1207          ************************************************************************************************************************
   1208          */
   1209          

   \                                 In section .text, align 2, keep-with-next
   1210          void  OS_PendListChangePrio (OS_TCB  *p_tcb)
   1211          {
   \                     OS_PendListChangePrio: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1212              OS_PEND_LIST  *p_pend_list;
   1213              OS_PEND_OBJ   *p_obj;
   1214          
   1215              p_obj       =  p_tcb->PendObjPtr;                           /* Get pointer to pend list                             */
   \   00000004   0x6BA6             LDR      R6,[R4, #+56]
   1216              p_pend_list = &p_obj->PendList;
   \   00000006   0xF116 0x0508      ADDS     R5,R6,#+8
   1217          
   1218              if (p_pend_list->HeadPtr->PendNextPtr != DEF_NULL) {        /* Only move if multiple entries in the list            */
   \   0000000A   0x6828             LDR      R0,[R5, #+0]
   \   0000000C   0x6B00             LDR      R0,[R0, #+48]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD007             BEQ.N    ??OS_PendListChangePrio_0
   1219                      OS_PendListRemove(p_tcb);                           /* Remove entry from current position                   */
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       OS_PendListRemove
   1220                      p_tcb->PendObjPtr = p_obj;
   \   00000018   0x63A6             STR      R6,[R4, #+56]
   1221                      OS_PendListInsertPrio(p_pend_list,                  /* INSERT it back in the list                           */
   1222                                            p_tcb);
   \   0000001A   0x0021             MOVS     R1,R4
   \   0000001C   0x0028             MOVS     R0,R5
   \   0000001E   0x.... 0x....      BL       OS_PendListInsertPrio
   1223              }
   1224          }
   \                     ??OS_PendListChangePrio_0: (+1)
   \   00000022   0xBD70             POP      {R4-R6,PC}       ;; return
   1225          
   1226          
   1227          /*
   1228          ************************************************************************************************************************
   1229          *                                                INITIALIZE A WAIT LIST
   1230          *
   1231          * Description: This function is called to initialize the fields of an OS_PEND_LIST.
   1232          *
   1233          * Arguments  : p_pend_list   is a pointer to an OS_PEND_LIST
   1234          *              -----------
   1235          *
   1236          * Returns    : none
   1237          *
   1238          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application must not call it.
   1239          ************************************************************************************************************************
   1240          */
   1241          

   \                                 In section .text, align 2, keep-with-next
   1242          void  OS_PendListInit (OS_PEND_LIST  *p_pend_list)
   1243          {
   1244              p_pend_list->HeadPtr    = DEF_NULL;
   \                     OS_PendListInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
   1245              p_pend_list->TailPtr    = DEF_NULL;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6041             STR      R1,[R0, #+4]
   1246          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   1247              p_pend_list->NbrEntries = 0u;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x8101             STRH     R1,[R0, #+8]
   1248          #endif
   1249          }
   \   0000000C   0x4770             BX       LR               ;; return
   1250          
   1251          
   1252          /*
   1253          ************************************************************************************************************************
   1254          *                                  INSERT A TASK BASED ON IT'S PRIORITY IN A PEND LIST
   1255          *
   1256          * Description: This function is called to place an OS_TCB entry in a linked list based on its priority.  The
   1257          *              highest priority being placed at the head of the list. The TCB is assumed to contain the priority
   1258          *              of the task in its .Prio field.
   1259          *
   1260          *              CASE 0: Insert in an empty list.
   1261          *
   1262          *                     OS_PEND_LIST
   1263          *                     +---------------+
   1264          *                     | TailPtr       |-> 0
   1265          *                     +---------------+
   1266          *                     | HeadPtr       |-> 0
   1267          *                     +---------------+
   1268          *                     | NbrEntries=0  |
   1269          *                     +---------------+
   1270          *
   1271          *
   1272          *
   1273          *              CASE 1: Insert BEFORE or AFTER an OS_TCB
   1274          *
   1275          *                     OS_PEND_LIST
   1276          *                     +--------------+         OS_TCB
   1277          *                     | TailPtr      |--+---> +--------------+
   1278          *                     +--------------+  |     | PendNextPtr  |->0
   1279          *                     | HeadPtr      |--/     +--------------+
   1280          *                     +--------------+     0<-| PendPrevPtr  |
   1281          *                     | NbrEntries=1 |        +--------------+
   1282          *                     +--------------+        |              |
   1283          *                                             +--------------+
   1284          *                                             |              |
   1285          *                                             +--------------+
   1286          *
   1287          *
   1288          *                     OS_PEND_LIST
   1289          *                     +--------------+
   1290          *                     | TailPtr      |---------------------------------------------------+
   1291          *                     +--------------+         OS_TCB                 OS_TCB             |    OS_TCB
   1292          *                     | HeadPtr      |------> +--------------+       +--------------+    +-> +--------------+
   1293          *                     +--------------+        | PendNextPtr  |<------| PendNextPtr  | ...... | PendNextPtr  |->0
   1294          *                     | NbrEntries=N |        +--------------+       +--------------+        +--------------+
   1295          *                     +--------------+     0<-| PendPrevPtr  |<------| PendPrevPtr  | ...... | PendPrevPtr  |
   1296          *                                             +--------------+       +--------------+        +--------------+
   1297          *                                             |              |       |              |        |              |
   1298          *                                             +--------------+       +--------------+        +--------------+
   1299          *                                             |              |       |              |        |              |
   1300          *                                             +--------------+       +--------------+        +--------------+
   1301          *
   1302          *
   1303          * Arguments  : p_pend_list    is a pointer to the OS_PEND_LIST where the OS_TCB entry will be inserted
   1304          *              -----------
   1305          *
   1306          *              p_tcb          is the OS_TCB to insert in the list
   1307          *              -----
   1308          *
   1309          * Returns    : none
   1310          *
   1311          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1312          ************************************************************************************************************************
   1313          */
   1314          

   \                                 In section .text, align 2, keep-with-next
   1315          void  OS_PendListInsertPrio (OS_PEND_LIST  *p_pend_list,
   1316                                       OS_TCB        *p_tcb)
   1317          {
   \                     OS_PendListInsertPrio: (+1)
   \   00000000   0xB410             PUSH     {R4}
   1318              OS_PRIO   prio;
   1319              OS_TCB   *p_tcb_next;
   1320          
   1321          
   1322              prio  = p_tcb->Prio;                                        /* Obtain the priority of the task to insert            */
   \   00000002   0xF891 0x203F      LDRB     R2,[R1, #+63]
   1323          
   1324              if (p_pend_list->HeadPtr == DEF_NULL) {                     /* CASE 0: Insert when there are no entries             */
   \   00000006   0x6803             LDR      R3,[R0, #+0]
   \   00000008   0x2B00             CMP      R3,#+0
   \   0000000A   0xD108             BNE.N    ??OS_PendListInsertPrio_0
   1325          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   1326                  p_pend_list->NbrEntries = 1u;                           /* This is the first entry                              */
   \   0000000C   0x2201             MOVS     R2,#+1
   \   0000000E   0x8102             STRH     R2,[R0, #+8]
   1327          #endif
   1328                  p_tcb->PendNextPtr   = DEF_NULL;                        /* No other OS_TCBs in the list                         */
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x630A             STR      R2,[R1, #+48]
   1329                  p_tcb->PendPrevPtr   = DEF_NULL;
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0x634A             STR      R2,[R1, #+52]
   1330                  p_pend_list->HeadPtr = p_tcb;
   \   00000018   0x6001             STR      R1,[R0, #+0]
   1331                  p_pend_list->TailPtr = p_tcb;
   \   0000001A   0x6041             STR      R1,[R0, #+4]
   \   0000001C   0xE025             B.N      ??OS_PendListInsertPrio_1
   1332              } else {
   1333          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   1334                  p_pend_list->NbrEntries++;                              /* CASE 1: One more OS_TCBs in the list                 */
   \                     ??OS_PendListInsertPrio_0: (+1)
   \   0000001E   0x8903             LDRH     R3,[R0, #+8]
   \   00000020   0x1C5B             ADDS     R3,R3,#+1
   \   00000022   0x8103             STRH     R3,[R0, #+8]
   1335          #endif
   1336                  p_tcb_next = p_pend_list->HeadPtr;
   \   00000024   0x6803             LDR      R3,[R0, #+0]
   \   00000026   0xE000             B.N      ??OS_PendListInsertPrio_2
   1337                  while (p_tcb_next != DEF_NULL) {                        /* Find the position where to insert                    */
   1338                      if (prio < p_tcb_next->Prio) {
   1339                          break;                                          /* Found! ... insert BEFORE current                     */
   1340                      } else {
   1341                          p_tcb_next = p_tcb_next->PendNextPtr;           /* Not Found, follow the list                           */
   \                     ??OS_PendListInsertPrio_3: (+1)
   \   00000028   0x6B1B             LDR      R3,[R3, #+48]
   1342                      }
   \                     ??OS_PendListInsertPrio_2: (+1)
   \   0000002A   0x2B00             CMP      R3,#+0
   \   0000002C   0xD004             BEQ.N    ??OS_PendListInsertPrio_4
   \   0000002E   0xF893 0x403F      LDRB     R4,[R3, #+63]
   \   00000032   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000034   0x42A2             CMP      R2,R4
   \   00000036   0xD2F7             BCS.N    ??OS_PendListInsertPrio_3
   1343                  }
   1344                  if (p_tcb_next == DEF_NULL) {                           /* TCB to insert is lowest in priority                  */
   \                     ??OS_PendListInsertPrio_4: (+1)
   \   00000038   0x2B00             CMP      R3,#+0
   \   0000003A   0xD107             BNE.N    ??OS_PendListInsertPrio_5
   1345                      p_tcb->PendNextPtr              = DEF_NULL;         /* ... insert at the tail.                              */
   \   0000003C   0x2200             MOVS     R2,#+0
   \   0000003E   0x630A             STR      R2,[R1, #+48]
   1346                      p_tcb->PendPrevPtr              = p_pend_list->TailPtr;
   \   00000040   0x6842             LDR      R2,[R0, #+4]
   \   00000042   0x634A             STR      R2,[R1, #+52]
   1347                      p_tcb->PendPrevPtr->PendNextPtr = p_tcb;
   \   00000044   0x6B4A             LDR      R2,[R1, #+52]
   \   00000046   0x6311             STR      R1,[R2, #+48]
   1348                      p_pend_list->TailPtr            = p_tcb;
   \   00000048   0x6041             STR      R1,[R0, #+4]
   \   0000004A   0xE00E             B.N      ??OS_PendListInsertPrio_1
   1349                  } else {
   1350                      if (p_tcb_next->PendPrevPtr == DEF_NULL) {          /* Is new TCB highest priority?                         */
   \                     ??OS_PendListInsertPrio_5: (+1)
   \   0000004C   0x6B5A             LDR      R2,[R3, #+52]
   \   0000004E   0x2A00             CMP      R2,#+0
   \   00000050   0xD105             BNE.N    ??OS_PendListInsertPrio_6
   1351                          p_tcb->PendNextPtr      = p_tcb_next;           /* Yes, insert as new Head of list                      */
   \   00000052   0x630B             STR      R3,[R1, #+48]
   1352                          p_tcb->PendPrevPtr      = DEF_NULL;
   \   00000054   0x2200             MOVS     R2,#+0
   \   00000056   0x634A             STR      R2,[R1, #+52]
   1353                          p_tcb_next->PendPrevPtr = p_tcb;
   \   00000058   0x6359             STR      R1,[R3, #+52]
   1354                          p_pend_list->HeadPtr    = p_tcb;
   \   0000005A   0x6001             STR      R1,[R0, #+0]
   \   0000005C   0xE005             B.N      ??OS_PendListInsertPrio_1
   1355                      } else {                                            /* No,  insert in between two entries                   */
   1356                          p_tcb->PendNextPtr              = p_tcb_next;
   \                     ??OS_PendListInsertPrio_6: (+1)
   \   0000005E   0x630B             STR      R3,[R1, #+48]
   1357                          p_tcb->PendPrevPtr              = p_tcb_next->PendPrevPtr;
   \   00000060   0x6B58             LDR      R0,[R3, #+52]
   \   00000062   0x6348             STR      R0,[R1, #+52]
   1358                          p_tcb->PendPrevPtr->PendNextPtr = p_tcb;
   \   00000064   0x6B48             LDR      R0,[R1, #+52]
   \   00000066   0x6301             STR      R1,[R0, #+48]
   1359                          p_tcb_next->PendPrevPtr         = p_tcb;
   \   00000068   0x6359             STR      R1,[R3, #+52]
   1360                      }
   1361                  }
   1362              }
   1363          }
   \                     ??OS_PendListInsertPrio_1: (+1)
   \   0000006A   0xBC10             POP      {R4}
   \   0000006C   0x4770             BX       LR               ;; return
   1364          
   1365          
   1366          /*
   1367          ************************************************************************************************************************
   1368          *                           REMOVE TASK FROM A PEND LIST KNOWING ONLY WHICH TCB TO REMOVE
   1369          *
   1370          * Description: This function is called to remove a task from a pend list knowing the TCB of the task to remove.
   1371          *
   1372          *              CASE 0: OS_PEND_LIST list is empty, nothing to do.
   1373          *
   1374          *              CASE 1: Only 1 OS_TCB in the list.
   1375          *
   1376          *                     OS_PEND_LIST
   1377          *                     +--------------+         OS_TCB
   1378          *                     | TailPtr      |--+---> +--------------+
   1379          *                     +--------------+  |     | PendNextPtr  |->0
   1380          *                     | HeadPtr      |--/     +--------------+
   1381          *                     +--------------+     0<-| PendPrevPtr  |
   1382          *                     | NbrEntries=1 |        +--------------+
   1383          *                     +--------------+        |              |
   1384          *                                             +--------------+
   1385          *                                             |              |
   1386          *                                             +--------------+
   1387          *
   1388          *              CASE N: Two or more OS_TCBs in the list.
   1389          *
   1390          *                     OS_PEND_LIST
   1391          *                     +--------------+
   1392          *                     | TailPtr      |---------------------------------------------------+
   1393          *                     +--------------+         OS_TCB                 OS_TCB             |    OS_TCB
   1394          *                     | HeadPtr      |------> +--------------+       +--------------+    +-> +--------------+
   1395          *                     +--------------+        | PendNextPtr  |<------| PendNextPtr  | ...... | PendNextPtr  |->0
   1396          *                     | NbrEntries=N |        +--------------+       +--------------+        +--------------+
   1397          *                     +--------------+     0<-| PendPrevPtr  |<------| PendPrevPtr  | ...... | PendPrevPtr  |
   1398          *                                             +--------------+       +--------------+        +--------------+
   1399          *                                             |              |       |              |        |              |
   1400          *                                             +--------------+       +--------------+        +--------------+
   1401          *                                             |              |       |              |        |              |
   1402          *                                             +--------------+       +--------------+        +--------------+
   1403          *
   1404          *
   1405          * Arguments  : p_tcb          is a pointer to the TCB of the task to remove from the pend list
   1406          *              -----
   1407          *
   1408          * Returns    : none
   1409          *
   1410          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1411          ************************************************************************************************************************
   1412          */
   1413          

   \                                 In section .text, align 2, keep-with-next
   1414          void  OS_PendListRemove (OS_TCB  *p_tcb)
   1415          {
   1416              OS_PEND_LIST  *p_pend_list;
   1417              OS_TCB        *p_next;
   1418              OS_TCB        *p_prev;
   1419          
   1420          
   1421              if (p_tcb->PendObjPtr != DEF_NULL) {                        /* Only remove if object has a pend list.               */
   \                     OS_PendListRemove: (+1)
   \   00000000   0x6B81             LDR      R1,[R0, #+56]
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD027             BEQ.N    ??OS_PendListRemove_0
   1422                  p_pend_list = &p_tcb->PendObjPtr->PendList;             /* Get pointer to pend list                             */
   \   00000006   0x6B81             LDR      R1,[R0, #+56]
   \   00000008   0x3108             ADDS     R1,R1,#+8
   1423          
   1424                                                                          /* Remove TCB from the pend list.                       */
   1425                  if (p_pend_list->HeadPtr->PendNextPtr == DEF_NULL) {
   \   0000000A   0x680A             LDR      R2,[R1, #+0]
   \   0000000C   0x6B12             LDR      R2,[R2, #+48]
   \   0000000E   0x2A00             CMP      R2,#+0
   \   00000010   0xD104             BNE.N    ??OS_PendListRemove_1
   1426                      p_pend_list->HeadPtr = DEF_NULL;                    /* Only one entry in the pend list                      */
   \   00000012   0x2200             MOVS     R2,#+0
   \   00000014   0x600A             STR      R2,[R1, #+0]
   1427                      p_pend_list->TailPtr = DEF_NULL;
   \   00000016   0x2200             MOVS     R2,#+0
   \   00000018   0x604A             STR      R2,[R1, #+4]
   \   0000001A   0xE013             B.N      ??OS_PendListRemove_2
   1428                  } else if (p_tcb->PendPrevPtr == DEF_NULL) {            /* See if entry is at the head of the list              */
   \                     ??OS_PendListRemove_1: (+1)
   \   0000001C   0x6B42             LDR      R2,[R0, #+52]
   \   0000001E   0x2A00             CMP      R2,#+0
   \   00000020   0xD104             BNE.N    ??OS_PendListRemove_3
   1429                      p_next               = p_tcb->PendNextPtr;          /* Yes                                                  */
   \   00000022   0x6B02             LDR      R2,[R0, #+48]
   1430                      p_next->PendPrevPtr  = DEF_NULL;
   \   00000024   0x2300             MOVS     R3,#+0
   \   00000026   0x6353             STR      R3,[R2, #+52]
   1431                      p_pend_list->HeadPtr = p_next;
   \   00000028   0x600A             STR      R2,[R1, #+0]
   \   0000002A   0xE00B             B.N      ??OS_PendListRemove_2
   1432          
   1433                  } else if (p_tcb->PendNextPtr == DEF_NULL) {            /* See if entry is at the tail of the list              */
   \                     ??OS_PendListRemove_3: (+1)
   \   0000002C   0x6B02             LDR      R2,[R0, #+48]
   \   0000002E   0x2A00             CMP      R2,#+0
   \   00000030   0xD104             BNE.N    ??OS_PendListRemove_4
   1434                      p_prev               = p_tcb->PendPrevPtr;          /* Yes                                                  */
   \   00000032   0x6B43             LDR      R3,[R0, #+52]
   1435                      p_prev->PendNextPtr  = DEF_NULL;
   \   00000034   0x2200             MOVS     R2,#+0
   \   00000036   0x631A             STR      R2,[R3, #+48]
   1436                      p_pend_list->TailPtr = p_prev;
   \   00000038   0x604B             STR      R3,[R1, #+4]
   \   0000003A   0xE003             B.N      ??OS_PendListRemove_2
   1437          
   1438                  } else {
   1439                      p_prev               = p_tcb->PendPrevPtr;          /* Remove from inside the list                          */
   \                     ??OS_PendListRemove_4: (+1)
   \   0000003C   0x6B43             LDR      R3,[R0, #+52]
   1440                      p_next               = p_tcb->PendNextPtr;
   \   0000003E   0x6B02             LDR      R2,[R0, #+48]
   1441                      p_prev->PendNextPtr  = p_next;
   \   00000040   0x631A             STR      R2,[R3, #+48]
   1442                      p_next->PendPrevPtr  = p_prev;
   \   00000042   0x6353             STR      R3,[R2, #+52]
   1443                  }
   1444          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   1445                  p_pend_list->NbrEntries--;                              /* One less entry in the list                           */
   \                     ??OS_PendListRemove_2: (+1)
   \   00000044   0x890A             LDRH     R2,[R1, #+8]
   \   00000046   0x1E52             SUBS     R2,R2,#+1
   \   00000048   0x810A             STRH     R2,[R1, #+8]
   1446          #endif
   1447                  p_tcb->PendNextPtr = DEF_NULL;
   \   0000004A   0x2100             MOVS     R1,#+0
   \   0000004C   0x6301             STR      R1,[R0, #+48]
   1448                  p_tcb->PendPrevPtr = DEF_NULL;
   \   0000004E   0x2100             MOVS     R1,#+0
   \   00000050   0x6341             STR      R1,[R0, #+52]
   1449                  p_tcb->PendObjPtr  = DEF_NULL;
   \   00000052   0x2100             MOVS     R1,#+0
   \   00000054   0x6381             STR      R1,[R0, #+56]
   1450              }
   1451          }
   \                     ??OS_PendListRemove_0: (+1)
   \   00000056   0x4770             BX       LR               ;; return
   1452          
   1453          
   1454          /*
   1455          ************************************************************************************************************************
   1456          *                                                   POST TO A TASK
   1457          *
   1458          * Description: This function is called to post to a task.  This function exist because it is common to a number of
   1459          *              OSxxxPost() services.
   1460          *
   1461          * Arguments  : p_obj          Is a pointer to the object being posted to or NULL pointer if there is no object
   1462          *              -----
   1463          *
   1464          *              p_tcb          Is a pointer to the OS_TCB that will receive the 'post'
   1465          *              -----
   1466          *
   1467          *              p_void         If we are posting a message to a task, this is the message that the task will receive
   1468          *
   1469          *              msg_size       If we are posting a message to a task, this is the size of the message
   1470          *
   1471          *              ts             The timestamp as to when the post occurred
   1472          *
   1473          * Returns    : none
   1474          *
   1475          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   1476          ************************************************************************************************************************
   1477          */
   1478          

   \                                 In section .text, align 2, keep-with-next
   1479          void  OS_Post (OS_PEND_OBJ  *p_obj,
   1480                         OS_TCB       *p_tcb,
   1481                         void         *p_void,
   1482                         OS_MSG_SIZE   msg_size,
   1483                         CPU_TS        ts)
   1484          {
   \                     OS_Post: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
   \   00000006   0x9804             LDR      R0,[SP, #+16]
   1485          #if (OS_CFG_TS_EN == DEF_DISABLED)
   1486              (void)ts;                                                   /* Prevent compiler warning for not using 'ts'          */
   1487          #endif
   1488          
   1489              switch (p_tcb->TaskState) {
   \   00000008   0xF894 0x103E      LDRB     R1,[R4, #+62]
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD00B             BEQ.N    ??OS_Post_0
   \   00000010   0x2902             CMP      R1,#+2
   \   00000012   0xD00A             BEQ.N    ??OS_Post_1
   \   00000014   0xD308             BCC.N    ??OS_Post_0
   \   00000016   0x2904             CMP      R1,#+4
   \   00000018   0xD006             BEQ.N    ??OS_Post_0
   \   0000001A   0xD306             BCC.N    ??OS_Post_1
   \   0000001C   0x2906             CMP      R1,#+6
   \   0000001E   0xD025             BEQ.N    ??OS_Post_2
   \   00000020   0xD302             BCC.N    ??OS_Post_0
   \   00000022   0x2907             CMP      R1,#+7
   \   00000024   0xD022             BEQ.N    ??OS_Post_2
   \   00000026   0xE03F             B.N      ??OS_Post_3
   1490                  case OS_TASK_STATE_RDY:                                 /* Cannot Post a task that is ready                     */
   1491                  case OS_TASK_STATE_DLY:                                 /* Cannot Post a task that is delayed                   */
   1492                  case OS_TASK_STATE_SUSPENDED:                           /* Cannot Post a suspended task                         */
   1493                  case OS_TASK_STATE_DLY_SUSPENDED:                       /* Cannot Post a suspended task that was also dly'd     */
   1494                       break;
   \                     ??OS_Post_0: (+1)
   \   00000028   0xE03E             B.N      ??OS_Post_4
   1495          
   1496                  case OS_TASK_STATE_PEND:
   1497                  case OS_TASK_STATE_PEND_TIMEOUT:
   1498          #if (OS_MSG_EN == DEF_ENABLED)
   1499                       p_tcb->MsgPtr  = p_void;                           /* Deposit message in OS_TCB of task waiting            */
   \                     ??OS_Post_1: (+1)
   \   0000002A   0x6622             STR      R2,[R4, #+96]
   1500                       p_tcb->MsgSize = msg_size;                         /* ... assuming posting a message                       */
   \   0000002C   0xF8A4 0x3064      STRH     R3,[R4, #+100]
   1501          #endif
   1502          #if (OS_CFG_TS_EN == DEF_ENABLED)
   1503                           p_tcb->TS      = ts;
   \   00000030   0x6520             STR      R0,[R4, #+80]
   1504          #endif
   1505                       if (p_obj != DEF_NULL) {
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0xD002             BEQ.N    ??OS_Post_5
   1506                           OS_PendListRemove(p_tcb);                      /* Remove task from pend list                           */
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x.... 0x....      BL       OS_PendListRemove
   1507                       }
   1508          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   1509                       OS_PendDbgNameRemove(p_obj,
   1510                                            p_tcb);
   \                     ??OS_Post_5: (+1)
   \   0000003C   0x0021             MOVS     R1,R4
   \   0000003E   0x0028             MOVS     R0,R5
   \   00000040   0x.... 0x....      BL       OS_PendDbgNameRemove
   1511          #endif
   1512          #if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
   1513                       if (p_tcb->TaskState == OS_TASK_STATE_PEND_TIMEOUT) {
   \   00000044   0xF894 0x003E      LDRB     R0,[R4, #+62]
   \   00000048   0x2803             CMP      R0,#+3
   \   0000004A   0xD102             BNE.N    ??OS_Post_6
   1514                           OS_TickListRemove(p_tcb);                      /* Remove from tick list                                */
   \   0000004C   0x0020             MOVS     R0,R4
   \   0000004E   0x.... 0x....      BL       OS_TickListRemove
   1515                       }
   1516          #endif
   1517                       OS_RdyListInsert(p_tcb);                           /* Insert the task in the ready list                    */
   \                     ??OS_Post_6: (+1)
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0x.... 0x....      BL       OS_RdyListInsert
   1518                       p_tcb->TaskState  = OS_TASK_STATE_RDY;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xF884 0x003E      STRB     R0,[R4, #+62]
   1519                       p_tcb->PendStatus = OS_STATUS_PEND_OK;             /* Clear pend status                                    */
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xF884 0x003D      STRB     R0,[R4, #+61]
   1520                       p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;       /* Indicate no longer pending                           */
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xF884 0x003C      STRB     R0,[R4, #+60]
   1521                       break;
   \   0000006A   0xE01D             B.N      ??OS_Post_4
   1522          
   1523                  case OS_TASK_STATE_PEND_SUSPENDED:
   1524                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
   1525          #if (OS_MSG_EN == DEF_ENABLED)
   1526                       p_tcb->MsgPtr  = p_void;                           /* Deposit message in OS_TCB of task waiting            */
   \                     ??OS_Post_2: (+1)
   \   0000006C   0x6622             STR      R2,[R4, #+96]
   1527                       p_tcb->MsgSize = msg_size;                         /* ... assuming posting a message                       */
   \   0000006E   0xF8A4 0x3064      STRH     R3,[R4, #+100]
   1528          #endif
   1529          #if (OS_CFG_TS_EN == DEF_ENABLED)
   1530                       p_tcb->TS      = ts;
   \   00000072   0x6520             STR      R0,[R4, #+80]
   1531          #endif
   1532                       if (p_obj != DEF_NULL) {
   \   00000074   0x2D00             CMP      R5,#+0
   \   00000076   0xD002             BEQ.N    ??OS_Post_7
   1533                           OS_PendListRemove(p_tcb);                      /* Remove from pend list                                */
   \   00000078   0x0020             MOVS     R0,R4
   \   0000007A   0x.... 0x....      BL       OS_PendListRemove
   1534                       }
   1535          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   1536                       OS_PendDbgNameRemove(p_obj,
   1537                                            p_tcb);
   \                     ??OS_Post_7: (+1)
   \   0000007E   0x0021             MOVS     R1,R4
   \   00000080   0x0028             MOVS     R0,R5
   \   00000082   0x.... 0x....      BL       OS_PendDbgNameRemove
   1538          #endif
   1539          #if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
   1540                       if (p_tcb->TaskState == OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED) {
   \   00000086   0xF894 0x003E      LDRB     R0,[R4, #+62]
   \   0000008A   0x2807             CMP      R0,#+7
   \   0000008C   0xD102             BNE.N    ??OS_Post_8
   1541                           OS_TickListRemove(p_tcb);                      /* Cancel any timeout                                   */
   \   0000008E   0x0020             MOVS     R0,R4
   \   00000090   0x.... 0x....      BL       OS_TickListRemove
   1542                       }
   1543          #endif
   1544                       p_tcb->TaskState  = OS_TASK_STATE_SUSPENDED;
   \                     ??OS_Post_8: (+1)
   \   00000094   0x2004             MOVS     R0,#+4
   \   00000096   0xF884 0x003E      STRB     R0,[R4, #+62]
   1545                       p_tcb->PendStatus = OS_STATUS_PEND_OK;             /* Clear pend status                                    */
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0xF884 0x003D      STRB     R0,[R4, #+61]
   1546                       p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;       /* Indicate no longer pending                           */
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0xF884 0x003C      STRB     R0,[R4, #+60]
   1547                       break;
   \   000000A6   0xE7FF             B.N      ??OS_Post_4
   1548          
   1549                  default:
   1550                       break;
   1551              }
   1552          }
   \                     ??OS_Post_3: (+1)
   \                     ??OS_Post_4: (+1)
   \   000000A8   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1553          
   1554          
   1555          /*
   1556          ************************************************************************************************************************
   1557          *                                                    INITIALIZATION
   1558          *                                               READY LIST INITIALIZATION
   1559          *
   1560          * Description: This function is called by OSInit() to initialize the ready list.  The ready list contains a list of all
   1561          *              the tasks that are ready to run.  The list is actually an array of OS_RDY_LIST.  An OS_RDY_LIST contains
   1562          *              three fields.  The number of OS_TCBs in the list (i.e. .NbrEntries), a pointer to the first OS_TCB in the
   1563          *              OS_RDY_LIST (i.e. .HeadPtr) and a pointer to the last OS_TCB in the OS_RDY_LIST (i.e. .TailPtr).
   1564          *
   1565          *              OS_TCBs are doubly linked in the OS_RDY_LIST and each OS_TCB points pack to the OS_RDY_LIST it belongs
   1566          *              to.
   1567          *
   1568          *              'OS_RDY_LIST  OSRdyTbl[OS_CFG_PRIO_MAX]'  looks like this once initialized:
   1569          *
   1570          *                               +---------------+--------------+
   1571          *                               |               | TailPtr      |-----> 0
   1572          *                          [0]  | NbrEntries=0  +--------------+
   1573          *                               |               | HeadPtr      |-----> 0
   1574          *                               +---------------+--------------+
   1575          *                               |               | TailPtr      |-----> 0
   1576          *                          [1]  | NbrEntries=0  +--------------+
   1577          *                               |               | HeadPtr      |-----> 0
   1578          *                               +---------------+--------------+
   1579          *                                       :              :
   1580          *                                       :              :
   1581          *                                       :              :
   1582          *                               +---------------+--------------+
   1583          *                               |               | TailPtr      |-----> 0
   1584          *          [OS_CFG_PRIO_MAX-1]  | NbrEntries=0  +--------------+
   1585          *                               |               | HeadPtr      |-----> 0
   1586          *                               +---------------+--------------+
   1587          *
   1588          *
   1589          * Arguments  : none
   1590          *
   1591          * Returns    : none
   1592          *
   1593          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   1594          ************************************************************************************************************************
   1595          */
   1596          

   \                                 In section .text, align 2, keep-with-next
   1597          void  OS_RdyListInit (void)
   1598          {
   1599              CPU_INT32U    i;
   1600              OS_RDY_LIST  *p_rdy_list;
   1601          
   1602          
   1603          
   1604              for (i = 0u; i < OS_CFG_PRIO_MAX; i++) {                    /* Initialize the array of OS_RDY_LIST at each priority */
   \                     OS_RdyListInit: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0xE00A             B.N      ??OS_RdyListInit_0
   1605                  p_rdy_list = &OSRdyList[i];
   \                     ??OS_RdyListInit_1: (+1)
   \   00000004   0x....             LDR.N    R1,??DataTable17_26
   \   00000006   0x220C             MOVS     R2,#+12
   \   00000008   0xFB02 0x1100      MLA      R1,R2,R0,R1
   1606          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   1607                  p_rdy_list->NbrEntries = 0u;
   \   0000000C   0x2200             MOVS     R2,#+0
   \   0000000E   0x810A             STRH     R2,[R1, #+8]
   1608          #endif
   1609                  p_rdy_list->HeadPtr    = DEF_NULL;
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x600A             STR      R2,[R1, #+0]
   1610                  p_rdy_list->TailPtr    = DEF_NULL;
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0x604A             STR      R2,[R1, #+4]
   1611              }
   \   00000018   0x1C40             ADDS     R0,R0,#+1
   \                     ??OS_RdyListInit_0: (+1)
   \   0000001A   0x2840             CMP      R0,#+64
   \   0000001C   0xD3F2             BCC.N    ??OS_RdyListInit_1
   1612          }
   \   0000001E   0x4770             BX       LR               ;; return
   1613          
   1614          
   1615          /*
   1616          ************************************************************************************************************************
   1617          *                                             INSERT TCB IN THE READY LIST
   1618          *
   1619          * Description: This function is called to insert a TCB in the ready list.
   1620          *
   1621          *              The TCB is inserted at the tail of the list if the priority of the TCB is the same as the priority of the
   1622          *              current task.  The TCB is inserted at the head of the list if not.
   1623          *
   1624          * Arguments  : p_tcb     is a pointer to the TCB to insert into the ready list
   1625          *              -----
   1626          *
   1627          * Returns    : none
   1628          *
   1629          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   1630          ************************************************************************************************************************
   1631          */
   1632          

   \                                 In section .text, align 2, keep-with-next
   1633          void  OS_RdyListInsert (OS_TCB  *p_tcb)
   1634          {
   \                     OS_RdyListInsert: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1635              OS_PrioInsert(p_tcb->Prio);
   \   00000004   0xF894 0x003F      LDRB     R0,[R4, #+63]
   \   00000008   0x.... 0x....      BL       OS_PrioInsert
   1636              if (p_tcb->Prio == OSPrioCur) {                             /* Are we readying a task at the same prio?             */
   \   0000000C   0xF894 0x003F      LDRB     R0,[R4, #+63]
   \   00000010   0x....             LDR.N    R1,??DataTable17_5
   \   00000012   0x7809             LDRB     R1,[R1, #+0]
   \   00000014   0x4288             CMP      R0,R1
   \   00000016   0xD103             BNE.N    ??OS_RdyListInsert_0
   1637                  OS_RdyListInsertTail(p_tcb);                            /* Yes, insert readied task at the end of the list      */
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       OS_RdyListInsertTail
   \   0000001E   0xE002             B.N      ??OS_RdyListInsert_1
   1638              } else {
   1639                  OS_RdyListInsertHead(p_tcb);                            /* No,  insert readied task at the beginning of the list*/
   \                     ??OS_RdyListInsert_0: (+1)
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       OS_RdyListInsertHead
   1640              }
   1641          
   1642              OS_TRACE_TASK_READY(p_tcb);
   1643          }
   \                     ??OS_RdyListInsert_1: (+1)
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
   1644          
   1645          
   1646          /*
   1647          ************************************************************************************************************************
   1648          *                                          INSERT TCB AT THE BEGINNING OF A LIST
   1649          *
   1650          * Description: This function is called to place an OS_TCB at the beginning of a linked list as follows:
   1651          *
   1652          *              CASE 0: Insert in an empty list.
   1653          *
   1654          *                     OS_RDY_LIST
   1655          *                     +--------------+
   1656          *                     | TailPtr      |-> 0
   1657          *                     +--------------+
   1658          *                     | HeadPtr      |-> 0
   1659          *                     +--------------+
   1660          *                     | NbrEntries=0 |
   1661          *                     +--------------+
   1662          *
   1663          *
   1664          *
   1665          *              CASE 1: Insert BEFORE the current head of list
   1666          *
   1667          *                     OS_RDY_LIST
   1668          *                     +--------------+          OS_TCB
   1669          *                     | TailPtr      |--+---> +------------+
   1670          *                     +--------------+  |     | NextPtr    |->0
   1671          *                     | HeadPtr      |--/     +------------+
   1672          *                     +--------------+     0<-| PrevPtr    |
   1673          *                     | NbrEntries=1 |        +------------+
   1674          *                     +--------------+        :            :
   1675          *                                             :            :
   1676          *                                             +------------+
   1677          *
   1678          *
   1679          *                     OS_RDY_LIST
   1680          *                     +--------------+
   1681          *                     | TailPtr      |-----------------------------------------------+
   1682          *                     +--------------+          OS_TCB               OS_TCB          |     OS_TCB
   1683          *                     | HeadPtr      |------> +------------+       +------------+    +-> +------------+
   1684          *                     +--------------+        | NextPtr    |------>| NextPtr    | ...... | NextPtr    |->0
   1685          *                     | NbrEntries=N |        +------------+       +------------+        +------------+
   1686          *                     +--------------+     0<-| PrevPtr    |<------| PrevPtr    | ...... | PrevPtr    |
   1687          *                                             +------------+       +------------+        +------------+
   1688          *                                             :            :       :            :        :            :
   1689          *                                             :            :       :            :        :            :
   1690          *                                             +------------+       +------------+        +------------+
   1691          *
   1692          *
   1693          * Arguments  : p_tcb     is the OS_TCB to insert in the list
   1694          *              -----
   1695          *
   1696          * Returns    : none
   1697          *
   1698          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1699          ************************************************************************************************************************
   1700          */
   1701          

   \                                 In section .text, align 2, keep-with-next
   1702          void  OS_RdyListInsertHead (OS_TCB  *p_tcb)
   1703          {
   1704              OS_RDY_LIST  *p_rdy_list;
   1705              OS_TCB       *p_tcb2;
   1706          
   1707          
   1708          
   1709              p_rdy_list = &OSRdyList[p_tcb->Prio];
   \                     OS_RdyListInsertHead: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable17_26
   \   00000002   0xF890 0x203F      LDRB     R2,[R0, #+63]
   \   00000006   0x230C             MOVS     R3,#+12
   \   00000008   0xFB03 0x1102      MLA      R1,R3,R2,R1
   1710              if (p_rdy_list->HeadPtr == DEF_NULL) {                      /* CASE 0: Insert when there are no entries             */
   \   0000000C   0x680A             LDR      R2,[R1, #+0]
   \   0000000E   0x2A00             CMP      R2,#+0
   \   00000010   0xD108             BNE.N    ??OS_RdyListInsertHead_0
   1711          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   1712                  p_rdy_list->NbrEntries =  1u;                           /* This is the first entry                              */
   \   00000012   0x2201             MOVS     R2,#+1
   \   00000014   0x810A             STRH     R2,[R1, #+8]
   1713          #endif
   1714                  p_tcb->NextPtr         =  DEF_NULL;                     /* No other OS_TCBs in the list                         */
   \   00000016   0x2200             MOVS     R2,#+0
   \   00000018   0x6102             STR      R2,[R0, #+16]
   1715                  p_tcb->PrevPtr         =  DEF_NULL;
   \   0000001A   0x2200             MOVS     R2,#+0
   \   0000001C   0x6142             STR      R2,[R0, #+20]
   1716                  p_rdy_list->HeadPtr    =  p_tcb;                        /* Both list pointers point to this OS_TCB              */
   \   0000001E   0x6008             STR      R0,[R1, #+0]
   1717                  p_rdy_list->TailPtr    =  p_tcb;
   \   00000020   0x6048             STR      R0,[R1, #+4]
   \   00000022   0xE009             B.N      ??OS_RdyListInsertHead_1
   1718              } else {                                                    /* CASE 1: Insert BEFORE the current head of list       */
   1719          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   1720                  p_rdy_list->NbrEntries++;                               /* One more OS_TCB in the list                          */
   \                     ??OS_RdyListInsertHead_0: (+1)
   \   00000024   0x890A             LDRH     R2,[R1, #+8]
   \   00000026   0x1C52             ADDS     R2,R2,#+1
   \   00000028   0x810A             STRH     R2,[R1, #+8]
   1721          #endif
   1722                  p_tcb->NextPtr         = p_rdy_list->HeadPtr;           /* Adjust new OS_TCBs links                             */
   \   0000002A   0x680A             LDR      R2,[R1, #+0]
   \   0000002C   0x6102             STR      R2,[R0, #+16]
   1723                  p_tcb->PrevPtr         = DEF_NULL;
   \   0000002E   0x2200             MOVS     R2,#+0
   \   00000030   0x6142             STR      R2,[R0, #+20]
   1724                  p_tcb2                 = p_rdy_list->HeadPtr;           /* Adjust old head of list's links                      */
   \   00000032   0x680A             LDR      R2,[R1, #+0]
   1725                  p_tcb2->PrevPtr        = p_tcb;
   \   00000034   0x6150             STR      R0,[R2, #+20]
   1726                  p_rdy_list->HeadPtr    = p_tcb;
   \   00000036   0x6008             STR      R0,[R1, #+0]
   1727              }
   1728          }
   \                     ??OS_RdyListInsertHead_1: (+1)
   \   00000038   0x4770             BX       LR               ;; return
   1729          
   1730          
   1731          /*
   1732          ************************************************************************************************************************
   1733          *                                           INSERT TCB AT THE END OF A LIST
   1734          *
   1735          * Description: This function is called to place an OS_TCB at the end of a linked list as follows:
   1736          *
   1737          *              CASE 0: Insert in an empty list.
   1738          *
   1739          *                     OS_RDY_LIST
   1740          *                     +--------------+
   1741          *                     | TailPtr      |-> 0
   1742          *                     +--------------+
   1743          *                     | HeadPtr      |-> 0
   1744          *                     +--------------+
   1745          *                     | NbrEntries=0 |
   1746          *                     +--------------+
   1747          *
   1748          *
   1749          *
   1750          *              CASE 1: Insert AFTER the current tail of list
   1751          *
   1752          *                     OS_RDY_LIST
   1753          *                     +--------------+          OS_TCB
   1754          *                     | TailPtr      |--+---> +------------+
   1755          *                     +--------------+  |     | NextPtr    |->0
   1756          *                     | HeadPtr      |--/     +------------+
   1757          *                     +--------------+     0<-| PrevPtr    |
   1758          *                     | NbrEntries=1 |        +------------+
   1759          *                     +--------------+        :            :
   1760          *                                             :            :
   1761          *                                             +------------+
   1762          *
   1763          *
   1764          *                     OS_RDY_LIST
   1765          *                     +--------------+
   1766          *                     | TailPtr      |-----------------------------------------------+
   1767          *                     +--------------+          OS_TCB               OS_TCB          |     OS_TCB
   1768          *                     | HeadPtr      |------> +------------+       +------------+    +-> +------------+
   1769          *                     +--------------+        | NextPtr    |------>| NextPtr    | ...... | NextPtr    |->0
   1770          *                     | NbrEntries=N |        +------------+       +------------+        +------------+
   1771          *                     +--------------+     0<-| PrevPtr    |<------| PrevPtr    | ...... | PrevPtr    |
   1772          *                                             +------------+       +------------+        +------------+
   1773          *                                             :            :       :            :        :            :
   1774          *                                             :            :       :            :        :            :
   1775          *                                             +------------+       +------------+        +------------+
   1776          *
   1777          *
   1778          * Arguments  : p_tcb     is the OS_TCB to insert in the list
   1779          *              -----
   1780          *
   1781          * Returns    : none
   1782          *
   1783          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1784          ************************************************************************************************************************
   1785          */
   1786          

   \                                 In section .text, align 2, keep-with-next
   1787          void  OS_RdyListInsertTail (OS_TCB  *p_tcb)
   1788          {
   1789              OS_RDY_LIST  *p_rdy_list;
   1790              OS_TCB       *p_tcb2;
   1791          
   1792          
   1793          
   1794              p_rdy_list = &OSRdyList[p_tcb->Prio];
   \                     OS_RdyListInsertTail: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable17_26
   \   00000002   0xF890 0x203F      LDRB     R2,[R0, #+63]
   \   00000006   0x230C             MOVS     R3,#+12
   \   00000008   0xFB03 0x1102      MLA      R1,R3,R2,R1
   1795              if (p_rdy_list->HeadPtr == DEF_NULL) {                      /* CASE 0: Insert when there are no entries             */
   \   0000000C   0x680A             LDR      R2,[R1, #+0]
   \   0000000E   0x2A00             CMP      R2,#+0
   \   00000010   0xD108             BNE.N    ??OS_RdyListInsertTail_0
   1796          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   1797                  p_rdy_list->NbrEntries  = 1u;                           /* This is the first entry                              */
   \   00000012   0x2201             MOVS     R2,#+1
   \   00000014   0x810A             STRH     R2,[R1, #+8]
   1798          #endif
   1799                  p_tcb->NextPtr          = DEF_NULL;                     /* No other OS_TCBs in the list                         */
   \   00000016   0x2200             MOVS     R2,#+0
   \   00000018   0x6102             STR      R2,[R0, #+16]
   1800                  p_tcb->PrevPtr          = DEF_NULL;
   \   0000001A   0x2200             MOVS     R2,#+0
   \   0000001C   0x6142             STR      R2,[R0, #+20]
   1801                  p_rdy_list->HeadPtr     = p_tcb;                        /* Both list pointers point to this OS_TCB              */
   \   0000001E   0x6008             STR      R0,[R1, #+0]
   1802                  p_rdy_list->TailPtr     = p_tcb;
   \   00000020   0x6048             STR      R0,[R1, #+4]
   \   00000022   0xE008             B.N      ??OS_RdyListInsertTail_1
   1803              } else {                                                    /* CASE 1: Insert AFTER the current tail of list        */
   1804          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   1805                  p_rdy_list->NbrEntries++;                               /* One more OS_TCB in the list                          */
   \                     ??OS_RdyListInsertTail_0: (+1)
   \   00000024   0x890A             LDRH     R2,[R1, #+8]
   \   00000026   0x1C52             ADDS     R2,R2,#+1
   \   00000028   0x810A             STRH     R2,[R1, #+8]
   1806          #endif
   1807                  p_tcb->NextPtr          = DEF_NULL;                     /* Adjust new OS_TCBs links                             */
   \   0000002A   0x2200             MOVS     R2,#+0
   \   0000002C   0x6102             STR      R2,[R0, #+16]
   1808                  p_tcb2                  = p_rdy_list->TailPtr;
   \   0000002E   0x684A             LDR      R2,[R1, #+4]
   1809                  p_tcb->PrevPtr          = p_tcb2;
   \   00000030   0x6142             STR      R2,[R0, #+20]
   1810                  p_tcb2->NextPtr         = p_tcb;                        /* Adjust old tail of list's links                      */
   \   00000032   0x6110             STR      R0,[R2, #+16]
   1811                  p_rdy_list->TailPtr     = p_tcb;
   \   00000034   0x6048             STR      R0,[R1, #+4]
   1812              }
   1813          }
   \                     ??OS_RdyListInsertTail_1: (+1)
   \   00000036   0x4770             BX       LR               ;; return
   1814          
   1815          
   1816          /*
   1817          ************************************************************************************************************************
   1818          *                                                MOVE TCB AT HEAD TO TAIL
   1819          *
   1820          * Description: This function is called to move the current head of a list to the tail of the list.
   1821          *
   1822          *
   1823          *              CASE 0: TCB list is empty, nothing to do.
   1824          *
   1825          *              CASE 1: Only 1 OS_TCB  in the list, nothing to do.
   1826          *
   1827          *              CASE 2: Only 2 OS_TCBs in the list.
   1828          *
   1829          *                     OS_RDY_LIST
   1830          *                     +--------------+
   1831          *                     | TailPtr      |--------------------------+
   1832          *                     +--------------+          OS_TCB          |     OS_TCB
   1833          *                     | HeadPtr      |------> +------------+    +-> +------------+
   1834          *                     +--------------+        | NextPtr    |------> | NextPtr    |->0
   1835          *                     | NbrEntries=2 |        +------------+        +------------+
   1836          *                     +--------------+     0<-| PrevPtr    | <------| PrevPtr    |
   1837          *                                             +------------+        +------------+
   1838          *                                             :            :        :            :
   1839          *                                             :            :        :            :
   1840          *                                             +------------+        +------------+
   1841          *
   1842          *
   1843          *              CASE N: More than 2 OS_TCBs in the list.
   1844          *
   1845          *                     OS_RDY_LIST
   1846          *                     +--------------+
   1847          *                     | TailPtr      |-----------------------------------------------+
   1848          *                     +--------------+          OS_TCB               OS_TCB          |     OS_TCB
   1849          *                     | HeadPtr      |------> +------------+       +------------+    +-> +------------+
   1850          *                     +--------------+        | NextPtr    |------>| NextPtr    | ...... | NextPtr    |->0
   1851          *                     | NbrEntries=N |        +------------+       +------------+        +------------+
   1852          *                     +--------------+     0<-| PrevPtr    |<------| PrevPtr    | ...... | PrevPtr    |
   1853          *                                             +------------+       +------------+        +------------+
   1854          *                                             :            :       :            :        :            :
   1855          *                                             :            :       :            :        :            :
   1856          *                                             +------------+       +------------+        +------------+
   1857          *
   1858          *
   1859          * Arguments  : p_rdy_list    is a pointer to the OS_RDY_LIST where the OS_TCB will be inserted
   1860          *              ------
   1861          *
   1862          * Returns    : none
   1863          *
   1864          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1865          ************************************************************************************************************************
   1866          */
   1867          

   \                                 In section .text, align 2, keep-with-next
   1868          void  OS_RdyListMoveHeadToTail (OS_RDY_LIST  *p_rdy_list)
   1869          {
   \                     OS_RdyListMoveHeadToTail: (+1)
   \   00000000   0xB410             PUSH     {R4}
   1870              OS_TCB  *p_tcb1;
   1871              OS_TCB  *p_tcb2;
   1872              OS_TCB  *p_tcb3;
   1873          
   1874          
   1875               if (p_rdy_list->HeadPtr != p_rdy_list->TailPtr) {
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x6842             LDR      R2,[R0, #+4]
   \   00000006   0x4291             CMP      R1,R2
   \   00000008   0xD01A             BEQ.N    ??OS_RdyListMoveHeadToTail_0
   1876                   if (p_rdy_list->HeadPtr->NextPtr == p_rdy_list->TailPtr) { /* SWAP the TCBs                                    */
   \   0000000A   0x6801             LDR      R1,[R0, #+0]
   \   0000000C   0x6909             LDR      R1,[R1, #+16]
   \   0000000E   0x6842             LDR      R2,[R0, #+4]
   \   00000010   0x4291             CMP      R1,R2
   \   00000012   0xD10A             BNE.N    ??OS_RdyListMoveHeadToTail_1
   1877                       p_tcb1              = p_rdy_list->HeadPtr;         /* Point to current head                                */
   \   00000014   0x6801             LDR      R1,[R0, #+0]
   1878                       p_tcb2              = p_rdy_list->TailPtr;         /* Point to current tail                                */
   \   00000016   0x6842             LDR      R2,[R0, #+4]
   1879                       p_tcb1->PrevPtr     = p_tcb2;
   \   00000018   0x614A             STR      R2,[R1, #+20]
   1880                       p_tcb1->NextPtr     = DEF_NULL;
   \   0000001A   0x2300             MOVS     R3,#+0
   \   0000001C   0x610B             STR      R3,[R1, #+16]
   1881                       p_tcb2->PrevPtr     = DEF_NULL;
   \   0000001E   0x2300             MOVS     R3,#+0
   \   00000020   0x6153             STR      R3,[R2, #+20]
   1882                       p_tcb2->NextPtr     = p_tcb1;
   \   00000022   0x6111             STR      R1,[R2, #+16]
   1883                       p_rdy_list->HeadPtr = p_tcb2;
   \   00000024   0x6002             STR      R2,[R0, #+0]
   1884                       p_rdy_list->TailPtr = p_tcb1;
   \   00000026   0x6041             STR      R1,[R0, #+4]
   \   00000028   0xE00A             B.N      ??OS_RdyListMoveHeadToTail_0
   1885                   } else {
   1886                       p_tcb1              = p_rdy_list->HeadPtr;         /* Point to current head                                */
   \                     ??OS_RdyListMoveHeadToTail_1: (+1)
   \   0000002A   0x6801             LDR      R1,[R0, #+0]
   1887                       p_tcb2              = p_rdy_list->TailPtr;         /* Point to current tail                                */
   \   0000002C   0x6842             LDR      R2,[R0, #+4]
   1888                       p_tcb3              = p_tcb1->NextPtr;             /* Point to new list head                               */
   \   0000002E   0x690B             LDR      R3,[R1, #+16]
   1889                       p_tcb3->PrevPtr     = DEF_NULL;                    /* Adjust back    link of new list head                 */
   \   00000030   0x2400             MOVS     R4,#+0
   \   00000032   0x615C             STR      R4,[R3, #+20]
   1890                       p_tcb1->NextPtr     = DEF_NULL;                    /* Adjust forward link of new list tail                 */
   \   00000034   0x2400             MOVS     R4,#+0
   \   00000036   0x610C             STR      R4,[R1, #+16]
   1891                       p_tcb1->PrevPtr     = p_tcb2;                      /* Adjust back    link of new list tail                 */
   \   00000038   0x614A             STR      R2,[R1, #+20]
   1892                       p_tcb2->NextPtr     = p_tcb1;                      /* Adjust forward link of old list tail                 */
   \   0000003A   0x6111             STR      R1,[R2, #+16]
   1893                       p_rdy_list->HeadPtr = p_tcb3;                      /* Adjust new list head and tail pointers               */
   \   0000003C   0x6003             STR      R3,[R0, #+0]
   1894                       p_rdy_list->TailPtr = p_tcb1;
   \   0000003E   0x6041             STR      R1,[R0, #+4]
   1895                   }
   1896               }
   1897          }
   \                     ??OS_RdyListMoveHeadToTail_0: (+1)
   \   00000040   0xBC10             POP      {R4}
   \   00000042   0x4770             BX       LR               ;; return
   1898          
   1899          
   1900          /*
   1901          ************************************************************************************************************************
   1902          *                                REMOVE TCB FROM LIST KNOWING ONLY WHICH OS_TCB TO REMOVE
   1903          *
   1904          * Description: This function is called to remove an OS_TCB from an OS_RDY_LIST knowing the address of the OS_TCB to
   1905          *              remove.
   1906          *
   1907          *
   1908          *              CASE 0: TCB list is empty, nothing to do.
   1909          *
   1910          *              CASE 1: Only 1 OS_TCBs in the list.
   1911          *
   1912          *                     OS_RDY_LIST
   1913          *                     +--------------+          OS_TCB
   1914          *                     | TailPtr      |--+---> +------------+
   1915          *                     +--------------+  |     | NextPtr    |->0
   1916          *                     | HeadPtr      |--/     +------------+
   1917          *                     +--------------+     0<-| PrevPtr    |
   1918          *                     | NbrEntries=1 |        +------------+
   1919          *                     +--------------+        :            :
   1920          *                                             :            :
   1921          *                                             +------------+
   1922          *
   1923          *              CASE N: Two or more OS_TCBs in the list.
   1924          *
   1925          *                     OS_RDY_LIST
   1926          *                     +--------------+
   1927          *                     | TailPtr      |-----------------------------------------------+
   1928          *                     +--------------+          OS_TCB               OS_TCB          |     OS_TCB
   1929          *                     | HeadPtr      |------> +------------+       +------------+    +-> +------------+
   1930          *                     +--------------+        | NextPtr    |------>| NextPtr    | ...... | NextPtr    |->0
   1931          *                     | NbrEntries=N |        +------------+       +------------+        +------------+
   1932          *                     +--------------+     0<-| PrevPtr    |<------| PrevPtr    | ...... | PrevPtr    |
   1933          *                                             +------------+       +------------+        +------------+
   1934          *                                             :            :       :            :        :            :
   1935          *                                             :            :       :            :        :            :
   1936          *                                             +------------+       +------------+        +------------+
   1937          *
   1938          *
   1939          * Arguments  : p_tcb    is a pointer to the OS_TCB to remove
   1940          *              -----
   1941          *
   1942          * Returns    : A pointer to the OS_RDY_LIST where the OS_TCB was
   1943          *
   1944          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1945          ************************************************************************************************************************
   1946          */
   1947          

   \                                 In section .text, align 2, keep-with-next
   1948          void  OS_RdyListRemove (OS_TCB  *p_tcb)
   1949          {
   \                     OS_RdyListRemove: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1950              OS_RDY_LIST  *p_rdy_list;
   1951              OS_TCB       *p_tcb1;
   1952              OS_TCB       *p_tcb2;
   1953          
   1954          
   1955          
   1956              p_rdy_list = &OSRdyList[p_tcb->Prio];
   \   00000004   0x....             LDR.N    R0,??DataTable17_26
   \   00000006   0xF894 0x103F      LDRB     R1,[R4, #+63]
   \   0000000A   0x220C             MOVS     R2,#+12
   \   0000000C   0xFB02 0x0001      MLA      R0,R2,R1,R0
   1957              p_tcb1     = p_tcb->PrevPtr;                                /* Point to next and previous OS_TCB in the list        */
   \   00000010   0x6961             LDR      R1,[R4, #+20]
   1958              p_tcb2     = p_tcb->NextPtr;
   \   00000012   0x6922             LDR      R2,[R4, #+16]
   1959              if (p_tcb1 == DEF_NULL) {                                   /* Was the OS_TCB to remove at the head?                */
   \   00000014   0x2900             CMP      R1,#+0
   \   00000016   0xD113             BNE.N    ??OS_RdyListRemove_0
   1960                  if (p_tcb2 == DEF_NULL) {                               /* Yes, was it the only OS_TCB?                         */
   \   00000018   0x2A00             CMP      R2,#+0
   \   0000001A   0xD10A             BNE.N    ??OS_RdyListRemove_1
   1961          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   1962                      p_rdy_list->NbrEntries = 0u;                        /* Yes, no more entries                                 */
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x8101             STRH     R1,[R0, #+8]
   1963          #endif
   1964                      p_rdy_list->HeadPtr    = DEF_NULL;
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x6001             STR      R1,[R0, #+0]
   1965                      p_rdy_list->TailPtr    = DEF_NULL;
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0x6041             STR      R1,[R0, #+4]
   1966                      OS_PrioRemove(p_tcb->Prio);
   \   00000028   0xF894 0x003F      LDRB     R0,[R4, #+63]
   \   0000002C   0x.... 0x....      BL       OS_PrioRemove
   \   00000030   0xE00F             B.N      ??OS_RdyListRemove_2
   1967                  } else {
   1968          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   1969                      p_rdy_list->NbrEntries--;                           /* No,  one less entry                                  */
   \                     ??OS_RdyListRemove_1: (+1)
   \   00000032   0x8901             LDRH     R1,[R0, #+8]
   \   00000034   0x1E49             SUBS     R1,R1,#+1
   \   00000036   0x8101             STRH     R1,[R0, #+8]
   1970          #endif
   1971                      p_tcb2->PrevPtr     = DEF_NULL;                     /* adjust back link of new list head                    */
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0x6151             STR      R1,[R2, #+20]
   1972                      p_rdy_list->HeadPtr = p_tcb2;                       /* adjust OS_RDY_LIST's new head                        */
   \   0000003C   0x6002             STR      R2,[R0, #+0]
   \   0000003E   0xE008             B.N      ??OS_RdyListRemove_2
   1973                  }
   1974              } else {
   1975          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   1976                  p_rdy_list->NbrEntries--;                               /* No,  one less entry                                  */
   \                     ??OS_RdyListRemove_0: (+1)
   \   00000040   0x8903             LDRH     R3,[R0, #+8]
   \   00000042   0x1E5B             SUBS     R3,R3,#+1
   \   00000044   0x8103             STRH     R3,[R0, #+8]
   1977          #endif
   1978                  p_tcb1->NextPtr = p_tcb2;
   \   00000046   0x610A             STR      R2,[R1, #+16]
   1979                  if (p_tcb2 == DEF_NULL) {
   \   00000048   0x2A00             CMP      R2,#+0
   \   0000004A   0xD101             BNE.N    ??OS_RdyListRemove_3
   1980                      p_rdy_list->TailPtr = p_tcb1;                       /* Removing the TCB at the tail, adj the tail ptr       */
   \   0000004C   0x6041             STR      R1,[R0, #+4]
   \   0000004E   0xE000             B.N      ??OS_RdyListRemove_2
   1981                  } else {
   1982                      p_tcb2->PrevPtr     = p_tcb1;
   \                     ??OS_RdyListRemove_3: (+1)
   \   00000050   0x6151             STR      R1,[R2, #+20]
   1983                  }
   1984              }
   1985              p_tcb->PrevPtr = DEF_NULL;
   \                     ??OS_RdyListRemove_2: (+1)
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x6160             STR      R0,[R4, #+20]
   1986              p_tcb->NextPtr = DEF_NULL;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x6120             STR      R0,[R4, #+16]
   1987          
   1988              OS_TRACE_TASK_SUSPENDED(p_tcb);
   1989          }
   \   0000005A   0xBD10             POP      {R4,PC}          ;; return
   1990          
   1991          
   1992          /*
   1993          ************************************************************************************************************************
   1994          *                                               SCHEDULER LOCK TIME MEASUREMENT
   1995          *
   1996          * Description: These functions are used to measure the peak amount of time that the scheduler is locked
   1997          *
   1998          * Arguments  : none
   1999          *
   2000          * Returns    : none
   2001          *
   2002          * Note(s)    : 1) The are internal functions to uC/OS-III and MUST not be called by your application code.
   2003          *
   2004          *              2) It's assumed that these functions are called when interrupts are disabled.
   2005          *
   2006          *              3) We are reading the CPU_TS_TmrRd() directly even if this is a 16-bit timer.  The reason is that we
   2007          *                 don't expect to have the scheduler locked for 65536 counts even at the rate the TS timer is updated.
   2008          *                 In other words, locking the scheduler for longer than 65536 count would not be a good thing for a
   2009          *                 real-time system.
   2010          ************************************************************************************************************************
   2011          */
   2012          
   2013          #if (OS_CFG_SCHED_LOCK_TIME_MEAS_EN == DEF_ENABLED)
   2014          void  OS_SchedLockTimeMeasStart (void)
   2015          {
   2016              if (OSSchedLockNestingCtr == 1u) {
   2017                  OSSchedLockTimeBegin = CPU_TS_TmrRd();
   2018              }
   2019          }
   2020          
   2021          
   2022          
   2023          
   2024          void  OS_SchedLockTimeMeasStop (void)
   2025          {
   2026              CPU_TS_TMR  delta;
   2027          
   2028          
   2029              if (OSSchedLockNestingCtr == 0u) {                          /* Make sure we fully un-nested scheduler lock          */
   2030                  delta = CPU_TS_TmrRd()                                  /* Compute the delta time between begin and end         */
   2031                        - OSSchedLockTimeBegin;
   2032                  if (OSSchedLockTimeMax    < delta) {                    /* Detect peak value                                    */
   2033                      OSSchedLockTimeMax    = delta;
   2034                  }
   2035                  if (OSSchedLockTimeMaxCur < delta) {                    /* Detect peak value (for resettable value)             */
   2036                      OSSchedLockTimeMaxCur = delta;
   2037                  }
   2038              }
   2039          }
   2040          #endif
   2041          
   2042          
   2043          /*
   2044          ************************************************************************************************************************
   2045          *                                        RUN ROUND-ROBIN SCHEDULING ALGORITHM
   2046          *
   2047          * Description: This function is called on every tick to determine if a new task at the same priority needs to execute.
   2048          *
   2049          *
   2050          * Arguments  : p_rdy_list    is a pointer to the OS_RDY_LIST entry of the ready list at the current priority
   2051          *              ----------
   2052          *
   2053          * Returns    : none
   2054          *
   2055          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   2056          ************************************************************************************************************************
   2057          */
   2058          
   2059          #if (OS_CFG_SCHED_ROUND_ROBIN_EN == DEF_ENABLED)
   2060          void  OS_SchedRoundRobin (OS_RDY_LIST  *p_rdy_list)
   2061          {
   2062              OS_TCB   *p_tcb;
   2063              CPU_SR_ALLOC();
   2064          
   2065          
   2066              if (OSSchedRoundRobinEn != DEF_TRUE) {                      /* Make sure round-robin has been enabled               */
   2067                  return;
   2068              }
   2069          
   2070              CPU_CRITICAL_ENTER();
   2071              p_tcb = p_rdy_list->HeadPtr;                                /* Decrement time quanta counter                        */
   2072          
   2073              if (p_tcb == DEF_NULL) {
   2074                  CPU_CRITICAL_EXIT();
   2075                  return;
   2076              }
   2077          
   2078          #if (OS_CFG_TASK_IDLE_EN == DEF_ENABLED)
   2079              if (p_tcb == &OSIdleTaskTCB) {
   2080                  CPU_CRITICAL_EXIT();
   2081                  return;
   2082              }
   2083          #endif
   2084          
   2085              if (p_tcb->TimeQuantaCtr > 0u) {
   2086                  p_tcb->TimeQuantaCtr--;
   2087              }
   2088          
   2089              if (p_tcb->TimeQuantaCtr > 0u) {                            /* Task not done with its time quanta                   */
   2090                  CPU_CRITICAL_EXIT();
   2091                  return;
   2092              }
   2093          
   2094              if (p_rdy_list->HeadPtr == p_rdy_list->TailPtr) {           /* See if it's time to time slice current task          */
   2095                  CPU_CRITICAL_EXIT();                                    /* ... only if multiple tasks at same priority          */
   2096                  return;
   2097              }
   2098          
   2099              if (OSSchedLockNestingCtr > 0u) {                           /* Can't round-robin if the scheduler is locked         */
   2100                  CPU_CRITICAL_EXIT();
   2101                  return;
   2102              }
   2103          
   2104              OS_RdyListMoveHeadToTail(p_rdy_list);                       /* Move current OS_TCB to the end of the list           */
   2105              p_tcb = p_rdy_list->HeadPtr;                                /* Point to new OS_TCB at head of the list              */
   2106              if (p_tcb->TimeQuanta == 0u) {                              /* See if we need to use the default time slice         */
   2107                  p_tcb->TimeQuantaCtr = OSSchedRoundRobinDfltTimeQuanta;
   2108              } else {
   2109                  p_tcb->TimeQuantaCtr = p_tcb->TimeQuanta;               /* Load time slice counter with new time                */
   2110              }
   2111              CPU_CRITICAL_EXIT();
   2112          }
   2113          #endif
   2114          
   2115          
   2116          /*
   2117          ************************************************************************************************************************
   2118          *                                                     BLOCK A TASK
   2119          *
   2120          * Description: This function is called to remove a task from the ready list and also insert it in the timer tick list if
   2121          *              the specified timeout is non-zero.
   2122          *
   2123          * Arguments  : p_tcb          is a pointer to the OS_TCB of the task block
   2124          *              -----
   2125          *
   2126          *              timeout        is the desired timeout
   2127          *
   2128          * Returns    : none
   2129          *
   2130          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   2131          ************************************************************************************************************************
   2132          */
   2133          

   \                                 In section .text, align 2, keep-with-next
   2134          void  OS_TaskBlock (OS_TCB   *p_tcb,
   2135                              OS_TICK   timeout)
   2136          {
   \                     OS_TaskBlock: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2137          #if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
   2138          #if (OS_CFG_DYN_TICK_EN == DEF_ENABLED)
   2139                  OS_TICK tick_ctr;
   2140          #endif
   2141          
   2142          
   2143              if (timeout > 0u) {                                         /* Add task to tick list if timeout non zero            */
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD008             BEQ.N    ??OS_TaskBlock_0
   2144          #if (OS_CFG_DYN_TICK_EN == DEF_ENABLED)
   2145                  tick_ctr = BSP_OS_TickGet();
   2146                  OS_TickListInsert(&OSTickListTimeout, p_tcb, timeout + (tick_ctr - OSTickCtr));
   2147          #else
   2148                  OS_TickListInsert(&OSTickListTimeout, p_tcb, timeout);
   \   00000008   0x000A             MOVS     R2,R1
   \   0000000A   0x0021             MOVS     R1,R4
   \   0000000C   0x....             LDR.N    R0,??DataTable17_39
   \   0000000E   0x.... 0x....      BL       OS_TickListInsert
   2149          #endif
   2150                  p_tcb->TaskState = OS_TASK_STATE_PEND_TIMEOUT;
   \   00000012   0x2003             MOVS     R0,#+3
   \   00000014   0xF884 0x003E      STRB     R0,[R4, #+62]
   \   00000018   0xE002             B.N      ??OS_TaskBlock_1
   2151              } else {
   2152                  p_tcb->TaskState = OS_TASK_STATE_PEND;
   \                     ??OS_TaskBlock_0: (+1)
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xF884 0x003E      STRB     R0,[R4, #+62]
   2153              }
   2154          #else
   2155              p_tcb->TaskState = OS_TASK_STATE_PEND;
   2156          #endif
   2157              OS_RdyListRemove(p_tcb);
   \                     ??OS_TaskBlock_1: (+1)
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       OS_RdyListRemove
   2158          }
   \   00000026   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x20 0x00          DC8      " ",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x........         DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   0x........         DC32     OSRunning

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \   00000000   0x........         DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_3:
   \   00000000   0x........         DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_4:
   \   00000000   0x........         DC32     OSTCBHighRdyPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_5:
   \   00000000   0x........         DC32     OSPrioCur

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_6:
   \   00000000   0x........         DC32     OSPrioHighRdy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_7:
   \   00000000   0x........         DC32     OSCfg_ISRStkBasePtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_8:
   \   00000000   0x........         DC32     OSCfg_ISRStkSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_9:
   \   00000000   0x........         DC32     OS_AppTaskCreateHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_10:
   \   00000000   0x........         DC32     OS_AppTaskDelHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_11:
   \   00000000   0x........         DC32     OS_AppTaskReturnHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_12:
   \   00000000   0x........         DC32     OS_AppIdleTaskHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_13:
   \   00000000   0x........         DC32     OS_AppStatTaskHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_14:
   \   00000000   0x........         DC32     OS_AppTaskSwHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_15:
   \   00000000   0x........         DC32     OS_AppTimeTickHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_16:
   \   00000000   0x........         DC32     OSTaskRegNextAvailID

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_17:
   \   00000000   0x........         DC32     OSFlagDbgListPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_18:
   \   00000000   0x........         DC32     OSFlagQty

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_19:
   \   00000000   0x........         DC32     OSMutexDbgListPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_20:
   \   00000000   0x........         DC32     OSMutexQty

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_21:
   \   00000000   0x........         DC32     OSQDbgListPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_22:
   \   00000000   0x........         DC32     OSQQty

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_23:
   \   00000000   0x........         DC32     OSSemDbgListPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_24:
   \   00000000   0x........         DC32     OSSemQty

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_25:
   \   00000000   0x........         DC32     OSInitialized

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_26:
   \   00000000   0x........         DC32     OSRdyList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_27:
   \   00000000   0x........         DC32     OSTaskCtxSwCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_28:
   \   00000000   0xE000ED04         DC32     0xe000ed04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_29:
   \   00000000   0x........         DC32     OSTaskQty

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_30:
   \   00000000   0x........         DC32     OSIdleTaskCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_31:
   \   00000000   0x........         DC32     OSCfg_IdleTaskStkSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_32:
   \   00000000   0x........         DC32     OSCfg_IdleTaskStkLimit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_33:
   \   00000000   0x........         DC32     OSCfg_IdleTaskStkBasePtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_34:
   \   00000000   0x........         DC32     OS_IdleTask

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_35:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_36:
   \   00000000   0x........         DC32     OSIdleTaskTCB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_37:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_38:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_39:
   \   00000000   0x........         DC32     OSTickListTimeout

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x75 0x43          DC8 "uC/OS-III Idle Task"
   \              0x2F 0x4F    
   \              0x53 0x2D    
   \              0x49 0x49    
   \              0x49 0x20    
   \              0x49 0x64    
   \              0x6C 0x65    
   \              0x20 0x54    
   \              0x61 0x73    
   \              0x6B 0x00    

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x54 0x61          DC8 "Task Q"
   \              0x73 0x6B    
   \              0x20 0x51    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x54 0x61          DC8 "Task Sem"
   \              0x73 0x6B    
   \              0x20 0x53    
   \              0x65 0x6D    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 2
   \   00000000   0x20 0x00          DC8 " "

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   OSInit
         8   -> OSCfg_Init
         8   -> OSInitHook
         8   -> OS_Dbg_Init
         8   -> OS_IdleTaskInit
         8   -> OS_MemInit
         8   -> OS_MsgPoolInit
         8   -> OS_PrioInit
         8   -> OS_RdyListInit
         8   -> OS_TaskInit
         8   -> OS_TickTaskInit
       0   OSIntEnter
       8   OSIntExit
         8   -> CPU_SR_Restore
         8   -> CPU_SR_Save
         8   -> OS_PrioGetHighest
       8   OSSched
         8   -> CPU_SR_Restore
         8   -> CPU_SR_Save
         8   -> OS_PrioGetHighest
      16   OSSchedLock
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
      16   OSSchedUnlock
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> OSSched
       8   OSStart
         8   -> OSStartHighRdy
         8   -> OS_PrioGetHighest
       0   OSVersion
       8   OS_IdleTask
         8   -> CPU_IntDisMeasStart
         8   -> CPU_IntDisMeasStop
         8   -> CPU_SR_Restore
         8   -> CPU_SR_Save
         8   -> OSIdleTaskHook
      40   OS_IdleTaskInit
        40   -> OSTaskCreate
       8   OS_Pend
         8   -> OS_PendDbgNameAdd
         8   -> OS_PendListInsertPrio
         8   -> OS_TaskBlock
      16   OS_PendAbort
        16   -> OS_PendListRemove
        16   -> OS_RdyListInsert
        16   -> OS_TickListRemove
       0   OS_PendDbgNameAdd
       0   OS_PendDbgNameRemove
      16   OS_PendListChangePrio
        16   -> OS_PendListInsertPrio
        16   -> OS_PendListRemove
       0   OS_PendListInit
       4   OS_PendListInsertPrio
       0   OS_PendListRemove
      16   OS_Post
        16   -> OS_PendDbgNameRemove
        16   -> OS_PendListRemove
        16   -> OS_RdyListInsert
        16   -> OS_TickListRemove
       0   OS_RdyListInit
       8   OS_RdyListInsert
         8   -> OS_PrioInsert
         8   -> OS_RdyListInsertHead
         8   -> OS_RdyListInsertTail
       0   OS_RdyListInsertHead
       0   OS_RdyListInsertTail
       4   OS_RdyListMoveHeadToTail
       8   OS_RdyListRemove
         8   -> OS_PrioRemove
       8   OS_TaskBlock
         8   -> OS_RdyListRemove
         8   -> OS_TickListInsert


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable16
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_10
       4  ??DataTable17_11
       4  ??DataTable17_12
       4  ??DataTable17_13
       4  ??DataTable17_14
       4  ??DataTable17_15
       4  ??DataTable17_16
       4  ??DataTable17_17
       4  ??DataTable17_18
       4  ??DataTable17_19
       4  ??DataTable17_2
       4  ??DataTable17_20
       4  ??DataTable17_21
       4  ??DataTable17_22
       4  ??DataTable17_23
       4  ??DataTable17_24
       4  ??DataTable17_25
       4  ??DataTable17_26
       4  ??DataTable17_27
       4  ??DataTable17_28
       4  ??DataTable17_29
       4  ??DataTable17_3
       4  ??DataTable17_30
       4  ??DataTable17_31
       4  ??DataTable17_32
       4  ??DataTable17_33
       4  ??DataTable17_34
       4  ??DataTable17_35
       4  ??DataTable17_36
       4  ??DataTable17_37
       4  ??DataTable17_38
       4  ??DataTable17_39
       4  ??DataTable17_4
       4  ??DataTable17_5
       4  ??DataTable17_6
       4  ??DataTable17_7
       4  ??DataTable17_8
       4  ??DataTable17_9
      20  ?_0
       8  ?_1
      12  ?_2
       2  ?_3
     308  OSInit
      36  OSIntEnter
     178  OSIntExit
     120  OSSched
     100  OSSchedLock
     132  OSSchedUnlock
     144  OSStart
      10  OSVersion
      44  OS_IdleTask
      80  OS_IdleTaskInit
      90  OS_Pend
     132  OS_PendAbort
      64  OS_PendDbgNameAdd
      32  OS_PendDbgNameRemove
      36  OS_PendListChangePrio
      14  OS_PendListInit
     110  OS_PendListInsertPrio
      88  OS_PendListRemove
     170  OS_Post
      32  OS_RdyListInit
      40  OS_RdyListInsert
      58  OS_RdyListInsertHead
      56  OS_RdyListInsertTail
      68  OS_RdyListMoveHeadToTail
      92  OS_RdyListRemove
      40  OS_TaskBlock

 
    42 bytes in section .rodata
 2 438 bytes in section .text
 
 2 438 bytes of CODE  memory
    42 bytes of CONST memory

Errors: none
Warnings: none
