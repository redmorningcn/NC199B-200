###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       11/Jul/2018  11:13:10
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC210\NC210-200处理板\source\Software\uCOS-III\Source\os_tmr.c
#    Command line =  
#        F:\iar\NC210\NC210-200处理板\source\Software\uCOS-III\Source\os_tmr.c
#        -D USE_STDPERIPH_DRIVER -D APP_RELEASE -lCN
#        F:\iar\NC210\NC210-200处理板\project\app_release\List -o
#        F:\iar\NC210\NC210-200处理板\project\app_release\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC210\NC210-200处理板\project\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\config\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\task\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\user\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\OS\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\Ports\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\driver\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-LIB\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Source\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\ST\STM32\inc\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Ports\STM32\STM32F103\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Source\
#        -Ol --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC210\NC210-200处理板\project\app_release\List\os_tmr.lst
#    Object file  =  
#        F:\iar\NC210\NC210-200处理板\project\app_release\Obj\os_tmr.o
#
###############################################################################

F:\iar\NC210\NC210-200处理板\source\Software\uCOS-III\Source\os_tmr.c
      1          /*
      2          ************************************************************************************************************************
      3          *                                                      uC/OS-III
      4          *                                                 The Real-Time Kernel
      5          *
      6          *                                  (c) Copyright 2009-2016; Micrium, Inc.; Weston, FL
      7          *                           All rights reserved.  Protected by international copyright laws.
      8          *
      9          *                                                   TIMER MANAGEMENT
     10          *
     11          * File    : OS_TMR.C
     12          * By      : JJL
     13          * Version : V3.06.00
     14          *
     15          * LICENSING TERMS:
     16          * ---------------
     17          *           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or
     18          *           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
     19          *           product then, you need to contact Micrium to properly license uC/OS-III for its use in your
     20          *           application/product.   We provide ALL the source code for your convenience and to help you
     21          *           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use
     22          *           it commercially without paying a licensing fee.
     23          *
     24          *           Knowledge of the source code may NOT be used to develop a similar product.
     25          *
     26          *           Please help us continue to provide the embedded community with the finest software available.
     27          *           Your honesty is greatly appreciated.
     28          *
     29          *           You can find our product's user manual, API reference, release notes and
     30          *           more information at https://doc.micrium.com.
     31          *           You can contact us at www.micrium.com.
     32          ************************************************************************************************************************
     33          */
     34          
     35          #define  MICRIUM_SOURCE
     36          #include "os.h"
     37          
     38          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     39          const  CPU_CHAR  *os_tmr__c = "$Id: $";
     40          #endif
     41          
     42          
     43          #if (OS_CFG_TMR_EN == DEF_ENABLED)
     44          /*
     45          ************************************************************************************************************************
     46          *                                               LOCAL FUNCTION PROTOTYPES
     47          ************************************************************************************************************************
     48          */
     49          
     50          static  void  OS_TmrLock   (void);
     51          static  void  OS_TmrUnlock (void);
     52          
     53          
     54          /*
     55          ************************************************************************************************************************
     56          *                                                   CREATE A TIMER
     57          *
     58          * Description: This function is called by your application code to create a timer.
     59          *
     60          * Arguments  : p_tmr           Is a pointer to a timer control block
     61          *
     62          *              p_name          Is a pointer to an ASCII string that is used to name the timer.  Names are useful for
     63          *                              debugging.
     64          *
     65          *              dly             Initial delay.
     66          *                              If the timer is configured for ONE-SHOT mode, this is the timeout used
     67          *                              If the timer is configured for PERIODIC mode, this is the first timeout to wait for
     68          *                              before the timer starts entering periodic mode
     69          *
     70          *              period          The 'period' being repeated for the timer.
     71          *                              If you specified 'OS_OPT_TMR_PERIODIC' as an option, when the timer expires, it will
     72          *                              automatically restart with the same period.
     73          *
     74          *              opt             Specifies either:
     75          *
     76          *                                  OS_OPT_TMR_ONE_SHOT       The timer counts down only once
     77          *                                  OS_OPT_TMR_PERIODIC       The timer counts down and then reloads itself
     78          *
     79          *              p_callback      Is a pointer to a callback function that will be called when the timer expires.  The
     80          *                              callback function must be declared as follows:
     81          *
     82          *                                  void  MyCallback (OS_TMR *p_tmr, void *p_arg);
     83          *
     84          *              p_callback_arg  Is an argument (a pointer) that is passed to the callback function when it is called.
     85          *
     86          *              p_err           Is a pointer to an error code.  '*p_err' will contain one of the following:
     87          *
     88          *                                 OS_ERR_NONE                    The call succeeded
     89          *                                 OS_ERR_ILLEGAL_CREATE_RUN_TIME If you are trying to create the timer after you called
     90          *                                                                  OSSafetyCriticalStart()
     91          *                                 OS_ERR_OBJ_PTR_NULL            Is 'p_tmr' is a NULL pointer
     92          *                                 OS_ERR_OPT_INVALID             You specified an invalid option
     93          *                                 OS_ERR_TMR_INVALID_CALLBACK    You specified an invalid callback for a periodic timer
     94          *                                 OS_ERR_TMR_INVALID_DLY         You specified an invalid delay
     95          *                                 OS_ERR_TMR_INVALID_PERIOD      You specified an invalid period
     96          *                                 OS_ERR_TMR_ISR                 If the call was made from an ISR
     97          *
     98          * Returns    : none
     99          *
    100          * Note(s)    : 1) This function only creates the timer.  In other words, the timer is not started when created.  To
    101          *                 start the timer, call OSTmrStart().
    102          ************************************************************************************************************************
    103          */
    104          
    105          void  OSTmrCreate (OS_TMR               *p_tmr,
    106                             CPU_CHAR             *p_name,
    107                             OS_TICK               dly,
    108                             OS_TICK               period,
    109                             OS_OPT                opt,
    110                             OS_TMR_CALLBACK_PTR   p_callback,
    111                             void                 *p_callback_arg,
    112                             OS_ERR               *p_err)
    113          {
    114          #ifdef OS_SAFETY_CRITICAL
    115              if (p_err == DEF_NULL) {
    116                  OS_SAFETY_CRITICAL_EXCEPTION();
    117                  return;
    118              }
    119          #endif
    120          
    121          #ifdef OS_SAFETY_CRITICAL_IEC61508
    122              if (OSSafetyCriticalStartFlag == DEF_TRUE) {
    123                 *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
    124                  return;
    125              }
    126          #endif
    127          
    128          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
    129              if (OSIntNestingCtr > 0u) {                                 /* See if trying to call from an ISR                    */
    130                 *p_err = OS_ERR_TMR_ISR;
    131                  return;
    132              }
    133          #endif
    134          
    135          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
    136              if (p_tmr == DEF_NULL) {                                    /* Validate 'p_tmr'                                     */
    137                 *p_err = OS_ERR_OBJ_PTR_NULL;
    138                  return;
    139              }
    140          
    141              switch (opt) {
    142                  case OS_OPT_TMR_PERIODIC:
    143                       if (period == 0u) {
    144                          *p_err = OS_ERR_TMR_INVALID_PERIOD;
    145                           return;
    146                       }
    147          
    148                       if (p_callback == DEF_NULL) {                      /* No point in a periodic timer without a callback      */
    149                          *p_err = OS_ERR_TMR_INVALID_CALLBACK;
    150                           return;
    151                       }
    152                       break;
    153          
    154                  case OS_OPT_TMR_ONE_SHOT:
    155                       if (dly == 0u) {
    156                          *p_err = OS_ERR_TMR_INVALID_DLY;
    157                           return;
    158                       }
    159                       break;
    160          
    161                  default:
    162                      *p_err = OS_ERR_OPT_INVALID;
    163                       return;
    164              }
    165          #endif
    166          
    167              if (OSRunning == OS_STATE_OS_RUNNING) {                     /* Only lock when the kernel is running                 */
    168                  OS_TmrLock();
    169              }
    170          
    171              p_tmr->State          = OS_TMR_STATE_STOPPED;               /* Initialize the timer fields                          */
    172          #if (OS_OBJ_TYPE_REQ == DEF_ENABLED)
    173              p_tmr->Type           = OS_OBJ_TYPE_TMR;
    174          #endif
    175          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    176              p_tmr->NamePtr        = p_name;
    177          #else
    178              (void)p_name;
    179          #endif
    180              p_tmr->Dly            = dly;
    181              p_tmr->Remain         = 0u;
    182              p_tmr->Period         = period;
    183              p_tmr->Opt            = opt;
    184              p_tmr->CallbackPtr    = p_callback;
    185              p_tmr->CallbackPtrArg = p_callback_arg;
    186              p_tmr->NextPtr        = DEF_NULL;
    187              p_tmr->PrevPtr        = DEF_NULL;
    188          
    189          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    190              OS_TmrDbgListAdd(p_tmr);
    191          #endif
    192          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    193              OSTmrQty++;                                                 /* Keep track of the number of timers created           */
    194          #endif
    195          
    196              if (OSRunning == OS_STATE_OS_RUNNING) {
    197                  OS_TmrUnlock();
    198              }
    199          
    200             *p_err = OS_ERR_NONE;
    201          }
    202          
    203          
    204          /*
    205          ************************************************************************************************************************
    206          *                                                   DELETE A TIMER
    207          *
    208          * Description: This function is called by your application code to delete a timer.
    209          *
    210          * Arguments  : p_tmr          Is a pointer to the timer to stop and delete.
    211          *
    212          *              p_err          Is a pointer to an error code.  '*p_err' will contain one of the following:
    213          *
    214          *                                 OS_ERR_NONE                    The call succeeded
    215          *                                 OS_ERR_ILLEGAL_DEL_RUN_TIME    If you are trying to delete the timer after you called
    216          *                                                                  OSStart()
    217          *                                 OS_ERR_OBJ_TYPE                If 'p_tmr' is not pointing to a timer
    218          *                                 OS_ERR_OS_NOT_RUNNING          If uC/OS-III is not running yet
    219          *                                 OS_ERR_TMR_INACTIVE            If the timer was not created
    220          *                                 OS_ERR_TMR_INVALID             If 'p_tmr' is a NULL pointer
    221          *                                 OS_ERR_TMR_INVALID_STATE       The timer is in an invalid state
    222          *                                 OS_ERR_TMR_ISR                 If the function was called from an ISR
    223          *
    224          * Returns    : DEF_TRUE   if the timer was deleted
    225          *              DEF_FALSE  if not or upon an error
    226          *
    227          * Note(s)    : none
    228          ************************************************************************************************************************
    229          */
    230          
    231          #if (OS_CFG_TMR_DEL_EN == DEF_ENABLED)
    232          CPU_BOOLEAN  OSTmrDel (OS_TMR  *p_tmr,
    233                                 OS_ERR  *p_err)
    234          {
    235              CPU_BOOLEAN  success;
    236          
    237          
    238          
    239          #ifdef OS_SAFETY_CRITICAL
    240              if (p_err == DEF_NULL) {
    241                  OS_SAFETY_CRITICAL_EXCEPTION();
    242                  return (DEF_FALSE);
    243              }
    244          #endif
    245          
    246          #ifdef OS_SAFETY_CRITICAL_IEC61508
    247              if (OSSafetyCriticalStartFlag == DEF_TRUE) {
    248                 *p_err = OS_ERR_ILLEGAL_DEL_RUN_TIME;
    249                  return (DEF_FALSE);
    250              }
    251          #endif
    252          
    253          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
    254              if (OSIntNestingCtr > 0u) {                                 /* See if trying to call from an ISR                    */
    255                 *p_err  = OS_ERR_TMR_ISR;
    256                  return (DEF_FALSE);
    257              }
    258          #endif
    259          
    260          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
    261              if (OSRunning != OS_STATE_OS_RUNNING) {
    262                 *p_err = OS_ERR_OS_NOT_RUNNING;
    263                  return (DEF_FALSE);
    264              }
    265          #endif
    266          
    267          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
    268              if (p_tmr == DEF_NULL) {
    269                 *p_err = OS_ERR_TMR_INVALID;
    270                  return (DEF_FALSE);
    271              }
    272          #endif
    273          
    274          #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
    275              if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                       /* Make sure timer was created                          */
    276                 *p_err = OS_ERR_OBJ_TYPE;
    277                  return (DEF_FALSE);
    278              }
    279          #endif
    280          
    281              OS_TmrLock();
    282          
    283          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    284              OS_TmrDbgListRemove(p_tmr);
    285          #endif
    286          
    287              switch (p_tmr->State) {
    288                  case OS_TMR_STATE_RUNNING:
    289                       OS_TmrUnlink(p_tmr);                               /* Remove from the list                                 */
    290                       OS_TmrClr(p_tmr);
    291          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    292                       OSTmrQty--;                                        /* One less timer                                       */
    293          #endif
    294                      *p_err   = OS_ERR_NONE;
    295                       success = DEF_TRUE;
    296                       break;
    297          
    298                  case OS_TMR_STATE_STOPPED:                              /* Timer has not started or ...                         */
    299                  case OS_TMR_STATE_COMPLETED:                            /* ... timer has completed the ONE-SHOT time            */
    300                       OS_TmrClr(p_tmr);                                  /* Clear timer fields                                   */
    301          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    302                       OSTmrQty--;                                        /* One less timer                                       */
    303          #endif
    304                      *p_err   = OS_ERR_NONE;
    305                       success = DEF_TRUE;
    306                       break;
    307          
    308                  case OS_TMR_STATE_UNUSED:                               /* Already deleted                                      */
    309                      *p_err   = OS_ERR_TMR_INACTIVE;
    310                       success = DEF_FALSE;
    311                       break;
    312          
    313                  default:
    314                      *p_err   = OS_ERR_TMR_INVALID_STATE;
    315                       success = DEF_FALSE;
    316                       break;
    317              }
    318          
    319              OS_TmrUnlock();
    320          
    321              return (success);
    322          }
    323          #endif
    324          
    325          
    326          /*
    327          ************************************************************************************************************************
    328          *                                    GET HOW MUCH TIME IS LEFT BEFORE A TIMER EXPIRES
    329          *
    330          * Description: This function is called to get the number of ticks before a timer times out.
    331          *
    332          * Arguments  : p_tmr    Is a pointer to the timer to obtain the remaining time from.
    333          *
    334          *              p_err    Is a pointer to an error code.  '*p_err' will contain one of the following:
    335          *
    336          *                           OS_ERR_NONE               The call succeeded
    337          *                           OS_ERR_OBJ_TYPE           If 'p_tmr' is not pointing to a timer
    338          *                           OS_ERR_OS_NOT_RUNNING     If uC/OS-III is not running yet
    339          *                           OS_ERR_TMR_INACTIVE       If 'p_tmr' points to a timer that is not active
    340          *                           OS_ERR_TMR_INVALID        If 'p_tmr' is a NULL pointer
    341          *                           OS_ERR_TMR_INVALID_STATE  The timer is in an invalid state
    342          *                           OS_ERR_TMR_ISR            If the call was made from an ISR
    343          *
    344          * Returns    : The time remaining for the timer to expire.  The time represents 'timer' increments.  In other words, if
    345          *              OS_TmrTask() is signaled every 1/10 of a second then the returned value represents the number of 1/10 of
    346          *              a second remaining before the timer expires.
    347          *
    348          * Note(s)    : none
    349          ************************************************************************************************************************
    350          */
    351          
    352          OS_TICK  OSTmrRemainGet (OS_TMR  *p_tmr,
    353                                   OS_ERR  *p_err)
    354          {
    355              OS_TICK  remain;
    356          
    357          
    358          #ifdef OS_SAFETY_CRITICAL
    359              if (p_err == DEF_NULL) {
    360                  OS_SAFETY_CRITICAL_EXCEPTION();
    361                  return (0u);
    362              }
    363          #endif
    364          
    365          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
    366              if (OSIntNestingCtr > 0u) {                                 /* See if trying to call from an ISR                    */
    367                 *p_err = OS_ERR_TMR_ISR;
    368                  return (0u);
    369              }
    370          #endif
    371          
    372          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
    373              if (OSRunning != OS_STATE_OS_RUNNING) {
    374                 *p_err = OS_ERR_OS_NOT_RUNNING;
    375                  return (0u);
    376              }
    377          #endif
    378          
    379          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
    380              if (p_tmr == DEF_NULL) {
    381                 *p_err = OS_ERR_TMR_INVALID;
    382                  return (0u);
    383              }
    384          #endif
    385          
    386          #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
    387              if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                       /* Make sure timer was created                          */
    388                 *p_err = OS_ERR_OBJ_TYPE;
    389                  return (0u);
    390              }
    391          #endif
    392          
    393              OS_TmrLock();
    394          
    395              switch (p_tmr->State) {
    396                  case OS_TMR_STATE_RUNNING:
    397                       remain = p_tmr->Remain;
    398                      *p_err  = OS_ERR_NONE;
    399                       break;
    400          
    401                  case OS_TMR_STATE_STOPPED:                              /* It's assumed that the timer has not started yet      */
    402                       if (p_tmr->Opt == OS_OPT_TMR_PERIODIC) {
    403                           if (p_tmr->Dly == 0u) {
    404                               remain = p_tmr->Period;
    405                           } else {
    406                               remain = p_tmr->Dly;
    407                           }
    408                       } else {
    409                           remain = p_tmr->Dly;
    410                       }
    411                      *p_err = OS_ERR_NONE;
    412                       break;
    413          
    414                  case OS_TMR_STATE_COMPLETED:                            /* Only ONE-SHOT that timed out can be in this state    */
    415                      *p_err  = OS_ERR_NONE;
    416                       remain = 0u;
    417                       break;
    418          
    419                  case OS_TMR_STATE_UNUSED:
    420                      *p_err  = OS_ERR_TMR_INACTIVE;
    421                       remain = 0u;
    422                       break;
    423          
    424                  default:
    425                      *p_err = OS_ERR_TMR_INVALID_STATE;
    426                       remain = 0u;
    427                       break;
    428              }
    429          
    430              OS_TmrUnlock();
    431          
    432              return (remain);
    433          }
    434          
    435          
    436          /*
    437          ************************************************************************************************************************
    438          *                                                    SET A TIMER
    439          *
    440          * Description: This function is called by your application code to set a timer.
    441          *
    442          * Arguments  : p_tmr           Is a pointer to a timer control block
    443          *
    444          *              dly             Initial delay.
    445          *                              If the timer is configured for ONE-SHOT mode, this is the timeout used
    446          *                              If the timer is configured for PERIODIC mode, this is the first timeout to wait for
    447          *                              before the timer starts entering periodic mode
    448          *
    449          *              period          The 'period' being repeated for the timer.
    450          *                              If you specified 'OS_OPT_TMR_PERIODIC' as an option, when the timer expires, it will
    451          *                              automatically restart with the same period.
    452          *
    453          *              p_callback      Is a pointer to a callback function that will be called when the timer expires.  The
    454          *                              callback function must be declared as follows:
    455          *
    456          *                                  void  MyCallback (OS_TMR *p_tmr, void *p_arg);
    457          *
    458          *              p_callback_arg  Is an argument (a pointer) that is passed to the callback function when it is called.
    459          *
    460          *              p_err           Is a pointer to an error code.  '*p_err' will contain one of the following:
    461          *
    462          *                                 OS_ERR_NONE                    The timer was configured as expected
    463          *                                 OS_ERR_OBJ_TYPE                If the object type is invalid
    464          *                                 OS_ERR_OS_NOT_RUNNING          If uC/OS-III is not running yet
    465          *                                 OS_ERR_TMR_INVALID             If 'p_tmr' is a NULL pointer or invalid option
    466          *                                 OS_ERR_TMR_INVALID_CALLBACK    you specified an invalid callback for a periodic timer
    467          *                                 OS_ERR_TMR_INVALID_DLY         You specified an invalid delay
    468          *                                 OS_ERR_TMR_INVALID_PERIOD      You specified an invalid period
    469          *                                 OS_ERR_TMR_ISR                 If the call was made from an ISR
    470          *
    471          * Returns    : none
    472          *
    473          * Note(s)    : 1) This function can be called on a running timer. The change to the delay and period will only
    474          *                 take effect after the current period or delay has passed. Change to the callback will take
    475          *                 effect immediately.
    476          ************************************************************************************************************************
    477          */
    478          
    479          void  OSTmrSet (OS_TMR               *p_tmr,
    480                          OS_TICK               dly,
    481                          OS_TICK               period,
    482                          OS_TMR_CALLBACK_PTR   p_callback,
    483                          void                 *p_callback_arg,
    484                          OS_ERR               *p_err)
    485          {
    486          #ifdef OS_SAFETY_CRITICAL
    487              if (p_err == DEF_NULL) {
    488                  OS_SAFETY_CRITICAL_EXCEPTION();
    489                  return;
    490              }
    491          #endif
    492          
    493          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
    494              if (OSIntNestingCtr > 0u) {                                 /* See if trying to call from an ISR                    */
    495                 *p_err = OS_ERR_TMR_ISR;
    496                  return;
    497              }
    498          #endif
    499          
    500          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
    501              if (OSRunning != OS_STATE_OS_RUNNING) {
    502                 *p_err = OS_ERR_OS_NOT_RUNNING;
    503                  return;
    504              }
    505          #endif
    506          
    507          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
    508              if (p_tmr == DEF_NULL) {                                    /* Validate 'p_tmr'                                     */
    509                 *p_err = OS_ERR_TMR_INVALID;
    510                  return;
    511              }
    512          #endif
    513          
    514          #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
    515              if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                       /* Make sure timer was created                          */
    516                 *p_err = OS_ERR_OBJ_TYPE;
    517                  return;
    518              }
    519          #endif
    520          
    521          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
    522              switch (p_tmr->Opt) {
    523                  case OS_OPT_TMR_PERIODIC:
    524                       if (period == 0u) {
    525                          *p_err = OS_ERR_TMR_INVALID_PERIOD;
    526                           return;
    527                       }
    528          
    529                       if (p_callback == DEF_NULL) {                      /* No point in a periodic timer without a callback      */
    530                          *p_err = OS_ERR_TMR_INVALID_CALLBACK;
    531                           return;
    532                       }
    533                       break;
    534          
    535                  case OS_OPT_TMR_ONE_SHOT:
    536                       if (dly == 0u) {
    537                          *p_err = OS_ERR_TMR_INVALID_DLY;
    538                           return;
    539                       }
    540                       break;
    541          
    542                  default:
    543                      *p_err = OS_ERR_TMR_INVALID;
    544                       return;
    545              }
    546          #endif
    547          
    548              OS_TmrLock();
    549          
    550              p_tmr->Dly            = dly;
    551              p_tmr->Period         = period;
    552              p_tmr->CallbackPtr    = p_callback;
    553              p_tmr->CallbackPtrArg = p_callback_arg;
    554          
    555             *p_err = OS_ERR_NONE;
    556          
    557              OS_TmrUnlock();
    558          
    559          }
    560          
    561          
    562          /*
    563          ************************************************************************************************************************
    564          *                                                   START A TIMER
    565          *
    566          * Description: This function is called by your application code to start a timer.
    567          *
    568          * Arguments  : p_tmr    Is a pointer to an OS_TMR
    569          *
    570          *              p_err    Is a pointer to an error code.  '*p_err' will contain one of the following:
    571          *
    572          *                           OS_ERR_NONE                The timer was started
    573          *                           OS_ERR_OBJ_TYPE            If 'p_tmr' is not pointing to a timer
    574          *                           OS_ERR_OS_NOT_RUNNING      If uC/OS-III is not running yet
    575          *                           OS_ERR_TMR_INACTIVE        If the timer was not created
    576          *                           OS_ERR_TMR_INVALID         If 'p_tmr' is a NULL pointer
    577          *                           OS_ERR_TMR_INVALID_STATE   The timer is in an invalid state
    578          *                           OS_ERR_TMR_ISR             If the call was made from an ISR
    579          *
    580          * Returns    : DEF_TRUE      is the timer was started
    581          *              DEF_FALSE     if not or upon an error
    582          *
    583          * Note(s)    : 1) When starting/restarting a timer, regardless if it is in PERIODIC or ONE-SHOT mode, the timer is
    584          *                 linked to the timer list with the OS_OPT_LINK_DLY option. This option sets the initial expiration
    585          *                 time for the timer. For timers in PERIODIC mode, subsequent expiration times are handled by
    586          *                 the OS_TmrTask().
    587          ************************************************************************************************************************
    588          */
    589          
    590          CPU_BOOLEAN  OSTmrStart (OS_TMR  *p_tmr,
    591                                   OS_ERR  *p_err)
    592          {
    593              OS_TMR      *p_next;
    594              CPU_BOOLEAN  success;
    595          
    596          
    597          
    598          #ifdef OS_SAFETY_CRITICAL
    599              if (p_err == DEF_NULL) {
    600                  OS_SAFETY_CRITICAL_EXCEPTION();
    601                  return (DEF_FALSE);
    602              }
    603          #endif
    604          
    605          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
    606              if (OSIntNestingCtr > 0u) {                                 /* See if trying to call from an ISR                    */
    607                 *p_err = OS_ERR_TMR_ISR;
    608                  return (DEF_FALSE);
    609              }
    610          #endif
    611          
    612          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
    613              if (OSRunning != OS_STATE_OS_RUNNING) {
    614                 *p_err = OS_ERR_OS_NOT_RUNNING;
    615                  return (DEF_FALSE);
    616              }
    617          #endif
    618          
    619          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
    620              if (p_tmr == DEF_NULL) {
    621                 *p_err = OS_ERR_TMR_INVALID;
    622                  return (DEF_FALSE);
    623              }
    624          #endif
    625          
    626          #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
    627              if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                       /* Make sure timer was created                          */
    628                 *p_err = OS_ERR_OBJ_TYPE;
    629                  return (DEF_FALSE);
    630              }
    631          #endif
    632          
    633              OS_TmrLock();
    634          
    635              switch (p_tmr->State) {
    636                  case OS_TMR_STATE_RUNNING:                              /* Restart the timer                                    */
    637                       if (p_tmr->Dly == 0u) {
    638                           p_tmr->Remain = p_tmr->Period;
    639                       } else {
    640                           p_tmr->Remain = p_tmr->Dly;
    641                       }
    642                      *p_err         = OS_ERR_NONE;
    643                       success       = DEF_TRUE;
    644                       break;
    645          
    646                  case OS_TMR_STATE_STOPPED:                              /* Start the timer                                      */
    647                  case OS_TMR_STATE_COMPLETED:
    648                       p_tmr->State  = OS_TMR_STATE_RUNNING;
    649                       if (p_tmr->Dly == 0u) {
    650                           p_tmr->Remain = p_tmr->Period;
    651                       } else {
    652                           p_tmr->Remain = p_tmr->Dly;
    653                       }
    654                       if (OSTmrListPtr ==  DEF_NULL) {                   /* Link into timer list                                 */
    655                           p_tmr->NextPtr   = DEF_NULL;                   /* This is the first timer in the list                  */
    656                           p_tmr->PrevPtr   = DEF_NULL;
    657                           OSTmrListPtr     = p_tmr;
    658          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    659                           OSTmrListEntries = 1u;
    660          #endif
    661                       } else {
    662                           p_next           = OSTmrListPtr;               /* Insert at the beginning of the list                  */
    663                           p_tmr->NextPtr   = OSTmrListPtr;
    664                           p_tmr->PrevPtr   = DEF_NULL;
    665                           p_next->PrevPtr  = p_tmr;
    666                           OSTmrListPtr     = p_tmr;
    667          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    668                           OSTmrListEntries++;
    669          #endif
    670                       }
    671                      *p_err   = OS_ERR_NONE;
    672                       success = DEF_TRUE;
    673                       break;
    674          
    675                  case OS_TMR_STATE_UNUSED:                               /* Timer not created                                    */
    676                      *p_err   = OS_ERR_TMR_INACTIVE;
    677                       success = DEF_FALSE;
    678                       break;
    679          
    680                  default:
    681                      *p_err = OS_ERR_TMR_INVALID_STATE;
    682                       success = DEF_FALSE;
    683                       break;
    684              }
    685          
    686              OS_TmrUnlock();
    687          
    688              return (success);
    689          }
    690          
    691          
    692          /*
    693          ************************************************************************************************************************
    694          *                                           FIND OUT WHAT STATE A TIMER IS IN
    695          *
    696          * Description: This function is called to determine what state the timer is in:
    697          *
    698          *                  OS_TMR_STATE_UNUSED     the timer has not been created
    699          *                  OS_TMR_STATE_STOPPED    the timer has been created but has not been started or has been stopped
    700          *                  OS_TMR_STATE_COMPLETED  the timer is in ONE-SHOT mode and has completed it's timeout
    701          *                  OS_TMR_SATE_RUNNING     the timer is currently running
    702          *
    703          * Arguments  : p_tmr    Is a pointer to the desired timer
    704          *
    705          *              p_err    Is a pointer to an error code.  '*p_err' will contain one of the following:
    706          *
    707          *                           OS_ERR_NONE               The return value reflects the state of the timer
    708          *                           OS_ERR_OBJ_TYPE           If 'p_tmr' is not pointing to a timer
    709          *                           OS_ERR_OS_NOT_RUNNING     If uC/OS-III is not running yet
    710          *                           OS_ERR_TMR_INVALID        If 'p_tmr' is a NULL pointer
    711          *                           OS_ERR_TMR_INVALID_STATE  If the timer is not in a valid state
    712          *                           OS_ERR_TMR_ISR            If the call was made from an ISR
    713          *
    714          * Returns    : The current state of the timer (see description).
    715          *
    716          * Note(s)    : none
    717          ************************************************************************************************************************
    718          */
    719          
    720          OS_STATE  OSTmrStateGet (OS_TMR  *p_tmr,
    721                                   OS_ERR  *p_err)
    722          {
    723              OS_STATE  state;
    724          
    725          
    726          
    727          #ifdef OS_SAFETY_CRITICAL
    728              if (p_err == DEF_NULL) {
    729                  OS_SAFETY_CRITICAL_EXCEPTION();
    730                  return (OS_TMR_STATE_UNUSED);
    731              }
    732          #endif
    733          
    734          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
    735              if (OSIntNestingCtr > 0u) {                                 /* See if trying to call from an ISR                    */
    736                 *p_err = OS_ERR_TMR_ISR;
    737                  return (OS_TMR_STATE_UNUSED);
    738              }
    739          #endif
    740          
    741          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
    742              if (OSRunning != OS_STATE_OS_RUNNING) {
    743                 *p_err = OS_ERR_OS_NOT_RUNNING;
    744                  return (OS_TMR_STATE_UNUSED);
    745              }
    746          #endif
    747          
    748          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
    749              if (p_tmr == DEF_NULL) {
    750                 *p_err = OS_ERR_TMR_INVALID;
    751                  return (OS_TMR_STATE_UNUSED);
    752              }
    753          #endif
    754          
    755          #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
    756              if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                       /* Make sure timer was created                          */
    757                 *p_err = OS_ERR_OBJ_TYPE;
    758                  return (OS_TMR_STATE_UNUSED);
    759              }
    760          #endif
    761          
    762              OS_TmrLock();
    763          
    764              state = p_tmr->State;
    765              switch (state) {
    766                  case OS_TMR_STATE_UNUSED:
    767                  case OS_TMR_STATE_STOPPED:
    768                  case OS_TMR_STATE_COMPLETED:
    769                  case OS_TMR_STATE_RUNNING:
    770                      *p_err = OS_ERR_NONE;
    771                       break;
    772          
    773                  default:
    774                      *p_err = OS_ERR_TMR_INVALID_STATE;
    775                       break;
    776              }
    777          
    778              OS_TmrUnlock();
    779          
    780              return (state);
    781          }
    782          
    783          
    784          /*
    785          ************************************************************************************************************************
    786          *                                                    STOP A TIMER
    787          *
    788          * Description: This function is called by your application code to stop a timer.
    789          *
    790          * Arguments  : p_tmr          Is a pointer to the timer to stop.
    791          *
    792          *              opt            Allows you to specify an option to this functions which can be:
    793          *
    794          *                               OS_OPT_TMR_NONE            Do nothing special but stop the timer
    795          *                               OS_OPT_TMR_CALLBACK        Execute the callback function, pass it the callback argument
    796          *                                                          specified when the timer was created.
    797          *                               OS_OPT_TMR_CALLBACK_ARG    Execute the callback function, pass it the callback argument
    798          *                                                          specified in THIS function call
    799          *
    800          *              callback_arg   Is a pointer to a 'new' callback argument that can be passed to the callback function
    801          *                               instead of the timer's callback argument.  In other words, use 'callback_arg' passed in
    802          *                               THIS function INSTEAD of p_tmr->OSTmrCallbackArg
    803          *
    804          *              p_err          Is a pointer to an error code.  '*p_err' will contain one of the following:
    805          *
    806          *                               OS_ERR_NONE                The timer has stopped
    807          *                               OS_ERR_OBJ_TYPE            If 'p_tmr' is not pointing to a timer
    808          *                               OS_ERR_OPT_INVALID         If you specified an invalid option for 'opt'
    809          *                               OS_ERR_OS_NOT_RUNNING      If uC/OS-III is not running yet
    810          *                               OS_ERR_TMR_INACTIVE        If the timer was not created
    811          *                               OS_ERR_TMR_INVALID         If 'p_tmr' is a NULL pointer
    812          *                               OS_ERR_TMR_INVALID_STATE   The timer is in an invalid state
    813          *                               OS_ERR_TMR_ISR             If the function was called from an ISR
    814          *                               OS_ERR_TMR_NO_CALLBACK     If the timer does not have a callback function defined
    815          *                               OS_ERR_TMR_STOPPED         If the timer was already stopped
    816          *
    817          * Returns    : DEF_TRUE       If we stopped the timer (if the timer is already stopped, we also return DEF_TRUE)
    818          *              DEF_FALSE      If not
    819          *
    820          * Note(s)    : none
    821          ************************************************************************************************************************
    822          */
    823          
    824          CPU_BOOLEAN  OSTmrStop (OS_TMR  *p_tmr,
    825                                  OS_OPT   opt,
    826                                  void    *p_callback_arg,
    827                                  OS_ERR  *p_err)
    828          {
    829              OS_TMR_CALLBACK_PTR  p_fnct;
    830              CPU_BOOLEAN          success;
    831          
    832          
    833          
    834          #ifdef OS_SAFETY_CRITICAL
    835              if (p_err == DEF_NULL) {
    836                  OS_SAFETY_CRITICAL_EXCEPTION();
    837                  return (DEF_FALSE);
    838              }
    839          #endif
    840          
    841          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
    842              if (OSIntNestingCtr > 0u) {                                 /* See if trying to call from an ISR                    */
    843                 *p_err = OS_ERR_TMR_ISR;
    844                  return (DEF_FALSE);
    845              }
    846          #endif
    847          
    848          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
    849              if (OSRunning != OS_STATE_OS_RUNNING) {
    850                 *p_err = OS_ERR_OS_NOT_RUNNING;
    851                  return (DEF_FALSE);
    852              }
    853          #endif
    854          
    855          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
    856              if (p_tmr == DEF_NULL) {
    857                 *p_err = OS_ERR_TMR_INVALID;
    858                  return (DEF_FALSE);
    859              }
    860          #endif
    861          
    862          #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
    863              if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                       /* Make sure timer was created                          */
    864                 *p_err = OS_ERR_OBJ_TYPE;
    865                  return (DEF_FALSE);
    866              }
    867          #endif
    868          
    869              OS_TmrLock();
    870          
    871              switch (p_tmr->State) {
    872                  case OS_TMR_STATE_RUNNING:
    873                      *p_err = OS_ERR_NONE;
    874                       switch (opt) {
    875                           case OS_OPT_TMR_CALLBACK:
    876                                OS_TmrUnlink(p_tmr);                      /* Remove from timer list                               */
    877                                p_fnct = p_tmr->CallbackPtr;              /* Execute callback function ...                        */
    878                                if (p_fnct != DEF_NULL) {                 /* ... if available                                     */
    879                                  (*p_fnct)(p_tmr, p_tmr->CallbackPtrArg);/* Use callback arg when timer was created     */
    880                                } else {
    881                                   *p_err = OS_ERR_TMR_NO_CALLBACK;
    882                                }
    883                                break;
    884          
    885                           case OS_OPT_TMR_CALLBACK_ARG:
    886                                OS_TmrUnlink(p_tmr);                      /* Remove from timer list                               */
    887                                p_fnct = p_tmr->CallbackPtr;              /* Execute callback function if available ...           */
    888                                if (p_fnct != DEF_NULL) {
    889                                  (*p_fnct)(p_tmr, p_callback_arg);       /* .. using the 'callback_arg' provided in call       */
    890                                } else {
    891                                   *p_err = OS_ERR_TMR_NO_CALLBACK;
    892                                }
    893                                break;
    894          
    895                           case OS_OPT_TMR_NONE:
    896                                OS_TmrUnlink(p_tmr);                      /* Remove from timer list                               */
    897                                break;
    898          
    899                           default:
    900                               OS_TmrUnlock();
    901                              *p_err = OS_ERR_OPT_INVALID;
    902                               return (DEF_FALSE);
    903                       }
    904                       success = DEF_TRUE;
    905                       break;
    906          
    907                  case OS_TMR_STATE_COMPLETED:                            /* Timer has already completed the ONE-SHOT or          */
    908                  case OS_TMR_STATE_STOPPED:                              /* ... timer has not started yet.                       */
    909                      *p_err   = OS_ERR_TMR_STOPPED;
    910                       success = DEF_TRUE;
    911                       break;
    912          
    913                  case OS_TMR_STATE_UNUSED:                               /* Timer was not created                                */
    914                      *p_err   = OS_ERR_TMR_INACTIVE;
    915                       success = DEF_FALSE;
    916                       break;
    917          
    918                  default:
    919                      *p_err   = OS_ERR_TMR_INVALID_STATE;
    920                       success = DEF_FALSE;
    921                       break;
    922              }
    923          
    924              OS_TmrUnlock();
    925          
    926              return (success);
    927          }
    928          
    929          
    930          /*
    931          ************************************************************************************************************************
    932          *                                                 CLEAR TIMER FIELDS
    933          *
    934          * Description: This function is called to clear all timer fields.
    935          *
    936          * Argument(s): p_tmr    Is a pointer to the timer to clear
    937          *              -----
    938          *
    939          * Returns    : none
    940          *
    941          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    942          ************************************************************************************************************************
    943          */
    944          
    945          void  OS_TmrClr (OS_TMR  *p_tmr)
    946          {
    947              p_tmr->State          = OS_TMR_STATE_UNUSED;                /* Clear timer fields                                   */
    948          #if (OS_OBJ_TYPE_REQ == DEF_ENABLED)
    949              p_tmr->Type           = OS_OBJ_TYPE_NONE;
    950          #endif
    951          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    952              p_tmr->NamePtr        = (CPU_CHAR *)((void *)"?TMR");
    953          #endif
    954              p_tmr->Dly            = 0u;
    955              p_tmr->Remain         = 0u;
    956              p_tmr->Period         = 0u;
    957              p_tmr->Opt            = 0u;
    958              p_tmr->CallbackPtr    = DEF_NULL;
    959              p_tmr->CallbackPtrArg = DEF_NULL;
    960              p_tmr->NextPtr        = DEF_NULL;
    961              p_tmr->PrevPtr        = DEF_NULL;
    962          }
    963          
    964          
    965          /*
    966          ************************************************************************************************************************
    967          *                                         ADD/REMOVE TIMER TO/FROM DEBUG TABLE
    968          *
    969          * Description: These functions are called by uC/OS-III to add or remove a timer to/from a timer debug table.
    970          *
    971          * Arguments  : p_tmr     is a pointer to the timer to add/remove
    972          *
    973          * Returns    : none
    974          *
    975          * Note(s)    : These functions are INTERNAL to uC/OS-III and your application should not call it.
    976          ************************************************************************************************************************
    977          */
    978          
    979          
    980          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    981          void  OS_TmrDbgListAdd (OS_TMR  *p_tmr)
    982          {
    983              p_tmr->DbgPrevPtr               = DEF_NULL;
    984              if (OSTmrDbgListPtr == DEF_NULL) {
    985                  p_tmr->DbgNextPtr           = DEF_NULL;
    986              } else {
    987                  p_tmr->DbgNextPtr           =  OSTmrDbgListPtr;
    988                  OSTmrDbgListPtr->DbgPrevPtr =  p_tmr;
    989              }
    990              OSTmrDbgListPtr                 =  p_tmr;
    991          }
    992          
    993          
    994          
    995          void  OS_TmrDbgListRemove (OS_TMR  *p_tmr)
    996          {
    997              OS_TMR  *p_tmr_next;
    998              OS_TMR  *p_tmr_prev;
    999          
   1000          
   1001              p_tmr_prev = p_tmr->DbgPrevPtr;
   1002              p_tmr_next = p_tmr->DbgNextPtr;
   1003          
   1004              if (p_tmr_prev == DEF_NULL) {
   1005                  OSTmrDbgListPtr = p_tmr_next;
   1006                  if (p_tmr_next != DEF_NULL) {
   1007                      p_tmr_next->DbgPrevPtr = DEF_NULL;
   1008                  }
   1009                  p_tmr->DbgNextPtr = DEF_NULL;
   1010          
   1011              } else if (p_tmr_next == DEF_NULL) {
   1012                  p_tmr_prev->DbgNextPtr = DEF_NULL;
   1013                  p_tmr->DbgPrevPtr      = DEF_NULL;
   1014          
   1015              } else {
   1016                  p_tmr_prev->DbgNextPtr = p_tmr_next;
   1017                  p_tmr_next->DbgPrevPtr = p_tmr_prev;
   1018                  p_tmr->DbgNextPtr      = DEF_NULL;
   1019                  p_tmr->DbgPrevPtr      = DEF_NULL;
   1020              }
   1021          }
   1022          #endif
   1023          
   1024          
   1025          /*
   1026          ************************************************************************************************************************
   1027          *                                             INITIALIZE THE TIMER MANAGER
   1028          *
   1029          * Description: This function is called by OSInit() to initialize the timer manager module.
   1030          *
   1031          * Argument(s): p_err    is a pointer to a variable that will contain an error code returned by this function.
   1032          *
   1033          *                           OS_ERR_NONE
   1034          *                           OS_ERR_TMR_STK_INVALID       if you didn't specify a stack for the timer task
   1035          *                           OS_ERR_TMR_STK_SIZE_INVALID  if you didn't allocate enough space for the timer stack
   1036          *                           OS_ERR_PRIO_INVALID          if you specified the same priority as the idle task
   1037          *                           OS_ERR_xxx                   any error code returned by OSTaskCreate()
   1038          *
   1039          * Returns    : none
   1040          *
   1041          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1042          ************************************************************************************************************************
   1043          */
   1044          
   1045          void  OS_TmrInit (OS_ERR  *p_err)
   1046          {
   1047          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   1048              OSTmrDbgListPtr = DEF_NULL;
   1049          #endif
   1050          
   1051              OSTmrListPtr        = DEF_NULL;                             /* Create an empty timer list                           */
   1052          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   1053              OSTmrListEntries    = 0u;
   1054          #endif
   1055          
   1056              if (OSCfg_TmrTaskRate_Hz > 0u) {
   1057                  OSTmrUpdateCnt  = OSCfg_TickRate_Hz / OSCfg_TmrTaskRate_Hz;
   1058              } else {
   1059                  OSTmrUpdateCnt  = OSCfg_TickRate_Hz / 10u;
   1060              }
   1061              OSTmrUpdateCtr      = OSTmrUpdateCnt;
   1062          
   1063              OSTmrTickCtr        = 0u;
   1064          
   1065          #if (OS_CFG_TS_EN == DEF_ENABLED)
   1066              OSTmrTaskTimeMax    = 0u;
   1067          #endif
   1068          
   1069          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
   1070              OSMutexCreate(&OSTmrMutex,                                  /* Use a mutex to protect the timers                    */
   1071                            (CPU_CHAR *)"OS Tmr Mutex",
   1072                            p_err);
   1073              if (*p_err != OS_ERR_NONE) {
   1074                  return;
   1075              }
   1076          #endif
   1077          
   1078                                                                          /* -------------- CREATE THE TIMER TASK --------------- */
   1079              if (OSCfg_TmrTaskStkBasePtr == DEF_NULL) {
   1080                 *p_err = OS_ERR_TMR_STK_INVALID;
   1081                  return;
   1082              }
   1083          
   1084              if (OSCfg_TmrTaskStkSize < OSCfg_StkSizeMin) {
   1085                 *p_err = OS_ERR_TMR_STK_SIZE_INVALID;
   1086                  return;
   1087              }
   1088          
   1089              if (OSCfg_TmrTaskPrio >= (OS_CFG_PRIO_MAX - 1u)) {
   1090                 *p_err = OS_ERR_TMR_PRIO_INVALID;
   1091                  return;
   1092              }
   1093          
   1094              OSTaskCreate(&OSTmrTaskTCB,
   1095                           (CPU_CHAR   *)"uC/OS-III Timer Task",
   1096                           OS_TmrTask,
   1097                           DEF_NULL,
   1098                           OSCfg_TmrTaskPrio,
   1099                           OSCfg_TmrTaskStkBasePtr,
   1100                           OSCfg_TmrTaskStkLimit,
   1101                           OSCfg_TmrTaskStkSize,
   1102                           0u,
   1103                           0u,
   1104                           DEF_NULL,
   1105                           (OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR | OS_OPT_TASK_NO_TLS),
   1106                           p_err);
   1107          }
   1108          
   1109          
   1110          /*
   1111          ************************************************************************************************************************
   1112          *                                         REMOVE A TIMER FROM THE TIMER LIST
   1113          *
   1114          * Description: This function is called to remove the timer from the timer list.
   1115          *
   1116          * Arguments  : p_tmr          Is a pointer to the timer to remove.
   1117          *              -----
   1118          *
   1119          * Returns    : none
   1120          *
   1121          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1122          ************************************************************************************************************************
   1123          */
   1124          
   1125          void  OS_TmrUnlink (OS_TMR  *p_tmr)
   1126          {
   1127              OS_TMR  *p_tmr1;
   1128              OS_TMR  *p_tmr2;
   1129          
   1130          
   1131              if (OSTmrListPtr == p_tmr) {                                /* See if timer to remove is at the beginning of list   */
   1132                  p_tmr1       = p_tmr->NextPtr;
   1133                  OSTmrListPtr = p_tmr1;
   1134                  if (p_tmr1 != DEF_NULL) {
   1135                      p_tmr1->PrevPtr = DEF_NULL;
   1136                  }
   1137              } else {
   1138                  p_tmr1          = p_tmr->PrevPtr;                       /* Remove timer from somewhere in the list              */
   1139                  p_tmr2          = p_tmr->NextPtr;
   1140                  p_tmr1->NextPtr = p_tmr2;
   1141                  if (p_tmr2 != DEF_NULL) {
   1142                      p_tmr2->PrevPtr = p_tmr1;
   1143                  }
   1144              }
   1145              p_tmr->State   = OS_TMR_STATE_STOPPED;
   1146              p_tmr->NextPtr = DEF_NULL;
   1147              p_tmr->PrevPtr = DEF_NULL;
   1148          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   1149              OSTmrListEntries--;
   1150          #endif
   1151          }
   1152          
   1153          
   1154          /*
   1155          ************************************************************************************************************************
   1156          *                                                 TIMER MANAGEMENT TASK
   1157          *
   1158          * Description: This task is created by OS_TmrInit().
   1159          *
   1160          * Arguments  : none
   1161          *
   1162          * Returns    : none
   1163          *
   1164          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1165          ************************************************************************************************************************
   1166          */
   1167          
   1168          void  OS_TmrTask (void  *p_arg)
   1169          {
   1170              OS_ERR               err;
   1171              OS_TMR_CALLBACK_PTR  p_fnct;
   1172              OS_TMR              *p_tmr;
   1173              OS_TMR              *p_tmr_next;
   1174          #if (OS_CFG_DYN_TICK_EN != DEF_ENABLED)
   1175              CPU_TS               ts;
   1176          #endif
   1177          #if (OS_CFG_TS_EN == DEF_ENABLED)
   1178              CPU_TS               ts_start;
   1179              CPU_TS               ts_delta;
   1180          #endif
   1181          
   1182          
   1183          
   1184              (void)p_arg;                                                /* Not using 'p_arg', prevent compiler warning          */
   1185              for (;;) {
   1186          #if (OS_CFG_DYN_TICK_EN != DEF_ENABLED)
   1187                  (void)OSTaskSemPend( 0u,                                /* Wait for signal indicating time to update tmrs       */
   1188                                       OS_OPT_PEND_BLOCKING,
   1189                                      &ts,
   1190                                      &err);
   1191                  (void)err;
   1192          #else
   1193                  OSTimeDly(OSTmrUpdateCnt, OS_OPT_TIME_DLY, &err);
   1194                  (void)err;
   1195          #endif
   1196          
   1197          
   1198                  OS_TmrLock();
   1199          #if (OS_CFG_TS_EN == DEF_ENABLED)
   1200                  ts_start = OS_TS_GET();
   1201          #endif
   1202                  OSTmrTickCtr++;                                         /* Increment the current time                           */
   1203                  p_tmr    = OSTmrListPtr;
   1204                  while (p_tmr != DEF_NULL) {                             /* Update all the timers in the list                    */
   1205                      OSSchedLock(&err);
   1206                      (void)err;
   1207                      p_tmr_next = p_tmr->NextPtr;
   1208                      p_tmr->Remain--;
   1209                      if (p_tmr->Remain == 0u) {
   1210                          if (p_tmr->Opt == OS_OPT_TMR_PERIODIC) {
   1211                              p_tmr->Remain = p_tmr->Period;              /* Reload the time remaining                            */
   1212                          } else {
   1213                              OS_TmrUnlink(p_tmr);                        /* Remove from list                                     */
   1214                              p_tmr->State = OS_TMR_STATE_COMPLETED;      /* Indicate that the timer has completed                */
   1215                          }
   1216                          p_fnct = p_tmr->CallbackPtr;                    /* Execute callback function if available               */
   1217                          if (p_fnct != (OS_TMR_CALLBACK_PTR)0u) {
   1218                              (*p_fnct)(p_tmr, p_tmr->CallbackPtrArg);
   1219                          }
   1220                      }
   1221                      p_tmr = p_tmr_next;
   1222                      OSSchedUnlock(&err);
   1223                      (void)err;
   1224                  }
   1225          
   1226          #if (OS_CFG_TS_EN == DEF_ENABLED)
   1227                  ts_delta = OS_TS_GET() - ts_start;                      /* Measure execution time of timer task                 */
   1228                  if (OSTmrTaskTimeMax < ts_delta) {
   1229                      OSTmrTaskTimeMax = ts_delta;
   1230                  }
   1231          #endif
   1232          
   1233                  OS_TmrUnlock();
   1234              }
   1235          }
   1236          
   1237          
   1238          /*
   1239          ************************************************************************************************************************
   1240          *                                          TIMER MANAGEMENT LOCKING MECHANISM
   1241          *
   1242          * Description: These functions are use to handle timer critical sections.  The preferred method is to use a mutex in
   1243          *              order to avoid locking the scheduler and also, to avoid calling callback functions while the scheduler is
   1244          *              locked.
   1245          *
   1246          * Arguments  : none
   1247          *
   1248          * Returns    : none
   1249          *
   1250          * Note(s)    : 1) These function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1251          ************************************************************************************************************************
   1252          */
   1253          
   1254          static  void  OS_TmrLock (void)
   1255          {
   1256              OS_ERR  err;
   1257          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
   1258              CPU_TS  ts;
   1259          
   1260          
   1261              OSMutexPend(&OSTmrMutex,                                    /* Use a mutex to protect the timers                    */
   1262                          0u,
   1263                          OS_OPT_PEND_BLOCKING,
   1264                          &ts,
   1265                          &err);
   1266          #else
   1267              OSSchedLock(&err);                                          /* Lock the scheduler to protect the timers             */
   1268          #endif
   1269              (void)err;
   1270          }
   1271          
   1272          
   1273          
   1274          
   1275          static  void  OS_TmrUnlock (void)
   1276          {
   1277              OS_ERR  err;
   1278          
   1279          
   1280          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
   1281              OSMutexPost(&OSTmrMutex,                                    /* Use a mutex to protect the timers                    */
   1282                           OS_OPT_POST_NONE,
   1283                          &err);
   1284          #else
   1285              OSSchedUnlock(&err);                                        /* Lock the scheduler to protect the timers             */
   1286          #endif
   1287              (void)err;
   1288          }
   1289          
   1290          #endif


 

 


Errors: none
Warnings: none
