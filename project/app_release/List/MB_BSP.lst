###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       15/Jul/2018  10:36:23
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC210\NC210-200处理板\source\Software\uC-MB\Ports\STM32\STM32F103\IAR\MB_BSP.C
#    Command line =  
#        F:\iar\NC210\NC210-200处理板\source\Software\uC-MB\Ports\STM32\STM32F103\IAR\MB_BSP.C
#        -D USE_STDPERIPH_DRIVER -D APP_RELEASE -lCN
#        F:\iar\NC210\NC210-200处理板\project\app_release\List -o
#        F:\iar\NC210\NC210-200处理板\project\app_release\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC210\NC210-200处理板\project\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\config\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\task\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\user\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\OS\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\Ports\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\driver\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-LIB\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Source\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\ST\STM32\inc\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Ports\STM32\STM32F103\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Source\
#        -Ol --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC210\NC210-200处理板\project\app_release\List\MB_BSP.lst
#    Object file  =  
#        F:\iar\NC210\NC210-200处理板\project\app_release\Obj\MB_BSP.o
#
###############################################################################

F:\iar\NC210\NC210-200处理板\source\Software\uC-MB\Ports\STM32\STM32F103\IAR\MB_BSP.C
      1          /*
      2          *********************************************************************************************************
      3          *                                              uC/Modbus
      4          *                                       The Embedded Modbus Stack
      5          *
      6          *                          (c) Copyright 2003-2009; Micrium, Inc.; Weston, FL               
      7          *
      8          *               All rights reserved.  Protected by international copyright laws.
      9          *               Knowledge of the source code may NOT be used to develop a similar product.
     10          *               Please help us continue to provide the Embedded community with the finest
     11          *               software available.  Your honesty is greatly appreciated.
     12          *********************************************************************************************************
     13          */
     14          
     15          /*
     16          *********************************************************************************************************
     17          *
     18          *                                            uC/Modbus
     19          *
     20          *                                      MODBUS BOARD SUPPORT PACKAGE
     21          *                                         Philips LPC2000 (ARM7)
     22          *
     23          * Filename    : mb_bsp.c
     24          * Version     : V2.12
     25          * Programmers : JJL
     26          *********************************************************************************************************
     27          */
     28          
     29          /*
     30          *********************************************************************************************************
     31          *                                            INCLUDE FILES
     32          *********************************************************************************************************
     33          */
     34          #include <includes.h>
     35          
     36          /*
     37          *********************************************************************************************************
     38          *                                            LOCAL DEFINES 
     39          *********************************************************************************************************
     40          */
     41          
     42          #define  BIT0                       0x01
     43          #define  BIT1                       0x02
     44          #define  BIT2                       0x04
     45          #define  BIT3                       0x08
     46          #define  BIT4                       0x10
     47          #define  BIT5                       0x20
     48          #define  BIT6                       0x40
     49          #define  BIT7                       0x80
     50          
     51          #define UARAT_CFG_MAX_PORT          5           // 定义最大串口数量
     52          /***********************************************
     53          * 描述： 
     54          */
     55          #define  BSP_COM1_TXD               DEF_BIT_09
     56          #define  BSP_COM1_RXD               DEF_BIT_10
     57          
     58          #define  BSP_COM2_TXD               DEF_BIT_02
     59          #define  BSP_COM2_RXD               DEF_BIT_03
     60          
     61          #define  BSP_COM3_TXD               DEF_BIT_02
     62          #define  BSP_COM3_RXD               DEF_BIT_03
     63          
     64          /***********************************************
     65          * 描述： 
     66          */
     67          #define  BSP_COM1_REN               DEF_ENABLED
     68          #define  BSP_COM2_REN               DEF_ENABLED
     69          #define  BSP_COM3_REN               DEF_DISABLED
     70          #define  BSP_COM4_REN               DEF_ENABLED
     71          
     72          /***********************************************
     73          * 描述： 
     74          */
     75          #if (BSP_COM1_REN == DEF_ENABLED)
     76          #define MBREN1_GPIO_PIN        GPIO_Pin_8             /* PA.08 */
     77          #define MBREN1_GPIO_PORT       GPIOA
     78          #define MBREN1_GPIO_RCC        RCC_APB2Periph_GPIOA
     79          #endif
     80          
     81          #if (BSP_COM2_REN == DEF_ENABLED)
     82          #define MBREN2_GPIO_PIN        GPIO_Pin_1             /* PA.01 */
     83          #define MBREN2_GPIO_PORT       GPIOA
     84          #define MBREN2_GPIO_RCC        RCC_APB2Periph_GPIOA
     85          #endif
     86          
     87          #if (BSP_COM3_REN == DEF_ENABLED)
     88          #define MBREN3_GPIO_PIN        GPIO_Pin_15             /* PE.15 */
     89          #define MBREN3_GPIO_PORT       GPIOE
     90          #define MBREN3_GPIO_RCC        RCC_APB2Periph_GPIOE
     91          #endif
     92          
     93          #if (BSP_COM4_REN == DEF_ENABLED)
     94          #define MBREN4_GPIO_PIN        GPIO_Pin_12             /* PC.12 */
     95          #define MBREN4_GPIO_PORT       GPIOC
     96          #define MBREN4_GPIO_RCC        RCC_APB2Periph_GPIOC
     97          #endif
     98          /*
     99          *********************************************************************************************************
    100          *                                             LOCAL VARIABLES
    101          *********************************************************************************************************
    102          */
    103          

   \                                 In section .bss, align 4
    104          static          CPU_INT32U  MB_Tmr_ReloadCnts;
   \                     MB_Tmr_ReloadCnts:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    105          static          MODBUS_CH  *MB_ChPortMap[UARAT_CFG_MAX_PORT] = {NULL,NULL,NULL,NULL,NULL};
   \                     MB_ChPortMap:
   \   00000000                      DS8 20
    106          
    107          void            USART1_RxTxISRHandler   (void);
    108          void            USART2_RxTxISRHandler   (void);
    109          void            USART3_RxTxISRHandler   (void);
    110          void            USART4_RxTxISRHandler   (void);
    111          void            USARTx_RxTxISRHandler   (MODBUS_CH *pch);
    112          
    113          /*$PAGE*/
    114          /*
    115          *********************************************************************************************************
    116          *                                             MB_CommExit()
    117          *
    118          * Description : This function is called to terminate Modbus communications.  All Modbus channels are close.
    119          *
    120          * Argument(s) : none
    121          *
    122          * Return(s)   : none.
    123          *
    124          * Caller(s)   : MB_Exit()
    125          *
    126          * Note(s)     : none.
    127          *********************************************************************************************************
    128          */

   \                                 In section .text, align 2, keep-with-next
    129          void  MB_CommExit (void)
    130          {
   \                     MB_CommExit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    131              CPU_INT08U   ch;
    132              MODBUS_CH   *pch;
    133          
    134          
    135              pch = &MB_ChTbl[0];
   \   00000002   0x.... 0x....      LDR.W    R5,??DataTable13
    136              for (ch = 0; ch < MODBUS_CFG_MAX_CH; ch++) {
   \   00000006   0x2400             MOVS     R4,#+0
   \   00000008   0xE008             B.N      ??MB_CommExit_0
    137                  MB_CommTxIntDis(pch);
   \                     ??MB_CommExit_1: (+1)
   \   0000000A   0x0028             MOVS     R0,R5
   \   0000000C   0x.... 0x....      BL       MB_CommTxIntDis
    138                  MB_CommRxIntDis(pch);
   \   00000010   0x0028             MOVS     R0,R5
   \   00000012   0x.... 0x....      BL       MB_CommRxIntDis
    139                  pch++;
   \   00000016   0xF605 0x0568      ADDW     R5,R5,#+2152
    140              }
   \   0000001A   0x1C64             ADDS     R4,R4,#+1
   \                     ??MB_CommExit_0: (+1)
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x2C04             CMP      R4,#+4
   \   00000020   0xDBF3             BLT.N    ??MB_CommExit_1
    141          }
   \   00000022   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    142          
    143          /*$PAGE*/
    144          /*
    145          *********************************************************************************************************
    146          *                                           MB_CommPortCfg()
    147          *
    148          * Description : This function initializes the serial port to the desired baud rate and the UART will be
    149          *               configured for N, 8, 1 (No parity, 8 bits, 1 stop).
    150          *
    151          * Argument(s) : pch        is a pointer to the Modbus channel
    152          *               port_nbr   is the desired serial port number.  This argument allows you to assign a
    153          *                          specific serial port to a sepcific Modbus channel.
    154          *               baud       is the desired baud rate for the serial port.
    155          *               parity     is the desired parity and can be either:
    156          *
    157          *                          MODBUS_PARITY_NONE
    158          *                          MODBUS_PARITY_ODD
    159          *                          MODBUS_PARITY_EVEN
    160          *
    161          *               bits       specifies the number of bit and can be either 7 or 8.
    162          *               stops      specifies the number of stop bits and can either be 1 or 2
    163          *
    164          * Return(s)   : none.
    165          *
    166          * Caller(s)   : MB_CfgCh()
    167          *
    168          * Note(s)     : none.
    169          *********************************************************************************************************
    170          */

   \                                 In section .text, align 2, keep-with-next
    171          void  MB_CommPortCfg (MODBUS_CH  *pch,
    172                                CPU_INT08U  port_nbr,
    173                                CPU_INT32U  baud,
    174                                CPU_INT08U  bits,
    175                                CPU_INT08U  parity,
    176                                CPU_INT08U  stops)
    177          {
   \                     MB_CommPortCfg: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB086             SUB      SP,SP,#+24
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
    178              USART_InitTypeDef USART_InitStructure;
    179              GPIO_InitTypeDef  GPIO_InitStructure;
    180              CPU_INT16U        BSP_INT_ID_USARTx;
    181              USART_TypeDef*    USARTx;
    182              CPU_FNCT_VOID     USARTx_RxTxISRHandler;
    183              
    184              /***********************************************
    185              * 描述： 串口3引脚接到地，不能使用
    186              */
    187              if ( port_nbr >= UARAT_CFG_MAX_PORT )
   \   0000000E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000010   0x2D05             CMP      R5,#+5
   \   00000012   0xF280 0x809D      BGE.W    ??MB_CommPortCfg_0
    188                return;
    189              
    190              /***********************************************
    191              * 描述： 
    192              */
    193              switch ( port_nbr ) {
   \                     ??MB_CommPortCfg_1: (+1)
   \   00000016   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD008             BEQ.N    ??MB_CommPortCfg_2
   \   0000001C   0x2D02             CMP      R5,#+2
   \   0000001E   0xF000 0x80C3      BEQ.W    ??MB_CommPortCfg_3
   \   00000022   0xF0C0 0x8098      BCC.W    ??MB_CommPortCfg_4
   \   00000026   0x2D03             CMP      R5,#+3
   \   00000028   0xF000 0x80E9      BEQ.W    ??MB_CommPortCfg_5
   \   0000002C   0xE125             B.N      ??MB_CommPortCfg_6
    194              case 0:
    195                  USARTx                    = USART1;
   \                     ??MB_CommPortCfg_2: (+1)
   \   0000002E   0x.... 0x....      LDR.W    R8,??DataTable13_1  ;; 0x40013800
    196                  BSP_INT_ID_USARTx         = BSP_INT_ID_USART1;
   \   00000032   0xF05F 0x0925      MOVS     R9,#+37
    197                  USARTx_RxTxISRHandler     = USART1_RxTxISRHandler;
   \   00000036   0x.... 0x....      ADR.W    R10,USART1_RxTxISRHandler
    198                  
    199                  /* Enable USART1 clock */
    200                  RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
   \   0000003A   0x2101             MOVS     R1,#+1
   \   0000003C   0xF44F 0x4080      MOV      R0,#+16384
   \   00000040   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    201                  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
   \   00000044   0x2101             MOVS     R1,#+1
   \   00000046   0x2004             MOVS     R0,#+4
   \   00000048   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    202                  
    203                  /* Configure USART1 Rx (PA.10) as input floating */
    204                  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
   \   0000004C   0xF44F 0x6080      MOV      R0,#+1024
   \   00000050   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    205                  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
   \   00000054   0x2004             MOVS     R0,#+4
   \   00000056   0xF88D 0x0003      STRB     R0,[SP, #+3]
    206                  GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   0000005A   0x4669             MOV      R1,SP
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable13_2  ;; 0x40010800
   \   00000060   0x.... 0x....      BL       GPIO_Init
    207                  
    208                  /* Configure USART1 Tx (PA.09) as alternate function push-pull */
    209                  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
   \   00000064   0xF44F 0x7000      MOV      R0,#+512
   \   00000068   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    210                  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   0000006C   0x2003             MOVS     R0,#+3
   \   0000006E   0xF88D 0x0002      STRB     R0,[SP, #+2]
    211                  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
   \   00000072   0x2018             MOVS     R0,#+24
   \   00000074   0xF88D 0x0003      STRB     R0,[SP, #+3]
    212                  GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   00000078   0x4669             MOV      R1,SP
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable13_2  ;; 0x40010800
   \   0000007E   0x.... 0x....      BL       GPIO_Init
    213                  
    214                  /***********************************************
    215                  * 描述： 接收发送使能信号
    216                  */
    217          #if (BSP_COM1_REN == DEF_ENABLED)
    218                  RCC_APB2PeriphClockCmd(MBREN1_GPIO_RCC, ENABLE);
   \   00000082   0x2101             MOVS     R1,#+1
   \   00000084   0x2004             MOVS     R0,#+4
   \   00000086   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    219                  GPIO_InitStructure.GPIO_Pin   = MBREN1_GPIO_PIN;
   \   0000008A   0xF44F 0x7080      MOV      R0,#+256
   \   0000008E   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    220                  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000092   0x2003             MOVS     R0,#+3
   \   00000094   0xF88D 0x0002      STRB     R0,[SP, #+2]
    221                  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
   \   00000098   0x2010             MOVS     R0,#+16
   \   0000009A   0xF88D 0x0003      STRB     R0,[SP, #+3]
    222                  GPIO_Init(MBREN1_GPIO_PORT, &GPIO_InitStructure);
   \   0000009E   0x4669             MOV      R1,SP
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable13_2  ;; 0x40010800
   \   000000A4   0x.... 0x....      BL       GPIO_Init
    223                  
    224                  GPIO_ResetBits(MBREN1_GPIO_PORT, MBREN1_GPIO_PIN);  // 低电平接收使能 
   \   000000A8   0xF44F 0x7180      MOV      R1,#+256
   \   000000AC   0x.... 0x....      LDR.W    R0,??DataTable13_2  ;; 0x40010800
   \   000000B0   0x.... 0x....      BL       GPIO_ResetBits
    225          #endif
    226                  
    227                  break;
    228              case 1:
    229                  USARTx                    = USART2;
    230                  BSP_INT_ID_USARTx         = BSP_INT_ID_USART2;
    231                  USARTx_RxTxISRHandler     = USART2_RxTxISRHandler;
    232                  
    233                  /* Enable USART2 clock */
    234                  RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
    235                  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
    236                  
    237                  /* Configure USART1 Rx (PA.3) as input floating */
    238                  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
    239                  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    240                  GPIO_Init(GPIOA, &GPIO_InitStructure);
    241                  
    242                  /* Configure USART1 Tx (PA.2) as alternate function push-pull */
    243                  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
    244                  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    245                  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    246                  GPIO_Init(GPIOA, &GPIO_InitStructure);
    247                  
    248                  /***********************************************
    249                  * 描述： 接收发送使能信号
    250                  */
    251          //#if (BSP_COM2_REN == DEF_ENABLED)
    252          //        GPIO_InitTypeDef  GPIO_InitStructure;
    253          //        RCC_APB2PeriphClockCmd(MBREN2_GPIO_RCC, ENABLE);
    254          //        GPIO_InitStructure.GPIO_Pin   = MBREN2_GPIO_PIN;
    255          //        GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    256          //        GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
    257          //        GPIO_Init(MBREN2_GPIO_PORT, &GPIO_InitStructure);
    258          //        
    259          //        GPIO_ResetBits(MBREN2_GPIO_PORT, MBREN2_GPIO_PIN);  // 低电平接收使能  
    260          //#endif
    261                  break;
    262              case 2:
    263                  USARTx                    = USART3;
    264                  BSP_INT_ID_USARTx         = BSP_INT_ID_USART3;
    265                  USARTx_RxTxISRHandler     = USART3_RxTxISRHandler;
    266                  
    267                  /* Enable USART3 clock */
    268                  RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
    269                  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
    270                  
    271                  /* Configure USART1 Rx (PB.11) as input floating */
    272                  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
    273                  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    274                  GPIO_Init(GPIOB, &GPIO_InitStructure);
    275                  
    276                  /* Configure USART1 Tx (PB.10) as alternate function push-pull */
    277                  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    278                  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    279                  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    280                  GPIO_Init(GPIOB, &GPIO_InitStructure);
    281                  
    282                  /***********************************************
    283                  * 描述： 接收发送使能信号
    284                  */
    285          #if (BSP_COM3_REN == DEF_ENABLED)
    286                  RCC_APB2PeriphClockCmd(MBREN3_GPIO_RCC, ENABLE);
    287                  GPIO_InitStructure.GPIO_Pin   = MBREN3_GPIO_PIN;
    288                  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    289                  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
    290                  GPIO_Init(MBREN3_GPIO_PORT, &GPIO_InitStructure);
    291                  
    292                  GPIO_ResetBits(MBREN3_GPIO_PORT, MBREN3_GPIO_PIN);  // 低电平接收使能  
    293          #endif
    294                  break;
    295              case 3:
    296                  USARTx                    = UART4;
    297                  BSP_INT_ID_USARTx         = BSP_INT_ID_USART4;
    298                  USARTx_RxTxISRHandler     = USART4_RxTxISRHandler;
    299                  
    300                  /* Enable USART4 clock */
    301                  RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, ENABLE);
    302                  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
    303                  
    304                  /* Configure USART4 Rx (PC.11) as input floating */
    305                  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
    306                  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    307                  GPIO_Init(GPIOC, &GPIO_InitStructure);
    308                  
    309                  /* Configure USART4 Tx (PC.10) as alternate function push-pull */
    310                  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    311                  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    312                  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    313                  GPIO_Init(GPIOC, &GPIO_InitStructure);
    314                  
    315                  /***********************************************
    316                  * 描述： 接收发送使能信号
    317                  */
    318          #if (BSP_COM4_REN == DEF_ENABLED)
    319                  RCC_APB2PeriphClockCmd(MBREN4_GPIO_RCC, ENABLE);
    320                  GPIO_InitStructure.GPIO_Pin   = MBREN4_GPIO_PIN;
    321                  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    322                  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
    323                  GPIO_Init(MBREN4_GPIO_PORT, &GPIO_InitStructure);
    324                  
    325                  //GPIO_ResetBits(MBREN4_GPIO_PORT, MBREN4_GPIO_PIN);  // 低电平接收使能  
    326          #endif
    327                  break;
    328              default:
    329                  return;
    330              }
    331              
    332              /***********************************************
    333              * 描述： configuration
    334              */
    335              USART_InitStructure.USART_BaudRate              = baud;
   \                     ??MB_CommPortCfg_7: (+1)
   \   000000B4   0x9601             STR      R6,[SP, #+4]
    336              USART_InitStructure.USART_WordLength            = USART_WordLength_8b;
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    337              USART_InitStructure.USART_StopBits              = USART_StopBits_1;
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    338              USART_InitStructure.USART_Parity                = USART_Parity_No;
   \   000000C2   0x2000             MOVS     R0,#+0
   \   000000C4   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    339              USART_InitStructure.USART_HardwareFlowControl   = USART_HardwareFlowControl_None;
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0xF8AD 0x0010      STRH     R0,[SP, #+16]
    340              USART_InitStructure.USART_Mode                  = USART_Mode_Rx | USART_Mode_Tx;
   \   000000CE   0x200C             MOVS     R0,#+12
   \   000000D0   0xF8AD 0x000E      STRH     R0,[SP, #+14]
    341              
    342              /***********************************************
    343              * 描述： 
    344              */
    345              USART_DeInit(USARTx);
   \   000000D4   0x4640             MOV      R0,R8
   \   000000D6   0x.... 0x....      BL       USART_DeInit
    346              USART_Init(USARTx, &USART_InitStructure);
   \   000000DA   0xA901             ADD      R1,SP,#+4
   \   000000DC   0x4640             MOV      R0,R8
   \   000000DE   0x.... 0x....      BL       USART_Init
    347              
    348              /***********************************************
    349              * 描述： 
    350              */
    351              USART_ClearFlag(USARTx,USART_FLAG_TXE);
   \   000000E2   0x2180             MOVS     R1,#+128
   \   000000E4   0x4640             MOV      R0,R8
   \   000000E6   0x.... 0x....      BL       USART_ClearFlag
    352              USART_ClearFlag(USARTx,USART_FLAG_RXNE);
   \   000000EA   0x2120             MOVS     R1,#+32
   \   000000EC   0x4640             MOV      R0,R8
   \   000000EE   0x.... 0x....      BL       USART_ClearFlag
    353              USART_ClearFlag(USARTx,USART_FLAG_IDLE);
   \   000000F2   0x2110             MOVS     R1,#+16
   \   000000F4   0x4640             MOV      R0,R8
   \   000000F6   0x.... 0x....      BL       USART_ClearFlag
    354                
    355              /***********************************************
    356              * 描述： 
    357              */
    358              USART_ITConfig(USARTx, USART_IT_RXNE, ENABLE);
   \   000000FA   0x2201             MOVS     R2,#+1
   \   000000FC   0xF240 0x5125      MOVW     R1,#+1317
   \   00000100   0x4640             MOV      R0,R8
   \   00000102   0x.... 0x....      BL       USART_ITConfig
    359              USART_ITConfig(USARTx, USART_IT_TXE, DISABLE);
   \   00000106   0x2200             MOVS     R2,#+0
   \   00000108   0xF240 0x7127      MOVW     R1,#+1831
   \   0000010C   0x4640             MOV      R0,R8
   \   0000010E   0x.... 0x....      BL       USART_ITConfig
    360              //USART_ITConfig(USARTx, USART_IT_IDLE, ENABLE);
    361              
    362              /***********************************************
    363              * 描述： 
    364              */
    365              USART_Cmd(USARTx, ENABLE);
   \   00000112   0x2101             MOVS     R1,#+1
   \   00000114   0x4640             MOV      R0,R8
   \   00000116   0x.... 0x....      BL       USART_Cmd
    366              
    367              /***********************************************
    368              * 描述： 
    369              */
    370              BSP_IntVectSet(BSP_INT_ID_USARTx, USARTx_RxTxISRHandler);
   \   0000011A   0x4651             MOV      R1,R10
   \   0000011C   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000120   0x4648             MOV      R0,R9
   \   00000122   0x.... 0x....      BL       BSP_IntVectSet
    371              BSP_IntEn(BSP_INT_ID_USARTx);
   \   00000126   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   0000012A   0x4648             MOV      R0,R9
   \   0000012C   0x.... 0x....      BL       BSP_IntEn
    372              
    373              if (pch != (MODBUS_CH *)0) {
   \   00000130   0x2C00             CMP      R4,#+0
   \   00000132   0xD00D             BEQ.N    ??MB_CommPortCfg_8
    374                  pch->PortNbr            = port_nbr;                                 /* Store configuration in channel             */
   \   00000134   0x7265             STRB     R5,[R4, #+9]
    375                  pch->BaudRate           = baud;
   \   00000136   0x60E6             STR      R6,[R4, #+12]
    376                  pch->Parity             = parity;
   \   00000138   0x980E             LDR      R0,[SP, #+56]
   \   0000013A   0x7420             STRB     R0,[R4, #+16]
    377                  pch->Bits               = bits;
   \   0000013C   0x7467             STRB     R7,[R4, #+17]
    378                  pch->Stops              = stops;
   \   0000013E   0x980F             LDR      R0,[SP, #+60]
   \   00000140   0x74A0             STRB     R0,[R4, #+18]
    379                  pch->USARTx             = USARTx;        
   \   00000142   0xF8C4 0x8860      STR      R8,[R4, #+2144]
    380                  MB_ChPortMap[port_nbr]  = pch;
   \   00000146   0x.... 0x....      LDR.W    R0,??DataTable13_3
   \   0000014A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000014C   0xF840 0x4025      STR      R4,[R0, R5, LSL #+2]
    381              }
    382          }
   \                     ??MB_CommPortCfg_8: (+1)
   \                     ??MB_CommPortCfg_0: (+1)
   \   00000150   0xB006             ADD      SP,SP,#+24
   \   00000152   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   \                     ??MB_CommPortCfg_4: (+1)
   \   00000156   0x.... 0x....      LDR.W    R8,??DataTable13_4  ;; 0x40004400
   \   0000015A   0xF05F 0x0926      MOVS     R9,#+38
   \   0000015E   0x.... 0x....      ADR.W    R10,USART2_RxTxISRHandler
   \   00000162   0x2101             MOVS     R1,#+1
   \   00000164   0xF45F 0x3000      MOVS     R0,#+131072
   \   00000168   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
   \   0000016C   0x2101             MOVS     R1,#+1
   \   0000016E   0x2004             MOVS     R0,#+4
   \   00000170   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
   \   00000174   0x2008             MOVS     R0,#+8
   \   00000176   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   0000017A   0x2004             MOVS     R0,#+4
   \   0000017C   0xF88D 0x0003      STRB     R0,[SP, #+3]
   \   00000180   0x4669             MOV      R1,SP
   \   00000182   0x.... 0x....      LDR.W    R0,??DataTable13_2  ;; 0x40010800
   \   00000186   0x.... 0x....      BL       GPIO_Init
   \   0000018A   0x2004             MOVS     R0,#+4
   \   0000018C   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   00000190   0x2003             MOVS     R0,#+3
   \   00000192   0xF88D 0x0002      STRB     R0,[SP, #+2]
   \   00000196   0x2018             MOVS     R0,#+24
   \   00000198   0xF88D 0x0003      STRB     R0,[SP, #+3]
   \   0000019C   0x4669             MOV      R1,SP
   \   0000019E   0x.... 0x....      LDR.W    R0,??DataTable13_2  ;; 0x40010800
   \   000001A2   0x.... 0x....      BL       GPIO_Init
   \   000001A6   0xE785             B.N      ??MB_CommPortCfg_7
   \                     ??MB_CommPortCfg_3: (+1)
   \   000001A8   0x.... 0x....      LDR.W    R8,??DataTable13_5  ;; 0x40004800
   \   000001AC   0xF05F 0x0927      MOVS     R9,#+39
   \   000001B0   0x.... 0x....      ADR.W    R10,USART3_RxTxISRHandler
   \   000001B4   0x2101             MOVS     R1,#+1
   \   000001B6   0xF45F 0x2080      MOVS     R0,#+262144
   \   000001BA   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
   \   000001BE   0x2101             MOVS     R1,#+1
   \   000001C0   0x2008             MOVS     R0,#+8
   \   000001C2   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
   \   000001C6   0xF44F 0x6000      MOV      R0,#+2048
   \   000001CA   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   000001CE   0x2004             MOVS     R0,#+4
   \   000001D0   0xF88D 0x0003      STRB     R0,[SP, #+3]
   \   000001D4   0x4669             MOV      R1,SP
   \   000001D6   0x.... 0x....      LDR.W    R0,??DataTable13_6  ;; 0x40010c00
   \   000001DA   0x.... 0x....      BL       GPIO_Init
   \   000001DE   0xF44F 0x6080      MOV      R0,#+1024
   \   000001E2   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   000001E6   0x2003             MOVS     R0,#+3
   \   000001E8   0xF88D 0x0002      STRB     R0,[SP, #+2]
   \   000001EC   0x2018             MOVS     R0,#+24
   \   000001EE   0xF88D 0x0003      STRB     R0,[SP, #+3]
   \   000001F2   0x4669             MOV      R1,SP
   \   000001F4   0x.... 0x....      LDR.W    R0,??DataTable13_6  ;; 0x40010c00
   \   000001F8   0x.... 0x....      BL       GPIO_Init
   \   000001FC   0xE75A             B.N      ??MB_CommPortCfg_7
   \                     ??MB_CommPortCfg_5: (+1)
   \   000001FE   0x.... 0x....      LDR.W    R8,??DataTable13_7  ;; 0x40004c00
   \   00000202   0xF05F 0x0934      MOVS     R9,#+52
   \   00000206   0x.... 0x....      ADR.W    R10,USART4_RxTxISRHandler
   \   0000020A   0x2101             MOVS     R1,#+1
   \   0000020C   0xF45F 0x2000      MOVS     R0,#+524288
   \   00000210   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
   \   00000214   0x2101             MOVS     R1,#+1
   \   00000216   0x2010             MOVS     R0,#+16
   \   00000218   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
   \   0000021C   0xF44F 0x6000      MOV      R0,#+2048
   \   00000220   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   00000224   0x2004             MOVS     R0,#+4
   \   00000226   0xF88D 0x0003      STRB     R0,[SP, #+3]
   \   0000022A   0x4669             MOV      R1,SP
   \   0000022C   0x.... 0x....      LDR.W    R0,??DataTable13_8  ;; 0x40011000
   \   00000230   0x.... 0x....      BL       GPIO_Init
   \   00000234   0xF44F 0x6080      MOV      R0,#+1024
   \   00000238   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   0000023C   0x2003             MOVS     R0,#+3
   \   0000023E   0xF88D 0x0002      STRB     R0,[SP, #+2]
   \   00000242   0x2018             MOVS     R0,#+24
   \   00000244   0xF88D 0x0003      STRB     R0,[SP, #+3]
   \   00000248   0x4669             MOV      R1,SP
   \   0000024A   0x.... 0x....      LDR.W    R0,??DataTable13_8  ;; 0x40011000
   \   0000024E   0x.... 0x....      BL       GPIO_Init
   \   00000252   0x2101             MOVS     R1,#+1
   \   00000254   0x2010             MOVS     R0,#+16
   \   00000256   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
   \   0000025A   0xF44F 0x5080      MOV      R0,#+4096
   \   0000025E   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   00000262   0x2003             MOVS     R0,#+3
   \   00000264   0xF88D 0x0002      STRB     R0,[SP, #+2]
   \   00000268   0x2010             MOVS     R0,#+16
   \   0000026A   0xF88D 0x0003      STRB     R0,[SP, #+3]
   \   0000026E   0x4669             MOV      R1,SP
   \   00000270   0x.... 0x....      LDR.W    R0,??DataTable13_8  ;; 0x40011000
   \   00000274   0x.... 0x....      BL       GPIO_Init
   \   00000278   0xE71C             B.N      ??MB_CommPortCfg_7
   \                     ??MB_CommPortCfg_6: (+1)
   \   0000027A   0xE769             B.N      ??MB_CommPortCfg_0
    383          
    384          /*$PAGE*/
    385          /*
    386          *********************************************************************************************************
    387          *                                         MB_CommRxIntDis()
    388          *
    389          * Description : This function disables Rx interrupts.
    390          *
    391          * Argument(s) : pch        is a pointer to the Modbus channel
    392          *
    393          * Return(s)   : none.
    394          *
    395          * Caller(s)   : MB_CommExit()
    396          *
    397          * Note(s)     : none.
    398          *********************************************************************************************************
    399          */

   \                                 In section .text, align 2, keep-with-next
    400          void  MB_CommRxIntDis (MODBUS_CH  *pch)
    401          {
   \                     MB_CommRxIntDis: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    402          //    CPU_SR  cpu_sr = 0;
    403          
    404              switch (pch->PortNbr) {
   \   00000002   0x7A40             LDRB     R0,[R0, #+9]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD005             BEQ.N    ??MB_CommRxIntDis_0
   \   00000008   0x2802             CMP      R0,#+2
   \   0000000A   0xD01E             BEQ.N    ??MB_CommRxIntDis_1
   \   0000000C   0xD310             BCC.N    ??MB_CommRxIntDis_2
   \   0000000E   0x2803             CMP      R0,#+3
   \   00000010   0xD022             BEQ.N    ??MB_CommRxIntDis_3
   \   00000012   0xE02C             B.N      ??MB_CommRxIntDis_4
    405              case 0:
    406                  /***********************************************
    407                  * 描述： 收发送使能控制信号
    408                  */
    409          #if (BSP_COM1_REN == DEF_ENABLED)
    410                  GPIO_SetBits(MBREN1_GPIO_PORT, MBREN1_GPIO_PIN);        // 高电平发送使能 
   \                     ??MB_CommRxIntDis_0: (+1)
   \   00000014   0xF44F 0x7180      MOV      R1,#+256
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable13_2  ;; 0x40010800
   \   0000001C   0x.... 0x....      BL       GPIO_SetBits
    411          #endif
    412                  USART_ITConfig(USART1, USART_IT_RXNE, DISABLE);
   \   00000020   0x2200             MOVS     R2,#+0
   \   00000022   0xF240 0x5125      MOVW     R1,#+1317
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable13_1  ;; 0x40013800
   \   0000002A   0x.... 0x....      BL       USART_ITConfig
    413                  break;
   \   0000002E   0xE01E             B.N      ??MB_CommRxIntDis_4
    414                  
    415              case 1:
    416                  /***********************************************
    417                  * 描述： 收发送使能控制信号
    418                  */
    419          #if (BSP_COM2_REN == DEF_ENABLED)
    420                  GPIO_SetBits(MBREN2_GPIO_PORT, MBREN2_GPIO_PIN);        // 高电平发送使能 
   \                     ??MB_CommRxIntDis_2: (+1)
   \   00000030   0x2102             MOVS     R1,#+2
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable13_2  ;; 0x40010800
   \   00000036   0x.... 0x....      BL       GPIO_SetBits
    421          #endif
    422                  USART_ITConfig(USART2, USART_IT_RXNE, DISABLE);
   \   0000003A   0x2200             MOVS     R2,#+0
   \   0000003C   0xF240 0x5125      MOVW     R1,#+1317
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable13_4  ;; 0x40004400
   \   00000044   0x.... 0x....      BL       USART_ITConfig
    423                  break;
   \   00000048   0xE011             B.N      ??MB_CommRxIntDis_4
    424                  
    425              case 2:
    426                  /***********************************************
    427                  * 描述： 收发送使能控制信号
    428                  */
    429          #if (BSP_COM3_REN == DEF_ENABLED)
    430                  GPIO_SetBits(MBREN3_GPIO_PORT, MBREN3_GPIO_PIN);        // 高电平发送使能 
    431          #endif
    432                  USART_ITConfig(USART3, USART_IT_RXNE, DISABLE);
   \                     ??MB_CommRxIntDis_1: (+1)
   \   0000004A   0x2200             MOVS     R2,#+0
   \   0000004C   0xF240 0x5125      MOVW     R1,#+1317
   \   00000050   0x....             LDR.N    R0,??DataTable13_5  ;; 0x40004800
   \   00000052   0x.... 0x....      BL       USART_ITConfig
    433                  break;
   \   00000056   0xE00A             B.N      ??MB_CommRxIntDis_4
    434                  
    435              case 3:
    436                  /***********************************************
    437                  * 描述： 收发送使能控制信号
    438                  */
    439          #if (BSP_COM4_REN == DEF_ENABLED)
    440                  GPIO_SetBits(MBREN4_GPIO_PORT, MBREN4_GPIO_PIN);        // 高电平发送使能 
   \                     ??MB_CommRxIntDis_3: (+1)
   \   00000058   0xF44F 0x5180      MOV      R1,#+4096
   \   0000005C   0x....             LDR.N    R0,??DataTable13_8  ;; 0x40011000
   \   0000005E   0x.... 0x....      BL       GPIO_SetBits
    441          #endif
    442                  USART_ITConfig(UART4, USART_IT_RXNE, DISABLE);
   \   00000062   0x2200             MOVS     R2,#+0
   \   00000064   0xF240 0x5125      MOVW     R1,#+1317
   \   00000068   0x....             LDR.N    R0,??DataTable13_7  ;; 0x40004c00
   \   0000006A   0x.... 0x....      BL       USART_ITConfig
    443                  break;
    444              }
    445          }
   \                     ??MB_CommRxIntDis_4: (+1)
   \   0000006E   0xBD01             POP      {R0,PC}          ;; return
    446          
    447          /*$PAGE*/
    448          /*
    449          *********************************************************************************************************
    450          *                                          MB_CommRxIntEn()
    451          *
    452          * Description : This function enables Rx interrupts.
    453          *
    454          * Argument(s) : pch        is a pointer to the Modbus channel
    455          *
    456          * Return(s)   : none.
    457          *
    458          * Caller(s)   : MB_TxByte()
    459          *
    460          * Note(s)     : none.
    461          *********************************************************************************************************
    462          */

   \                                 In section .text, align 2, keep-with-next
    463          void  MB_CommRxIntEn (MODBUS_CH  *pch)
    464          {
   \                     MB_CommRxIntEn: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    465          //    CPU_SR  cpu_sr = 0;
    466          
    467          //    CPU_CRITICAL_ENTER();
    468              switch (pch->PortNbr) {
   \   00000002   0x7A40             LDRB     R0,[R0, #+9]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD005             BEQ.N    ??MB_CommRxIntEn_0
   \   00000008   0x2802             CMP      R0,#+2
   \   0000000A   0xD01A             BEQ.N    ??MB_CommRxIntEn_1
   \   0000000C   0xD30E             BCC.N    ??MB_CommRxIntEn_2
   \   0000000E   0x2803             CMP      R0,#+3
   \   00000010   0xD01E             BEQ.N    ??MB_CommRxIntEn_3
   \   00000012   0xE028             B.N      ??MB_CommRxIntEn_4
    469              case 0:
    470          #if (BSP_COM1_REN == DEF_ENABLED)
    471                  GPIO_ResetBits(MBREN1_GPIO_PORT, MBREN1_GPIO_PIN);  // 低电平接收使能 
   \                     ??MB_CommRxIntEn_0: (+1)
   \   00000014   0xF44F 0x7180      MOV      R1,#+256
   \   00000018   0x....             LDR.N    R0,??DataTable13_2  ;; 0x40010800
   \   0000001A   0x.... 0x....      BL       GPIO_ResetBits
    472          #endif
    473                  USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);        
   \   0000001E   0x2201             MOVS     R2,#+1
   \   00000020   0xF240 0x5125      MOVW     R1,#+1317
   \   00000024   0x....             LDR.N    R0,??DataTable13_1  ;; 0x40013800
   \   00000026   0x.... 0x....      BL       USART_ITConfig
    474                  break;
   \   0000002A   0xE01C             B.N      ??MB_CommRxIntEn_4
    475                  
    476              case 1:
    477          #if (BSP_COM2_REN == DEF_ENABLED)
    478                  GPIO_ResetBits(MBREN2_GPIO_PORT, MBREN2_GPIO_PIN);  // 低电平接收使能 
   \                     ??MB_CommRxIntEn_2: (+1)
   \   0000002C   0x2102             MOVS     R1,#+2
   \   0000002E   0x....             LDR.N    R0,??DataTable13_2  ;; 0x40010800
   \   00000030   0x.... 0x....      BL       GPIO_ResetBits
    479          #endif
    480                  USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);
   \   00000034   0x2201             MOVS     R2,#+1
   \   00000036   0xF240 0x5125      MOVW     R1,#+1317
   \   0000003A   0x....             LDR.N    R0,??DataTable13_4  ;; 0x40004400
   \   0000003C   0x.... 0x....      BL       USART_ITConfig
    481                  break;
   \   00000040   0xE011             B.N      ??MB_CommRxIntEn_4
    482                  
    483              case 2:
    484          #if (BSP_COM3_REN == DEF_ENABLED)
    485                  GPIO_ResetBits(MBREN3_GPIO_PORT, MBREN3_GPIO_PIN);  // 低电平接收使能 
    486          #endif
    487                  USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);
   \                     ??MB_CommRxIntEn_1: (+1)
   \   00000042   0x2201             MOVS     R2,#+1
   \   00000044   0xF240 0x5125      MOVW     R1,#+1317
   \   00000048   0x....             LDR.N    R0,??DataTable13_5  ;; 0x40004800
   \   0000004A   0x.... 0x....      BL       USART_ITConfig
    488                  break;
   \   0000004E   0xE00A             B.N      ??MB_CommRxIntEn_4
    489                  
    490              case 3:
    491          #if (BSP_COM4_REN == DEF_ENABLED)
    492                  GPIO_ResetBits(MBREN4_GPIO_PORT, MBREN4_GPIO_PIN);  // 低电平接收使能 
   \                     ??MB_CommRxIntEn_3: (+1)
   \   00000050   0xF44F 0x5180      MOV      R1,#+4096
   \   00000054   0x....             LDR.N    R0,??DataTable13_8  ;; 0x40011000
   \   00000056   0x.... 0x....      BL       GPIO_ResetBits
    493          #endif
    494                  USART_ITConfig(UART4, USART_IT_RXNE, ENABLE);
   \   0000005A   0x2201             MOVS     R2,#+1
   \   0000005C   0xF240 0x5125      MOVW     R1,#+1317
   \   00000060   0x....             LDR.N    R0,??DataTable13_7  ;; 0x40004c00
   \   00000062   0x.... 0x....      BL       USART_ITConfig
    495                  break;
    496              }
    497          //    CPU_CRITICAL_EXIT();
    498          }
   \                     ??MB_CommRxIntEn_4: (+1)
   \   00000066   0xBD01             POP      {R0,PC}          ;; return
    499          
    500          /*$PAGE*/
    501          /*
    502          *********************************************************************************************************
    503          *                                       MB_CommRxTxISR_Handler()
    504          *
    505          * Description : This function is the ISR for either a received or transmitted character.
    506          *
    507          * Argument(s) : none.
    508          *
    509          * Return(s)   : none.
    510          *
    511          * Caller(s)   : This is a ISR
    512          *
    513          * Note(s)     : (1) The pseudo-code for this function should be:  
    514          *
    515          *               if (Rx Byte has been received) {
    516          *                  c = get byte from serial port;
    517          *                  Clear receive interrupt;
    518          *                  pch->RxCtr++;                      Increment the number of bytes received
    519          *                  MB_RxByte(pch, c);                 Pass character to Modbus to process
    520          *              }
    521          *
    522          *              if (Byte has been transmitted) {
    523          *                  pch->TxCtr++;                      Increment the number of bytes transmitted
    524          *                  MB_TxByte(pch);                    Send next byte in response
    525          *                  Clear transmit interrupt           Clear Transmit Interrupt flag
    526          *              }
    527          *********************************************************************************************************
    528          */

   \                                 In section .bss, align 1
    529          CPU_INT08U   port_nbr   = 0;
   \                     port_nbr:
   \   00000000                      DS8 1
    530          

   \                                 In section .text, align 2, keep-with-next
    531          void  USARTx_RxTxISRHandler (MODBUS_CH *pch)
    532          {
   \                     USARTx_RxTxISRHandler: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    533              volatile  CPU_INT08U    rx_data;
    534              USART_TypeDef*          USARTx  = pch->USARTx;
   \   00000004   0xF8D4 0x5860      LDR      R5,[R4, #+2144]
    535              
    536              /***********************************************
    537              * 描述：接收中断
    538              */
    539              if (SET == USART_GetFlagStatus(USARTx, USART_FLAG_RXNE)) {
   \   00000008   0x2120             MOVS     R1,#+32
   \   0000000A   0x0028             MOVS     R0,R5
   \   0000000C   0x.... 0x....      BL       USART_GetFlagStatus
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD111             BNE.N    ??USARTx_RxTxISRHandler_0
    540                  rx_data = USART_ReceiveData(USARTx);
   \   00000014   0x0028             MOVS     R0,R5
   \   00000016   0x.... 0x....      BL       USART_ReceiveData
   \   0000001A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    541                  pch->RxCtr++;
   \   0000001E   0x6AE0             LDR      R0,[R4, #+44]
   \   00000020   0x1C40             ADDS     R0,R0,#+1
   \   00000022   0x62E0             STR      R0,[R4, #+44]
    542                  MB_RxByte(pch, rx_data);                                    /* Pass character to Modbus to process                  */
   \   00000024   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0x.... 0x....      BL       MB_RxByte
    543                  USART_ClearITPendingBit(USARTx, USART_IT_RXNE);             /* Clear the USART2 receive interrupt.                  */
   \   0000002E   0xF240 0x5125      MOVW     R1,#+1317
   \   00000032   0x0028             MOVS     R0,R5
   \   00000034   0x.... 0x....      BL       USART_ClearITPendingBit
    544              }
    545              /***********************************************
    546              * 描述：发送中断
    547              */
    548              if (SET == USART_GetFlagStatus(USARTx, USART_FLAG_TC)) {
   \                     ??USARTx_RxTxISRHandler_0: (+1)
   \   00000038   0x2140             MOVS     R1,#+64
   \   0000003A   0x0028             MOVS     R0,R5
   \   0000003C   0x.... 0x....      BL       USART_GetFlagStatus
   \   00000040   0x2801             CMP      R0,#+1
   \   00000042   0xD10C             BNE.N    ??USARTx_RxTxISRHandler_1
    549                  USART_ClearITPendingBit(USARTx, USART_IT_TC);               /* Clear the USART2 receive interrupt.                  */
   \   00000044   0xF240 0x6126      MOVW     R1,#+1574
   \   00000048   0x0028             MOVS     R0,R5
   \   0000004A   0x.... 0x....      BL       USART_ClearITPendingBit
    550                  pch->TxCtr++;
   \   0000004E   0xF8D4 0x0238      LDR      R0,[R4, #+568]
   \   00000052   0x1C40             ADDS     R0,R0,#+1
   \   00000054   0xF8C4 0x0238      STR      R0,[R4, #+568]
    551                  MB_TxByte(pch);                                             /* Send next byte                                       */
   \   00000058   0x0020             MOVS     R0,R4
   \   0000005A   0x.... 0x....      BL       MB_TxByte
    552              }
    553          }
   \                     ??USARTx_RxTxISRHandler_1: (+1)
   \   0000005E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    554          
    555          /*$PAGE*/
    556          /*
    557          *********************************************************************************************************
    558          *                                UART #0 Rx/Tx Communication handler for Modbus
    559          *********************************************************************************************************
    560          */
    561          
    562          /***********************************************
    563          * 描述： UART1中断服务程序
    564          */

   \                                 In section .text, align 4, keep-with-next
    565          void  USART1_RxTxISRHandler (void)
    566          {
   \                     USART1_RxTxISRHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    567              USARTx_RxTxISRHandler(MB_ChPortMap[0]);
   \   00000002   0x....             LDR.N    R0,??DataTable13_3
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x.... 0x....      BL       USARTx_RxTxISRHandler
    568          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    569          
    570          /***********************************************
    571          * 描述： UART2中断服务程序
    572          */

   \                                 In section .text, align 4, keep-with-next
    573          void  USART2_RxTxISRHandler (void)
    574          {
   \                     USART2_RxTxISRHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    575              USARTx_RxTxISRHandler(MB_ChPortMap[1]);
   \   00000002   0x....             LDR.N    R0,??DataTable13_3
   \   00000004   0x6840             LDR      R0,[R0, #+4]
   \   00000006   0x.... 0x....      BL       USARTx_RxTxISRHandler
    576          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    577          
    578          /***********************************************
    579          * 描述： UART3中断服务程序
    580          */

   \                                 In section .text, align 4, keep-with-next
    581          void  USART3_RxTxISRHandler (void)
    582          {
   \                     USART3_RxTxISRHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    583              USARTx_RxTxISRHandler(MB_ChPortMap[2]);
   \   00000002   0x....             LDR.N    R0,??DataTable13_3
   \   00000004   0x6880             LDR      R0,[R0, #+8]
   \   00000006   0x.... 0x....      BL       USARTx_RxTxISRHandler
    584          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    585          
    586          /***********************************************
    587          * 描述： UART4中断服务程序
    588          */

   \                                 In section .text, align 4, keep-with-next
    589          void  USART4_RxTxISRHandler (void)
    590          {
   \                     USART4_RxTxISRHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    591              USARTx_RxTxISRHandler(MB_ChPortMap[3]);
   \   00000002   0x....             LDR.N    R0,??DataTable13_3
   \   00000004   0x68C0             LDR      R0,[R0, #+12]
   \   00000006   0x.... 0x....      BL       USARTx_RxTxISRHandler
    592          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    593          /*$PAGE*/
    594          /*
    595          *********************************************************************************************************
    596          *                                             MB_CommTx1()
    597          *
    598          * Description : This function is called to obtain the next byte to send from the transmit buffer.  When
    599          *               all bytes in the reply have been sent, transmit interrupts are disabled and the receiver
    600          *               is enabled to accept the next Modbus request.
    601          *
    602          * Argument(s) : c     is the byte to send to the serial port
    603          *
    604          * Return(s)   : none.
    605          *
    606          * Caller(s)   : MB_TxByte()
    607          *
    608          * Note(s)     : none.
    609          *********************************************************************************************************
    610          */
    611          

   \                                 In section .text, align 2, keep-with-next
    612          void  MB_CommTx1 (MODBUS_CH  *pch,
    613                            CPU_INT08U  c)
    614          {
    615              switch (pch->PortNbr) {
   \                     MB_CommTx1: (+1)
   \   00000000   0x7A40             LDRB     R0,[R0, #+9]
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD005             BEQ.N    ??MB_CommTx1_0
   \   00000006   0x2802             CMP      R0,#+2
   \   00000008   0xD00B             BEQ.N    ??MB_CommTx1_1
   \   0000000A   0xD306             BCC.N    ??MB_CommTx1_2
   \   0000000C   0x2803             CMP      R0,#+3
   \   0000000E   0xD00C             BEQ.N    ??MB_CommTx1_3
   \   00000010   0xE00E             B.N      ??MB_CommTx1_4
    616              case 0:
    617                  /* Transmit Data */
    618                  USART1->DR = (c & (u16)0x01FF);
   \                     ??MB_CommTx1_0: (+1)
   \   00000012   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000014   0x....             LDR.N    R0,??DataTable13_9  ;; 0x40013804
   \   00000016   0x8001             STRH     R1,[R0, #+0]
    619                  break;
   \   00000018   0xE00A             B.N      ??MB_CommTx1_4
    620                  
    621              case 1:
    622                  /* Transmit Data */
    623                  USART2->DR = (c & (u16)0x01FF);
   \                     ??MB_CommTx1_2: (+1)
   \   0000001A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001C   0x....             LDR.N    R0,??DataTable13_10  ;; 0x40004404
   \   0000001E   0x8001             STRH     R1,[R0, #+0]
    624                  break;
   \   00000020   0xE006             B.N      ??MB_CommTx1_4
    625                  
    626              case 2:
    627                  /* Transmit Data */
    628                  USART3->DR = (c & (u16)0x01FF);
   \                     ??MB_CommTx1_1: (+1)
   \   00000022   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000024   0x....             LDR.N    R0,??DataTable13_11  ;; 0x40004804
   \   00000026   0x8001             STRH     R1,[R0, #+0]
    629                  break;
   \   00000028   0xE002             B.N      ??MB_CommTx1_4
    630                  
    631              case 3:
    632                  /* Transmit Data */
    633                  UART4->DR = (c & (u16)0x01FF);
   \                     ??MB_CommTx1_3: (+1)
   \   0000002A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002C   0x....             LDR.N    R0,??DataTable13_12  ;; 0x40004c04
   \   0000002E   0x8001             STRH     R1,[R0, #+0]
    634                  break;
    635              }
    636          }
   \                     ??MB_CommTx1_4: (+1)
   \   00000030   0x4770             BX       LR               ;; return
    637          
    638          /*$PAGE*/
    639          /*
    640          *********************************************************************************************************
    641          *                                         MB_CommTxIntDis()
    642          *
    643          * Description : This function disables Tx interrupts.
    644          *
    645          * Argument(s) : pch        is a pointer to the Modbus channel
    646          *
    647          * Return(s)   : none.
    648          *
    649          * Caller(s)   : MB_CommExit()
    650          *               MB_TxByte()
    651          *
    652          * Note(s)     : none.
    653          *********************************************************************************************************
    654          */
    655          

   \                                 In section .text, align 2, keep-with-next
    656          void  MB_CommTxIntDis (MODBUS_CH  *pch)
    657          {
   \                     MB_CommTxIntDis: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    658          //    CPU_SR  cpu_sr = 0;
    659          
    660          //    CPU_CRITICAL_ENTER();
    661              switch (pch->PortNbr) {                       /* Just enable the receiver interrupt                */
   \   00000002   0x7A40             LDRB     R0,[R0, #+9]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD005             BEQ.N    ??MB_CommTxIntDis_0
   \   00000008   0x2802             CMP      R0,#+2
   \   0000000A   0xD01D             BEQ.N    ??MB_CommTxIntDis_1
   \   0000000C   0xD30F             BCC.N    ??MB_CommTxIntDis_2
   \   0000000E   0x2803             CMP      R0,#+3
   \   00000010   0xD027             BEQ.N    ??MB_CommTxIntDis_3
   \   00000012   0xE032             B.N      ??MB_CommTxIntDis_4
    662              case 0:
    663                  USART_ITConfig(USART1, USART_IT_TC, DISABLE);
   \                     ??MB_CommTxIntDis_0: (+1)
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0xF240 0x6126      MOVW     R1,#+1574
   \   0000001A   0x....             LDR.N    R0,??DataTable13_1  ;; 0x40013800
   \   0000001C   0x.... 0x....      BL       USART_ITConfig
    664                  USART_ITConfig(USART1, USART_IT_TXE, DISABLE);
   \   00000020   0x2200             MOVS     R2,#+0
   \   00000022   0xF240 0x7127      MOVW     R1,#+1831
   \   00000026   0x....             LDR.N    R0,??DataTable13_1  ;; 0x40013800
   \   00000028   0x.... 0x....      BL       USART_ITConfig
    665                  break;
   \   0000002C   0xE025             B.N      ??MB_CommTxIntDis_4
    666                  
    667              case 1:
    668                  USART_ITConfig(USART2, USART_IT_TC, DISABLE);
   \                     ??MB_CommTxIntDis_2: (+1)
   \   0000002E   0x2200             MOVS     R2,#+0
   \   00000030   0xF240 0x6126      MOVW     R1,#+1574
   \   00000034   0x....             LDR.N    R0,??DataTable13_4  ;; 0x40004400
   \   00000036   0x.... 0x....      BL       USART_ITConfig
    669                  USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
   \   0000003A   0x2200             MOVS     R2,#+0
   \   0000003C   0xF240 0x7127      MOVW     R1,#+1831
   \   00000040   0x....             LDR.N    R0,??DataTable13_4  ;; 0x40004400
   \   00000042   0x.... 0x....      BL       USART_ITConfig
    670                  break;
   \   00000046   0xE018             B.N      ??MB_CommTxIntDis_4
    671                  
    672              case 2:
    673                  USART_ITConfig(USART3, USART_IT_TC, DISABLE);
   \                     ??MB_CommTxIntDis_1: (+1)
   \   00000048   0x2200             MOVS     R2,#+0
   \   0000004A   0xF240 0x6126      MOVW     R1,#+1574
   \   0000004E   0x....             LDR.N    R0,??DataTable13_5  ;; 0x40004800
   \   00000050   0x.... 0x....      BL       USART_ITConfig
    674                  USART_ITConfig(USART3, USART_IT_TXE, DISABLE);
   \   00000054   0x2200             MOVS     R2,#+0
   \   00000056   0xF240 0x7127      MOVW     R1,#+1831
   \   0000005A   0x....             LDR.N    R0,??DataTable13_5  ;; 0x40004800
   \   0000005C   0x.... 0x....      BL       USART_ITConfig
    675                  break;
   \   00000060   0xE00B             B.N      ??MB_CommTxIntDis_4
    676                  
    677              case 3:
    678                  USART_ITConfig(UART4, USART_IT_TC, DISABLE);
   \                     ??MB_CommTxIntDis_3: (+1)
   \   00000062   0x2200             MOVS     R2,#+0
   \   00000064   0xF240 0x6126      MOVW     R1,#+1574
   \   00000068   0x....             LDR.N    R0,??DataTable13_7  ;; 0x40004c00
   \   0000006A   0x.... 0x....      BL       USART_ITConfig
    679                  USART_ITConfig(UART4, USART_IT_TXE, DISABLE);
   \   0000006E   0x2200             MOVS     R2,#+0
   \   00000070   0xF240 0x7127      MOVW     R1,#+1831
   \   00000074   0x....             LDR.N    R0,??DataTable13_7  ;; 0x40004c00
   \   00000076   0x.... 0x....      BL       USART_ITConfig
    680                  break;
    681              }
    682          //    CPU_CRITICAL_EXIT();
    683          }
   \                     ??MB_CommTxIntDis_4: (+1)
   \   0000007A   0xBD01             POP      {R0,PC}          ;; return
    684          
    685          /*$PAGE*/
    686          /*
    687          *********************************************************************************************************
    688          *                                         MB_CommTxIntEn()
    689          *
    690          * Description : This function enables Tx interrupts.
    691          *
    692          * Argument(s) : pch        is a pointer to the Modbus channel
    693          *
    694          * Return(s)   : none.
    695          *
    696          * Caller(s)   : MB_Tx()
    697          *
    698          * Note(s)     : none.
    699          *********************************************************************************************************
    700          */

   \                                 In section .text, align 2, keep-with-next
    701          void  MB_CommTxIntEn (MODBUS_CH  *pch)
    702          {
   \                     MB_CommTxIntEn: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    703          //    CPU_SR  cpu_sr = 0;
    704          
    705              switch (pch->PortNbr) {                       /* Just enable the receiver interrupt                */
   \   00000002   0x7A40             LDRB     R0,[R0, #+9]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD005             BEQ.N    ??MB_CommTxIntEn_0
   \   00000008   0x2802             CMP      R0,#+2
   \   0000000A   0xD01D             BEQ.N    ??MB_CommTxIntEn_1
   \   0000000C   0xD30F             BCC.N    ??MB_CommTxIntEn_2
   \   0000000E   0x2803             CMP      R0,#+3
   \   00000010   0xD027             BEQ.N    ??MB_CommTxIntEn_3
   \   00000012   0xE032             B.N      ??MB_CommTxIntEn_4
    706              case 0:
    707                  USART_ITConfig(USART1, USART_IT_TC,  ENABLE);
   \                     ??MB_CommTxIntEn_0: (+1)
   \   00000014   0x2201             MOVS     R2,#+1
   \   00000016   0xF240 0x6126      MOVW     R1,#+1574
   \   0000001A   0x....             LDR.N    R0,??DataTable13_1  ;; 0x40013800
   \   0000001C   0x.... 0x....      BL       USART_ITConfig
    708                  USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
   \   00000020   0x2201             MOVS     R2,#+1
   \   00000022   0xF240 0x7127      MOVW     R1,#+1831
   \   00000026   0x....             LDR.N    R0,??DataTable13_1  ;; 0x40013800
   \   00000028   0x.... 0x....      BL       USART_ITConfig
    709                  break;
   \   0000002C   0xE025             B.N      ??MB_CommTxIntEn_4
    710                  
    711              case 1:
    712                  USART_ITConfig(USART2, USART_IT_TC,  ENABLE);
   \                     ??MB_CommTxIntEn_2: (+1)
   \   0000002E   0x2201             MOVS     R2,#+1
   \   00000030   0xF240 0x6126      MOVW     R1,#+1574
   \   00000034   0x....             LDR.N    R0,??DataTable13_4  ;; 0x40004400
   \   00000036   0x.... 0x....      BL       USART_ITConfig
    713                  USART_ITConfig(USART2, USART_IT_TXE, ENABLE);
   \   0000003A   0x2201             MOVS     R2,#+1
   \   0000003C   0xF240 0x7127      MOVW     R1,#+1831
   \   00000040   0x....             LDR.N    R0,??DataTable13_4  ;; 0x40004400
   \   00000042   0x.... 0x....      BL       USART_ITConfig
    714                  break;
   \   00000046   0xE018             B.N      ??MB_CommTxIntEn_4
    715                  
    716              case 2:
    717                  USART_ITConfig(USART3, USART_IT_TC,  ENABLE);
   \                     ??MB_CommTxIntEn_1: (+1)
   \   00000048   0x2201             MOVS     R2,#+1
   \   0000004A   0xF240 0x6126      MOVW     R1,#+1574
   \   0000004E   0x....             LDR.N    R0,??DataTable13_5  ;; 0x40004800
   \   00000050   0x.... 0x....      BL       USART_ITConfig
    718                  USART_ITConfig(USART3, USART_IT_TXE, ENABLE);
   \   00000054   0x2201             MOVS     R2,#+1
   \   00000056   0xF240 0x7127      MOVW     R1,#+1831
   \   0000005A   0x....             LDR.N    R0,??DataTable13_5  ;; 0x40004800
   \   0000005C   0x.... 0x....      BL       USART_ITConfig
    719                  break;
   \   00000060   0xE00B             B.N      ??MB_CommTxIntEn_4
    720                  
    721              case 3:
    722                  USART_ITConfig(UART4, USART_IT_TC,  ENABLE);
   \                     ??MB_CommTxIntEn_3: (+1)
   \   00000062   0x2201             MOVS     R2,#+1
   \   00000064   0xF240 0x6126      MOVW     R1,#+1574
   \   00000068   0x....             LDR.N    R0,??DataTable13_7  ;; 0x40004c00
   \   0000006A   0x.... 0x....      BL       USART_ITConfig
    723                  USART_ITConfig(UART4, USART_IT_TXE, ENABLE);
   \   0000006E   0x2201             MOVS     R2,#+1
   \   00000070   0xF240 0x7127      MOVW     R1,#+1831
   \   00000074   0x....             LDR.N    R0,??DataTable13_7  ;; 0x40004c00
   \   00000076   0x.... 0x....      BL       USART_ITConfig
    724                  break;
    725              }
    726          }
   \                     ??MB_CommTxIntEn_4: (+1)
   \   0000007A   0xBD01             POP      {R0,PC}          ;; return
    727          
    728          /*$PAGE*/
    729          /*
    730          *********************************************************************************************************
    731          *                                           MB_RTU_TmrInit()
    732          *
    733          * Description : This function is called to initialize the RTU timeout timer.
    734          *
    735          * Argument(s) : freq          Is the frequency of the modbus RTU timer interrupt.
    736          *
    737          * Return(s)   : none.
    738          *
    739          * Caller(s)   : MB_Init().
    740          *
    741          * Note(s)     : none.
    742          *********************************************************************************************************
    743          */
    744          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    745          void  MB_RTU_TmrInit (void)
    746          {
   \                     MB_RTU_TmrInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
    747              CPU_INT32U  clk_freq;
    748              TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure; 
    749              int         prescaler = 3600;
   \   00000004   0xF44F 0x6461      MOV      R4,#+3600
    750              clk_freq            = BSP_CPU_ClkFreq();
   \   00000008   0x.... 0x....      BL       BSP_CPU_ClkFreq
   \   0000000C   0xE002             B.N      ??MB_RTU_TmrInit_0
    751              
    752              while( (clk_freq / prescaler/ MB_RTU_Freq) == 0 )           //redmorningcn 计算分频系数，不满足最小值要求
    753                  prescaler /= 2;
   \                     ??MB_RTU_TmrInit_1: (+1)
   \   0000000E   0x2102             MOVS     R1,#+2
   \   00000010   0xFB94 0xF4F1      SDIV     R4,R4,R1
   \                     ??MB_RTU_TmrInit_0: (+1)
   \   00000014   0xFBB0 0xF1F4      UDIV     R1,R0,R4
   \   00000018   0x....             LDR.N    R2,??DataTable13_13
   \   0000001A   0x8812             LDRH     R2,[R2, #+0]
   \   0000001C   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   00000020   0x2900             CMP      R1,#+0
   \   00000022   0xD0F4             BEQ.N    ??MB_RTU_TmrInit_1
    754              
    755              MB_Tmr_ReloadCnts   = clk_freq / prescaler/ MB_RTU_Freq - 1;
   \   00000024   0xFBB0 0xF0F4      UDIV     R0,R0,R4
   \   00000028   0x....             LDR.N    R1,??DataTable13_13
   \   0000002A   0x8809             LDRH     R1,[R1, #+0]
   \   0000002C   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000030   0x1E40             SUBS     R0,R0,#+1
   \   00000032   0x....             LDR.N    R1,??DataTable13_14
   \   00000034   0x6008             STR      R0,[R1, #+0]
    756              
    757              //预分频系数（TIM_Prescaler）  = 36000-1，这样计数器时钟为72MHz/36000 = 2kHz 
    758              //中断计数器 （TIM_Period）    = MB_Tmr_ReloadCnts
    759              //定时器中断频率               = clk_freq / （TIM_Prescaler + 1） / （TIM_Period + 1）
    760              //定时器中断频率               = 72000000 / 36000 / 5 = 400Hz
    761              
    762              RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);            // 使能定时器时钟
   \   00000036   0x2101             MOVS     R1,#+1
   \   00000038   0x2002             MOVS     R0,#+2
   \   0000003A   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
    763              TIM_DeInit(TIM3);                                               // 复位TIM3定时器
   \   0000003E   0x....             LDR.N    R0,??DataTable13_15  ;; 0x40000400
   \   00000040   0x.... 0x....      BL       TIM_DeInit
    764              
    765              /* TIM3 configuration */
    766              TIM_TimeBaseStructure.TIM_Period        = MB_Tmr_ReloadCnts;    // 中断频率     
   \   00000044   0x....             LDR.N    R0,??DataTable13_14
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    767              TIM_TimeBaseStructure.TIM_Prescaler     = prescaler - 1;            // 分频36000       
   \   0000004C   0x1E60             SUBS     R0,R4,#+1
   \   0000004E   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    768              TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;         // 时钟分频  
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    769              TIM_TimeBaseStructure.TIM_CounterMode   = TIM_CounterMode_Up;   // 计数方向向上计数
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    770              TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);
   \   0000005E   0x4669             MOV      R1,SP
   \   00000060   0x....             LDR.N    R0,??DataTable13_15  ;; 0x40000400
   \   00000062   0x.... 0x....      BL       TIM_TimeBaseInit
    771              
    772              TIM_ClearFlag(TIM3, TIM_FLAG_Update);                           // 清除TIM3溢出中断标志
   \   00000066   0x2101             MOVS     R1,#+1
   \   00000068   0x....             LDR.N    R0,??DataTable13_15  ;; 0x40000400
   \   0000006A   0x.... 0x....      BL       TIM_ClearFlag
    773              TIM_ITConfig(TIM3, TIM_IT_Update, ENABLE);                      // TIM3溢出中断允许
   \   0000006E   0x2201             MOVS     R2,#+1
   \   00000070   0x2101             MOVS     R1,#+1
   \   00000072   0x....             LDR.N    R0,??DataTable13_15  ;; 0x40000400
   \   00000074   0x.... 0x....      BL       TIM_ITConfig
    774              TIM_Cmd(TIM3, ENABLE);                                          // 允许tim3计数
   \   00000078   0x2101             MOVS     R1,#+1
   \   0000007A   0x....             LDR.N    R0,??DataTable13_15  ;; 0x40000400
   \   0000007C   0x.... 0x....      BL       TIM_Cmd
    775              
    776              /***********************************************
    777              * 描述：设置中断入口函数及中断优先级
    778              */
    779              BSP_IntVectSet(BSP_INT_ID_TIM3, MB_RTU_TmrISR_Handler);
   \   00000080   0x.... 0x....      ADR.W    R1,MB_RTU_TmrISR_Handler
   \   00000084   0x201D             MOVS     R0,#+29
   \   00000086   0x.... 0x....      BL       BSP_IntVectSet
    780              BSP_IntEn(BSP_INT_ID_TIM3);
   \   0000008A   0x201D             MOVS     R0,#+29
   \   0000008C   0x.... 0x....      BL       BSP_IntEn
    781              
    782              MB_RTU_TmrResetAll();                                     /* Reset all the RTU timers, we changed freq. */
   \   00000090   0x.... 0x....      BL       MB_RTU_TmrResetAll
    783          }
   \   00000094   0xBD1F             POP      {R0-R4,PC}       ;; return
    784          #endif
    785          
    786          /*$PAGE*/
    787          /*
    788          *********************************************************************************************************
    789          *                                           MB_RTU_TmrExit()
    790          *
    791          * Description : This function is called to disable the RTU timeout timer.
    792          *
    793          * Argument(s) : none.
    794          *
    795          * Return(s)   : none.
    796          *
    797          * Caller(s)   : MB_Exit()
    798          *
    799          * Note(s)     : none.
    800          *********************************************************************************************************
    801          */
    802          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    803          void  MB_RTU_TmrExit (void)
    804          {
   \                     MB_RTU_TmrExit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    805              TIM_Cmd(TIM3,DISABLE);              //禁止计数器 
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x....             LDR.N    R0,??DataTable13_15  ;; 0x40000400
   \   00000006   0x.... 0x....      BL       TIM_Cmd
    806              RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, DISABLE);
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
    807          }
   \   00000012   0xBD01             POP      {R0,PC}          ;; return
    808          #endif
    809          
    810          /*$PAGE*/
    811          /*
    812          *********************************************************************************************************
    813          *                                       MB_RTU_TmrISR_Handler()
    814          *
    815          * Description : This function handles the case when the RTU timeout timer expires.
    816          *
    817          * Arguments   : none.
    818          *
    819          * Returns     : none.
    820          *
    821          * Caller(s)   : This is a ISR.
    822          *
    823          * Note(s)     : none.
    824          *********************************************************************************************************
    825          */
    826          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)

   \                                 In section .text, align 4, keep-with-next
    827          void  MB_RTU_TmrISR_Handler (void)
    828          {
   \                     MB_RTU_TmrISR_Handler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    829              if(TIM_GetITStatus(TIM3, TIM_IT_Update)== SET) {//检测是否发生溢出更新事件
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x....             LDR.N    R0,??DataTable13_15  ;; 0x40000400
   \   00000006   0x.... 0x....      BL       TIM_GetITStatus
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD10A             BNE.N    ??MB_RTU_TmrISR_Handler_0
    830                TIM_ClearITPendingBit(TIM3 , TIM_FLAG_Update);/* Clear timer #1 interrupt                           */
   \   0000000E   0x2101             MOVS     R1,#+1
   \   00000010   0x....             LDR.N    R0,??DataTable13_15  ;; 0x40000400
   \   00000012   0x.... 0x....      BL       TIM_ClearITPendingBit
    831                MB_RTU_TmrCtr++;                              /* Indicate that we had activities on this interrupt. */
   \   00000016   0x....             LDR.N    R0,??DataTable13_16
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x1C40             ADDS     R0,R0,#+1
   \   0000001C   0x....             LDR.N    R1,??DataTable13_16
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    832                MB_RTU_TmrUpdate();                           /* Check for RTU timers that have expired             */
   \   00000020   0x.... 0x....      BL       MB_RTU_TmrUpdate
    833              }
    834          }
   \                     ??MB_RTU_TmrISR_Handler_0: (+1)
   \   00000024   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x........         DC32     MB_ChTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x40013800         DC32     0x40013800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x40010800         DC32     0x40010800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   0x........         DC32     MB_ChPortMap

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   0x40004400         DC32     0x40004400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \   00000000   0x40004800         DC32     0x40004800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_6:
   \   00000000   0x40010C00         DC32     0x40010c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_7:
   \   00000000   0x40004C00         DC32     0x40004c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_8:
   \   00000000   0x40011000         DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_9:
   \   00000000   0x40013804         DC32     0x40013804

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_10:
   \   00000000   0x40004404         DC32     0x40004404

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_11:
   \   00000000   0x40004804         DC32     0x40004804

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_12:
   \   00000000   0x40004C04         DC32     0x40004c04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_13:
   \   00000000   0x........         DC32     MB_RTU_Freq

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_14:
   \   00000000   0x........         DC32     MB_Tmr_ReloadCnts

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_15:
   \   00000000   0x40000400         DC32     0x40000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_16:
   \   00000000   0x........         DC32     MB_RTU_TmrCtr
    835          #endif
    836                                

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   MB_CommExit
        16   -> MB_CommRxIntDis
        16   -> MB_CommTxIntDis
      56   MB_CommPortCfg
        56   -> BSP_IntEn
        56   -> BSP_IntVectSet
        56   -> GPIO_Init
        56   -> GPIO_ResetBits
        56   -> RCC_APB1PeriphClockCmd
        56   -> RCC_APB2PeriphClockCmd
        56   -> USART_ClearFlag
        56   -> USART_Cmd
        56   -> USART_DeInit
        56   -> USART_ITConfig
        56   -> USART_Init
       8   MB_CommRxIntDis
         8   -> GPIO_SetBits
         8   -> USART_ITConfig
       8   MB_CommRxIntEn
         8   -> GPIO_ResetBits
         8   -> USART_ITConfig
       0   MB_CommTx1
       8   MB_CommTxIntDis
         8   -> USART_ITConfig
       8   MB_CommTxIntEn
         8   -> USART_ITConfig
       8   MB_RTU_TmrExit
         8   -> RCC_APB1PeriphClockCmd
         8   -> TIM_Cmd
       8   MB_RTU_TmrISR_Handler
         8   -> MB_RTU_TmrUpdate
         8   -> TIM_ClearITPendingBit
         8   -> TIM_GetITStatus
      24   MB_RTU_TmrInit
        24   -> BSP_CPU_ClkFreq
        24   -> BSP_IntEn
        24   -> BSP_IntVectSet
        24   -> MB_RTU_TmrResetAll
        24   -> RCC_APB1PeriphClockCmd
        24   -> TIM_ClearFlag
        24   -> TIM_Cmd
        24   -> TIM_DeInit
        24   -> TIM_ITConfig
        24   -> TIM_TimeBaseInit
       8   USART1_RxTxISRHandler
         8   -> USARTx_RxTxISRHandler
       8   USART2_RxTxISRHandler
         8   -> USARTx_RxTxISRHandler
       8   USART3_RxTxISRHandler
         8   -> USARTx_RxTxISRHandler
       8   USART4_RxTxISRHandler
         8   -> USARTx_RxTxISRHandler
      16   USARTx_RxTxISRHandler
        16   -> MB_RxByte
        16   -> MB_TxByte
        16   -> USART_ClearITPendingBit
        16   -> USART_GetFlagStatus
        16   -> USART_ReceiveData


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_10
       4  ??DataTable13_11
       4  ??DataTable13_12
       4  ??DataTable13_13
       4  ??DataTable13_14
       4  ??DataTable13_15
       4  ??DataTable13_16
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable13_8
       4  ??DataTable13_9
      20  MB_ChPortMap
      36  MB_CommExit
     636  MB_CommPortCfg
     112  MB_CommRxIntDis
     104  MB_CommRxIntEn
      50  MB_CommTx1
     124  MB_CommTxIntDis
     124  MB_CommTxIntEn
      20  MB_RTU_TmrExit
      38  MB_RTU_TmrISR_Handler
     150  MB_RTU_TmrInit
       4  MB_Tmr_ReloadCnts
      12  USART1_RxTxISRHandler
      12  USART2_RxTxISRHandler
      12  USART3_RxTxISRHandler
      12  USART4_RxTxISRHandler
      96  USARTx_RxTxISRHandler
       1  port_nbr

 
    25 bytes in section .bss
 1 606 bytes in section .text
 
 1 606 bytes of CODE memory
    25 bytes of DATA memory

Errors: none
Warnings: none
