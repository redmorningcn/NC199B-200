###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       15/Jul/2018  10:36:19
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  F:\iar\NC210\NC210-200处理板\source\driver\bsp_time.c
#    Command line =  
#        F:\iar\NC210\NC210-200处理板\source\driver\bsp_time.c -D
#        USE_STDPERIPH_DRIVER -D APP_RELEASE -lCN
#        F:\iar\NC210\NC210-200处理板\project\app_release\List -o
#        F:\iar\NC210\NC210-200处理板\project\app_release\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC210\NC210-200处理板\project\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\config\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\task\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\user\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\OS\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\Ports\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\driver\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-LIB\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Source\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\ST\STM32\inc\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Ports\STM32\STM32F103\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Source\
#        -Ol --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC210\NC210-200处理板\project\app_release\List\bsp_time.lst
#    Object file  =  
#        F:\iar\NC210\NC210-200处理板\project\app_release\Obj\bsp_time.o
#
###############################################################################

F:\iar\NC210\NC210-200处理板\source\driver\bsp_time.c
      1          
      2          /*******************************************************************************
      3           *   Filename:       bsp_time.h
      4           *   Revised:        $Date: 2014-05-27$
      5           *   Revision:       $
      6           *	 Writer:		 Wuming Shen.
      7           *
      8           *   Description:
      9           *   本文件实现基于RTC的日期功能，提供年月日的读写。（基于ANSI-C的time.h）
     10          *
     11          * RTC中保存的时间格式，是UNIX时间戳格式的。即一个32bit的TIME_t变量（实为u32）
     12          *
     13          * ANSI-C的标准库中，提供了两种表示时间的数据  型：
     14          * time_t:    UNIX时间戳（从1970-1-1起到某时间经过的秒数）
     15          * typedef unsigned int time_t;
     16          *
     17          * struct tm: Calendar格式（年月日形式）
     18          * tm结构如下：
     19          * struct tm {
     20          *   int tm_sec;   // 秒 seconds after the minute, 0 to 59
     21          *               (0 - 59 allows for the occasional leap second)
     22          *   int tm_min;   // 分 minutes after the hour, 0 to 59
     23          *   int tm_hour;  // 时 hours since midnight, 0 to 23
     24          *   int tm_mday;  // 日 day of the month, 1 to 31
     25          *   int tm_mon;   // 月 months since January, 0 to 11
     26          *   int tm_year;  // 年 years since 1900
     27          *   int tm_wday;  // 星期 days since Sunday, 0 to 6
     28          *   int tm_yday;  // 从元旦起的天数 days since January 1, 0 to 365
     29          *   int tm_isdst; // 夏令时？？Daylight Savings Time flag
     30          *   ...
     31          * }
     32          *  其中wday，yday可以自动产生，软件直接读取
     33          *  mon的取值为0-11
     34          * ***注意***：
     35          * tm_year:在time.h库中定义为1900年起的年份，即2008年应表示为2008-1900=108
     36          *  这种表示方法对用户来说不是十分友好，与现实有较大差异。
     37          *  所以在本文件中，屏蔽了这种差异。
     38          *  即外部调用本文件的函数时，tm结构体类型的日期，tm_year即为2008
     39          *  注意：若要调用系统库time.c中的函数，需要自行将tm_year-=1900
     40          *
     41          * 成员函数说明：
     42          * struct tm TIME_ConvUnixToCalendar(time_t t);
     43          *  输入一个Unix时间戳（TIME_t），返回Calendar格式日期
     44          * time_t TIME_ConvCalendarToUnix(struct tm t);
     45          *  输入一个Calendar格式日期，返回Unix时间戳（TIME_t）
     46          * time_t TIME_GetUnixTime(void);
     47          *  从RTC取当前时间的Unix时间戳值
     48          * struct tm TIME_GetCalendarTime(void);
     49          *  从RTC取当前时间的日历时间
     50          * void TIME_SetUnixTime(time_t);
     51          *  输入UNIX时间戳格式时间，设置为当前RTC时间
     52          * void TIME_SetCalendarTime(struct tm t);
     53          *  输入Calendar格式时间，设置为当前RTC时间
     54          *
     55          * 外部调用实例：
     56          * 定义一个Calendar格式的日期变量：
     57          * struct tm now;
     58          * now.tm_year = 2008;
     59          * now.tm_mon = 11;  //12月
     60          * now.tm_mday = 20;
     61          * now.tm_hour = 20;
     62          * now.tm_min = 12;
     63          * now.tm_sec = 30;
     64          *
     65          * 获取当前日期时间：
     66          * tm_now = TIME_GetCalendarTime();
     67          * 然后可以直接读tm_now.tm_wday获取星期数
     68          *
     69          * 设置时间：
     70          * Step1. tm_now.xxx = xxxxxxxxx;
     71          * Step2. TIME_SetCalendarTime(tm_now);
     72          *
     73          * 计算两个时间的差
     74          * struct tm t1,t2;
     75          * t1_t = TIME_ConvCalendarToUnix(t1);
     76          * t2_t = TIME_ConvCalendarToUnix(t2);
     77          * dt = t1_t - t2_t;
     78          * dt就是两个时间差的秒数
     79          * dt_tm = mktime(dt); //注意dt的年份匹配，ansi库中函数为相对年份，注意超限
     80          * 另可以参考相关资料，调用ansi-c库的格式化输出等功能，ctime，strftime等
     81          *
     82           *   Notes:
     83           *					QQ:276193028
     84           *     				E-mail:shenchangwei945@163.com
     85           *
     86           *   All copyrights reserved to Wuming Shen.
     87           *
     88           *******************************************************************************/
     89          
     90          /*******************************************************************************
     91           * INCLUDES
     92           */
     93          #include <includes.h>
     94          #include <bsp_time.h>
     95          #include <ds3231.h>
     96          
     97          /*******************************************************************************
     98           * CONSTANTS
     99           */
    100          #define UTC 8
    101          /*******************************************************************************
    102           * MACROS
    103           */
    104          
    105          /*******************************************************************************
    106           * TYPEDEFS
    107           */
    108          
    109          /*******************************************************************************
    110           * LOCAL VARIABLES
    111           */
    112          
    113          /*******************************************************************************
    114           * GLOBAL VARIABLES
    115           */

   \                                 In section .data, align 4
    116          struct tm   tm_now = {
   \                     tm_now:
   \   00000000   0x00000000         DC32 0, 30, 14, 3, 9, 2015, 4, 0, 0, 0, 0
   \              0x0000001E   
   \              0x0000000E   
   \              0x00000003   
   \              0x00000009   
   \              0x000007DF   
   \              0x00000004   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
    117            0,30,14,3,9,2015,4
    118          };

   \                                 In section .bss, align 4
    119          time_t  t_now,t_last;
   \                     t_now:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     t_last:
   \   00000000                      DS8 4
    120          
    121          /*******************************************************************************
    122           * LOCAL FUNCTIONS
    123           */
    124          void            TIME_Set        (u32 t);
    125          unsigned int    xDate2Seconds   (struct tm *t_tm);
    126          void            xSeconds2Date   (unsigned long seconds,struct tm *time );
    127          
    128          /*******************************************************************************
    129           * GLOBAL FUNCTIONS
    130           */
    131          
    132          /*******************************************************************************
    133           * EXTERN VARIABLES
    134           */
    135          
    136          /*******************************************************************************
    137           * EXTERN FUNCTIONS
    138           */
    139          
    140          /*******************************************************************************
    141          * Function Name  : TIME_ConvUnixToCalendar(time_t t)
    142          * Description    : 转换UNIX时间戳为日历时间
    143          * Input    : u32 t  当前时间的UNIX时间戳
    144          * Output   : None
    145          * Return   : struct tm
    146          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    147          struct tm TIME_ConvUnixToCalendar(time_t t)
    148          {
   \                     TIME_ConvUnixToCalendar: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB08C             SUB      SP,SP,#+48
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x0008             MOVS     R0,R1
    149              struct tm t_tm;
    150              xSeconds2Date(t,&t_tm );
   \   00000008   0x4669             MOV      R1,SP
   \   0000000A   0x.... 0x....      BL       xSeconds2Date
    151              
    152              return t_tm;
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x4669             MOV      R1,SP
   \   00000012   0x222C             MOVS     R2,#+44
   \   00000014   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000018   0xB00C             ADD      SP,SP,#+48
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
    153          }
    154          
    155          /*******************************************************************************
    156          * Function Name  : TIME_ConvCalendarToUnix(struct tm t)
    157          * Description    : 写入RTC时钟当前时间
    158          * Input    : struct tm t
    159          * Output   : None
    160          * Return   : time_t
    161          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    162          time_t TIME_ConvCalendarToUnix(struct tm t)
    163          {
   \                     TIME_ConvCalendarToUnix: (+1)
   \   00000000   0xB40F             PUSH     {R0-R3}
   \   00000002   0xB580             PUSH     {R7,LR}
    164            return xDate2Seconds((struct tm *) &t);
   \   00000004   0xA802             ADD      R0,SP,#+8
   \   00000006   0x.... 0x....      BL       xDate2Seconds
   \   0000000A   0xBC02             POP      {R1}
   \   0000000C   0xF85D 0xFB14      LDR      PC,[SP], #+20    ;; return
    165          }
    166          
    167          /*******************************************************************************
    168          * Function Name  : TIME_GetUnixTime()
    169          * Description    : 从RTC取当前时间的Unix时间戳值
    170          * Input    : None
    171          * Output   : None
    172          * Return   : time_t t
    173          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    174          time_t TIME_GetUnixTime(void)
    175          {
   \                     TIME_GetUnixTime: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB093             SUB      SP,SP,#+76
    176              return TIME_ConvCalendarToUnix(TIME_GetCalendarTime());
   \   00000004   0xA807             ADD      R0,SP,#+28
   \   00000006   0x.... 0x....      BL       TIME_GetCalendarTime
   \   0000000A   0xA907             ADD      R1,SP,#+28
   \   0000000C   0xB084             SUB      SP,SP,#+16
   \   0000000E   0x4668             MOV      R0,SP
   \   00000010   0x222C             MOVS     R2,#+44
   \   00000012   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000016   0xBC0F             POP      {R0-R3}
   \   00000018   0x.... 0x....      BL       TIME_ConvCalendarToUnix
   \   0000001C   0xB013             ADD      SP,SP,#+76
   \   0000001E   0xBD00             POP      {PC}             ;; return
    177          }
    178          
    179          /*******************************************************************************
    180          * Function Name  : TIME_GetCalendarTime()
    181          * Description    : 从RTC取当前时间的日历时间（struct tm）
    182          * Input    : None
    183          * Output   : None
    184          * Return   : time_t t
    185          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    186          struct tm TIME_GetCalendarTime(void)
    187          {
   \                     TIME_GetCalendarTime: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB08C             SUB      SP,SP,#+48
   \   00000004   0x0004             MOVS     R4,R0
    188              struct tm t_tm;
    189              
    190              if ( BSP_GetTime(&t_tm) ) {
   \   00000006   0x4668             MOV      R0,SP
   \   00000008   0x.... 0x....      BL       BSP_GetTime
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD005             BEQ.N    ??TIME_GetCalendarTime_0
    191                  return t_tm;
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x4669             MOV      R1,SP
   \   00000014   0x222C             MOVS     R2,#+44
   \   00000016   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000001A   0xE004             B.N      ??TIME_GetCalendarTime_1
    192              } else {
    193                  return tm_now;
   \                     ??TIME_GetCalendarTime_0: (+1)
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x....             LDR.N    R1,??DataTable3
   \   00000020   0x222C             MOVS     R2,#+44
   \   00000022   0x.... 0x....      BL       __aeabi_memcpy4
   \                     ??TIME_GetCalendarTime_1: (+1)
   \   00000026   0xB00C             ADD      SP,SP,#+48
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    194              }
    195          }
    196          
    197          /*******************************************************************************
    198          * Function Name  : TIME_SetUnixTime()
    199          * Description    : 将给定的Unix时间戳写入RTC
    200          * Input    : time_t t
    201          * Output   : None
    202          * Return   : None
    203          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    204          void TIME_SetUnixTime(time_t t)
    205          {    
   \                     TIME_SetUnixTime: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB093             SUB      SP,SP,#+76
    206              TIME_SetCalendarTime(TIME_ConvUnixToCalendar(t));
   \   00000004   0x0001             MOVS     R1,R0
   \   00000006   0xA807             ADD      R0,SP,#+28
   \   00000008   0x.... 0x....      BL       TIME_ConvUnixToCalendar
   \   0000000C   0xA907             ADD      R1,SP,#+28
   \   0000000E   0xB084             SUB      SP,SP,#+16
   \   00000010   0x4668             MOV      R0,SP
   \   00000012   0x222C             MOVS     R2,#+44
   \   00000014   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000018   0xBC0F             POP      {R0-R3}
   \   0000001A   0x.... 0x....      BL       TIME_SetCalendarTime
    207          }
   \   0000001E   0xB013             ADD      SP,SP,#+76
   \   00000020   0xBD00             POP      {PC}             ;; return
    208          
    209          /*******************************************************************************
    210          * Function Name  : TIME_SetCalendarTime()
    211          * Description    : 将给定的Calendar格式时间转换成UNIX时间戳写入RTC
    212          * Input    : struct tm t
    213          * Output   : None
    214          * Return   : None
    215          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    216          void TIME_SetCalendarTime(struct tm t_tm)
    217          {
   \                     TIME_SetCalendarTime: (+1)
   \   00000000   0xB40F             PUSH     {R0-R3}
   \   00000002   0xB500             PUSH     {LR}
   \   00000004   0xB087             SUB      SP,SP,#+28
    218              BSP_SetTime(t_tm);
   \   00000006   0xA908             ADD      R1,SP,#+32
   \   00000008   0xB084             SUB      SP,SP,#+16
   \   0000000A   0x4668             MOV      R0,SP
   \   0000000C   0x222C             MOVS     R2,#+44
   \   0000000E   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000012   0xBC0F             POP      {R0-R3}
   \   00000014   0x.... 0x....      BL       BSP_SetTime
    219          }
   \   00000018   0xB007             ADD      SP,SP,#+28
   \   0000001A   0xF85D 0xFB14      LDR      PC,[SP], #+20    ;; return
    220          
    221          /*******************************************************************************
    222          * Function Name  : BSP_TIME_Init()
    223          * Description    : 
    224          * Input    : struct tm t
    225          * Output   : None
    226          * Return   : None
    227          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    228          BOOL BSP_TIME_Init(void)
    229          {
   \                     BSP_TIME_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB08C             SUB      SP,SP,#+48
    230              BOOL ret = BSP_RTC_Init();
   \   00000004   0x.... 0x....      BL       BSP_RTC_Init
   \   00000008   0x0004             MOVS     R4,R0
    231              /***********************************************
    232              * 描述： 读取RTC时间
    233              */
    234              tm_now  = TIME_GetCalendarTime();
   \   0000000A   0x4668             MOV      R0,SP
   \   0000000C   0x.... 0x....      BL       TIME_GetCalendarTime
   \   00000010   0x....             LDR.N    R0,??DataTable3
   \   00000012   0x4669             MOV      R1,SP
   \   00000014   0x222C             MOVS     R2,#+44
   \   00000016   0x.... 0x....      BL       __aeabi_memcpy4
    235          
    236              return ret;
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   0xB00C             ADD      SP,SP,#+48
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
    237          }   
    238          
    239          /*******************************************************************************
    240          * Description  : 时钟芯片时间
    241          * Author       : 2018/5/15 星期二, by redmorningcn
    242          *******************************************************************************/
    243          typedef struct t_xtime {
    244            int year; int month;  int day; 
    245            int hour; int minute;  int second; 
    246          } _xtime ;
    247          
    248          #define xMINUTE     (60)            //1分的秒数
    249          #define xHOUR       (60*xMINUTE)    //1小时的秒数
    250          #define xDAY        (24*xHOUR)      //1天的秒数
    251          #define xYEAR       (365*xDAY)      //1年的秒数
    252          
    253          /*******************************************************************************
    254          * Function Name : xDate2Seconds()
    255          * Description   : 将localtime（UTC+8北京时间）转为UNIX TIME，以1970年1月1日为起点 
    256          * Input         : struct tm t
    257          * Output        : None
    258          * Return        : None
    259          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    260          unsigned int  xDate2Seconds(struct tm *t_tm)
    261          {
   \                     xDate2Seconds: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB08C             SUB      SP,SP,#+48
   \   00000004   0x0004             MOVS     R4,R0
    262              const unsigned int  month[12]={
    263              /*01月*/xDAY*(0),
    264              /*02月*/xDAY*(31),
    265              /*03月*/xDAY*(31+28),
    266              /*04月*/xDAY*(31+28+31),
    267              /*05月*/xDAY*(31+28+31+30),
    268              /*06月*/xDAY*(31+28+31+30+31),
    269              /*07月*/xDAY*(31+28+31+30+31+30),
    270              /*08月*/xDAY*(31+28+31+30+31+30+31),
    271              /*09月*/xDAY*(31+28+31+30+31+30+31+31),
    272              /*10月*/xDAY*(31+28+31+30+31+30+31+31+30),
    273              /*11月*/xDAY*(31+28+31+30+31+30+31+31+30+31),
    274              /*12月*/xDAY*(31+28+31+30+31+30+31+31+30+31+30)
    275            };
   \   00000006   0x4668             MOV      R0,SP
   \   00000008   0x....             LDR.N    R1,??DataTable3_1
   \   0000000A   0x2230             MOVS     R2,#+48
   \   0000000C   0x.... 0x....      BL       __aeabi_memcpy4
    276          
    277            unsigned int  seconds = 0;
   \   00000010   0x2000             MOVS     R0,#+0
    278            unsigned int  year = 0;
   \   00000012   0x2100             MOVS     R1,#+0
    279          
    280            year      = t_tm->tm_year - 1970;                 //不考虑2100年千年虫问题
   \   00000014   0x6960             LDR      R0,[R4, #+20]
   \   00000016   0xF2A0 0x71B2      SUBW     R1,R0,#+1970
    281            seconds   = xYEAR*year + xDAY*((year+1)/4);       //前几年过去的秒数
   \   0000001A   0x....             LDR.N    R0,??DataTable3_2  ;; 0x1e13380
   \   0000001C   0x1C4A             ADDS     R2,R1,#+1
   \   0000001E   0x0892             LSRS     R2,R2,#+2
   \   00000020   0x....             LDR.N    R3,??DataTable3_3  ;; 0x15180
   \   00000022   0x435A             MULS     R2,R3,R2
   \   00000024   0xFB00 0x2001      MLA      R0,R0,R1,R2
    282            seconds  += month[t_tm->tm_mon-1];                //加上今年本月过去的秒数
   \   00000028   0x466A             MOV      R2,SP
   \   0000002A   0x6923             LDR      R3,[R4, #+16]
   \   0000002C   0xEB12 0x0283      ADDS     R2,R2,R3, LSL #+2
   \   00000030   0xF852 0x2C04      LDR      R2,[R2, #-4]
   \   00000034   0x1810             ADDS     R0,R2,R0
    283          
    284            if( (t_tm->tm_mon > 2) && (((year+2)%4)==0) )     //2008年为闰年
   \   00000036   0x6922             LDR      R2,[R4, #+16]
   \   00000038   0x2A03             CMP      R2,#+3
   \   0000003A   0xDB09             BLT.N    ??xDate2Seconds_0
   \   0000003C   0x1C89             ADDS     R1,R1,#+2
   \   0000003E   0x2204             MOVS     R2,#+4
   \   00000040   0xFBB1 0xF3F2      UDIV     R3,R1,R2
   \   00000044   0xFB03 0x1312      MLS      R3,R3,R2,R1
   \   00000048   0x2B00             CMP      R3,#+0
   \   0000004A   0xD101             BNE.N    ??xDate2Seconds_0
    285              seconds += xDAY;                                //闰年加1天秒数
   \   0000004C   0x....             LDR.N    R1,??DataTable3_3  ;; 0x15180
   \   0000004E   0x1808             ADDS     R0,R1,R0
    286          
    287            seconds += xDAY*(t_tm->tm_mday-1);                //加上本天过去的秒数
   \                     ??xDate2Seconds_0: (+1)
   \   00000050   0x68E1             LDR      R1,[R4, #+12]
   \   00000052   0x1E49             SUBS     R1,R1,#+1
   \   00000054   0x....             LDR.N    R2,??DataTable3_3  ;; 0x15180
   \   00000056   0xFB02 0x0001      MLA      R0,R2,R1,R0
    288            seconds += xHOUR*t_tm->tm_hour;                   //加上本小时过去的秒数
   \   0000005A   0x68A1             LDR      R1,[R4, #+8]
   \   0000005C   0xF44F 0x6261      MOV      R2,#+3600
   \   00000060   0xFB02 0x0001      MLA      R0,R2,R1,R0
    289            seconds += xMINUTE*t_tm->tm_min;                  //加上本分钟过去的秒数
   \   00000064   0x6861             LDR      R1,[R4, #+4]
   \   00000066   0x223C             MOVS     R2,#+60
   \   00000068   0xFB02 0x0001      MLA      R0,R2,R1,R0
    290            seconds += t_tm->tm_sec;                          //加上当前秒数<br>　seconds -= 8 * xHOUR;
   \   0000006C   0x6821             LDR      R1,[R4, #+0]
   \   0000006E   0x1808             ADDS     R0,R1,R0
    291            seconds -= (UTC * 3600);
   \   00000070   0xF5B0 0x40E1      SUBS     R0,R0,#+28800
    292            
    293            return seconds;
   \   00000074   0xB00C             ADD      SP,SP,#+48
   \   00000076   0xBD10             POP      {R4,PC}          ;; return
    294          } 
    295          
    296          /*******************************************************************************
    297          * Function Name : xSeconds2Date()
    298          * Description   : 将UNIX时间转为UTC+8 即北京时间
    299          *                 UNIX转为UTC 已进行时区转换 北京时间UTC+8
    300          * Input         : struct tm t
    301          * Output        : None
    302          * Return        : None
    303          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    304          void xSeconds2Date(unsigned long seconds,struct tm *time )
    305          {
   \                     xSeconds2Date: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB08D             SUB      SP,SP,#+52
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000C             MOVS     R4,R1
    306              const unsigned int month[12]={
    307              /*01月*/31,
    308              /*02月*/28,
    309              /*03月*/31,
    310              /*04月*/30,
    311              /*05月*/31,
    312              /*06月*/30,
    313              /*07月*/31,
    314              /*08月*/31,
    315              /*09月*/30,
    316              /*10月*/31,
    317              /*11月*/30,
    318              /*12月*/31 
    319              };
   \   00000008   0x4668             MOV      R0,SP
   \   0000000A   0x....             LDR.N    R1,??DataTable3_4
   \   0000000C   0x2230             MOVS     R2,#+48
   \   0000000E   0x.... 0x....      BL       __aeabi_memcpy4
    320          
    321              unsigned int days; 
    322              unsigned short leap_y_count;  
    323          
    324              seconds        += UTC * 3600;               //时区矫正 转为UTC+8 bylzs
   \   00000012   0xF515 0x45E1      ADDS     R5,R5,#+28800
    325              
    326              time->tm_sec    = seconds % 60;             //获得秒 
   \   00000016   0x203C             MOVS     R0,#+60
   \   00000018   0xFBB5 0xF1F0      UDIV     R1,R5,R0
   \   0000001C   0xFB00 0x5011      MLS      R0,R0,R1,R5
   \   00000020   0x6020             STR      R0,[R4, #+0]
    327              seconds        /= 60; 
   \   00000022   0x203C             MOVS     R0,#+60
   \   00000024   0xFBB5 0xF5F0      UDIV     R5,R5,R0
    328              time->tm_min    =  seconds % 60;            //获得分  
   \   00000028   0x203C             MOVS     R0,#+60
   \   0000002A   0xFBB5 0xF1F0      UDIV     R1,R5,R0
   \   0000002E   0xFB00 0x5011      MLS      R0,R0,R1,R5
   \   00000032   0x6060             STR      R0,[R4, #+4]
    329              seconds        /= 60;  
   \   00000034   0x203C             MOVS     R0,#+60
   \   00000036   0xFBB5 0xF5F0      UDIV     R5,R5,R0
    330              time->tm_hour   = seconds % 24;             //获得时 
   \   0000003A   0x2018             MOVS     R0,#+24
   \   0000003C   0xFBB5 0xF1F0      UDIV     R1,R5,R0
   \   00000040   0xFB00 0x5011      MLS      R0,R0,R1,R5
   \   00000044   0x60A0             STR      R0,[R4, #+8]
    331              days            = seconds / 24;             //获得总天数
   \   00000046   0x2018             MOVS     R0,#+24
   \   00000048   0xFBB5 0xF0F0      UDIV     R0,R5,R0
    332              leap_y_count    = (days + 365) / 1461;      //过去了多少个闰年(4年一闰)  
   \   0000004C   0xF200 0x116D      ADDW     R1,R0,#+365
   \   00000050   0xF240 0x52B5      MOVW     R2,#+1461
   \   00000054   0xFBB1 0xF1F2      UDIV     R1,R1,R2
    333          
    334              if( ((days + 366) % 1461) == 0) {           //闰年的最后1天  
   \   00000058   0xF510 0x72B7      ADDS     R2,R0,#+366
   \   0000005C   0xF240 0x53B5      MOVW     R3,#+1461
   \   00000060   0xFBB2 0xF5F3      UDIV     R5,R2,R3
   \   00000064   0xFB03 0x2215      MLS      R2,R3,R5,R2
   \   00000068   0x2A00             CMP      R2,#+0
   \   0000006A   0xD10B             BNE.N    ??xSeconds2Date_0
    335                  time->tm_year   = 1970 + (days / 366);  //获得年  
   \   0000006C   0xF44F 0x71B7      MOV      R1,#+366
   \   00000070   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000074   0xF200 0x70B2      ADDW     R0,R0,#+1970
   \   00000078   0x6160             STR      R0,[R4, #+20]
    336                  time->tm_mon    = 12;                   //调整月  
   \   0000007A   0x200C             MOVS     R0,#+12
   \   0000007C   0x6120             STR      R0,[R4, #+16]
    337                  time->tm_mday   = 31;  
   \   0000007E   0x201F             MOVS     R0,#+31
   \   00000080   0x60E0             STR      R0,[R4, #+12]
    338                  return;  
   \   00000082   0xE036             B.N      ??xSeconds2Date_1
    339              }  
    340          
    341              days -= leap_y_count; 
   \                     ??xSeconds2Date_0: (+1)
   \   00000084   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000086   0x1A40             SUBS     R0,R0,R1
    342              time->tm_year = 1970 + (days / 365);        //获得年  
   \   00000088   0xF240 0x116D      MOVW     R1,#+365
   \   0000008C   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \   00000090   0xF201 0x71B2      ADDW     R1,R1,#+1970
   \   00000094   0x6161             STR      R1,[R4, #+20]
    343              days %= 365;                                //今年的第几天  
   \   00000096   0xF240 0x116D      MOVW     R1,#+365
   \   0000009A   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \   0000009E   0xFB01 0x0012      MLS      R0,R1,R2,R0
    344          
    345              days = 01 + days;                           //1日开始  
   \   000000A2   0x1C40             ADDS     R0,R0,#+1
    346          
    347              if( (time->tm_year % 4) == 0 ) { 
   \   000000A4   0x6961             LDR      R1,[R4, #+20]
   \   000000A6   0x2204             MOVS     R2,#+4
   \   000000A8   0xFB91 0xF3F2      SDIV     R3,R1,R2
   \   000000AC   0xFB03 0x1312      MLS      R3,R3,R2,R1
   \   000000B0   0x2B00             CMP      R3,#+0
   \   000000B2   0xD102             BNE.N    ??xSeconds2Date_2
    348                  if(days > 60)
   \   000000B4   0x283D             CMP      R0,#+61
   \   000000B6   0xD303             BCC.N    ??xSeconds2Date_3
    349                      --days;                             //闰年调整  
   \   000000B8   0x1E40             SUBS     R0,R0,#+1
    350                  else {  
    351                      if(days == 60){  
    352                          time->tm_mon = 2;  
    353                          time->tm_mday = 29;  
    354                          return;  
    355                      }  
    356                  }  
    357              }  
    358          
    359              for(time->tm_mon = 0;month[time->tm_mon] < days;time->tm_mon++) {  
   \                     ??xSeconds2Date_2: (+1)
   \   000000BA   0x2100             MOVS     R1,#+0
   \   000000BC   0x6121             STR      R1,[R4, #+16]
   \   000000BE   0xE00E             B.N      ??xSeconds2Date_4
   \                     ??xSeconds2Date_3: (+1)
   \   000000C0   0x283C             CMP      R0,#+60
   \   000000C2   0xD1FA             BNE.N    ??xSeconds2Date_2
   \   000000C4   0x2002             MOVS     R0,#+2
   \   000000C6   0x6120             STR      R0,[R4, #+16]
   \   000000C8   0x201D             MOVS     R0,#+29
   \   000000CA   0x60E0             STR      R0,[R4, #+12]
   \   000000CC   0xE011             B.N      ??xSeconds2Date_1
    360                  days -= month[time->tm_mon]; 
   \                     ??xSeconds2Date_5: (+1)
   \   000000CE   0x4669             MOV      R1,SP
   \   000000D0   0x6922             LDR      R2,[R4, #+16]
   \   000000D2   0xF851 0x1022      LDR      R1,[R1, R2, LSL #+2]
   \   000000D6   0x1A40             SUBS     R0,R0,R1
    361              }  
   \   000000D8   0x6921             LDR      R1,[R4, #+16]
   \   000000DA   0x1C49             ADDS     R1,R1,#+1
   \   000000DC   0x6121             STR      R1,[R4, #+16]
   \                     ??xSeconds2Date_4: (+1)
   \   000000DE   0x4669             MOV      R1,SP
   \   000000E0   0x6922             LDR      R2,[R4, #+16]
   \   000000E2   0xF851 0x1022      LDR      R1,[R1, R2, LSL #+2]
   \   000000E6   0x4281             CMP      R1,R0
   \   000000E8   0xD3F1             BCC.N    ??xSeconds2Date_5
    362          
    363              ++time->tm_mon;                             //调整月  
   \   000000EA   0x6921             LDR      R1,[R4, #+16]
   \   000000EC   0x1C49             ADDS     R1,R1,#+1
   \   000000EE   0x6121             STR      R1,[R4, #+16]
    364              time->tm_mday = days;                       //获得日  
   \   000000F0   0x60E0             STR      R0,[R4, #+12]
    365          } 
   \                     ??xSeconds2Date_1: (+1)
   \   000000F2   0xB00D             ADD      SP,SP,#+52
   \   000000F4   0xBD30             POP      {R4,R5,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     tm_now

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x01E13380         DC32     0x1e13380

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x00015180         DC32     0x15180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x00000000         DC32 0, 2678400, 5097600, 7776000, 10368000, 13046400, 15638400
   \              0x0028DE80   
   \              0x004DC880   
   \              0x0076A700   
   \              0x009E3400   
   \              0x00C71280   
   \              0x00EE9F80   
   \   0000001C   0x01177E00         DC32 18316800, 20995200, 23587200, 26265600, 28857600
   \              0x01405C80   
   \              0x0167E980   
   \              0x0190C800   
   \              0x01B85500   

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x0000001F         DC32 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
   \              0x0000001C   
   \              0x0000001F   
   \              0x0000001E   
   \              0x0000001F   
   \              0x0000001E   
   \              0x0000001F   
   \              0x0000001F   
   \              0x0000001E   
   \              0x0000001F   
   \              0x0000001E   
   \              0x0000001F   
    366          
    367          /*******************************************************************************
    368           *              end of file                                                    *
    369           *******************************************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      56   BSP_TIME_Init
        56   -> BSP_RTC_Init
        56   -> TIME_GetCalendarTime
        56   -> __aeabi_memcpy4
      24   TIME_ConvCalendarToUnix
        24   -> xDate2Seconds
      56   TIME_ConvUnixToCalendar
        56   -> __aeabi_memcpy4
        56   -> xSeconds2Date
      56   TIME_GetCalendarTime
        56   -> BSP_GetTime
        56   -> __aeabi_memcpy4
      96   TIME_GetUnixTime
        80   -> TIME_ConvCalendarToUnix
        80   -> TIME_GetCalendarTime
        96   -> __aeabi_memcpy4
      64   TIME_SetCalendarTime
        48   -> BSP_SetTime
        64   -> __aeabi_memcpy4
      96   TIME_SetUnixTime
        80   -> TIME_ConvUnixToCalendar
        80   -> TIME_SetCalendarTime
        96   -> __aeabi_memcpy4
      56   xDate2Seconds
        56   -> __aeabi_memcpy4
      64   xSeconds2Date
        64   -> __aeabi_memcpy4


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
      48  ?_0
      48  ?_1
      34  BSP_TIME_Init
      16  TIME_ConvCalendarToUnix
      28  TIME_ConvUnixToCalendar
      42  TIME_GetCalendarTime
      32  TIME_GetUnixTime
      30  TIME_SetCalendarTime
      34  TIME_SetUnixTime
       4  t_last
       4  t_now
      44  tm_now
     120  xDate2Seconds
     246  xSeconds2Date

 
   8 bytes in section .bss
  44 bytes in section .data
  96 bytes in section .rodata
 602 bytes in section .text
 
 602 bytes of CODE  memory
  96 bytes of CONST memory
  52 bytes of DATA  memory

Errors: none
Warnings: none
