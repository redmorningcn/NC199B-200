###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       11/Jul/2018  11:13:10
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC210\NC210-200处理板\source\Software\uCOS-III\Source\os_msg.c
#    Command line =  
#        F:\iar\NC210\NC210-200处理板\source\Software\uCOS-III\Source\os_msg.c
#        -D USE_STDPERIPH_DRIVER -D APP_RELEASE -lCN
#        F:\iar\NC210\NC210-200处理板\project\app_release\List -o
#        F:\iar\NC210\NC210-200处理板\project\app_release\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC210\NC210-200处理板\project\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\config\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\task\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\user\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\OS\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\Ports\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\driver\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-LIB\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Source\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\ST\STM32\inc\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Ports\STM32\STM32F103\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Source\
#        -Ol --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC210\NC210-200处理板\project\app_release\List\os_msg.lst
#    Object file  =  
#        F:\iar\NC210\NC210-200处理板\project\app_release\Obj\os_msg.o
#
###############################################################################

F:\iar\NC210\NC210-200处理板\source\Software\uCOS-III\Source\os_msg.c
      1          /*
      2          ************************************************************************************************************************
      3          *                                                      uC/OS-III
      4          *                                                 The Real-Time Kernel
      5          *
      6          *                                  (c) Copyright 2009-2016; Micrium, Inc.; Weston, FL
      7          *                           All rights reserved.  Protected by international copyright laws.
      8          *
      9          *                                              MESSAGE HANDLING SERVICES
     10          *
     11          * File    : OS_MSG.C
     12          * By      : JJL
     13          * Version : V3.06.00
     14          *
     15          * LICENSING TERMS:
     16          * ---------------
     17          *           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or
     18          *           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
     19          *           product then, you need to contact Micrium to properly license uC/OS-III for its use in your
     20          *           application/product.   We provide ALL the source code for your convenience and to help you
     21          *           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use
     22          *           it commercially without paying a licensing fee.
     23          *
     24          *           Knowledge of the source code may NOT be used to develop a similar product.
     25          *
     26          *           Please help us continue to provide the embedded community with the finest software available.
     27          *           Your honesty is greatly appreciated.
     28          *
     29          *           You can find our product's user manual, API reference, release notes and
     30          *           more information at https://doc.micrium.com.
     31          *           You can contact us at www.micrium.com.
     32          ************************************************************************************************************************
     33          */
     34          
     35          #define  MICRIUM_SOURCE
     36          #include "os.h"
     37          
     38          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     39          const  CPU_CHAR  *os_msg__c = "$Id: $";
     40          #endif
     41          
     42          
     43          #if (OS_MSG_EN == DEF_ENABLED)
     44          
     45          /*
     46          ************************************************************************************************************************
     47          *                                            INITIALIZE THE POOL OF 'OS_MSG'
     48          *
     49          * Description: This function is called by OSInit() to initialize the free list of OS_MSGs.
     50          *
     51          * Argument(s): p_err     is a pointer to a variable that will contain an error code returned by this function.
     52          *
     53          *                            OS_ERR_MSG_POOL_NULL_PTR
     54          *                            OS_ERR_MSG_POOL_EMPTY
     55          *                            OS_ERR_NONE
     56          *
     57          * Returns    : none
     58          *
     59          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
     60          ************************************************************************************************************************
     61          */
     62          

   \                                 In section .text, align 2, keep-with-next
     63          void  OS_MsgPoolInit (OS_ERR  *p_err)
     64          {
   \                     OS_MsgPoolInit: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
     65              OS_MSG      *p_msg1;
     66              OS_MSG      *p_msg2;
     67              OS_MSG_QTY   i;
     68              OS_MSG_QTY   loops;
     69          
     70          
     71          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
     72              if (OSCfg_MsgPoolBasePtr == DEF_NULL) {
   \   00000002   0x....             LDR.N    R1,??DataTable3
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD103             BNE.N    ??OS_MsgPoolInit_0
     73                 *p_err = OS_ERR_MSG_POOL_NULL_PTR;
   \   0000000A   0xF245 0x711E      MOVW     R1,#+22302
   \   0000000E   0x8001             STRH     R1,[R0, #+0]
     74                  return;
   \   00000010   0xE037             B.N      ??OS_MsgPoolInit_1
     75              }
     76              if (OSCfg_MsgPoolSize == 0u) {
   \                     ??OS_MsgPoolInit_0: (+1)
   \   00000012   0x....             LDR.N    R1,??DataTable3_1
   \   00000014   0x8809             LDRH     R1,[R1, #+0]
   \   00000016   0x2900             CMP      R1,#+0
   \   00000018   0xD103             BNE.N    ??OS_MsgPoolInit_2
     77                 *p_err = OS_ERR_MSG_POOL_EMPTY;
   \   0000001A   0xF245 0x711D      MOVW     R1,#+22301
   \   0000001E   0x8001             STRH     R1,[R0, #+0]
     78                  return;
   \   00000020   0xE02F             B.N      ??OS_MsgPoolInit_1
     79              }
     80          #endif
     81          
     82              p_msg1 = OSCfg_MsgPoolBasePtr;
   \                     ??OS_MsgPoolInit_2: (+1)
   \   00000022   0x....             LDR.N    R1,??DataTable3
   \   00000024   0x6809             LDR      R1,[R1, #+0]
     83              p_msg2 = OSCfg_MsgPoolBasePtr;
   \   00000026   0x....             LDR.N    R2,??DataTable3
   \   00000028   0x6812             LDR      R2,[R2, #+0]
     84              p_msg2++;
   \   0000002A   0x3210             ADDS     R2,R2,#+16
     85              loops  = OSCfg_MsgPoolSize - 1u;
   \   0000002C   0x....             LDR.N    R3,??DataTable3_1
   \   0000002E   0x881B             LDRH     R3,[R3, #+0]
   \   00000030   0x1E5C             SUBS     R4,R3,#+1
     86              for (i = 0u; i < loops; i++) {                              /* Init. list of free OS_MSGs                           */
   \   00000032   0x2300             MOVS     R3,#+0
   \   00000034   0xE009             B.N      ??OS_MsgPoolInit_3
     87                  p_msg1->NextPtr = p_msg2;
   \                     ??OS_MsgPoolInit_4: (+1)
   \   00000036   0x600A             STR      R2,[R1, #+0]
     88                  p_msg1->MsgPtr  = DEF_NULL;
   \   00000038   0x2500             MOVS     R5,#+0
   \   0000003A   0x604D             STR      R5,[R1, #+4]
     89                  p_msg1->MsgSize = 0u;
   \   0000003C   0x2500             MOVS     R5,#+0
   \   0000003E   0x810D             STRH     R5,[R1, #+8]
     90          #if (OS_CFG_TS_EN == DEF_ENABLED)
     91                  p_msg1->MsgTS   = 0u;
   \   00000040   0x2500             MOVS     R5,#+0
   \   00000042   0x60CD             STR      R5,[R1, #+12]
     92          #endif
     93                  p_msg1++;
   \   00000044   0x3110             ADDS     R1,R1,#+16
     94                  p_msg2++;
   \   00000046   0x3210             ADDS     R2,R2,#+16
     95              }
   \   00000048   0x1C5B             ADDS     R3,R3,#+1
   \                     ??OS_MsgPoolInit_3: (+1)
   \   0000004A   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000004C   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000004E   0x42A3             CMP      R3,R4
   \   00000050   0xD3F1             BCC.N    ??OS_MsgPoolInit_4
     96              p_msg1->NextPtr = DEF_NULL;                                 /* Last OS_MSG                                          */
   \   00000052   0x2200             MOVS     R2,#+0
   \   00000054   0x600A             STR      R2,[R1, #+0]
     97              p_msg1->MsgPtr  = DEF_NULL;
   \   00000056   0x2200             MOVS     R2,#+0
   \   00000058   0x604A             STR      R2,[R1, #+4]
     98              p_msg1->MsgSize = 0u;
   \   0000005A   0x2200             MOVS     R2,#+0
   \   0000005C   0x810A             STRH     R2,[R1, #+8]
     99          #if (OS_CFG_TS_EN == DEF_ENABLED)
    100              p_msg1->MsgTS   = 0u;
   \   0000005E   0x2200             MOVS     R2,#+0
   \   00000060   0x60CA             STR      R2,[R1, #+12]
    101          #endif
    102          
    103              OSMsgPool.NextPtr    = OSCfg_MsgPoolBasePtr;
   \   00000062   0x....             LDR.N    R1,??DataTable3
   \   00000064   0x6809             LDR      R1,[R1, #+0]
   \   00000066   0x....             LDR.N    R2,??DataTable3_2
   \   00000068   0x6011             STR      R1,[R2, #+0]
    104              OSMsgPool.NbrFree    = OSCfg_MsgPoolSize;
   \   0000006A   0x....             LDR.N    R1,??DataTable3_1
   \   0000006C   0x8809             LDRH     R1,[R1, #+0]
   \   0000006E   0x....             LDR.N    R2,??DataTable3_2
   \   00000070   0x8091             STRH     R1,[R2, #+4]
    105              OSMsgPool.NbrUsed    = 0u;
   \   00000072   0x2100             MOVS     R1,#+0
   \   00000074   0x....             LDR.N    R2,??DataTable3_2
   \   00000076   0x80D1             STRH     R1,[R2, #+6]
    106          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    107              OSMsgPool.NbrUsedMax = 0u;
   \   00000078   0x2100             MOVS     R1,#+0
   \   0000007A   0x....             LDR.N    R2,??DataTable3_2
   \   0000007C   0x8111             STRH     R1,[R2, #+8]
    108          #endif
    109             *p_err                =  OS_ERR_NONE;
   \   0000007E   0x2100             MOVS     R1,#+0
   \   00000080   0x8001             STRH     R1,[R0, #+0]
    110          }
   \                     ??OS_MsgPoolInit_1: (+1)
   \   00000082   0xBC30             POP      {R4,R5}
   \   00000084   0x4770             BX       LR               ;; return
    111          
    112          
    113          /*
    114          ************************************************************************************************************************
    115          *                                        RELEASE ALL MESSAGE IN MESSAGE QUEUE
    116          *
    117          * Description: This function returns all the messages in a message queue to the free list.
    118          *
    119          * Arguments  : p_msg_q       is a pointer to the OS_MSG_Q structure containing messages to free.
    120          *              -------
    121          *
    122          * Returns    : the number of OS_MSGs returned to the free list
    123          *
    124          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    125          ************************************************************************************************************************
    126          */
    127          

   \                                 In section .text, align 2, keep-with-next
    128          OS_MSG_QTY  OS_MsgQFreeAll (OS_MSG_Q  *p_msg_q)
    129          {
    130              OS_MSG      *p_msg;
    131              OS_MSG_QTY   qty;
    132          
    133          
    134          
    135              qty = p_msg_q->NbrEntries;                                  /* Get the number of OS_MSGs being freed                */
   \                     OS_MsgQFreeAll: (+1)
   \   00000000   0x8941             LDRH     R1,[R0, #+10]
    136              if (p_msg_q->NbrEntries > 0u) {
   \   00000002   0x8942             LDRH     R2,[R0, #+10]
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD01A             BEQ.N    ??OS_MsgQFreeAll_0
    137                  p_msg                   = p_msg_q->InPtr;               /* Point to end of message chain                        */
   \   00000008   0x6802             LDR      R2,[R0, #+0]
    138                  p_msg->NextPtr          = OSMsgPool.NextPtr;
   \   0000000A   0x....             LDR.N    R3,??DataTable3_2
   \   0000000C   0x681B             LDR      R3,[R3, #+0]
   \   0000000E   0x6013             STR      R3,[R2, #+0]
    139                  OSMsgPool.NextPtr       = p_msg_q->OutPtr;              /* Point to beginning of message chain                  */
   \   00000010   0x6842             LDR      R2,[R0, #+4]
   \   00000012   0x....             LDR.N    R3,??DataTable3_2
   \   00000014   0x601A             STR      R2,[R3, #+0]
    140                  OSMsgPool.NbrUsed      -= p_msg_q->NbrEntries;          /* Update statistics for free list of messages          */
   \   00000016   0x....             LDR.N    R2,??DataTable3_2
   \   00000018   0x88D2             LDRH     R2,[R2, #+6]
   \   0000001A   0x8943             LDRH     R3,[R0, #+10]
   \   0000001C   0x1AD2             SUBS     R2,R2,R3
   \   0000001E   0x....             LDR.N    R3,??DataTable3_2
   \   00000020   0x80DA             STRH     R2,[R3, #+6]
    141                  OSMsgPool.NbrFree      += p_msg_q->NbrEntries;
   \   00000022   0x....             LDR.N    R2,??DataTable3_2
   \   00000024   0x8892             LDRH     R2,[R2, #+4]
   \   00000026   0x8943             LDRH     R3,[R0, #+10]
   \   00000028   0x189A             ADDS     R2,R3,R2
   \   0000002A   0x....             LDR.N    R3,??DataTable3_2
   \   0000002C   0x809A             STRH     R2,[R3, #+4]
    142                  p_msg_q->NbrEntries     = 0u;                           /* Flush the message queue                              */
   \   0000002E   0x2200             MOVS     R2,#+0
   \   00000030   0x8142             STRH     R2,[R0, #+10]
    143          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    144                  p_msg_q->NbrEntriesMax  = 0u;
   \   00000032   0x2200             MOVS     R2,#+0
   \   00000034   0x8182             STRH     R2,[R0, #+12]
    145          #endif
    146                  p_msg_q->InPtr          = DEF_NULL;
   \   00000036   0x2200             MOVS     R2,#+0
   \   00000038   0x6002             STR      R2,[R0, #+0]
    147                  p_msg_q->OutPtr         = DEF_NULL;
   \   0000003A   0x2200             MOVS     R2,#+0
   \   0000003C   0x6042             STR      R2,[R0, #+4]
    148              }
    149              return (qty);
   \                     ??OS_MsgQFreeAll_0: (+1)
   \   0000003E   0x0008             MOVS     R0,R1
   \   00000040   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000042   0x4770             BX       LR               ;; return
    150          }
    151          
    152          
    153          /*
    154          ************************************************************************************************************************
    155          *                                               INITIALIZE A MESSAGE QUEUE
    156          *
    157          * Description: This function is called to initialize a message queue
    158          *
    159          * Arguments  : p_msg_q      is a pointer to the message queue to initialize
    160          *              -------
    161          *
    162          *              size          is the maximum number of entries that a message queue can have.
    163          *
    164          * Returns    : none
    165          *
    166          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    167          ************************************************************************************************************************
    168          */
    169          

   \                                 In section .text, align 2, keep-with-next
    170          void  OS_MsgQInit (OS_MSG_Q    *p_msg_q,
    171                             OS_MSG_QTY   size)
    172          {
    173              p_msg_q->NbrEntriesSize = size;
   \                     OS_MsgQInit: (+1)
   \   00000000   0x8101             STRH     R1,[R0, #+8]
    174              p_msg_q->NbrEntries     = 0u;
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x8141             STRH     R1,[R0, #+10]
    175          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    176              p_msg_q->NbrEntriesMax  = 0u;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x8181             STRH     R1,[R0, #+12]
    177          #endif
    178              p_msg_q->InPtr          = DEF_NULL;
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x6001             STR      R1,[R0, #+0]
    179              p_msg_q->OutPtr         = DEF_NULL;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x6041             STR      R1,[R0, #+4]
    180          }
   \   00000012   0x4770             BX       LR               ;; return
    181          
    182          
    183          /*
    184          ************************************************************************************************************************
    185          *                                           RETRIEVE MESSAGE FROM MESSAGE QUEUE
    186          *
    187          * Description: This function retrieves a message from a message queue
    188          *
    189          * Arguments  : p_msg_q     is a pointer to the message queue where we want to extract the message from
    190          *              -------
    191          *
    192          *              p_msg_size  is a pointer to where the size (in bytes) of the message will be placed
    193          *
    194          *              p_ts        is a pointer to where the time stamp will be placed
    195          *
    196          *              p_err       is a pointer to an error code that will be returned from this call.
    197          *
    198          *                              OS_ERR_Q_EMPTY
    199          *                              OS_ERR_NONE
    200          *
    201          * Returns    : The message (a pointer)
    202          *
    203          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    204          ************************************************************************************************************************
    205          */
    206          

   \                                 In section .text, align 2, keep-with-next
    207          void  *OS_MsgQGet (OS_MSG_Q     *p_msg_q,
    208                             OS_MSG_SIZE  *p_msg_size,
    209                             CPU_TS       *p_ts,
    210                             OS_ERR       *p_err)
    211          {
   \                     OS_MsgQGet: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    212              OS_MSG  *p_msg;
    213              void    *p_void;
    214          
    215          
    216          #if (OS_CFG_TS_EN == DEF_DISABLED)
    217              (void)p_ts;                                                 /* Prevent compiler warning for not using 'ts'          */
    218          #endif
    219          
    220              if (p_msg_q->NbrEntries == 0u) {                            /* Is the queue empty?                                  */
   \   00000002   0x8944             LDRH     R4,[R0, #+10]
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD10A             BNE.N    ??OS_MsgQGet_0
    221                 *p_msg_size = 0u;                                        /* Yes                                                  */
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x8008             STRH     R0,[R1, #+0]
    222          #if (OS_CFG_TS_EN == DEF_ENABLED)
    223                  if (p_ts != DEF_NULL) {
   \   0000000C   0x2A00             CMP      R2,#+0
   \   0000000E   0xD001             BEQ.N    ??OS_MsgQGet_1
    224                     *p_ts = 0u;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x6010             STR      R0,[R2, #+0]
    225                  }
    226          #endif
    227                 *p_err = OS_ERR_Q_EMPTY;
   \                     ??OS_MsgQGet_1: (+1)
   \   00000014   0xF246 0x5092      MOVW     R0,#+26002
   \   00000018   0x8018             STRH     R0,[R3, #+0]
    228                  return (DEF_NULL);
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE026             B.N      ??OS_MsgQGet_2
    229              }
    230          
    231              p_msg           = p_msg_q->OutPtr;                          /* No, get the next message to extract from the queue   */
   \                     ??OS_MsgQGet_0: (+1)
   \   0000001E   0x6845             LDR      R5,[R0, #+4]
    232              p_void          = p_msg->MsgPtr;
   \   00000020   0x686C             LDR      R4,[R5, #+4]
    233             *p_msg_size      = p_msg->MsgSize;
   \   00000022   0x892E             LDRH     R6,[R5, #+8]
   \   00000024   0x800E             STRH     R6,[R1, #+0]
    234          #if (OS_CFG_TS_EN == DEF_ENABLED)
    235              if (p_ts != DEF_NULL) {
   \   00000026   0x2A00             CMP      R2,#+0
   \   00000028   0xD001             BEQ.N    ??OS_MsgQGet_3
    236                 *p_ts = p_msg->MsgTS;
   \   0000002A   0x68E9             LDR      R1,[R5, #+12]
   \   0000002C   0x6011             STR      R1,[R2, #+0]
    237              }
    238          #endif
    239          
    240              p_msg_q->OutPtr = p_msg->NextPtr;                           /* Point to next message to extract                     */
   \                     ??OS_MsgQGet_3: (+1)
   \   0000002E   0x6829             LDR      R1,[R5, #+0]
   \   00000030   0x6041             STR      R1,[R0, #+4]
    241          
    242              if (p_msg_q->OutPtr == DEF_NULL) {                          /* Are there any more messages in the queue?            */
   \   00000032   0x6841             LDR      R1,[R0, #+4]
   \   00000034   0x2900             CMP      R1,#+0
   \   00000036   0xD104             BNE.N    ??OS_MsgQGet_4
    243                  p_msg_q->InPtr      = DEF_NULL;                         /* No                                                   */
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0x6001             STR      R1,[R0, #+0]
    244                  p_msg_q->NbrEntries = 0u;
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0x8141             STRH     R1,[R0, #+10]
   \   00000040   0xE002             B.N      ??OS_MsgQGet_5
    245              } else {
    246                  p_msg_q->NbrEntries--;                                  /* Yes, One less message in the queue                   */
   \                     ??OS_MsgQGet_4: (+1)
   \   00000042   0x8941             LDRH     R1,[R0, #+10]
   \   00000044   0x1E49             SUBS     R1,R1,#+1
   \   00000046   0x8141             STRH     R1,[R0, #+10]
    247              }
    248          
    249              p_msg->NextPtr    = OSMsgPool.NextPtr;                      /* Return message control block to free list            */
   \                     ??OS_MsgQGet_5: (+1)
   \   00000048   0x....             LDR.N    R0,??DataTable3_2
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x6028             STR      R0,[R5, #+0]
    250              OSMsgPool.NextPtr = p_msg;
   \   0000004E   0x....             LDR.N    R0,??DataTable3_2
   \   00000050   0x6005             STR      R5,[R0, #+0]
    251              OSMsgPool.NbrFree++;
   \   00000052   0x....             LDR.N    R0,??DataTable3_2
   \   00000054   0x8880             LDRH     R0,[R0, #+4]
   \   00000056   0x1C40             ADDS     R0,R0,#+1
   \   00000058   0x....             LDR.N    R1,??DataTable3_2
   \   0000005A   0x8088             STRH     R0,[R1, #+4]
    252              OSMsgPool.NbrUsed--;
   \   0000005C   0x....             LDR.N    R0,??DataTable3_2
   \   0000005E   0x88C0             LDRH     R0,[R0, #+6]
   \   00000060   0x1E40             SUBS     R0,R0,#+1
   \   00000062   0x....             LDR.N    R1,??DataTable3_2
   \   00000064   0x80C8             STRH     R0,[R1, #+6]
    253          
    254             *p_err             = OS_ERR_NONE;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x8018             STRH     R0,[R3, #+0]
    255              return (p_void);
   \   0000006A   0x0020             MOVS     R0,R4
   \                     ??OS_MsgQGet_2: (+1)
   \   0000006C   0xBC70             POP      {R4-R6}
   \   0000006E   0x4770             BX       LR               ;; return
    256          }
    257          
    258          
    259          /*
    260          ************************************************************************************************************************
    261          *                                           DEPOSIT MESSAGE IN MESSAGE QUEUE
    262          *
    263          * Description: This function places a message in a message queue
    264          *
    265          * Arguments  : p_msg_q     is a pointer to the OS_TCB of the task to post the message to
    266          *              -------
    267          *
    268          *              p_void      is a pointer to the message to send.
    269          *
    270          *              msg_size    is the size of the message (in bytes)
    271          *
    272          *              opt         specifies whether the message will be posted in FIFO or LIFO order
    273          *
    274          *                              OS_OPT_POST_FIFO
    275          *                              OS_OPT_POST_LIFO
    276          *
    277          *              ts          is a timestamp as to when the message was posted
    278          *
    279          *              p_err       is a pointer to a variable that will contain an error code returned by this function.
    280          *
    281          *                              OS_ERR_Q_MAX           if the queue is full
    282          *                              OS_ERR_MSG_POOL_EMPTY  if we no longer have any OS_MSG to use
    283          *                              OS_ERR_NONE            the message was deposited in the queue
    284          *
    285          * Returns    : none
    286          *
    287          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    288          ************************************************************************************************************************
    289          */
    290          

   \                                 In section .text, align 2, keep-with-next
    291          void  OS_MsgQPut (OS_MSG_Q     *p_msg_q,
    292                            void         *p_void,
    293                            OS_MSG_SIZE   msg_size,
    294                            OS_OPT        opt,
    295                            CPU_TS        ts,
    296                            OS_ERR       *p_err)
    297          {
   \                     OS_MsgQPut: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x9C05             LDR      R4,[SP, #+20]
    298              OS_MSG  *p_msg;
    299              OS_MSG  *p_msg_in;
    300          
    301          
    302          #if (OS_CFG_TS_EN == DEF_DISABLED)
    303              (void)ts;                                                   /* Prevent compiler warning for not using 'ts'          */
    304          #endif
    305          
    306              if (p_msg_q->NbrEntries >= p_msg_q->NbrEntriesSize) {
   \   00000004   0x8945             LDRH     R5,[R0, #+10]
   \   00000006   0x8906             LDRH     R6,[R0, #+8]
   \   00000008   0x42B5             CMP      R5,R6
   \   0000000A   0xD303             BCC.N    ??OS_MsgQPut_0
    307                 *p_err = OS_ERR_Q_MAX;                                   /* Message queue cannot accept any more messages        */
   \   0000000C   0xF246 0x5093      MOVW     R0,#+26003
   \   00000010   0x8020             STRH     R0,[R4, #+0]
    308                  return;
   \   00000012   0xE044             B.N      ??OS_MsgQPut_1
    309              }
    310          
    311              if (OSMsgPool.NbrFree == 0u) {
   \                     ??OS_MsgQPut_0: (+1)
   \   00000014   0x....             LDR.N    R5,??DataTable3_2
   \   00000016   0x88AD             LDRH     R5,[R5, #+4]
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD103             BNE.N    ??OS_MsgQPut_2
    312                 *p_err = OS_ERR_MSG_POOL_EMPTY;                          /* No more OS_MSG to use                                */
   \   0000001C   0xF245 0x701D      MOVW     R0,#+22301
   \   00000020   0x8020             STRH     R0,[R4, #+0]
    313                  return;
   \   00000022   0xE03C             B.N      ??OS_MsgQPut_1
    314              }
    315          
    316              p_msg = OSMsgPool.NextPtr;                                  /* Remove message control block from free list          */
   \                     ??OS_MsgQPut_2: (+1)
   \   00000024   0x....             LDR.N    R5,??DataTable3_2
   \   00000026   0x682D             LDR      R5,[R5, #+0]
    317              OSMsgPool.NextPtr = p_msg->NextPtr;
   \   00000028   0x682E             LDR      R6,[R5, #+0]
   \   0000002A   0x....             LDR.N    R7,??DataTable3_2
   \   0000002C   0x603E             STR      R6,[R7, #+0]
    318              OSMsgPool.NbrFree--;
   \   0000002E   0x....             LDR.N    R6,??DataTable3_2
   \   00000030   0x88B6             LDRH     R6,[R6, #+4]
   \   00000032   0x1E76             SUBS     R6,R6,#+1
   \   00000034   0x....             LDR.N    R7,??DataTable3_2
   \   00000036   0x80BE             STRH     R6,[R7, #+4]
    319              OSMsgPool.NbrUsed++;
   \   00000038   0x....             LDR.N    R6,??DataTable3_2
   \   0000003A   0x88F6             LDRH     R6,[R6, #+6]
   \   0000003C   0x1C76             ADDS     R6,R6,#+1
   \   0000003E   0x....             LDR.N    R7,??DataTable3_2
   \   00000040   0x80FE             STRH     R6,[R7, #+6]
    320          
    321          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    322              if (OSMsgPool.NbrUsedMax < OSMsgPool.NbrUsed) {
   \   00000042   0x....             LDR.N    R6,??DataTable3_2
   \   00000044   0x8936             LDRH     R6,[R6, #+8]
   \   00000046   0x....             LDR.N    R7,??DataTable3_2
   \   00000048   0x88FF             LDRH     R7,[R7, #+6]
   \   0000004A   0x42BE             CMP      R6,R7
   \   0000004C   0xD203             BCS.N    ??OS_MsgQPut_3
    323                  OSMsgPool.NbrUsedMax = OSMsgPool.NbrUsed;
   \   0000004E   0x....             LDR.N    R6,??DataTable3_2
   \   00000050   0x88F6             LDRH     R6,[R6, #+6]
   \   00000052   0x....             LDR.N    R7,??DataTable3_2
   \   00000054   0x813E             STRH     R6,[R7, #+8]
    324              }
    325          #endif
    326          
    327              if (p_msg_q->NbrEntries == 0u) {                            /* Is this first message placed in the queue?           */
   \                     ??OS_MsgQPut_3: (+1)
   \   00000056   0x8946             LDRH     R6,[R0, #+10]
   \   00000058   0x2E00             CMP      R6,#+0
   \   0000005A   0xD106             BNE.N    ??OS_MsgQPut_4
    328                  p_msg_q->InPtr         = p_msg;                         /* Yes                                                  */
   \   0000005C   0x6005             STR      R5,[R0, #+0]
    329                  p_msg_q->OutPtr        = p_msg;
   \   0000005E   0x6045             STR      R5,[R0, #+4]
    330                  p_msg_q->NbrEntries    = 1u;
   \   00000060   0x2301             MOVS     R3,#+1
   \   00000062   0x8143             STRH     R3,[R0, #+10]
    331                  p_msg->NextPtr         = DEF_NULL;
   \   00000064   0x2300             MOVS     R3,#+0
   \   00000066   0x602B             STR      R3,[R5, #+0]
   \   00000068   0xE00D             B.N      ??OS_MsgQPut_5
    332              } else {                                                    /* No                                                   */
    333                  if ((opt & OS_OPT_POST_LIFO) == OS_OPT_POST_FIFO) {     /* Is it FIFO or LIFO?                                  */
   \                     ??OS_MsgQPut_4: (+1)
   \   0000006A   0x06DB             LSLS     R3,R3,#+27
   \   0000006C   0xD405             BMI.N    ??OS_MsgQPut_6
    334                      p_msg_in           = p_msg_q->InPtr;                /* FIFO, add to the head                                */
   \   0000006E   0x6803             LDR      R3,[R0, #+0]
    335                      p_msg_in->NextPtr  = p_msg;
   \   00000070   0x601D             STR      R5,[R3, #+0]
    336                      p_msg_q->InPtr     = p_msg;
   \   00000072   0x6005             STR      R5,[R0, #+0]
    337                      p_msg->NextPtr     = DEF_NULL;
   \   00000074   0x2300             MOVS     R3,#+0
   \   00000076   0x602B             STR      R3,[R5, #+0]
   \   00000078   0xE002             B.N      ??OS_MsgQPut_7
    338                  } else {
    339                      p_msg->NextPtr     = p_msg_q->OutPtr;               /* LIFO, add to the tail                                */
   \                     ??OS_MsgQPut_6: (+1)
   \   0000007A   0x6843             LDR      R3,[R0, #+4]
   \   0000007C   0x602B             STR      R3,[R5, #+0]
    340                      p_msg_q->OutPtr    = p_msg;
   \   0000007E   0x6045             STR      R5,[R0, #+4]
    341                  }
    342                  p_msg_q->NbrEntries++;
   \                     ??OS_MsgQPut_7: (+1)
   \   00000080   0x8943             LDRH     R3,[R0, #+10]
   \   00000082   0x1C5B             ADDS     R3,R3,#+1
   \   00000084   0x8143             STRH     R3,[R0, #+10]
    343              }
    344          
    345          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    346              if (p_msg_q->NbrEntriesMax < p_msg_q->NbrEntries) {
   \                     ??OS_MsgQPut_5: (+1)
   \   00000086   0x8983             LDRH     R3,[R0, #+12]
   \   00000088   0x8946             LDRH     R6,[R0, #+10]
   \   0000008A   0x42B3             CMP      R3,R6
   \   0000008C   0xD201             BCS.N    ??OS_MsgQPut_8
    347                  p_msg_q->NbrEntriesMax = p_msg_q->NbrEntries;
   \   0000008E   0x8943             LDRH     R3,[R0, #+10]
   \   00000090   0x8183             STRH     R3,[R0, #+12]
    348              }
    349          #endif
    350          
    351              p_msg->MsgPtr  = p_void;                                    /* Deposit message in the message queue entry           */
   \                     ??OS_MsgQPut_8: (+1)
   \   00000092   0x6069             STR      R1,[R5, #+4]
    352              p_msg->MsgSize = msg_size;
   \   00000094   0x812A             STRH     R2,[R5, #+8]
    353          #if (OS_CFG_TS_EN == DEF_ENABLED)
    354              p_msg->MsgTS   = ts;
   \   00000096   0x9804             LDR      R0,[SP, #+16]
   \   00000098   0x60E8             STR      R0,[R5, #+12]
    355          #endif
    356             *p_err          = OS_ERR_NONE;
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0x8020             STRH     R0,[R4, #+0]
    357          }
   \                     ??OS_MsgQPut_1: (+1)
   \   0000009E   0xBCF0             POP      {R4-R7}
   \   000000A0   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     OSCfg_MsgPoolBasePtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x........         DC32     OSCfg_MsgPoolSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x........         DC32     OSMsgPool
    358          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   OS_MsgPoolInit
       0   OS_MsgQFreeAll
      12   OS_MsgQGet
       0   OS_MsgQInit
      16   OS_MsgQPut


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
     134  OS_MsgPoolInit
      68  OS_MsgQFreeAll
     112  OS_MsgQGet
      20  OS_MsgQInit
     162  OS_MsgQPut

 
 508 bytes in section .text
 
 508 bytes of CODE memory

Errors: none
Warnings: none
