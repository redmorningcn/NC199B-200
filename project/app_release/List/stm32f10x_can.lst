###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       11/Jul/2018  11:13:11
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC210\NC210-200处理板\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\ST\STM32\src\stm32f10x_can.c
#    Command line =  
#        F:\iar\NC210\NC210-200处理板\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\ST\STM32\src\stm32f10x_can.c
#        -D USE_STDPERIPH_DRIVER -D APP_RELEASE -lCN
#        F:\iar\NC210\NC210-200处理板\project\app_release\List -o
#        F:\iar\NC210\NC210-200处理板\project\app_release\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC210\NC210-200处理板\project\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\config\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\task\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\user\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\OS\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\Ports\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\driver\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-LIB\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Source\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\ST\STM32\inc\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Ports\STM32\STM32F103\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Source\
#        -Ol --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC210\NC210-200处理板\project\app_release\List\stm32f10x_can.lst
#    Object file  =  
#        F:\iar\NC210\NC210-200处理板\project\app_release\Obj\stm32f10x_can.o
#
###############################################################################

F:\iar\NC210\NC210-200处理板\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\ST\STM32\src\stm32f10x_can.c
      1          /******************** (C) COPYRIGHT 2009 STMicroelectronics ********************
      2          * File Name          : stm32f10x_can.c
      3          * Author             : MCD Application Team
      4          * Version            : V2.1.0RC2
      5          * Date               : 03/13/2009
      6          * Description        : This file provides all the CAN firmware functions.
      7          ********************************************************************************
      8          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
      9          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     10          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     11          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     12          * CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     13          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     14          *******************************************************************************/
     15          
     16          /* Includes ------------------------------------------------------------------*/
     17          #include "stm32f10x_can.h"
     18          #include "stm32f10x_rcc.h"
     19          
     20          /* Private typedef -----------------------------------------------------------*/
     21          
     22          /* Private define ------------------------------------------------------------*/
     23          /* CAN Master Control Register bits */
     24          #define MCR_INRQ     ((u32)0x00000001) /* Initialization request */
     25          #define MCR_SLEEP    ((u32)0x00000002) /* Sleep mode request */
     26          #define MCR_TXFP     ((u32)0x00000004) /* Transmit FIFO priority */
     27          #define MCR_RFLM     ((u32)0x00000008) /* Receive FIFO locked mode */
     28          #define MCR_NART     ((u32)0x00000010) /* No automatic retransmission */
     29          #define MCR_AWUM     ((u32)0x00000020) /* Automatic wake up mode */
     30          #define MCR_ABOM     ((u32)0x00000040) /* Automatic bus-off management */
     31          #define MCR_TTCM     ((u32)0x00000080) /* time triggered communication */
     32          #define MCR_RESET    ((u32)0x00008000) /* time triggered communication */
     33          #define MCR_DBF      ((u32)0x00010000) /* software master reset */
     34          
     35          /* CAN Master Status Register bits */
     36          #define MSR_INAK     ((u32)0x00000001)    /* Initialization acknowledge */
     37          #define MSR_WKUI     ((u32)0x00000008)    /* Wake-up interrupt */
     38          #define MSR_SLAKI    ((u32)0x00000010)    /* Sleep acknowledge interrupt */
     39          
     40          /* CAN Transmit Status Register bits */
     41          #define TSR_RQCP0    ((u32)0x00000001)    /* Request completed mailbox0 */
     42          #define TSR_TXOK0    ((u32)0x00000002)    /* Transmission OK of mailbox0 */
     43          #define TSR_ABRQ0    ((u32)0x00000080)    /* Abort request for mailbox0 */
     44          #define TSR_RQCP1    ((u32)0x00000100)    /* Request completed mailbox1 */
     45          #define TSR_TXOK1    ((u32)0x00000200)    /* Transmission OK of mailbox1 */
     46          #define TSR_ABRQ1    ((u32)0x00008000)    /* Abort request for mailbox1 */
     47          #define TSR_RQCP2    ((u32)0x00010000)    /* Request completed mailbox2 */
     48          #define TSR_TXOK2    ((u32)0x00020000)    /* Transmission OK of mailbox2 */
     49          #define TSR_ABRQ2    ((u32)0x00800000)    /* Abort request for mailbox2 */
     50          #define TSR_TME0     ((u32)0x04000000)    /* Transmit mailbox 0 empty */
     51          #define TSR_TME1     ((u32)0x08000000)    /* Transmit mailbox 1 empty */
     52          #define TSR_TME2     ((u32)0x10000000)    /* Transmit mailbox 2 empty */
     53          
     54          /* CAN Receive FIFO 0 Register bits */
     55          #define RF0R_FULL0   ((u32)0x00000008)    /* FIFO 0 full */
     56          #define RF0R_FOVR0   ((u32)0x00000010)    /* FIFO 0 overrun */
     57          #define RF0R_RFOM0   ((u32)0x00000020)    /* Release FIFO 0 output mailbox */
     58          
     59          /* CAN Receive FIFO 1 Register bits */
     60          #define RF1R_FULL1   ((u32)0x00000008)    /* FIFO 1 full */
     61          #define RF1R_FOVR1   ((u32)0x00000010)    /* FIFO 1 overrun */
     62          #define RF1R_RFOM1   ((u32)0x00000020)    /* Release FIFO 1 output mailbox */
     63          
     64          /* CAN Error Status Register bits */
     65          #define ESR_EWGF     ((u32)0x00000001)    /* Error warning flag */
     66          #define ESR_EPVF     ((u32)0x00000002)    /* Error passive flag */
     67          #define ESR_BOFF     ((u32)0x00000004)    /* Bus-off flag */
     68          
     69          /* CAN Mailbox Transmit Request */
     70          #define TMIDxR_TXRQ  ((u32)0x00000001) /* Transmit mailbox request */
     71          
     72          /* CAN Filter Master Register bits */
     73          #define FMR_FINIT    ((u32)0x00000001) /* Filter init mode */
     74          
     75          /* Time out for INAK bit */
     76          #define INAK_TimeOut        ((u16)0xFFFF)
     77          
     78          /* Time out for SLAK bit */
     79          #define SLAK_TimeOut        ((u16)0xFFFF)
     80          
     81          /* Private macro -------------------------------------------------------------*/
     82          /* Private variables ---------------------------------------------------------*/
     83          /* Private function prototypes -----------------------------------------------*/
     84          static ITStatus CheckITStatus(u32 CAN_Reg, u32 It_Bit);
     85          
     86          /* Private functions ---------------------------------------------------------*/
     87          /*******************************************************************************
     88          * Function Name  : CAN_DeInit
     89          * Description    : Deinitializes the CAN peripheral registers to their default
     90          *                  reset values.
     91          * Input          : - CANx: where x can be 1 or 2 to select the CAN peripheral.
     92          * Output         : None.
     93          * Return         : None.
     94          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     95          void CAN_DeInit(CAN_TypeDef* CANx)
     96          {
   \                     CAN_DeInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     97            /* Check the parameters */
     98            assert_param(IS_CAN_ALL_PERIPH(CANx));
     99           
    100            switch (*(u32*)&CANx)
   \   00000002   0x....             LDR.N    R1,??DataTable2  ;; 0x40006400
   \   00000004   0x4288             CMP      R0,R1
   \   00000006   0xD003             BEQ.N    ??CAN_DeInit_0
   \   00000008   0x....             LDR.N    R1,??DataTable2_1  ;; 0x40006800
   \   0000000A   0x4288             CMP      R0,R1
   \   0000000C   0xD00B             BEQ.N    ??CAN_DeInit_1
   \   0000000E   0xE015             B.N      ??CAN_DeInit_2
    101            {
    102              case CAN1_BASE:
    103                /* Enable CAN reset state */
    104                RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, ENABLE);
   \                     ??CAN_DeInit_0: (+1)
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0xF05F 0x7000      MOVS     R0,#+33554432
   \   00000016   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    105                /* Release CAN from reset state */
    106                RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, DISABLE);
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0xF05F 0x7000      MOVS     R0,#+33554432
   \   00000020   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    107                break;
   \   00000024   0xE00A             B.N      ??CAN_DeInit_3
    108              
    109          	case CAN2_BASE:
    110                /* Enable CAN reset state */
    111                RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, ENABLE);
   \                     ??CAN_DeInit_1: (+1)
   \   00000026   0x2101             MOVS     R1,#+1
   \   00000028   0xF05F 0x6080      MOVS     R0,#+67108864
   \   0000002C   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    112                /* Release CAN from reset state */
    113                RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, DISABLE);
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0xF05F 0x6080      MOVS     R0,#+67108864
   \   00000036   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    114                break;            
   \   0000003A   0xE7FF             B.N      ??CAN_DeInit_3
    115          
    116              default:
    117                break;
    118            }
    119          }
   \                     ??CAN_DeInit_2: (+1)
   \                     ??CAN_DeInit_3: (+1)
   \   0000003C   0xBD01             POP      {R0,PC}          ;; return
    120          
    121          /*******************************************************************************
    122          * Function Name  : CAN_Init
    123          * Description    : Initializes the CAN peripheral according to the specified
    124          *                  parameters in the CAN_InitStruct.
    125          * Input          : - CANx: where x can be 1 or 2 to select the CAN peripheral.
    126          *                  - CAN_InitStruct: pointer to a CAN_InitTypeDef structure that
    127          *                  contains the configuration information for the CAN peripheral.
    128          * Output         : None.
    129          * Return         : Constant indicates initialization succeed which will be 
    130          *                  CANINITFAILED or CANINITOK.
    131          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    132          u8 CAN_Init(CAN_TypeDef* CANx, CAN_InitTypeDef* CAN_InitStruct)
    133          {
    134            u8 InitStatus = CANINITFAILED;
   \                     CAN_Init: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
    135            u16 waitack = 0x0000;
   \   00000002   0x2200             MOVS     R2,#+0
    136          
    137            /* Check the parameters */
    138            assert_param(IS_CAN_ALL_PERIPH(CANx));
    139            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TTCM));
    140            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_ABOM));
    141            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_AWUM));
    142            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_NART));
    143            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_RFLM));
    144            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TXFP));
    145            assert_param(IS_CAN_MODE(CAN_InitStruct->CAN_Mode));
    146            assert_param(IS_CAN_SJW(CAN_InitStruct->CAN_SJW));
    147            assert_param(IS_CAN_BS1(CAN_InitStruct->CAN_BS1));
    148            assert_param(IS_CAN_BS2(CAN_InitStruct->CAN_BS2));
    149            assert_param(IS_CAN_PRESCALER(CAN_InitStruct->CAN_Prescaler));
    150          
    151            /* exit from sleep mode */
    152            CANx->MCR &= ~MCR_SLEEP;
   \   00000004   0x6803             LDR      R3,[R0, #+0]
   \   00000006   0xF033 0x0302      BICS     R3,R3,#0x2
   \   0000000A   0x6003             STR      R3,[R0, #+0]
    153            /* Request initialisation */
    154            CANx->MCR |= MCR_INRQ ;
   \   0000000C   0x6803             LDR      R3,[R0, #+0]
   \   0000000E   0xF053 0x0301      ORRS     R3,R3,#0x1
   \   00000012   0x6003             STR      R3,[R0, #+0]
   \   00000014   0xE000             B.N      ??CAN_Init_0
    155          
    156            /* Wait the acknowledge */
    157            while ((INAK_TimeOut != waitack)&&((CANx->MSR & MSR_INAK) != MSR_INAK))
    158            {
    159          	waitack++;
   \                     ??CAN_Init_1: (+1)
   \   00000016   0x1C52             ADDS     R2,R2,#+1
    160            }
   \                     ??CAN_Init_0: (+1)
   \   00000018   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000001A   0xF64F 0x73FF      MOVW     R3,#+65535
   \   0000001E   0x429A             CMP      R2,R3
   \   00000020   0xD002             BEQ.N    ??CAN_Init_2
   \   00000022   0x6843             LDR      R3,[R0, #+4]
   \   00000024   0x07DB             LSLS     R3,R3,#+31
   \   00000026   0xD5F6             BPL.N    ??CAN_Init_1
    161          
    162            /* ...and check acknowledged */
    163            if ((CANx->MSR & MSR_INAK) != MSR_INAK)
   \                     ??CAN_Init_2: (+1)
   \   00000028   0x6842             LDR      R2,[R0, #+4]
   \   0000002A   0x07D2             LSLS     R2,R2,#+31
   \   0000002C   0xD401             BMI.N    ??CAN_Init_3
    164            {
    165              InitStatus = CANINITFAILED;
   \   0000002E   0x2200             MOVS     R2,#+0
   \   00000030   0xE06B             B.N      ??CAN_Init_4
    166            }
    167            else 
    168            {
    169              /* Set the time triggered communication mode */
    170              if (CAN_InitStruct->CAN_TTCM == ENABLE)
   \                     ??CAN_Init_3: (+1)
   \   00000032   0x780A             LDRB     R2,[R1, #+0]
   \   00000034   0x2A01             CMP      R2,#+1
   \   00000036   0xD104             BNE.N    ??CAN_Init_5
    171              {
    172                CANx->MCR |= MCR_TTCM;
   \   00000038   0x6802             LDR      R2,[R0, #+0]
   \   0000003A   0xF052 0x0280      ORRS     R2,R2,#0x80
   \   0000003E   0x6002             STR      R2,[R0, #+0]
   \   00000040   0xE003             B.N      ??CAN_Init_6
    173              }
    174              else
    175              {
    176                CANx->MCR &= ~MCR_TTCM;
   \                     ??CAN_Init_5: (+1)
   \   00000042   0x6802             LDR      R2,[R0, #+0]
   \   00000044   0xF032 0x0280      BICS     R2,R2,#0x80
   \   00000048   0x6002             STR      R2,[R0, #+0]
    177              }
    178          
    179              /* Set the automatic bus-off management */
    180              if (CAN_InitStruct->CAN_ABOM == ENABLE)
   \                     ??CAN_Init_6: (+1)
   \   0000004A   0x784A             LDRB     R2,[R1, #+1]
   \   0000004C   0x2A01             CMP      R2,#+1
   \   0000004E   0xD104             BNE.N    ??CAN_Init_7
    181              {
    182                CANx->MCR |= MCR_ABOM;
   \   00000050   0x6802             LDR      R2,[R0, #+0]
   \   00000052   0xF052 0x0240      ORRS     R2,R2,#0x40
   \   00000056   0x6002             STR      R2,[R0, #+0]
   \   00000058   0xE003             B.N      ??CAN_Init_8
    183              }
    184              else
    185              {
    186                CANx->MCR &= ~MCR_ABOM;
   \                     ??CAN_Init_7: (+1)
   \   0000005A   0x6802             LDR      R2,[R0, #+0]
   \   0000005C   0xF032 0x0240      BICS     R2,R2,#0x40
   \   00000060   0x6002             STR      R2,[R0, #+0]
    187              }
    188          
    189              /* Set the automatic wake-up mode */
    190              if (CAN_InitStruct->CAN_AWUM == ENABLE)
   \                     ??CAN_Init_8: (+1)
   \   00000062   0x788A             LDRB     R2,[R1, #+2]
   \   00000064   0x2A01             CMP      R2,#+1
   \   00000066   0xD104             BNE.N    ??CAN_Init_9
    191              {
    192                CANx->MCR |= MCR_AWUM;
   \   00000068   0x6802             LDR      R2,[R0, #+0]
   \   0000006A   0xF052 0x0220      ORRS     R2,R2,#0x20
   \   0000006E   0x6002             STR      R2,[R0, #+0]
   \   00000070   0xE003             B.N      ??CAN_Init_10
    193              }
    194              else
    195              {
    196                CANx->MCR &= ~MCR_AWUM;
   \                     ??CAN_Init_9: (+1)
   \   00000072   0x6802             LDR      R2,[R0, #+0]
   \   00000074   0xF032 0x0220      BICS     R2,R2,#0x20
   \   00000078   0x6002             STR      R2,[R0, #+0]
    197              }
    198          
    199              /* Set the no automatic retransmission */
    200              if (CAN_InitStruct->CAN_NART == ENABLE)
   \                     ??CAN_Init_10: (+1)
   \   0000007A   0x78CA             LDRB     R2,[R1, #+3]
   \   0000007C   0x2A01             CMP      R2,#+1
   \   0000007E   0xD104             BNE.N    ??CAN_Init_11
    201              {
    202                CANx->MCR |= MCR_NART;
   \   00000080   0x6802             LDR      R2,[R0, #+0]
   \   00000082   0xF052 0x0210      ORRS     R2,R2,#0x10
   \   00000086   0x6002             STR      R2,[R0, #+0]
   \   00000088   0xE003             B.N      ??CAN_Init_12
    203              }
    204              else
    205              {
    206                CANx->MCR &= ~MCR_NART;
   \                     ??CAN_Init_11: (+1)
   \   0000008A   0x6802             LDR      R2,[R0, #+0]
   \   0000008C   0xF032 0x0210      BICS     R2,R2,#0x10
   \   00000090   0x6002             STR      R2,[R0, #+0]
    207              }
    208          
    209              /* Set the receive FIFO locked mode */
    210              if (CAN_InitStruct->CAN_RFLM == ENABLE)
   \                     ??CAN_Init_12: (+1)
   \   00000092   0x790A             LDRB     R2,[R1, #+4]
   \   00000094   0x2A01             CMP      R2,#+1
   \   00000096   0xD104             BNE.N    ??CAN_Init_13
    211              {
    212                CANx->MCR |= MCR_RFLM;
   \   00000098   0x6802             LDR      R2,[R0, #+0]
   \   0000009A   0xF052 0x0208      ORRS     R2,R2,#0x8
   \   0000009E   0x6002             STR      R2,[R0, #+0]
   \   000000A0   0xE003             B.N      ??CAN_Init_14
    213              }
    214              else
    215              {
    216                CANx->MCR &= ~MCR_RFLM;
   \                     ??CAN_Init_13: (+1)
   \   000000A2   0x6802             LDR      R2,[R0, #+0]
   \   000000A4   0xF032 0x0208      BICS     R2,R2,#0x8
   \   000000A8   0x6002             STR      R2,[R0, #+0]
    217              }
    218          
    219              /* Set the transmit FIFO priority */
    220              if (CAN_InitStruct->CAN_TXFP == ENABLE)
   \                     ??CAN_Init_14: (+1)
   \   000000AA   0x794A             LDRB     R2,[R1, #+5]
   \   000000AC   0x2A01             CMP      R2,#+1
   \   000000AE   0xD104             BNE.N    ??CAN_Init_15
    221              {
    222                CANx->MCR |= MCR_TXFP;
   \   000000B0   0x6802             LDR      R2,[R0, #+0]
   \   000000B2   0xF052 0x0204      ORRS     R2,R2,#0x4
   \   000000B6   0x6002             STR      R2,[R0, #+0]
   \   000000B8   0xE003             B.N      ??CAN_Init_16
    223              }
    224              else
    225              {
    226                CANx->MCR &= ~MCR_TXFP;
   \                     ??CAN_Init_15: (+1)
   \   000000BA   0x6802             LDR      R2,[R0, #+0]
   \   000000BC   0xF032 0x0204      BICS     R2,R2,#0x4
   \   000000C0   0x6002             STR      R2,[R0, #+0]
    227              }
    228          
    229              /* Set the bit timing register */
    230              CANx->BTR = (u32)((u32)CAN_InitStruct->CAN_Mode << 30) | ((u32)CAN_InitStruct->CAN_SJW << 24) |
    231                         ((u32)CAN_InitStruct->CAN_BS1 << 16) | ((u32)CAN_InitStruct->CAN_BS2 << 20) |
    232                         ((u32)CAN_InitStruct->CAN_Prescaler - 1);
   \                     ??CAN_Init_16: (+1)
   \   000000C2   0x798A             LDRB     R2,[R1, #+6]
   \   000000C4   0x79CB             LDRB     R3,[R1, #+7]
   \   000000C6   0x061B             LSLS     R3,R3,#+24
   \   000000C8   0xEA53 0x7282      ORRS     R2,R3,R2, LSL #+30
   \   000000CC   0x7A0B             LDRB     R3,[R1, #+8]
   \   000000CE   0xEA52 0x4203      ORRS     R2,R2,R3, LSL #+16
   \   000000D2   0x7A4B             LDRB     R3,[R1, #+9]
   \   000000D4   0xEA52 0x5203      ORRS     R2,R2,R3, LSL #+20
   \   000000D8   0x8949             LDRH     R1,[R1, #+10]
   \   000000DA   0x1E49             SUBS     R1,R1,#+1
   \   000000DC   0x4311             ORRS     R1,R1,R2
   \   000000DE   0x61C1             STR      R1,[R0, #+28]
    233          
    234              /* Request leave initialisation */
    235              CANx->MCR &= ~MCR_INRQ;
   \   000000E0   0x6801             LDR      R1,[R0, #+0]
   \   000000E2   0x0849             LSRS     R1,R1,#+1
   \   000000E4   0x0049             LSLS     R1,R1,#+1
   \   000000E6   0x6001             STR      R1,[R0, #+0]
    236          
    237             /* Wait the acknowledge */
    238             waitack = 0x0000;
   \   000000E8   0x2200             MOVS     R2,#+0
   \   000000EA   0xE000             B.N      ??CAN_Init_17
    239             while ((INAK_TimeOut != waitack)&&((CANx->MSR & MSR_INAK) == MSR_INAK))
    240             {
    241          	 waitack++;
   \                     ??CAN_Init_18: (+1)
   \   000000EC   0x1C52             ADDS     R2,R2,#+1
    242             }
   \                     ??CAN_Init_17: (+1)
   \   000000EE   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000000F0   0xF64F 0x71FF      MOVW     R1,#+65535
   \   000000F4   0x428A             CMP      R2,R1
   \   000000F6   0xD002             BEQ.N    ??CAN_Init_19
   \   000000F8   0x6841             LDR      R1,[R0, #+4]
   \   000000FA   0x07C9             LSLS     R1,R1,#+31
   \   000000FC   0xD4F6             BMI.N    ??CAN_Init_18
    243              /* ...and check acknowledged */
    244              if ((CANx->MSR & MSR_INAK) == MSR_INAK)
   \                     ??CAN_Init_19: (+1)
   \   000000FE   0x6840             LDR      R0,[R0, #+4]
   \   00000100   0x07C0             LSLS     R0,R0,#+31
   \   00000102   0xD501             BPL.N    ??CAN_Init_20
    245              {
    246                InitStatus = CANINITFAILED;
   \   00000104   0x2200             MOVS     R2,#+0
   \   00000106   0xE000             B.N      ??CAN_Init_4
    247              }
    248          	else
    249          	{
    250          	  InitStatus = CANINITOK ;
   \                     ??CAN_Init_20: (+1)
   \   00000108   0x2201             MOVS     R2,#+1
    251          	}
    252            }
    253          
    254            /* At this step, return the status of initialization */
    255            return InitStatus;
   \                     ??CAN_Init_4: (+1)
   \   0000010A   0x0010             MOVS     R0,R2
   \   0000010C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000010E   0x4770             BX       LR               ;; return
    256          }
    257          
    258          /*******************************************************************************
    259          * Function Name  : CAN_FilterInit
    260          * Description    : Initializes the CAN peripheral according to the specified
    261          *                  parameters in the CAN_FilterInitStruct.
    262          * Input          : CAN_FilterInitStruct: pointer to a CAN_FilterInitTypeDef
    263          *                  structure that contains the configuration information.
    264          * Output         : None.
    265          * Return         : None.
    266          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    267          void CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct)
    268          {
   \                     CAN_FilterInit: (+1)
   \   00000000   0xB410             PUSH     {R4}
    269            u32 FilterNumber_BitPos = 0;
   \   00000002   0x2100             MOVS     R1,#+0
    270          
    271            /* Check the parameters */
    272            assert_param(IS_CAN_FILTER_NUMBER(CAN_FilterInitStruct->CAN_FilterNumber));
    273            assert_param(IS_CAN_FILTER_MODE(CAN_FilterInitStruct->CAN_FilterMode));
    274            assert_param(IS_CAN_FILTER_SCALE(CAN_FilterInitStruct->CAN_FilterScale));
    275            assert_param(IS_CAN_FILTER_FIFO(CAN_FilterInitStruct->CAN_FilterFIFOAssignment));
    276            assert_param(IS_FUNCTIONAL_STATE(CAN_FilterInitStruct->CAN_FilterActivation));
    277          
    278            FilterNumber_BitPos = 
    279            (u32)(((u32)0x00000001) << ((u32)CAN_FilterInitStruct->CAN_FilterNumber));
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x7802             LDRB     R2,[R0, #+0]
   \   00000008   0x4091             LSLS     R1,R1,R2
    280          
    281            /* Initialisation mode for the filter */
    282            CAN1->FMR |= FMR_FINIT;
   \   0000000A   0x....             LDR.N    R2,??DataTable2_2  ;; 0x40006600
   \   0000000C   0x6812             LDR      R2,[R2, #+0]
   \   0000000E   0xF052 0x0201      ORRS     R2,R2,#0x1
   \   00000012   0x....             LDR.N    R3,??DataTable2_2  ;; 0x40006600
   \   00000014   0x601A             STR      R2,[R3, #+0]
    283          
    284            /* Filter Deactivation */
    285            CAN1->FA1R &= ~(u32)FilterNumber_BitPos;
   \   00000016   0x....             LDR.N    R2,??DataTable2_3  ;; 0x4000661c
   \   00000018   0x6812             LDR      R2,[R2, #+0]
   \   0000001A   0x438A             BICS     R2,R2,R1
   \   0000001C   0x....             LDR.N    R3,??DataTable2_3  ;; 0x4000661c
   \   0000001E   0x601A             STR      R2,[R3, #+0]
    286          
    287            /* Filter Scale */
    288            if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_16bit)
   \   00000020   0x7882             LDRB     R2,[R0, #+2]
   \   00000022   0x2A00             CMP      R2,#+0
   \   00000024   0xD115             BNE.N    ??CAN_FilterInit_0
    289            {
    290              /* 16-bit scale for the filter */
    291              CAN1->FS1R &= ~(u32)FilterNumber_BitPos;
   \   00000026   0x....             LDR.N    R2,??DataTable2_4  ;; 0x4000660c
   \   00000028   0x6812             LDR      R2,[R2, #+0]
   \   0000002A   0x438A             BICS     R2,R2,R1
   \   0000002C   0x....             LDR.N    R3,??DataTable2_4  ;; 0x4000660c
   \   0000002E   0x601A             STR      R2,[R3, #+0]
    292          
    293              /* First 16-bit identifier and First 16-bit mask */
    294              /* Or First 16-bit identifier and Second 16-bit identifier */
    295              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
    296              ((u32)((u32)0x0000FFFF & CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |
    297                  ((u32)0x0000FFFF & CAN_FilterInitStruct->CAN_FilterIdLow);
   \   00000030   0x8942             LDRH     R2,[R0, #+10]
   \   00000032   0x88C3             LDRH     R3,[R0, #+6]
   \   00000034   0xEA53 0x4202      ORRS     R2,R3,R2, LSL #+16
   \   00000038   0x....             LDR.N    R3,??DataTable2_5  ;; 0x40006640
   \   0000003A   0x7804             LDRB     R4,[R0, #+0]
   \   0000003C   0xF843 0x2034      STR      R2,[R3, R4, LSL #+3]
    298          
    299              /* Second 16-bit identifier and Second 16-bit mask */
    300              /* Or Third 16-bit identifier and Fourth 16-bit identifier */
    301              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
    302              ((u32)((u32)0x0000FFFF & CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
    303                  ((u32)0x0000FFFF & CAN_FilterInitStruct->CAN_FilterIdHigh);
   \   00000040   0x8902             LDRH     R2,[R0, #+8]
   \   00000042   0x8883             LDRH     R3,[R0, #+4]
   \   00000044   0xEA53 0x4202      ORRS     R2,R3,R2, LSL #+16
   \   00000048   0x....             LDR.N    R3,??DataTable2_5  ;; 0x40006640
   \   0000004A   0x7804             LDRB     R4,[R0, #+0]
   \   0000004C   0xEB13 0x03C4      ADDS     R3,R3,R4, LSL #+3
   \   00000050   0x605A             STR      R2,[R3, #+4]
    304            }
    305            if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_32bit)
   \                     ??CAN_FilterInit_0: (+1)
   \   00000052   0x7882             LDRB     R2,[R0, #+2]
   \   00000054   0x2A01             CMP      R2,#+1
   \   00000056   0xD115             BNE.N    ??CAN_FilterInit_1
    306            {
    307              /* 32-bit scale for the filter */
    308              CAN1->FS1R |= FilterNumber_BitPos;
   \   00000058   0x....             LDR.N    R2,??DataTable2_4  ;; 0x4000660c
   \   0000005A   0x6812             LDR      R2,[R2, #+0]
   \   0000005C   0x430A             ORRS     R2,R1,R2
   \   0000005E   0x....             LDR.N    R3,??DataTable2_4  ;; 0x4000660c
   \   00000060   0x601A             STR      R2,[R3, #+0]
    309          
    310              /* 32-bit identifier or First 32-bit identifier */
    311              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
    312              ((u32)((u32)0x0000FFFF & CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
    313                  ((u32)0x0000FFFF & CAN_FilterInitStruct->CAN_FilterIdLow);
   \   00000062   0x8882             LDRH     R2,[R0, #+4]
   \   00000064   0x88C3             LDRH     R3,[R0, #+6]
   \   00000066   0xEA53 0x4202      ORRS     R2,R3,R2, LSL #+16
   \   0000006A   0x....             LDR.N    R3,??DataTable2_5  ;; 0x40006640
   \   0000006C   0x7804             LDRB     R4,[R0, #+0]
   \   0000006E   0xF843 0x2034      STR      R2,[R3, R4, LSL #+3]
    314          
    315              /* 32-bit mask or Second 32-bit identifier */
    316              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
    317              ((u32)((u32)0x0000FFFF & CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
    318                  ((u32)0x0000FFFF & CAN_FilterInitStruct->CAN_FilterMaskIdLow);
   \   00000072   0x8902             LDRH     R2,[R0, #+8]
   \   00000074   0x8943             LDRH     R3,[R0, #+10]
   \   00000076   0xEA53 0x4202      ORRS     R2,R3,R2, LSL #+16
   \   0000007A   0x....             LDR.N    R3,??DataTable2_5  ;; 0x40006640
   \   0000007C   0x7804             LDRB     R4,[R0, #+0]
   \   0000007E   0xEB13 0x03C4      ADDS     R3,R3,R4, LSL #+3
   \   00000082   0x605A             STR      R2,[R3, #+4]
    319          
    320            }
    321          
    322            /* Filter Mode */
    323            if (CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdMask)
   \                     ??CAN_FilterInit_1: (+1)
   \   00000084   0x7842             LDRB     R2,[R0, #+1]
   \   00000086   0x2A00             CMP      R2,#+0
   \   00000088   0xD105             BNE.N    ??CAN_FilterInit_2
    324            {
    325              /*Id/Mask mode for the filter*/
    326              CAN1->FM1R &= ~(u32)FilterNumber_BitPos;
   \   0000008A   0x....             LDR.N    R2,??DataTable2_6  ;; 0x40006604
   \   0000008C   0x6812             LDR      R2,[R2, #+0]
   \   0000008E   0x438A             BICS     R2,R2,R1
   \   00000090   0x....             LDR.N    R3,??DataTable2_6  ;; 0x40006604
   \   00000092   0x601A             STR      R2,[R3, #+0]
   \   00000094   0xE004             B.N      ??CAN_FilterInit_3
    327            }
    328            else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
    329            {
    330              /*Identifier list mode for the filter*/
    331              CAN1->FM1R |= (u32)FilterNumber_BitPos;
   \                     ??CAN_FilterInit_2: (+1)
   \   00000096   0x....             LDR.N    R2,??DataTable2_6  ;; 0x40006604
   \   00000098   0x6812             LDR      R2,[R2, #+0]
   \   0000009A   0x430A             ORRS     R2,R1,R2
   \   0000009C   0x....             LDR.N    R3,??DataTable2_6  ;; 0x40006604
   \   0000009E   0x601A             STR      R2,[R3, #+0]
    332            }
    333          
    334            /* Filter FIFO assignment */
    335            if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_FilterFIFO0)
   \                     ??CAN_FilterInit_3: (+1)
   \   000000A0   0x8982             LDRH     R2,[R0, #+12]
   \   000000A2   0x2A00             CMP      R2,#+0
   \   000000A4   0xD104             BNE.N    ??CAN_FilterInit_4
    336            {
    337              /* FIFO 0 assignation for the filter */
    338              CAN1->FFA1R &= ~(u32)FilterNumber_BitPos;
   \   000000A6   0x....             LDR.N    R2,??DataTable2_7  ;; 0x40006614
   \   000000A8   0x6812             LDR      R2,[R2, #+0]
   \   000000AA   0x438A             BICS     R2,R2,R1
   \   000000AC   0x....             LDR.N    R3,??DataTable2_7  ;; 0x40006614
   \   000000AE   0x601A             STR      R2,[R3, #+0]
    339            }
    340            if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_FilterFIFO1)
   \                     ??CAN_FilterInit_4: (+1)
   \   000000B0   0x8982             LDRH     R2,[R0, #+12]
   \   000000B2   0x2A01             CMP      R2,#+1
   \   000000B4   0xD104             BNE.N    ??CAN_FilterInit_5
    341            {
    342              /* FIFO 1 assignation for the filter */
    343              CAN1->FFA1R |= (u32)FilterNumber_BitPos;
   \   000000B6   0x....             LDR.N    R2,??DataTable2_7  ;; 0x40006614
   \   000000B8   0x6812             LDR      R2,[R2, #+0]
   \   000000BA   0x430A             ORRS     R2,R1,R2
   \   000000BC   0x....             LDR.N    R3,??DataTable2_7  ;; 0x40006614
   \   000000BE   0x601A             STR      R2,[R3, #+0]
    344            }
    345            
    346            /* Filter activation */
    347            if (CAN_FilterInitStruct->CAN_FilterActivation == ENABLE)
   \                     ??CAN_FilterInit_5: (+1)
   \   000000C0   0x7B80             LDRB     R0,[R0, #+14]
   \   000000C2   0x2801             CMP      R0,#+1
   \   000000C4   0xD104             BNE.N    ??CAN_FilterInit_6
    348            {
    349              CAN1->FA1R |= FilterNumber_BitPos;
   \   000000C6   0x....             LDR.N    R0,??DataTable2_3  ;; 0x4000661c
   \   000000C8   0x6800             LDR      R0,[R0, #+0]
   \   000000CA   0x4308             ORRS     R0,R1,R0
   \   000000CC   0x....             LDR.N    R1,??DataTable2_3  ;; 0x4000661c
   \   000000CE   0x6008             STR      R0,[R1, #+0]
    350            }
    351          
    352            /* Leave the initialisation mode for the filter */
    353            CAN1->FMR &= ~FMR_FINIT;
   \                     ??CAN_FilterInit_6: (+1)
   \   000000D0   0x....             LDR.N    R0,??DataTable2_2  ;; 0x40006600
   \   000000D2   0x6800             LDR      R0,[R0, #+0]
   \   000000D4   0x0840             LSRS     R0,R0,#+1
   \   000000D6   0x0040             LSLS     R0,R0,#+1
   \   000000D8   0x....             LDR.N    R1,??DataTable2_2  ;; 0x40006600
   \   000000DA   0x6008             STR      R0,[R1, #+0]
    354          }
   \   000000DC   0xBC10             POP      {R4}
   \   000000DE   0x4770             BX       LR               ;; return
    355          
    356          /*******************************************************************************
    357          * Function Name  : CAN_StructInit
    358          * Description    : Fills each CAN_InitStruct member with its default value.
    359          * Input          : CAN_InitStruct: pointer to a CAN_InitTypeDef structure which
    360          *                  will be initialized.
    361          * Output         : None.
    362          * Return         : None.
    363          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    364          void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct)
    365          {
    366            /* Reset CAN init structure parameters values */
    367          
    368            /* Initialize the time triggered communication mode */
    369            CAN_InitStruct->CAN_TTCM = DISABLE;
   \                     CAN_StructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x7001             STRB     R1,[R0, #+0]
    370          
    371            /* Initialize the automatic bus-off management */
    372            CAN_InitStruct->CAN_ABOM = DISABLE;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x7041             STRB     R1,[R0, #+1]
    373          
    374            /* Initialize the automatic wake-up mode */
    375            CAN_InitStruct->CAN_AWUM = DISABLE;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x7081             STRB     R1,[R0, #+2]
    376          
    377            /* Initialize the no automatic retransmission */
    378            CAN_InitStruct->CAN_NART = DISABLE;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x70C1             STRB     R1,[R0, #+3]
    379          
    380            /* Initialize the receive FIFO locked mode */
    381            CAN_InitStruct->CAN_RFLM = DISABLE;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x7101             STRB     R1,[R0, #+4]
    382          
    383            /* Initialize the transmit FIFO priority */
    384            CAN_InitStruct->CAN_TXFP = DISABLE;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x7141             STRB     R1,[R0, #+5]
    385          
    386            /* Initialize the CAN_Mode member */
    387            CAN_InitStruct->CAN_Mode = CAN_Mode_Normal;
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x7181             STRB     R1,[R0, #+6]
    388          
    389            /* Initialize the CAN_SJW member */
    390            CAN_InitStruct->CAN_SJW = CAN_SJW_1tq;
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x71C1             STRB     R1,[R0, #+7]
    391          
    392            /* Initialize the CAN_BS1 member */
    393            CAN_InitStruct->CAN_BS1 = CAN_BS1_4tq;
   \   00000020   0x2103             MOVS     R1,#+3
   \   00000022   0x7201             STRB     R1,[R0, #+8]
    394          
    395            /* Initialize the CAN_BS2 member */
    396            CAN_InitStruct->CAN_BS2 = CAN_BS2_3tq;
   \   00000024   0x2102             MOVS     R1,#+2
   \   00000026   0x7241             STRB     R1,[R0, #+9]
    397          
    398            /* Initialize the CAN_Prescaler member */
    399            CAN_InitStruct->CAN_Prescaler = 1;
   \   00000028   0x2101             MOVS     R1,#+1
   \   0000002A   0x8141             STRH     R1,[R0, #+10]
    400          }
   \   0000002C   0x4770             BX       LR               ;; return
    401          /*******************************************************************************
    402          * Function Name  : CAN_SlaveStartBank
    403          * Description    : Select the start bank filter for slave CAN.
    404          * Input          : - CAN_BankNumber: Select the start slave bank filter from 1..27.
    405          * Output         : None.
    406          * Return         : None.
    407          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    408          void CAN_SlaveStartBank(u8 CAN_BankNumber) 
    409          {
    410            /* Check the parameters */
    411            assert_param(IS_CAN_BANKNUMBER(CAN_BankNumber));
    412          
    413            CAN1->FMR |= FMR_FINIT;
   \                     CAN_SlaveStartBank: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable2_2  ;; 0x40006600
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   00000008   0x....             LDR.N    R2,??DataTable2_2  ;; 0x40006600
   \   0000000A   0x6011             STR      R1,[R2, #+0]
    414            CAN1->FMR &= (u32)0xFFFFC0F1 ;
   \   0000000C   0x....             LDR.N    R1,??DataTable2_2  ;; 0x40006600
   \   0000000E   0x6809             LDR      R1,[R1, #+0]
   \   00000010   0x....             LDR.N    R2,??DataTable2_8  ;; 0xffffc0f1
   \   00000012   0x4011             ANDS     R1,R2,R1
   \   00000014   0x....             LDR.N    R2,??DataTable2_2  ;; 0x40006600
   \   00000016   0x6011             STR      R1,[R2, #+0]
    415            CAN1->FMR |= (u32)(CAN_BankNumber)<<8;
   \   00000018   0x....             LDR.N    R1,??DataTable2_2  ;; 0x40006600
   \   0000001A   0x6809             LDR      R1,[R1, #+0]
   \   0000001C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000022   0x....             LDR.N    R1,??DataTable2_2  ;; 0x40006600
   \   00000024   0x6008             STR      R0,[R1, #+0]
    416            CAN1->FMR &= ~FMR_FINIT;
   \   00000026   0x....             LDR.N    R0,??DataTable2_2  ;; 0x40006600
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x0840             LSRS     R0,R0,#+1
   \   0000002C   0x0040             LSLS     R0,R0,#+1
   \   0000002E   0x....             LDR.N    R1,??DataTable2_2  ;; 0x40006600
   \   00000030   0x6008             STR      R0,[R1, #+0]
    417          }
   \   00000032   0x4770             BX       LR               ;; return
    418          
    419          /*******************************************************************************
    420          * Function Name  : CAN_DBGFreeze
    421          * Description    : Enables or disables the DBG Freeze for CAN.
    422          * Input          :  - CANx: where x can be 1 or 2 to select the CAN peripheral.
    423          *                   - NewState: new state of the CAN peripheral.
    424          *                    This parameter can be: ENABLE or DISABLE.
    425          * Output         : None.
    426          * Return         : None.
    427          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    428          void CAN_DBGFreeze(CAN_TypeDef* CANx, FunctionalState NewState)
    429          {
    430            /* Check the parameters */
    431            assert_param(IS_CAN_ALL_PERIPH(CANx));
    432            assert_param(IS_FUNCTIONAL_STATE(NewState));
    433          
    434             if (NewState != DISABLE)
   \                     CAN_DBGFreeze: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??CAN_DBGFreeze_0
    435            {
    436              /* Enable Debug Freeze  */
    437              CANx->MCR |= MCR_DBF;
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0xF451 0x3180      ORRS     R1,R1,#0x10000
   \   0000000C   0x6001             STR      R1,[R0, #+0]
   \   0000000E   0xE003             B.N      ??CAN_DBGFreeze_1
    438            }
    439            else
    440            {
    441              /* Disable Debug Freeze */
    442              CANx->MCR &= ~MCR_DBF;
   \                     ??CAN_DBGFreeze_0: (+1)
   \   00000010   0x6801             LDR      R1,[R0, #+0]
   \   00000012   0xF431 0x3180      BICS     R1,R1,#0x10000
   \   00000016   0x6001             STR      R1,[R0, #+0]
    443            }
    444          }
   \                     ??CAN_DBGFreeze_1: (+1)
   \   00000018   0x4770             BX       LR               ;; return
    445          
    446          /*******************************************************************************
    447          * Function Name  : CAN_ITConfig
    448          * Description    : Enables or disables the specified CAN interrupts.
    449          * Input          : - CANx: where x can be 1 or 2 to select the CAN peripheral.
    450          *                  - CAN_IT: specifies the CAN interrupt sources to be enabled or
    451          *                    disabled.
    452          *                    This parameter can be: CAN_IT_TME, CAN_IT_FMP0, CAN_IT_FF0,
    453          *                                           CAN_IT_FOV0, CAN_IT_FMP1, CAN_IT_FF1,
    454          *                                           CAN_IT_FOV1, CAN_IT_EWG, CAN_IT_EPV,
    455          *                                           CAN_IT_LEC, CAN_IT_ERR, CAN_IT_WKU or
    456          *                                           CAN_IT_SLK.
    457          *                  - NewState: new state of the CAN interrupts.
    458          *                    This parameter can be: ENABLE or DISABLE.
    459          * Output         : None.
    460          * Return         : None.
    461          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    462          void CAN_ITConfig(CAN_TypeDef* CANx, u32 CAN_IT, FunctionalState NewState)
    463          {
    464            /* Check the parameters */
    465            assert_param(IS_CAN_ALL_PERIPH(CANx));
    466            assert_param(IS_CAN_ITConfig(CAN_IT));
    467            assert_param(IS_FUNCTIONAL_STATE(NewState));
    468          
    469            if (NewState != DISABLE)
   \                     CAN_ITConfig: (+1)
   \   00000000   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD003             BEQ.N    ??CAN_ITConfig_0
    470            {
    471              /* Enable the selected CAN interrupt */
    472              CANx->IER |= CAN_IT;
   \   00000006   0x6942             LDR      R2,[R0, #+20]
   \   00000008   0x4311             ORRS     R1,R1,R2
   \   0000000A   0x6141             STR      R1,[R0, #+20]
   \   0000000C   0xE003             B.N      ??CAN_ITConfig_1
    473            }
    474            else
    475            {
    476              /* Disable the selected CAN interrupt */
    477              CANx->IER &= ~CAN_IT;
   \                     ??CAN_ITConfig_0: (+1)
   \   0000000E   0x6942             LDR      R2,[R0, #+20]
   \   00000010   0xEA32 0x0101      BICS     R1,R2,R1
   \   00000014   0x6141             STR      R1,[R0, #+20]
    478            }
    479          }
   \                     ??CAN_ITConfig_1: (+1)
   \   00000016   0x4770             BX       LR               ;; return
    480          
    481          /*******************************************************************************
    482          * Function Name  : CAN_Transmit
    483          * Description    : Initiates the transmission of a message.
    484          * Input          : - CANx: where x can be 1 or 2 to select the CAN peripheral.
    485          *                  - TxMessage: pointer to a structure which contains CAN Id, CAN
    486          *                  DLC and CAN datas.
    487          * Output         : None.
    488          * Return         : The number of the mailbox that is used for transmission
    489          *                  or CAN_NO_MB if there is no empty mailbox.
    490          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    491          u8 CAN_Transmit(CAN_TypeDef* CANx, CanTxMsg* TxMessage)
    492          {
   \                     CAN_Transmit: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    493            u8 TransmitMailbox = 0;
   \   00000002   0x2200             MOVS     R2,#+0
    494          
    495            /* Check the parameters */
    496            assert_param(IS_CAN_ALL_PERIPH(CANx));
    497            assert_param(IS_CAN_IDTYPE(TxMessage->IDE));
    498            assert_param(IS_CAN_RTR(TxMessage->RTR));
    499            assert_param(IS_CAN_DLC(TxMessage->DLC));
    500          
    501            /* Select one empty transmit mailbox */
    502            if ((CANx->TSR&TSR_TME0) == TSR_TME0)
   \   00000004   0x6882             LDR      R2,[R0, #+8]
   \   00000006   0x0152             LSLS     R2,R2,#+5
   \   00000008   0xD501             BPL.N    ??CAN_Transmit_0
    503            {
    504              TransmitMailbox = 0;
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0xE00A             B.N      ??CAN_Transmit_1
    505            }
    506            else if ((CANx->TSR&TSR_TME1) == TSR_TME1)
   \                     ??CAN_Transmit_0: (+1)
   \   0000000E   0x6882             LDR      R2,[R0, #+8]
   \   00000010   0x0112             LSLS     R2,R2,#+4
   \   00000012   0xD501             BPL.N    ??CAN_Transmit_2
    507            {
    508              TransmitMailbox = 1;
   \   00000014   0x2201             MOVS     R2,#+1
   \   00000016   0xE005             B.N      ??CAN_Transmit_1
    509            }
    510            else if ((CANx->TSR&TSR_TME2) == TSR_TME2)
   \                     ??CAN_Transmit_2: (+1)
   \   00000018   0x6882             LDR      R2,[R0, #+8]
   \   0000001A   0x00D2             LSLS     R2,R2,#+3
   \   0000001C   0xD501             BPL.N    ??CAN_Transmit_3
    511            {
    512              TransmitMailbox = 2;
   \   0000001E   0x2202             MOVS     R2,#+2
   \   00000020   0xE000             B.N      ??CAN_Transmit_1
    513            }
    514            else
    515            {
    516              TransmitMailbox = CAN_NO_MB;
   \                     ??CAN_Transmit_3: (+1)
   \   00000022   0x2204             MOVS     R2,#+4
    517            }
    518          
    519            if (TransmitMailbox != CAN_NO_MB)
   \                     ??CAN_Transmit_1: (+1)
   \   00000024   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000026   0x2A04             CMP      R2,#+4
   \   00000028   0xD075             BEQ.N    ??CAN_Transmit_4
    520            {
    521              /* Set up the Id */
    522              CANx->sTxMailBox[TransmitMailbox].TIR &= TMIDxR_TXRQ;
   \   0000002A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000002C   0xEB10 0x1302      ADDS     R3,R0,R2, LSL #+4
   \   00000030   0xF8D3 0x3180      LDR      R3,[R3, #+384]
   \   00000034   0xF013 0x0301      ANDS     R3,R3,#0x1
   \   00000038   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000003A   0xEB10 0x1402      ADDS     R4,R0,R2, LSL #+4
   \   0000003E   0xF8C4 0x3180      STR      R3,[R4, #+384]
    523              if (TxMessage->IDE == CAN_ID_STD)
   \   00000042   0x7A0B             LDRB     R3,[R1, #+8]
   \   00000044   0x2B00             CMP      R3,#+0
   \   00000046   0xD10F             BNE.N    ??CAN_Transmit_5
    524              {
    525                assert_param(IS_CAN_STDID(TxMessage->StdId));  
    526                CANx->sTxMailBox[TransmitMailbox].TIR |= ((TxMessage->StdId << 21) | TxMessage->RTR);
   \   00000048   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000004A   0xEB10 0x1302      ADDS     R3,R0,R2, LSL #+4
   \   0000004E   0xF8D3 0x3180      LDR      R3,[R3, #+384]
   \   00000052   0x680C             LDR      R4,[R1, #+0]
   \   00000054   0x7A4D             LDRB     R5,[R1, #+9]
   \   00000056   0xEA55 0x5444      ORRS     R4,R5,R4, LSL #+21
   \   0000005A   0x4323             ORRS     R3,R4,R3
   \   0000005C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000005E   0xEB10 0x1402      ADDS     R4,R0,R2, LSL #+4
   \   00000062   0xF8C4 0x3180      STR      R3,[R4, #+384]
   \   00000066   0xE010             B.N      ??CAN_Transmit_6
    527              }
    528              else
    529              {
    530                assert_param(IS_CAN_EXTID(TxMessage->ExtId));
    531                CANx->sTxMailBox[TransmitMailbox].TIR |= ((TxMessage->ExtId<<3) | TxMessage->IDE | 
    532                                                         TxMessage->RTR);
   \                     ??CAN_Transmit_5: (+1)
   \   00000068   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000006A   0xEB10 0x1302      ADDS     R3,R0,R2, LSL #+4
   \   0000006E   0xF8D3 0x3180      LDR      R3,[R3, #+384]
   \   00000072   0x684C             LDR      R4,[R1, #+4]
   \   00000074   0x7A0D             LDRB     R5,[R1, #+8]
   \   00000076   0xEA55 0x04C4      ORRS     R4,R5,R4, LSL #+3
   \   0000007A   0x7A4D             LDRB     R5,[R1, #+9]
   \   0000007C   0x432C             ORRS     R4,R5,R4
   \   0000007E   0x4323             ORRS     R3,R4,R3
   \   00000080   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000082   0xEB10 0x1402      ADDS     R4,R0,R2, LSL #+4
   \   00000086   0xF8C4 0x3180      STR      R3,[R4, #+384]
    533              }
    534              
    535              /* Set up the DLC */
    536              TxMessage->DLC &= (u8)0x0000000F;
   \                     ??CAN_Transmit_6: (+1)
   \   0000008A   0x7A8B             LDRB     R3,[R1, #+10]
   \   0000008C   0xF013 0x030F      ANDS     R3,R3,#0xF
   \   00000090   0x728B             STRB     R3,[R1, #+10]
    537              CANx->sTxMailBox[TransmitMailbox].TDTR &= (u32)0xFFFFFFF0;
   \   00000092   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000094   0xEB10 0x1302      ADDS     R3,R0,R2, LSL #+4
   \   00000098   0xF8D3 0x3184      LDR      R3,[R3, #+388]
   \   0000009C   0x091B             LSRS     R3,R3,#+4
   \   0000009E   0x011B             LSLS     R3,R3,#+4
   \   000000A0   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000A2   0xEB10 0x1402      ADDS     R4,R0,R2, LSL #+4
   \   000000A6   0xF8C4 0x3184      STR      R3,[R4, #+388]
    538              CANx->sTxMailBox[TransmitMailbox].TDTR |= TxMessage->DLC;
   \   000000AA   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000AC   0xEB10 0x1302      ADDS     R3,R0,R2, LSL #+4
   \   000000B0   0xF8D3 0x3184      LDR      R3,[R3, #+388]
   \   000000B4   0x7A8C             LDRB     R4,[R1, #+10]
   \   000000B6   0x4323             ORRS     R3,R4,R3
   \   000000B8   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000BA   0xEB10 0x1402      ADDS     R4,R0,R2, LSL #+4
   \   000000BE   0xF8C4 0x3184      STR      R3,[R4, #+388]
    539          
    540              /* Set up the data field */
    541              CANx->sTxMailBox[TransmitMailbox].TDLR = (((u32)TxMessage->Data[3] << 24) | 
    542                                                       ((u32)TxMessage->Data[2] << 16) |
    543                                                       ((u32)TxMessage->Data[1] << 8) | 
    544                                                       ((u32)TxMessage->Data[0]));
   \   000000C2   0x7B8B             LDRB     R3,[R1, #+14]
   \   000000C4   0x7B4C             LDRB     R4,[R1, #+13]
   \   000000C6   0x0424             LSLS     R4,R4,#+16
   \   000000C8   0xEA54 0x6303      ORRS     R3,R4,R3, LSL #+24
   \   000000CC   0x7B0C             LDRB     R4,[R1, #+12]
   \   000000CE   0xEA53 0x2304      ORRS     R3,R3,R4, LSL #+8
   \   000000D2   0x7ACC             LDRB     R4,[R1, #+11]
   \   000000D4   0x4323             ORRS     R3,R4,R3
   \   000000D6   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000D8   0xEB10 0x1402      ADDS     R4,R0,R2, LSL #+4
   \   000000DC   0xF8C4 0x3188      STR      R3,[R4, #+392]
    545              CANx->sTxMailBox[TransmitMailbox].TDHR = (((u32)TxMessage->Data[7] << 24) | 
    546                                                       ((u32)TxMessage->Data[6] << 16) |
    547                                                       ((u32)TxMessage->Data[5] << 8) |
    548                                                       ((u32)TxMessage->Data[4]));
   \   000000E0   0x7C8B             LDRB     R3,[R1, #+18]
   \   000000E2   0x7C4C             LDRB     R4,[R1, #+17]
   \   000000E4   0x0424             LSLS     R4,R4,#+16
   \   000000E6   0xEA54 0x6303      ORRS     R3,R4,R3, LSL #+24
   \   000000EA   0x7C0C             LDRB     R4,[R1, #+16]
   \   000000EC   0xEA53 0x2304      ORRS     R3,R3,R4, LSL #+8
   \   000000F0   0x7BC9             LDRB     R1,[R1, #+15]
   \   000000F2   0x4319             ORRS     R1,R1,R3
   \   000000F4   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000F6   0xEB10 0x1302      ADDS     R3,R0,R2, LSL #+4
   \   000000FA   0xF8C3 0x118C      STR      R1,[R3, #+396]
    549          
    550              /* Request transmission */
    551              CANx->sTxMailBox[TransmitMailbox].TIR |= TMIDxR_TXRQ;
   \   000000FE   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000100   0xEB10 0x1102      ADDS     R1,R0,R2, LSL #+4
   \   00000104   0xF8D1 0x1180      LDR      R1,[R1, #+384]
   \   00000108   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   0000010C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000010E   0xEB10 0x1002      ADDS     R0,R0,R2, LSL #+4
   \   00000112   0xF8C0 0x1180      STR      R1,[R0, #+384]
    552            }
    553          
    554            return TransmitMailbox;
   \                     ??CAN_Transmit_4: (+1)
   \   00000116   0x0010             MOVS     R0,R2
   \   00000118   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000011A   0xBC30             POP      {R4,R5}
   \   0000011C   0x4770             BX       LR               ;; return
    555          }
    556          
    557          /*******************************************************************************
    558          * Function Name  : CAN_TransmitStatus
    559          * Description    : Checks the transmission of a message.
    560          * Input          : - CANx: where x can be 1 or 2 to select the CAN peripheral.
    561          *                  - TransmitMailbox: the number of the mailbox that is used for
    562          *                  transmission.
    563          * Output         : None.
    564          * Return         : CANTXOK if the CAN driver transmits the message, CANTXFAILED
    565          *                  in an other case.
    566          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    567          u8 CAN_TransmitStatus(CAN_TypeDef* CANx, u8 TransmitMailbox)
    568          {
   \                     CAN_TransmitStatus: (+1)
   \   00000000   0x000A             MOVS     R2,R1
    569            /* RQCP, TXOK and TME bits */
    570            u8 State = 0;
   \   00000002   0x2100             MOVS     R1,#+0
    571          
    572            /* Check the parameters */
    573            assert_param(IS_CAN_ALL_PERIPH(CANx));
    574            assert_param(IS_CAN_TRANSMITMAILBOX(TransmitMailbox));
    575          
    576            switch (TransmitMailbox)
   \   00000004   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000006   0x2A00             CMP      R2,#+0
   \   00000008   0xD003             BEQ.N    ??CAN_TransmitStatus_0
   \   0000000A   0x2A02             CMP      R2,#+2
   \   0000000C   0xD020             BEQ.N    ??CAN_TransmitStatus_1
   \   0000000E   0xD30F             BCC.N    ??CAN_TransmitStatus_2
   \   00000010   0xE02E             B.N      ??CAN_TransmitStatus_3
    577            {
    578              case (0): State |= (u8)((CANx->TSR & TSR_RQCP0) << 2);
   \                     ??CAN_TransmitStatus_0: (+1)
   \   00000012   0x6882             LDR      R2,[R0, #+8]
   \   00000014   0xF012 0x0201      ANDS     R2,R2,#0x1
   \   00000018   0xEA51 0x0182      ORRS     R1,R1,R2, LSL #+2
    579                State |= (u8)((CANx->TSR & TSR_TXOK0) >> 0);
   \   0000001C   0x6882             LDR      R2,[R0, #+8]
   \   0000001E   0xF012 0x0202      ANDS     R2,R2,#0x2
   \   00000022   0x4311             ORRS     R1,R2,R1
    580                State |= (u8)((CANx->TSR & TSR_TME0) >> 26);
   \   00000024   0x6880             LDR      R0,[R0, #+8]
   \   00000026   0x0E80             LSRS     R0,R0,#+26
   \   00000028   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000002C   0x4301             ORRS     R1,R0,R1
    581                break;
   \   0000002E   0xE020             B.N      ??CAN_TransmitStatus_4
    582              case (1): State |= (u8)((CANx->TSR & TSR_RQCP1) >> 6);
   \                     ??CAN_TransmitStatus_2: (+1)
   \   00000030   0x6882             LDR      R2,[R0, #+8]
   \   00000032   0x0992             LSRS     R2,R2,#+6
   \   00000034   0xF012 0x0204      ANDS     R2,R2,#0x4
   \   00000038   0x4311             ORRS     R1,R2,R1
    583                State |= (u8)((CANx->TSR & TSR_TXOK1) >> 8);
   \   0000003A   0x6882             LDR      R2,[R0, #+8]
   \   0000003C   0x0A12             LSRS     R2,R2,#+8
   \   0000003E   0xF012 0x0202      ANDS     R2,R2,#0x2
   \   00000042   0x4311             ORRS     R1,R2,R1
    584                State |= (u8)((CANx->TSR & TSR_TME1) >> 27);
   \   00000044   0x6880             LDR      R0,[R0, #+8]
   \   00000046   0x0EC0             LSRS     R0,R0,#+27
   \   00000048   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000004C   0x4301             ORRS     R1,R0,R1
    585                break;
   \   0000004E   0xE010             B.N      ??CAN_TransmitStatus_4
    586              case (2): State |= (u8)((CANx->TSR & TSR_RQCP2) >> 14);
   \                     ??CAN_TransmitStatus_1: (+1)
   \   00000050   0x6882             LDR      R2,[R0, #+8]
   \   00000052   0x0B92             LSRS     R2,R2,#+14
   \   00000054   0xF012 0x0204      ANDS     R2,R2,#0x4
   \   00000058   0x4311             ORRS     R1,R2,R1
    587                State |= (u8)((CANx->TSR & TSR_TXOK2) >> 16);
   \   0000005A   0x6882             LDR      R2,[R0, #+8]
   \   0000005C   0x0C12             LSRS     R2,R2,#+16
   \   0000005E   0xF012 0x0202      ANDS     R2,R2,#0x2
   \   00000062   0x4311             ORRS     R1,R2,R1
    588                State |= (u8)((CANx->TSR & TSR_TME2) >> 28);
   \   00000064   0x6880             LDR      R0,[R0, #+8]
   \   00000066   0x0F00             LSRS     R0,R0,#+28
   \   00000068   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000006C   0x4301             ORRS     R1,R0,R1
    589                break;
   \   0000006E   0xE000             B.N      ??CAN_TransmitStatus_4
    590              default:
    591                State = CANTXFAILED;
   \                     ??CAN_TransmitStatus_3: (+1)
   \   00000070   0x2100             MOVS     R1,#+0
    592                break;
    593            }
    594          
    595            switch (State)
   \                     ??CAN_TransmitStatus_4: (+1)
   \   00000072   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000074   0x2900             CMP      R1,#+0
   \   00000076   0xD004             BEQ.N    ??CAN_TransmitStatus_5
   \   00000078   0x2905             CMP      R1,#+5
   \   0000007A   0xD004             BEQ.N    ??CAN_TransmitStatus_6
   \   0000007C   0x2907             CMP      R1,#+7
   \   0000007E   0xD004             BEQ.N    ??CAN_TransmitStatus_7
   \   00000080   0xE005             B.N      ??CAN_TransmitStatus_8
    596            {
    597                /* transmit pending  */
    598              case (0x0): State = CANTXPENDING;
   \                     ??CAN_TransmitStatus_5: (+1)
   \   00000082   0x2102             MOVS     R1,#+2
    599                break;
   \   00000084   0xE004             B.N      ??CAN_TransmitStatus_9
    600                /* transmit failed  */
    601              case (0x5): State = CANTXFAILED;
   \                     ??CAN_TransmitStatus_6: (+1)
   \   00000086   0x2100             MOVS     R1,#+0
    602                break;
   \   00000088   0xE002             B.N      ??CAN_TransmitStatus_9
    603                /* transmit succedeed  */
    604              case (0x7): State = CANTXOK;
   \                     ??CAN_TransmitStatus_7: (+1)
   \   0000008A   0x2101             MOVS     R1,#+1
    605                break;
   \   0000008C   0xE000             B.N      ??CAN_TransmitStatus_9
    606              default:
    607                State = CANTXFAILED;
   \                     ??CAN_TransmitStatus_8: (+1)
   \   0000008E   0x2100             MOVS     R1,#+0
    608                break;
    609            }
    610          
    611            return State;
   \                     ??CAN_TransmitStatus_9: (+1)
   \   00000090   0x0008             MOVS     R0,R1
   \   00000092   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000094   0x4770             BX       LR               ;; return
    612          }
    613          
    614          /*******************************************************************************
    615          * Function Name  : CAN_CancelTransmit
    616          * Description    : Cancels a transmit request.
    617          * Input          : - CANx: where x can be 1 or 2 to select the CAN peripheral. 
    618          *                  - Mailbox:  number of the mailbox.
    619          * Output         : None.
    620          * Return         : None.
    621          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    622          void CAN_CancelTransmit(CAN_TypeDef* CANx, u8 Mailbox)
    623          {
    624            /* Check the parameters */
    625            assert_param(IS_CAN_ALL_PERIPH(CANx));
    626            assert_param(IS_CAN_TRANSMITMAILBOX(Mailbox));
    627          
    628            /* abort transmission */
    629            switch (Mailbox)
   \                     CAN_CancelTransmit: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD003             BEQ.N    ??CAN_CancelTransmit_0
   \   00000006   0x2902             CMP      R1,#+2
   \   00000008   0xD00B             BEQ.N    ??CAN_CancelTransmit_1
   \   0000000A   0xD305             BCC.N    ??CAN_CancelTransmit_2
   \   0000000C   0xE00E             B.N      ??CAN_CancelTransmit_3
    630            {
    631              case (0): CANx->TSR |= TSR_ABRQ0;
   \                     ??CAN_CancelTransmit_0: (+1)
   \   0000000E   0x6881             LDR      R1,[R0, #+8]
   \   00000010   0xF051 0x0180      ORRS     R1,R1,#0x80
   \   00000014   0x6081             STR      R1,[R0, #+8]
    632                break;
   \   00000016   0xE009             B.N      ??CAN_CancelTransmit_4
    633              case (1): CANx->TSR |= TSR_ABRQ1;
   \                     ??CAN_CancelTransmit_2: (+1)
   \   00000018   0x6881             LDR      R1,[R0, #+8]
   \   0000001A   0xF451 0x4100      ORRS     R1,R1,#0x8000
   \   0000001E   0x6081             STR      R1,[R0, #+8]
    634                break;
   \   00000020   0xE004             B.N      ??CAN_CancelTransmit_4
    635              case (2): CANx->TSR |= TSR_ABRQ2;
   \                     ??CAN_CancelTransmit_1: (+1)
   \   00000022   0x6881             LDR      R1,[R0, #+8]
   \   00000024   0xF451 0x0100      ORRS     R1,R1,#0x800000
   \   00000028   0x6081             STR      R1,[R0, #+8]
    636                break;
   \   0000002A   0xE7FF             B.N      ??CAN_CancelTransmit_4
    637              default:
    638                break;
    639            }
    640          }
   \                     ??CAN_CancelTransmit_3: (+1)
   \                     ??CAN_CancelTransmit_4: (+1)
   \   0000002C   0x4770             BX       LR               ;; return
    641          
    642          /*******************************************************************************
    643          * Function Name  : CAN_FIFORelease
    644          * Description    : Releases a FIFO.
    645          * Input          : - CANx: where x can be 1 or 2 to select the CAN peripheral. 
    646          *                  - FIFONumber: FIFO to release, CAN_FIFO0 or CAN_FIFO1.
    647          * Output         : None.
    648          * Return         : None.
    649          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    650          void CAN_FIFORelease(CAN_TypeDef* CANx, u8 FIFONumber)
    651          {
    652            /* Check the parameters */
    653            assert_param(IS_CAN_ALL_PERIPH(CANx));
    654            assert_param(IS_CAN_FIFO(FIFONumber));
    655          
    656            /* Release FIFO0 */
    657            if (FIFONumber == CAN_FIFO0)
   \                     CAN_FIFORelease: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD102             BNE.N    ??CAN_FIFORelease_0
    658            {
    659              CANx->RF0R = RF0R_RFOM0;
   \   00000006   0x2120             MOVS     R1,#+32
   \   00000008   0x60C1             STR      R1,[R0, #+12]
   \   0000000A   0xE001             B.N      ??CAN_FIFORelease_1
    660            }
    661            /* Release FIFO1 */
    662            else /* FIFONumber == CAN_FIFO1 */
    663            {
    664              CANx->RF1R = RF1R_RFOM1;
   \                     ??CAN_FIFORelease_0: (+1)
   \   0000000C   0x2120             MOVS     R1,#+32
   \   0000000E   0x6101             STR      R1,[R0, #+16]
    665            }
    666          }
   \                     ??CAN_FIFORelease_1: (+1)
   \   00000010   0x4770             BX       LR               ;; return
    667          
    668          /*******************************************************************************
    669          * Function Name  : CAN_MessagePending
    670          * Description    : Returns the number of pending messages.
    671          * Input          : - CANx: where x can be 1 or 2 to select the CAN peripheral.
    672          *                  - FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
    673          * Output         : None.
    674          * Return         : NbMessage which is the number of pending message.
    675          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    676          u8 CAN_MessagePending(CAN_TypeDef* CANx, u8 FIFONumber)
    677          {
    678            u8 MessagePending=0;
   \                     CAN_MessagePending: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
    679          
    680            /* Check the parameters */
    681            assert_param(IS_CAN_ALL_PERIPH(CANx));
    682            assert_param(IS_CAN_FIFO(FIFONumber));
    683          
    684            if (FIFONumber == CAN_FIFO0)
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD103             BNE.N    ??CAN_MessagePending_0
    685            {
    686              MessagePending = (u8)(CANx->RF0R&(u32)0x03);
   \   00000008   0x68C0             LDR      R0,[R0, #+12]
   \   0000000A   0xF010 0x0203      ANDS     R2,R0,#0x3
   \   0000000E   0xE007             B.N      ??CAN_MessagePending_1
    687            }
    688            else if (FIFONumber == CAN_FIFO1)
   \                     ??CAN_MessagePending_0: (+1)
   \   00000010   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000012   0x2901             CMP      R1,#+1
   \   00000014   0xD103             BNE.N    ??CAN_MessagePending_2
    689            {
    690              MessagePending = (u8)(CANx->RF1R&(u32)0x03);
   \   00000016   0x6900             LDR      R0,[R0, #+16]
   \   00000018   0xF010 0x0203      ANDS     R2,R0,#0x3
   \   0000001C   0xE000             B.N      ??CAN_MessagePending_1
    691            }
    692            else
    693            {
    694              MessagePending = 0;
   \                     ??CAN_MessagePending_2: (+1)
   \   0000001E   0x2200             MOVS     R2,#+0
    695            }
    696            return MessagePending;
   \                     ??CAN_MessagePending_1: (+1)
   \   00000020   0x0010             MOVS     R0,R2
   \   00000022   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000024   0x4770             BX       LR               ;; return
    697          }
    698          
    699          /*******************************************************************************
    700          * Function Name  : CAN_Receive
    701          * Description    : Receives a message.
    702          * Input          : - CANx: where x can be 1 or 2 to select the CAN peripheral.
    703          *                  - FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
    704          * Output         : RxMessage: pointer to a structure which contains CAN Id,
    705          *                  CAN DLC, CAN datas and FMI number.
    706          * Return         : None.
    707          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    708          void CAN_Receive(CAN_TypeDef* CANx, u8 FIFONumber, CanRxMsg* RxMessage)
    709          {
   \                     CAN_Receive: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    710            /* Check the parameters */
    711            assert_param(IS_CAN_ALL_PERIPH(CANx));
    712            assert_param(IS_CAN_FIFO(FIFONumber));
    713          
    714            /* Get the Id */
    715            RxMessage->IDE = (u8)0x04 & CANx->sFIFOMailBox[FIFONumber].RIR;
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0xEB10 0x1301      ADDS     R3,R0,R1, LSL #+4
   \   00000008   0xF8D3 0x31B0      LDR      R3,[R3, #+432]
   \   0000000C   0xF013 0x0304      ANDS     R3,R3,#0x4
   \   00000010   0x7213             STRB     R3,[R2, #+8]
    716            if (RxMessage->IDE == CAN_ID_STD)
   \   00000012   0x7A13             LDRB     R3,[R2, #+8]
   \   00000014   0x2B00             CMP      R3,#+0
   \   00000016   0xD107             BNE.N    ??CAN_Receive_0
    717            {
    718              RxMessage->StdId = (u32)0x000007FF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 21);
   \   00000018   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001A   0xEB10 0x1301      ADDS     R3,R0,R1, LSL #+4
   \   0000001E   0xF8D3 0x31B0      LDR      R3,[R3, #+432]
   \   00000022   0x0D5B             LSRS     R3,R3,#+21
   \   00000024   0x6013             STR      R3,[R2, #+0]
   \   00000026   0xE006             B.N      ??CAN_Receive_1
    719            }
    720            else
    721            {
    722              RxMessage->ExtId = (u32)0x1FFFFFFF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 3);
   \                     ??CAN_Receive_0: (+1)
   \   00000028   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002A   0xEB10 0x1301      ADDS     R3,R0,R1, LSL #+4
   \   0000002E   0xF8D3 0x31B0      LDR      R3,[R3, #+432]
   \   00000032   0x08DB             LSRS     R3,R3,#+3
   \   00000034   0x6053             STR      R3,[R2, #+4]
    723            }
    724            
    725            RxMessage->RTR = (u8)0x02 & CANx->sFIFOMailBox[FIFONumber].RIR;
   \                     ??CAN_Receive_1: (+1)
   \   00000036   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000038   0xEB10 0x1301      ADDS     R3,R0,R1, LSL #+4
   \   0000003C   0xF8D3 0x31B0      LDR      R3,[R3, #+432]
   \   00000040   0xF013 0x0302      ANDS     R3,R3,#0x2
   \   00000044   0x7253             STRB     R3,[R2, #+9]
    726          
    727            /* Get the DLC */
    728            RxMessage->DLC = (u8)0x0F & CANx->sFIFOMailBox[FIFONumber].RDTR;
   \   00000046   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000048   0xEB10 0x1301      ADDS     R3,R0,R1, LSL #+4
   \   0000004C   0xF8D3 0x31B4      LDR      R3,[R3, #+436]
   \   00000050   0xF013 0x030F      ANDS     R3,R3,#0xF
   \   00000054   0x7293             STRB     R3,[R2, #+10]
    729          
    730            /* Get the FMI */
    731            RxMessage->FMI = (u8)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDTR >> 8);
   \   00000056   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000058   0xEB10 0x1301      ADDS     R3,R0,R1, LSL #+4
   \   0000005C   0xF8D3 0x31B4      LDR      R3,[R3, #+436]
   \   00000060   0x0A1B             LSRS     R3,R3,#+8
   \   00000062   0x74D3             STRB     R3,[R2, #+19]
    732          
    733            /* Get the data field */
    734            RxMessage->Data[0] = (u8)0xFF & CANx->sFIFOMailBox[FIFONumber].RDLR;
   \   00000064   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000066   0xEB10 0x1301      ADDS     R3,R0,R1, LSL #+4
   \   0000006A   0xF8D3 0x31B8      LDR      R3,[R3, #+440]
   \   0000006E   0x72D3             STRB     R3,[R2, #+11]
    735            RxMessage->Data[1] = (u8)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 8);
   \   00000070   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000072   0xEB10 0x1301      ADDS     R3,R0,R1, LSL #+4
   \   00000076   0xF8D3 0x31B8      LDR      R3,[R3, #+440]
   \   0000007A   0x0A1B             LSRS     R3,R3,#+8
   \   0000007C   0x7313             STRB     R3,[R2, #+12]
    736            RxMessage->Data[2] = (u8)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 16);
   \   0000007E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000080   0xEB10 0x1301      ADDS     R3,R0,R1, LSL #+4
   \   00000084   0xF8D3 0x31B8      LDR      R3,[R3, #+440]
   \   00000088   0x0C1B             LSRS     R3,R3,#+16
   \   0000008A   0x7353             STRB     R3,[R2, #+13]
    737            RxMessage->Data[3] = (u8)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 24);
   \   0000008C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000008E   0xEB10 0x1301      ADDS     R3,R0,R1, LSL #+4
   \   00000092   0xF8D3 0x31B8      LDR      R3,[R3, #+440]
   \   00000096   0x0E1B             LSRS     R3,R3,#+24
   \   00000098   0x7393             STRB     R3,[R2, #+14]
    738          
    739            RxMessage->Data[4] = (u8)0xFF & CANx->sFIFOMailBox[FIFONumber].RDHR;
   \   0000009A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000009C   0xEB10 0x1301      ADDS     R3,R0,R1, LSL #+4
   \   000000A0   0xF8D3 0x31BC      LDR      R3,[R3, #+444]
   \   000000A4   0x73D3             STRB     R3,[R2, #+15]
    740            RxMessage->Data[5] = (u8)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 8);
   \   000000A6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000A8   0xEB10 0x1301      ADDS     R3,R0,R1, LSL #+4
   \   000000AC   0xF8D3 0x31BC      LDR      R3,[R3, #+444]
   \   000000B0   0x0A1B             LSRS     R3,R3,#+8
   \   000000B2   0x7413             STRB     R3,[R2, #+16]
    741            RxMessage->Data[6] = (u8)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 16);
   \   000000B4   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000B6   0xEB10 0x1301      ADDS     R3,R0,R1, LSL #+4
   \   000000BA   0xF8D3 0x31BC      LDR      R3,[R3, #+444]
   \   000000BE   0x0C1B             LSRS     R3,R3,#+16
   \   000000C0   0x7453             STRB     R3,[R2, #+17]
    742            RxMessage->Data[7] = (u8)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 24);
   \   000000C2   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000C4   0xEB10 0x1301      ADDS     R3,R0,R1, LSL #+4
   \   000000C8   0xF8D3 0x31BC      LDR      R3,[R3, #+444]
   \   000000CC   0x0E1B             LSRS     R3,R3,#+24
   \   000000CE   0x7493             STRB     R3,[R2, #+18]
    743          
    744            /* Release the FIFO */
    745            CAN_FIFORelease(CANx, FIFONumber);
   \   000000D0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000D2   0x.... 0x....      BL       CAN_FIFORelease
    746          }
   \   000000D6   0xBD01             POP      {R0,PC}          ;; return
    747          
    748          /*******************************************************************************
    749          * Function Name  : CAN_Sleep
    750          * Description    : Enters the low power mode.
    751          * Input          : - CANx: where x can be 1 or 2 to select the CAN peripheral.
    752          * Output         : None.
    753          * Return         : CANSLEEPOK if sleep entered, CANSLEEPFAILED in an other case.
    754          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    755          u8 CAN_Sleep(CAN_TypeDef* CANx)
    756          {
    757            u8 sleepstatus = CANSLEEPFAILED;
   \                     CAN_Sleep: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    758          
    759            /* Check the parameters */
    760            assert_param(IS_CAN_ALL_PERIPH(CANx));
    761            
    762            /* Request Sleep mode */
    763             CANx->MCR = (((CANx->MCR) & (u32)(~MCR_INRQ)) | MCR_SLEEP);
   \   00000002   0x6802             LDR      R2,[R0, #+0]
   \   00000004   0x0852             LSRS     R2,R2,#+1
   \   00000006   0x0052             LSLS     R2,R2,#+1
   \   00000008   0xF052 0x0202      ORRS     R2,R2,#0x2
   \   0000000C   0x6002             STR      R2,[R0, #+0]
    764            /* Sleep mode status */
    765            if ((CANx->MSR & (CAN_MSR_SLAK|CAN_MSR_INAK)) == CAN_MSR_SLAK)
   \   0000000E   0x6840             LDR      R0,[R0, #+4]
   \   00000010   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   00000014   0x2802             CMP      R0,#+2
   \   00000016   0xD100             BNE.N    ??CAN_Sleep_0
    766            {
    767              /* Sleep mode not entered */
    768              sleepstatus =  CANSLEEPOK;
   \   00000018   0x2101             MOVS     R1,#+1
    769            }
    770            /* At this step, sleep mode status */
    771             return (u8)sleepstatus;
   \                     ??CAN_Sleep_0: (+1)
   \   0000001A   0x0008             MOVS     R0,R1
   \   0000001C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   0x4770             BX       LR               ;; return
    772          }
    773          
    774          
    775          /*******************************************************************************
    776          * Function Name  : CAN_WakeUp
    777          * Description    : Wakes the CAN up.
    778          * Input          : - CANx: where x can be 1 or 2 to select the CAN peripheral.
    779          * Output         : None.
    780          * Return         : CANWAKEUPOK if sleep mode left, CANWAKEUPFAILED in an other
    781          *                  case.
    782          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    783          u8 CAN_WakeUp(CAN_TypeDef* CANx)
    784          {
    785            u16 waitslak = SLAK_TimeOut	;
   \                     CAN_WakeUp: (+1)
   \   00000000   0xF64F 0x72FF      MOVW     R2,#+65535
    786            u8 wakeupstatus = CANWAKEUPFAILED;
   \   00000004   0x2100             MOVS     R1,#+0
    787            
    788            /* Check the parameter */
    789            assert_param(IS_CAN_ALL_PERIPH(CANx));
    790            
    791            /* Wake up request */
    792            CANx->MCR &= ~MCR_SLEEP;
   \   00000006   0x6803             LDR      R3,[R0, #+0]
   \   00000008   0xF033 0x0302      BICS     R3,R3,#0x2
   \   0000000C   0x6003             STR      R3,[R0, #+0]
   \   0000000E   0xE000             B.N      ??CAN_WakeUp_0
    793              
    794            /* Sleep mode status */
    795          
    796            while(((CANx->MSR & CAN_MSR_SLAK) == CAN_MSR_SLAK)&&(waitslak!=0x00))
    797             {
    798             waitslak --;
   \                     ??CAN_WakeUp_1: (+1)
   \   00000010   0x1E52             SUBS     R2,R2,#+1
    799             }
   \                     ??CAN_WakeUp_0: (+1)
   \   00000012   0x6843             LDR      R3,[R0, #+4]
   \   00000014   0x079B             LSLS     R3,R3,#+30
   \   00000016   0xD502             BPL.N    ??CAN_WakeUp_2
   \   00000018   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000001A   0x2A00             CMP      R2,#+0
   \   0000001C   0xD1F8             BNE.N    ??CAN_WakeUp_1
    800          
    801            if((CANx->MSR & CAN_MSR_SLAK) != CAN_MSR_SLAK)
   \                     ??CAN_WakeUp_2: (+1)
   \   0000001E   0x6840             LDR      R0,[R0, #+4]
   \   00000020   0x0780             LSLS     R0,R0,#+30
   \   00000022   0xD400             BMI.N    ??CAN_WakeUp_3
    802            {
    803             /* Sleep mode exited */
    804              wakeupstatus = CANWAKEUPOK;
   \   00000024   0x2101             MOVS     R1,#+1
    805            }
    806            /* At this step, sleep mode status */
    807            return (u8)wakeupstatus;
   \                     ??CAN_WakeUp_3: (+1)
   \   00000026   0x0008             MOVS     R0,R1
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0x4770             BX       LR               ;; return
    808          }
    809          
    810          /*******************************************************************************
    811          * Function Name  : CAN_GetFlagStatus
    812          * Description    : Checks whether the specified CAN flag is set or not.
    813          * Input          : - CANx: where x can be 1 or 2 to select the CAN peripheral.
    814          *                  - CAN_FLAG: specifies the flag to check.
    815          *                  This parameter can be: CAN_FLAG_EWG, CAN_FLAG_EPV or
    816          *                                         CAN_FLAG_BOF.
    817          * Output         : None.
    818          * Return         : The new state of CAN_FLAG (SET or RESET).
    819          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    820          FlagStatus CAN_GetFlagStatus(CAN_TypeDef* CANx, u32 CAN_FLAG)
    821          {
    822            FlagStatus bitstatus = RESET;
   \                     CAN_GetFlagStatus: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
    823          
    824            /* Check the parameters */
    825            assert_param(IS_CAN_ALL_PERIPH(CANx));
    826            assert_param(IS_CAN_FLAG(CAN_FLAG));
    827          
    828            /* Check the status of the specified CAN flag */
    829            if ((CANx->ESR & CAN_FLAG) != (u32)RESET)
   \   00000002   0x6980             LDR      R0,[R0, #+24]
   \   00000004   0x4208             TST      R0,R1
   \   00000006   0xD001             BEQ.N    ??CAN_GetFlagStatus_0
    830            {
    831              /* CAN_FLAG is set */
    832              bitstatus = SET;
   \   00000008   0x2201             MOVS     R2,#+1
   \   0000000A   0xE000             B.N      ??CAN_GetFlagStatus_1
    833            }
    834            else
    835            {
    836              /* CAN_FLAG is reset */
    837              bitstatus = RESET;
   \                     ??CAN_GetFlagStatus_0: (+1)
   \   0000000C   0x2200             MOVS     R2,#+0
    838            }
    839            /* Return the CAN_FLAG status */
    840            return  bitstatus;
   \                     ??CAN_GetFlagStatus_1: (+1)
   \   0000000E   0x0010             MOVS     R0,R2
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x4770             BX       LR               ;; return
    841          }
    842          
    843          /*******************************************************************************
    844          * Function Name  : CAN_ClearFlag
    845          * Description    : Clears the CAN's pending flags.
    846          * Input          : - CANx: where x can be 1 or 2 to select the CAN peripheral.
    847          *                  - CAN_FLAG: specifies the flag to clear.
    848          * Output         : None.
    849          * Return         : None.
    850          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    851          void CAN_ClearFlag(CAN_TypeDef* CANx, u32 CAN_FLAG)
    852          {
    853            /* Check the parameters */
    854            assert_param(IS_CAN_ALL_PERIPH(CANx));
    855            assert_param(IS_CAN_FLAG(CAN_FLAG));
    856          
    857            /* Clear the selected CAN flags */
    858            CANx->ESR &= ~CAN_FLAG;
   \                     CAN_ClearFlag: (+1)
   \   00000000   0x6982             LDR      R2,[R0, #+24]
   \   00000002   0xEA32 0x0101      BICS     R1,R2,R1
   \   00000006   0x6181             STR      R1,[R0, #+24]
    859          }
   \   00000008   0x4770             BX       LR               ;; return
    860          
    861          /*******************************************************************************
    862          * Function Name  : CAN_GetITStatus
    863          * Description    : Checks whether the specified CAN interrupt has occurred or 
    864          *                  not.
    865          * Input          : - CANx: where x can be 1 or 2 to select the CAN peripheral.
    866          *                  - CAN_IT: specifies the CAN interrupt source to check.
    867          *                  This parameter can be: CAN_IT_RQCP0, CAN_IT_RQCP1, CAN_IT_RQCP2,
    868          *                                         CAN_IT_FF0, CAN_IT_FOV0, CAN_IT_FF1,
    869          *                                         CAN_IT_FOV1, CAN_IT_EWG, CAN_IT_EPV, 
    870          *                                         CAN_IT_BOF, CAN_IT_WKU or CAN_IT_SLK.
    871          * Output         : None.
    872          * Return         : The new state of CAN_IT (SET or RESET).
    873          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    874          ITStatus CAN_GetITStatus(CAN_TypeDef* CANx, u32 CAN_IT)
    875          {
   \                     CAN_GetITStatus: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    876            ITStatus pendingbitstatus = RESET;
   \   00000002   0x2200             MOVS     R2,#+0
    877          
    878            /* Check the parameters */
    879            assert_param(IS_CAN_ALL_PERIPH(CANx));
    880            assert_param(IS_CAN_ITStatus(CAN_IT));
    881          
    882            switch (CAN_IT)
   \   00000004   0x2904             CMP      R1,#+4
   \   00000006   0xD02F             BEQ.N    ??CAN_GetITStatus_0
   \   00000008   0x2905             CMP      R1,#+5
   \   0000000A   0xD019             BEQ.N    ??CAN_GetITStatus_1
   \   0000000C   0x2906             CMP      R1,#+6
   \   0000000E   0xD01D             BEQ.N    ??CAN_GetITStatus_2
   \   00000010   0x2907             CMP      R1,#+7
   \   00000012   0xD022             BEQ.N    ??CAN_GetITStatus_3
   \   00000014   0x2908             CMP      R1,#+8
   \   00000016   0xD02D             BEQ.N    ??CAN_GetITStatus_4
   \   00000018   0x2920             CMP      R1,#+32
   \   0000001A   0xD031             BEQ.N    ??CAN_GetITStatus_5
   \   0000001C   0x2940             CMP      R1,#+64
   \   0000001E   0xD035             BEQ.N    ??CAN_GetITStatus_6
   \   00000020   0xF5B1 0x7F80      CMP      R1,#+256
   \   00000024   0xD038             BEQ.N    ??CAN_GetITStatus_7
   \   00000026   0xF5B1 0x7F00      CMP      R1,#+512
   \   0000002A   0xD03B             BEQ.N    ??CAN_GetITStatus_8
   \   0000002C   0xF5B1 0x6F80      CMP      R1,#+1024
   \   00000030   0xD03E             BEQ.N    ??CAN_GetITStatus_9
   \   00000032   0xF5B1 0x3F80      CMP      R1,#+65536
   \   00000036   0xD047             BEQ.N    ??CAN_GetITStatus_10
   \   00000038   0xF5B1 0x3F00      CMP      R1,#+131072
   \   0000003C   0xD03E             BEQ.N    ??CAN_GetITStatus_11
   \   0000003E   0xE049             B.N      ??CAN_GetITStatus_12
    883            {
    884              case CAN_IT_RQCP0:
    885                pendingbitstatus = CheckITStatus(CANx->TSR, TSR_RQCP0);
   \                     ??CAN_GetITStatus_1: (+1)
   \   00000040   0x2101             MOVS     R1,#+1
   \   00000042   0x6880             LDR      R0,[R0, #+8]
   \   00000044   0x.... 0x....      BL       CheckITStatus
   \   00000048   0x0002             MOVS     R2,R0
    886                break;
   \   0000004A   0xE044             B.N      ??CAN_GetITStatus_13
    887              case CAN_IT_RQCP1:
    888                pendingbitstatus = CheckITStatus(CANx->TSR, TSR_RQCP1);
   \                     ??CAN_GetITStatus_2: (+1)
   \   0000004C   0xF44F 0x7180      MOV      R1,#+256
   \   00000050   0x6880             LDR      R0,[R0, #+8]
   \   00000052   0x.... 0x....      BL       CheckITStatus
   \   00000056   0x0002             MOVS     R2,R0
    889                break;
   \   00000058   0xE03D             B.N      ??CAN_GetITStatus_13
    890              case CAN_IT_RQCP2:
    891                pendingbitstatus = CheckITStatus(CANx->TSR, TSR_RQCP2);
   \                     ??CAN_GetITStatus_3: (+1)
   \   0000005A   0xF45F 0x3180      MOVS     R1,#+65536
   \   0000005E   0x6880             LDR      R0,[R0, #+8]
   \   00000060   0x.... 0x....      BL       CheckITStatus
   \   00000064   0x0002             MOVS     R2,R0
    892                break;
   \   00000066   0xE036             B.N      ??CAN_GetITStatus_13
    893              case CAN_IT_FF0:
    894                pendingbitstatus = CheckITStatus(CANx->RF0R, RF0R_FULL0);
   \                     ??CAN_GetITStatus_0: (+1)
   \   00000068   0x2108             MOVS     R1,#+8
   \   0000006A   0x68C0             LDR      R0,[R0, #+12]
   \   0000006C   0x.... 0x....      BL       CheckITStatus
   \   00000070   0x0002             MOVS     R2,R0
    895                break;
   \   00000072   0xE030             B.N      ??CAN_GetITStatus_13
    896              case CAN_IT_FOV0:
    897                pendingbitstatus = CheckITStatus(CANx->RF0R, RF0R_FOVR0);
   \                     ??CAN_GetITStatus_4: (+1)
   \   00000074   0x2110             MOVS     R1,#+16
   \   00000076   0x68C0             LDR      R0,[R0, #+12]
   \   00000078   0x.... 0x....      BL       CheckITStatus
   \   0000007C   0x0002             MOVS     R2,R0
    898                break;
   \   0000007E   0xE02A             B.N      ??CAN_GetITStatus_13
    899              case CAN_IT_FF1:
    900                pendingbitstatus = CheckITStatus(CANx->RF1R, RF1R_FULL1);
   \                     ??CAN_GetITStatus_5: (+1)
   \   00000080   0x2108             MOVS     R1,#+8
   \   00000082   0x6900             LDR      R0,[R0, #+16]
   \   00000084   0x.... 0x....      BL       CheckITStatus
   \   00000088   0x0002             MOVS     R2,R0
    901                break;
   \   0000008A   0xE024             B.N      ??CAN_GetITStatus_13
    902              case CAN_IT_FOV1:
    903                pendingbitstatus = CheckITStatus(CANx->RF1R, RF1R_FOVR1);
   \                     ??CAN_GetITStatus_6: (+1)
   \   0000008C   0x2110             MOVS     R1,#+16
   \   0000008E   0x6900             LDR      R0,[R0, #+16]
   \   00000090   0x.... 0x....      BL       CheckITStatus
   \   00000094   0x0002             MOVS     R2,R0
    904                break;
   \   00000096   0xE01E             B.N      ??CAN_GetITStatus_13
    905              case CAN_IT_EWG:
    906                pendingbitstatus = CheckITStatus(CANx->ESR, ESR_EWGF);
   \                     ??CAN_GetITStatus_7: (+1)
   \   00000098   0x2101             MOVS     R1,#+1
   \   0000009A   0x6980             LDR      R0,[R0, #+24]
   \   0000009C   0x.... 0x....      BL       CheckITStatus
   \   000000A0   0x0002             MOVS     R2,R0
    907                break;
   \   000000A2   0xE018             B.N      ??CAN_GetITStatus_13
    908              case CAN_IT_EPV:
    909                pendingbitstatus = CheckITStatus(CANx->ESR, ESR_EPVF);
   \                     ??CAN_GetITStatus_8: (+1)
   \   000000A4   0x2102             MOVS     R1,#+2
   \   000000A6   0x6980             LDR      R0,[R0, #+24]
   \   000000A8   0x.... 0x....      BL       CheckITStatus
   \   000000AC   0x0002             MOVS     R2,R0
    910                break;
   \   000000AE   0xE012             B.N      ??CAN_GetITStatus_13
    911              case CAN_IT_BOF:
    912                pendingbitstatus = CheckITStatus(CANx->ESR, ESR_BOFF);
   \                     ??CAN_GetITStatus_9: (+1)
   \   000000B0   0x2104             MOVS     R1,#+4
   \   000000B2   0x6980             LDR      R0,[R0, #+24]
   \   000000B4   0x.... 0x....      BL       CheckITStatus
   \   000000B8   0x0002             MOVS     R2,R0
    913                break;
   \   000000BA   0xE00C             B.N      ??CAN_GetITStatus_13
    914              case CAN_IT_SLK:
    915                pendingbitstatus = CheckITStatus(CANx->MSR, MSR_SLAKI);
   \                     ??CAN_GetITStatus_11: (+1)
   \   000000BC   0x2110             MOVS     R1,#+16
   \   000000BE   0x6840             LDR      R0,[R0, #+4]
   \   000000C0   0x.... 0x....      BL       CheckITStatus
   \   000000C4   0x0002             MOVS     R2,R0
    916                break;
   \   000000C6   0xE006             B.N      ??CAN_GetITStatus_13
    917              case CAN_IT_WKU:
    918                pendingbitstatus = CheckITStatus(CANx->MSR, MSR_WKUI);
   \                     ??CAN_GetITStatus_10: (+1)
   \   000000C8   0x2108             MOVS     R1,#+8
   \   000000CA   0x6840             LDR      R0,[R0, #+4]
   \   000000CC   0x.... 0x....      BL       CheckITStatus
   \   000000D0   0x0002             MOVS     R2,R0
    919                break;
   \   000000D2   0xE000             B.N      ??CAN_GetITStatus_13
    920          
    921              default :
    922                pendingbitstatus = RESET;
   \                     ??CAN_GetITStatus_12: (+1)
   \   000000D4   0x2200             MOVS     R2,#+0
    923                break;
    924            }
    925          
    926            /* Return the CAN_IT status */
    927            return  pendingbitstatus;
   \                     ??CAN_GetITStatus_13: (+1)
   \   000000D6   0x0010             MOVS     R0,R2
   \   000000D8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000DA   0xBD02             POP      {R1,PC}          ;; return
    928          }
    929          
    930          /*******************************************************************************
    931          * Function Name  : CAN_ClearITPendingBit
    932          * Description    : Clears the CANs interrupt pending bits.
    933          * Input          : - CANx: where x can be 1 or 2 to select the CAN peripheral.
    934          *                  - CAN_IT: specifies the interrupt pending bit to clear.
    935          * Output         : None.
    936          * Return         : None.
    937          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    938          void CAN_ClearITPendingBit(CAN_TypeDef* CANx, u32 CAN_IT)
    939          {
    940            /* Check the parameters */
    941            assert_param(IS_CAN_ALL_PERIPH(CANx));
    942            assert_param(IS_CAN_ITStatus(CAN_IT));
    943          
    944            switch (CAN_IT)
   \                     CAN_ClearITPendingBit: (+1)
   \   00000000   0x2904             CMP      R1,#+4
   \   00000002   0xD026             BEQ.N    ??CAN_ClearITPendingBit_0
   \   00000004   0x2905             CMP      R1,#+5
   \   00000006   0xD019             BEQ.N    ??CAN_ClearITPendingBit_1
   \   00000008   0x2906             CMP      R1,#+6
   \   0000000A   0xD01A             BEQ.N    ??CAN_ClearITPendingBit_2
   \   0000000C   0x2907             CMP      R1,#+7
   \   0000000E   0xD01C             BEQ.N    ??CAN_ClearITPendingBit_3
   \   00000010   0x2908             CMP      R1,#+8
   \   00000012   0xD021             BEQ.N    ??CAN_ClearITPendingBit_4
   \   00000014   0x2920             CMP      R1,#+32
   \   00000016   0xD022             BEQ.N    ??CAN_ClearITPendingBit_5
   \   00000018   0x2940             CMP      R1,#+64
   \   0000001A   0xD023             BEQ.N    ??CAN_ClearITPendingBit_6
   \   0000001C   0xF5B1 0x7F80      CMP      R1,#+256
   \   00000020   0xD023             BEQ.N    ??CAN_ClearITPendingBit_7
   \   00000022   0xF5B1 0x7F00      CMP      R1,#+512
   \   00000026   0xD025             BEQ.N    ??CAN_ClearITPendingBit_8
   \   00000028   0xF5B1 0x6F80      CMP      R1,#+1024
   \   0000002C   0xD027             BEQ.N    ??CAN_ClearITPendingBit_9
   \   0000002E   0xF5B1 0x3F80      CMP      R1,#+65536
   \   00000032   0xD029             BEQ.N    ??CAN_ClearITPendingBit_10
   \   00000034   0xF5B1 0x3F00      CMP      R1,#+131072
   \   00000038   0xD029             BEQ.N    ??CAN_ClearITPendingBit_11
   \   0000003A   0xE02B             B.N      ??CAN_ClearITPendingBit_12
    945            {
    946              case CAN_IT_RQCP0:
    947                CANx->TSR = TSR_RQCP0; /* rc_w1*/
   \                     ??CAN_ClearITPendingBit_1: (+1)
   \   0000003C   0x2101             MOVS     R1,#+1
   \   0000003E   0x6081             STR      R1,[R0, #+8]
    948                break;
   \   00000040   0xE028             B.N      ??CAN_ClearITPendingBit_13
    949              case CAN_IT_RQCP1:
    950                CANx->TSR = TSR_RQCP1; /* rc_w1*/
   \                     ??CAN_ClearITPendingBit_2: (+1)
   \   00000042   0xF44F 0x7180      MOV      R1,#+256
   \   00000046   0x6081             STR      R1,[R0, #+8]
    951                break;
   \   00000048   0xE024             B.N      ??CAN_ClearITPendingBit_13
    952              case CAN_IT_RQCP2:
    953                CANx->TSR = TSR_RQCP2; /* rc_w1*/
   \                     ??CAN_ClearITPendingBit_3: (+1)
   \   0000004A   0xF45F 0x3180      MOVS     R1,#+65536
   \   0000004E   0x6081             STR      R1,[R0, #+8]
    954                break;
   \   00000050   0xE020             B.N      ??CAN_ClearITPendingBit_13
    955              case CAN_IT_FF0:
    956                CANx->RF0R = RF0R_FULL0; /* rc_w1*/
   \                     ??CAN_ClearITPendingBit_0: (+1)
   \   00000052   0x2108             MOVS     R1,#+8
   \   00000054   0x60C1             STR      R1,[R0, #+12]
    957                break;
   \   00000056   0xE01D             B.N      ??CAN_ClearITPendingBit_13
    958              case CAN_IT_FOV0:
    959                CANx->RF0R = RF0R_FOVR0; /* rc_w1*/
   \                     ??CAN_ClearITPendingBit_4: (+1)
   \   00000058   0x2110             MOVS     R1,#+16
   \   0000005A   0x60C1             STR      R1,[R0, #+12]
    960                break;
   \   0000005C   0xE01A             B.N      ??CAN_ClearITPendingBit_13
    961              case CAN_IT_FF1:
    962                CANx->RF1R = RF1R_FULL1; /* rc_w1*/
   \                     ??CAN_ClearITPendingBit_5: (+1)
   \   0000005E   0x2108             MOVS     R1,#+8
   \   00000060   0x6101             STR      R1,[R0, #+16]
    963                break;
   \   00000062   0xE017             B.N      ??CAN_ClearITPendingBit_13
    964              case CAN_IT_FOV1:
    965                CANx->RF1R = RF1R_FOVR1; /* rc_w1*/
   \                     ??CAN_ClearITPendingBit_6: (+1)
   \   00000064   0x2110             MOVS     R1,#+16
   \   00000066   0x6101             STR      R1,[R0, #+16]
    966                break;
   \   00000068   0xE014             B.N      ??CAN_ClearITPendingBit_13
    967              case CAN_IT_EWG:
    968                CANx->ESR &= ~ ESR_EWGF; /* rw */
   \                     ??CAN_ClearITPendingBit_7: (+1)
   \   0000006A   0x6981             LDR      R1,[R0, #+24]
   \   0000006C   0x0849             LSRS     R1,R1,#+1
   \   0000006E   0x0049             LSLS     R1,R1,#+1
   \   00000070   0x6181             STR      R1,[R0, #+24]
    969                break;
   \   00000072   0xE00F             B.N      ??CAN_ClearITPendingBit_13
    970              case CAN_IT_EPV:
    971                CANx->ESR &= ~ ESR_EPVF; /* rw */
   \                     ??CAN_ClearITPendingBit_8: (+1)
   \   00000074   0x6981             LDR      R1,[R0, #+24]
   \   00000076   0xF031 0x0102      BICS     R1,R1,#0x2
   \   0000007A   0x6181             STR      R1,[R0, #+24]
    972                break;
   \   0000007C   0xE00A             B.N      ??CAN_ClearITPendingBit_13
    973              case CAN_IT_BOF:
    974                CANx->ESR &= ~ ESR_BOFF; /* rw */
   \                     ??CAN_ClearITPendingBit_9: (+1)
   \   0000007E   0x6981             LDR      R1,[R0, #+24]
   \   00000080   0xF031 0x0104      BICS     R1,R1,#0x4
   \   00000084   0x6181             STR      R1,[R0, #+24]
    975                break;
   \   00000086   0xE005             B.N      ??CAN_ClearITPendingBit_13
    976              case CAN_IT_WKU:
    977                CANx->MSR = MSR_WKUI;  /* rc_w1*/
   \                     ??CAN_ClearITPendingBit_10: (+1)
   \   00000088   0x2108             MOVS     R1,#+8
   \   0000008A   0x6041             STR      R1,[R0, #+4]
    978                break;
   \   0000008C   0xE002             B.N      ??CAN_ClearITPendingBit_13
    979              case CAN_IT_SLK:
    980                CANx->MSR = MSR_SLAKI;  /* rc_w1*/
   \                     ??CAN_ClearITPendingBit_11: (+1)
   \   0000008E   0x2110             MOVS     R1,#+16
   \   00000090   0x6041             STR      R1,[R0, #+4]
    981                break;
   \   00000092   0xE7FF             B.N      ??CAN_ClearITPendingBit_13
    982              default :
    983                break;
    984            }
    985          }
   \                     ??CAN_ClearITPendingBit_12: (+1)
   \                     ??CAN_ClearITPendingBit_13: (+1)
   \   00000094   0x4770             BX       LR               ;; return
    986          
    987          /*******************************************************************************
    988          * Function Name  : CheckITStatus
    989          * Description    : Checks whether the CAN interrupt has occurred or not.
    990          * Input          : - CAN_Reg: specifies the CAN interrupt register to check.
    991          *                  It_Bit: specifies the interrupt source bit to check.
    992          * Output         : None.
    993          * Return         : The new state of the CAN Interrupt (SET or RESET).
    994          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    995          static ITStatus CheckITStatus(u32 CAN_Reg, u32 It_Bit)
    996          {
    997            ITStatus pendingbitstatus = RESET;
   \                     CheckITStatus: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
    998          
    999            if ((CAN_Reg & It_Bit) != (u32)RESET)
   \   00000002   0x4208             TST      R0,R1
   \   00000004   0xD001             BEQ.N    ??CheckITStatus_0
   1000            {
   1001              /* CAN_IT is set */
   1002              pendingbitstatus = SET;
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0xE000             B.N      ??CheckITStatus_1
   1003            }
   1004            else
   1005            {
   1006              /* CAN_IT is reset */
   1007              pendingbitstatus = RESET;
   \                     ??CheckITStatus_0: (+1)
   \   0000000A   0x2200             MOVS     R2,#+0
   1008            }
   1009          
   1010            return pendingbitstatus;
   \                     ??CheckITStatus_1: (+1)
   \   0000000C   0x0010             MOVS     R0,R2
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x4770             BX       LR               ;; return
   1011          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x40006400         DC32     0x40006400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x40006800         DC32     0x40006800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x40006600         DC32     0x40006600

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x4000661C         DC32     0x4000661c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0x4000660C         DC32     0x4000660c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \   00000000   0x40006640         DC32     0x40006640

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \   00000000   0x40006604         DC32     0x40006604

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_7:
   \   00000000   0x40006614         DC32     0x40006614

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_8:
   \   00000000   0xFFFFC0F1         DC32     0xffffc0f1
   1012          
   1013          /******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   CAN_CancelTransmit
       0   CAN_ClearFlag
       0   CAN_ClearITPendingBit
       0   CAN_DBGFreeze
       8   CAN_DeInit
         8   -> RCC_APB1PeriphResetCmd
       0   CAN_FIFORelease
       4   CAN_FilterInit
       0   CAN_GetFlagStatus
       8   CAN_GetITStatus
         8   -> CheckITStatus
       0   CAN_ITConfig
       0   CAN_Init
       0   CAN_MessagePending
       8   CAN_Receive
         8   -> CAN_FIFORelease
       0   CAN_SlaveStartBank
       0   CAN_Sleep
       0   CAN_StructInit
       8   CAN_Transmit
       0   CAN_TransmitStatus
       0   CAN_WakeUp
       0   CheckITStatus


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
      46  CAN_CancelTransmit
      10  CAN_ClearFlag
     150  CAN_ClearITPendingBit
      26  CAN_DBGFreeze
      62  CAN_DeInit
      18  CAN_FIFORelease
     224  CAN_FilterInit
      20  CAN_GetFlagStatus
     220  CAN_GetITStatus
      24  CAN_ITConfig
     272  CAN_Init
      38  CAN_MessagePending
     216  CAN_Receive
      52  CAN_SlaveStartBank
      32  CAN_Sleep
      46  CAN_StructInit
     286  CAN_Transmit
     150  CAN_TransmitStatus
      44  CAN_WakeUp
      18  CheckITStatus

 
 1 990 bytes in section .text
 
 1 990 bytes of CODE memory

Errors: none
Warnings: none
