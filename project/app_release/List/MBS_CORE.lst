###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       15/Jul/2018  10:36:25
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC210\NC210-200处理板\source\Software\uC-MB\Source\MBS_CORE.C
#    Command line =  
#        F:\iar\NC210\NC210-200处理板\source\Software\uC-MB\Source\MBS_CORE.C
#        -D USE_STDPERIPH_DRIVER -D APP_RELEASE -lCN
#        F:\iar\NC210\NC210-200处理板\project\app_release\List -o
#        F:\iar\NC210\NC210-200处理板\project\app_release\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC210\NC210-200处理板\project\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\config\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\task\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\user\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\OS\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\Ports\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\driver\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-LIB\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Source\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\ST\STM32\inc\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Ports\STM32\STM32F103\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Source\
#        -Ol --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC210\NC210-200处理板\project\app_release\List\MBS_CORE.lst
#    Object file  =  
#        F:\iar\NC210\NC210-200处理板\project\app_release\Obj\MBS_CORE.o
#
###############################################################################

F:\iar\NC210\NC210-200处理板\source\Software\uC-MB\Source\MBS_CORE.C
      1          /*
      2          *********************************************************************************************************
      3          *                                              uC/Modbus
      4          *                                       The Embedded Modbus Stack
      5          *
      6          *                          (c) Copyright 2003-2009; Micrium, Inc.; Weston, FL
      7          *
      8          *               All rights reserved.  Protected by international copyright laws.
      9          *               Knowledge of the source code may NOT be used to develop a similar product.
     10          *               Please help us continue to provide the Embedded community with the finest
     11          *               software available.  Your honesty is greatly appreciated.
     12          *********************************************************************************************************
     13          */
     14          
     15          /*
     16          *********************************************************************************************************
     17          *
     18          *                                     uC/MODBUS SLAVE COMMAND PROCESSOR
     19          *
     20          * Filename      : mbs_core.c
     21          * Version       : V2.12
     22          * Programmer(s) : JJL
     23          *********************************************************************************************************
     24          * Note(s)       :
     25          *********************************************************************************************************
     26          */
     27          // FILE MODIFIED BY SE
     28          // added code for SE specific functions and features
     29          
     30          /*
     31          *********************************************************************************************************
     32          *                                             INCLUDE FILES
     33          *********************************************************************************************************
     34          */
     35          
     36          #define  MBS_MODULE
     37          #include <includes.h>
     38          //#include <mb_app_hooks.h>
     39          
     40          /*
     41          *********************************************************************************************************
     42          *                                                MACROS
     43          *********************************************************************************************************
     44          */
     45          
     46          #define  MBS_RX_DATA_START     (((CPU_INT16U)pch->RxFrameData[2] << 8) + (CPU_INT16U)pch->RxFrameData[3])
     47          #define  MBS_RX_DATA_START_H    (pch->RxFrameData[2])
     48          #define  MBS_RX_DATA_START_L    (pch->RxFrameData[3])
     49          
     50          #define  MBS_RX_DATA_POINTS    (((CPU_INT16U)pch->RxFrameData[4] << 8) + (CPU_INT16U)pch->RxFrameData[5])
     51          #define  MBS_RX_DATA_POINTS_H   (pch->RxFrameData[4])
     52          #define  MBS_RX_DATA_POINTS_L   (pch->RxFrameData[5])
     53          
     54          #define  MBS_RX_DATA_BYTES      (pch->RxFrameData[6])
     55          
     56          #define  MBS_RX_DATA_COIL      (((CPU_INT16U)pch->RxFrameData[4] << 8) + (CPU_INT16U)pch->RxFrameData[5])
     57          #define  MBS_RX_DATA_COIL_H     (pch->RxFrameData[4])
     58          #define  MBS_RX_DATA_COIL_L     (pch->RxFrameData[5])
     59          
     60          #define  MBS_RX_DATA_REG       (((CPU_INT16U)pch->RxFrameData[4] << 8) + (CPU_INT16U)pch->RxFrameData[5])
     61          #define  MBS_RX_DATA_REG_H      (pch->RxFrameData[4])
     62          #define  MBS_RX_DATA_REG_L      (pch->RxFrameData[5])
     63          
     64          #define  MBS_RX_DIAG_CODE      (((CPU_INT16U)pch->RxFrameData[2] << 8) + (CPU_INT16U)pch->RxFrameData[3])
     65          #define  MBS_RX_DIAG_CODE_H     (pch->RxFrameData[2])
     66          #define  MBS_RX_DIAG_CODE_L     (pch->RxFrameData[3])
     67          #define  MBS_RX_DIAG_DATA      (((CPU_INT16U)pch->RxFrameData[4] << 8) + (CPU_INT16U)pch->RxFrameData[5])
     68          #define  MBS_RX_DIAG_DATA_H     (pch->RxFrameData[4])
     69          #define  MBS_RX_DIAG_DATA_L     (pch->RxFrameData[5])
     70          
     71          #define  MBS_RX_FRAME          (&pch->RxFrame)
     72          #define  MBS_RX_FRAME_ADDR      (pch->RxFrameData[0])
     73          #define  MBS_RX_FRAME_FC        (pch->RxFrameData[1])
     74          #define  MBS_RX_FRAME_DATA      (pch->RxFrameData[2])
     75          #define  MBS_RX_FRAME_NBYTES    (pch->RxFrameNDataBytes)
     76          
     77          
     78          #define  MBS_TX_DATA_START_H    (pch->TxFrameData[2])
     79          #define  MBS_TX_DATA_START_L    (pch->TxFrameData[3])
     80          
     81          #define  MBS_TX_DATA_POINTS_H   (pch->TxFrameData[4])
     82          #define  MBS_TX_DATA_POINTS_L   (pch->TxFrameData[5])
     83          
     84          #define  MBS_TX_DATA_COIL_H     (pch->TxFrameData[4])
     85          #define  MBS_TX_DATA_COIL_L     (pch->TxFrameData[5])
     86          
     87          #define  MBS_TX_DATA_REG_H      (pch->TxFrameData[4])
     88          #define  MBS_TX_DATA_REG_L      (pch->TxFrameData[5])
     89          
     90          #define  MBS_TX_DIAG_CODE_H     (pch->TxFrameData[2])
     91          #define  MBS_TX_DIAG_CODE_L     (pch->TxFrameData[3])
     92          #define  MBS_TX_DIAG_DATA_H     (pch->TxFrameData[4])
     93          #define  MBS_TX_DIAG_DATA_L     (pch->TxFrameData[5])
     94          
     95          
     96          #define  MBS_TX_FRAME          (&pch->TxFrame)
     97          #define  MBS_TX_FRAME_ADDR      (pch->TxFrameData[0])
     98          #define  MBS_TX_FRAME_FC        (pch->TxFrameData[1])
     99          #define  MBS_TX_FRAME_DATA      (pch->TxFrameData[2])
    100          #define  MBS_TX_FRAME_NBYTES    (pch->TxFrameNDataBytes)
    101          
    102          //SE Added defines from this point forward
    103          #define  MBS_FC100_DATA_BYTES    (5u)
    104          
    105          /*$PAGE*/
    106          /*
    107          *********************************************************************************************************
    108          *                                    LOCAL FUNCTION PROTOTYPES
    109          *********************************************************************************************************
    110          */
    111          
    112          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED)
    113          
    114          static  void                 MBS_ErrRespSet                (MODBUS_CH *pch, CPU_INT08U errcode);
    115          
    116          #if     (MODBUS_CFG_FC01_EN == DEF_ENABLED)
    117          static  CPU_BOOLEAN          MBS_FC01_CoilRd               (MODBUS_CH *pch);
    118          #endif
    119          
    120          #if     (MODBUS_CFG_FC02_EN == DEF_ENABLED)
    121          static  CPU_BOOLEAN          MBS_FC02_DIRd                 (MODBUS_CH *pch);
    122          #endif
    123          
    124          #if     (MODBUS_CFG_FC03_EN == DEF_ENABLED)
    125          static  CPU_BOOLEAN          MBS_FC03_HoldingRegRd         (MODBUS_CH *pch);
    126          #endif
    127          
    128          #if     (MODBUS_CFG_FC04_EN == DEF_ENABLED)
    129          static  CPU_BOOLEAN          MBS_FC04_InRegRd              (MODBUS_CH *pch);
    130          #endif
    131          
    132          #if     (MODBUS_CFG_FC05_EN == DEF_ENABLED)
    133          static  CPU_BOOLEAN          MBS_FC05_CoilWr               (MODBUS_CH *pch);
    134          #endif
    135          
    136          #if     (MODBUS_CFG_FC06_EN == DEF_ENABLED)
    137          static  CPU_BOOLEAN          MBS_FC06_HoldingRegWr         (MODBUS_CH *pch);
    138          #endif
    139          
    140          #if     (MODBUS_CFG_FC08_EN == DEF_ENABLED)
    141          static  CPU_BOOLEAN          MBS_FC08_Loopback             (MODBUS_CH *pch);
    142          #endif
    143          
    144          #if     (MODBUS_CFG_FC15_EN == DEF_ENABLED)
    145          static  CPU_BOOLEAN          MBS_FC15_CoilWrMultiple       (MODBUS_CH *pch);
    146          #endif
    147          
    148          #if     (MODBUS_CFG_FC16_EN == DEF_ENABLED)
    149          static  CPU_BOOLEAN          MBS_FC16_HoldingRegWrMultiple (MODBUS_CH *pch);
    150          #endif
    151          
    152          #if     (MODBUS_CFG_FC20_EN == DEF_ENABLED)
    153          static  CPU_BOOLEAN          MBS_FC20_FileRd               (MODBUS_CH *pch);
    154          #endif
    155          
    156          #if     (MODBUS_CFG_FC21_EN == DEF_ENABLED)
    157          static  CPU_BOOLEAN          MBS_FC21_FileWr               (MODBUS_CH *pch);
    158          #endif
    159          
    160          
    161          #if     MODBUS_FC43_EN > 0
    162          // SE added
    163          static   CPU_BOOLEAN          MBS_FC43_readDeviceID         (MODBUS_CH  *pch);
    164          #endif
    165          
    166          #if     MODBUS_FC100_EN > 0
    167          //SE added
    168          static   CPU_BOOLEAN          MBS_FC100_scatteredRead       (MODBUS_CH  *pch);
    169          
    170          #endif
    171          
    172          #if     (MODBUS_CFG_ASCII_EN == DEF_ENABLED)
    173          static  void                 MBS_ASCII_Task                (MODBUS_CH   *pch);
    174          #endif
    175          
    176          #if     (MODBUS_CFG_RTU_EN   == DEF_ENABLED)
    177          static  void                 MBS_RTU_Task                  (MODBUS_CH   *pch);
    178          #endif
    179          
    180          #endif
    181          
    182          /*$PAGE*/
    183          /*
    184          *********************************************************************************************************
    185          *                                         MBM_ErrRespSet()
    186          *
    187          * Description : This function sets the indicated error response code into the response frame.  Then the
    188          *               routine is called to calculate the error check value.
    189          *
    190          * Argument(s) : pch         Is a pointer to the Modbus channel's data structure.
    191          *
    192          *               errcode     An unsigned byte value containing the error code that is to be placed in the
    193          *                           response frame.
    194          *
    195          * Return(s)   : none.
    196          *
    197          * Caller(s)   : MBM_FCxx_Handler()
    198          *             : Modbus Slave functions
    199          *
    200          * Note(s)     : none.
    201          *********************************************************************************************************
    202          */
    203          
    204          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    205          static  void  MBS_ErrRespSet (MODBUS_CH  *pch,
    206                                        CPU_INT08U  err_code)
    207          {
    208              pch->StatExceptCtr++;
   \                     MBS_ErrRespSet: (+1)
   \   00000000   0x8C42             LDRH     R2,[R0, #+34]
   \   00000002   0x1C52             ADDS     R2,R2,#+1
   \   00000004   0x8442             STRH     R2,[R0, #+34]
    209              //COM_incDiaCtr(COM_EXCEPTIONS);
    210              // TODO Frame address was new from Micrium
    211              MBS_TX_FRAME_ADDR   = MBS_RX_FRAME_ADDR;
   \   00000006   0xF890 0x2444      LDRB     R2,[R0, #+1092]
   \   0000000A   0xF880 0x264E      STRB     R2,[R0, #+1614]
    212              MBS_TX_FRAME_FC     = MBS_RX_FRAME_FC | 0x80;                /* Set the high order bit of the function code.     */
   \   0000000E   0xF890 0x2445      LDRB     R2,[R0, #+1093]
   \   00000012   0xF052 0x0280      ORRS     R2,R2,#0x80
   \   00000016   0xF880 0x264F      STRB     R2,[R0, #+1615]
    213              MBS_TX_FRAME_DATA   = err_code;                              /* Set the high order bit of the function code.     */
   \   0000001A   0xF880 0x1650      STRB     R1,[R0, #+1616]
    214              MBS_TX_FRAME_NBYTES = 1;                                     /* Nbr of data bytes in exception response is 1.    */
   \   0000001E   0x2101             MOVS     R1,#+1
   \   00000020   0xF8A0 0x184E      STRH     R1,[R0, #+2126]
    215          }
   \   00000024   0x4770             BX       LR               ;; return
    216          #endif
    217          
    218          /*$PAGE*/
    219          /*
    220          *********************************************************************************************************
    221          *                                           MBS_FCxx_Handler()
    222          *
    223          * Description : This is the main processing function for MODBUS commands.  The message integrity is
    224          *               verified, and if valid, the function requested is processed.  Unimplemented functions
    225          *               will generate an Illegal Function Exception Response code (01).
    226          *
    227          * Argument(s) : pch      Is a pointer to the Modbus channel's data structure.
    228          *
    229          * Return(s)   : none.
    230          *
    231          * Caller(s)   : MBS_ASCII_Task()
    232          *               MBS_RTU_Task
    233          *
    234          * Note(s)     : none.
    235          *********************************************************************************************************
    236          */
    237          
    238          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    239          CPU_BOOLEAN  MBS_FCxx_Handler (MODBUS_CH  *pch)
    240          {
   \                     MBS_FCxx_Handler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    241              CPU_BOOLEAN   send_reply;
    242          
    243          
    244              if ((MBS_RX_FRAME_ADDR == pch->NodeAddr) ||       /* Proper node address? (i.e. Is this message for us?)   */
    245                  (MBS_RX_FRAME_ADDR == 0) ||                   /* ... or a 'broadcast' address?                         */
    246                  (MBS_RX_FRAME_ADDR == MB_getPseudo( ) ) ) {
   \   00000004   0xF894 0x1444      LDRB     R1,[R4, #+1092]
   \   00000008   0x7A22             LDRB     R2,[R4, #+8]
   \   0000000A   0x4291             CMP      R1,R2
   \   0000000C   0xD00F             BEQ.N    ??MBS_FCxx_Handler_0
   \   0000000E   0xF894 0x1444      LDRB     R1,[R4, #+1092]
   \   00000012   0x2900             CMP      R1,#+0
   \   00000014   0xD00B             BEQ.N    ??MBS_FCxx_Handler_0
   \   00000016   0xF894 0x1444      LDRB     R1,[R4, #+1092]
   \   0000001A   0xF894 0x2446      LDRB     R2,[R4, #+1094]
   \   0000001E   0xF894 0x3445      LDRB     R3,[R4, #+1093]
   \   00000022   0xEB12 0x2203      ADDS     R2,R2,R3, LSL #+8
   \   00000026   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000028   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000002A   0x4291             CMP      R1,R2
   \   0000002C   0xD15B             BNE.N    ??MBS_FCxx_Handler_1
    247                  pch->StatSlaveMsgCtr++;
   \                     ??MBS_FCxx_Handler_0: (+1)
   \   0000002E   0x8CA0             LDRH     R0,[R4, #+36]
   \   00000030   0x1C40             ADDS     R0,R0,#+1
   \   00000032   0x84A0             STRH     R0,[R4, #+36]
    248                  //COM_incDiaCtr(COM_PACKETSTOUNIT);
    249          
    250                  switch (MBS_RX_FRAME_FC) {                           /* Handle the function requested in the frame.           */
   \   00000034   0xF894 0x0445      LDRB     R0,[R4, #+1093]
   \   00000038   0x2801             CMP      R0,#+1
   \   0000003A   0xD010             BEQ.N    ??MBS_FCxx_Handler_2
   \   0000003C   0x2803             CMP      R0,#+3
   \   0000003E   0xD012             BEQ.N    ??MBS_FCxx_Handler_3
   \   00000040   0x2805             CMP      R0,#+5
   \   00000042   0xD014             BEQ.N    ??MBS_FCxx_Handler_4
   \   00000044   0x2806             CMP      R0,#+6
   \   00000046   0xD01B             BEQ.N    ??MBS_FCxx_Handler_5
   \   00000048   0x2808             CMP      R0,#+8
   \   0000004A   0xD022             BEQ.N    ??MBS_FCxx_Handler_6
   \   0000004C   0x280F             CMP      R0,#+15
   \   0000004E   0xD024             BEQ.N    ??MBS_FCxx_Handler_7
   \   00000050   0x2810             CMP      R0,#+16
   \   00000052   0xD02B             BEQ.N    ??MBS_FCxx_Handler_8
   \   00000054   0x2814             CMP      R0,#+20
   \   00000056   0xD032             BEQ.N    ??MBS_FCxx_Handler_9
   \   00000058   0x2815             CMP      R0,#+21
   \   0000005A   0xD034             BEQ.N    ??MBS_FCxx_Handler_10
   \   0000005C   0xE03C             B.N      ??MBS_FCxx_Handler_11
    251          #if (MODBUS_CFG_FC01_EN == DEF_ENABLED)
    252                      case MODBUS_FC01_COIL_RD:
    253                           send_reply = MBS_FC01_CoilRd(pch);
   \                     ??MBS_FCxx_Handler_2: (+1)
   \   0000005E   0x0020             MOVS     R0,R4
   \   00000060   0x.... 0x....      BL       MBS_FC01_CoilRd
    254                           break;
   \   00000064   0xE03F             B.N      ??MBS_FCxx_Handler_1
    255          #endif
    256          
    257          #if (MODBUS_CFG_FC02_EN == DEF_ENABLED)
    258                      case MODBUS_FC02_DI_RD:
    259                           send_reply = MBS_FC02_DIRd(pch);
    260                           break;
    261          #endif
    262          
    263          #if (MODBUS_CFG_FC03_EN == DEF_ENABLED)
    264                      case MODBUS_FC03_HOLDING_REG_RD:                 /* Process read output registers command.                   */
    265                           send_reply = MBS_FC03_HoldingRegRd(pch);
   \                     ??MBS_FCxx_Handler_3: (+1)
   \   00000066   0x0020             MOVS     R0,R4
   \   00000068   0x.... 0x....      BL       MBS_FC03_HoldingRegRd
    266                           break;
   \   0000006C   0xE03B             B.N      ??MBS_FCxx_Handler_1
    267          #endif
    268          
    269          #if (MODBUS_CFG_FC04_EN == DEF_ENABLED)
    270                      case MODBUS_FC04_IN_REG_RD:
    271                           send_reply = MBS_FC04_InRegRd(pch);
    272                           break;
    273          #endif
    274          
    275          #if (MODBUS_CFG_FC05_EN == DEF_ENABLED)
    276                      case MODBUS_FC05_COIL_WR:
    277                           if (pch->WrEn == DEF_TRUE) {
   \                     ??MBS_FCxx_Handler_4: (+1)
   \   0000006E   0x7860             LDRB     R0,[R4, #+1]
   \   00000070   0x2801             CMP      R0,#+1
   \   00000072   0xD103             BNE.N    ??MBS_FCxx_Handler_12
    278                               send_reply  = MBS_FC05_CoilWr(pch);
   \   00000074   0x0020             MOVS     R0,R4
   \   00000076   0x.... 0x....      BL       MBS_FC05_CoilWr
   \   0000007A   0xE000             B.N      ??MBS_FCxx_Handler_13
    279                           } else {
    280                               send_reply  = DEF_FALSE;
   \                     ??MBS_FCxx_Handler_12: (+1)
   \   0000007C   0x2000             MOVS     R0,#+0
    281                           }
    282                           break;
   \                     ??MBS_FCxx_Handler_13: (+1)
   \   0000007E   0xE032             B.N      ??MBS_FCxx_Handler_1
    283          #endif
    284          
    285          #if (MODBUS_CFG_FC06_EN == DEF_ENABLED)
    286                      case MODBUS_FC06_HOLDING_REG_WR:
    287                           if (pch->WrEn == DEF_TRUE) {
   \                     ??MBS_FCxx_Handler_5: (+1)
   \   00000080   0x7860             LDRB     R0,[R4, #+1]
   \   00000082   0x2801             CMP      R0,#+1
   \   00000084   0xD103             BNE.N    ??MBS_FCxx_Handler_14
    288                               send_reply  = MBS_FC06_HoldingRegWr(pch);
   \   00000086   0x0020             MOVS     R0,R4
   \   00000088   0x.... 0x....      BL       MBS_FC06_HoldingRegWr
   \   0000008C   0xE000             B.N      ??MBS_FCxx_Handler_15
    289                           } else {
    290                               send_reply  = DEF_FALSE;
   \                     ??MBS_FCxx_Handler_14: (+1)
   \   0000008E   0x2000             MOVS     R0,#+0
    291                           }
    292                           break;
   \                     ??MBS_FCxx_Handler_15: (+1)
   \   00000090   0xE029             B.N      ??MBS_FCxx_Handler_1
    293          #endif
    294          
    295          #if (MODBUS_CFG_FC08_EN == DEF_ENABLED)
    296                      case MODBUS_FC08_LOOPBACK:
    297                           send_reply = MBS_FC08_Loopback(pch);        /* Process loopback command.                                */
   \                     ??MBS_FCxx_Handler_6: (+1)
   \   00000092   0x0020             MOVS     R0,R4
   \   00000094   0x.... 0x....      BL       MBS_FC08_Loopback
    298                           break;
   \   00000098   0xE025             B.N      ??MBS_FCxx_Handler_1
    299          #endif
    300          
    301          #if (MODBUS_CFG_FC15_EN == DEF_ENABLED)
    302                      case MODBUS_FC15_COIL_WR_MULTIPLE:
    303                           if (pch->WrEn == DEF_TRUE) {
   \                     ??MBS_FCxx_Handler_7: (+1)
   \   0000009A   0x7860             LDRB     R0,[R4, #+1]
   \   0000009C   0x2801             CMP      R0,#+1
   \   0000009E   0xD103             BNE.N    ??MBS_FCxx_Handler_16
    304                               send_reply  = MBS_FC15_CoilWrMultiple(pch);
   \   000000A0   0x0020             MOVS     R0,R4
   \   000000A2   0x.... 0x....      BL       MBS_FC15_CoilWrMultiple
   \   000000A6   0xE000             B.N      ??MBS_FCxx_Handler_17
    305                           } else {
    306                               send_reply  = DEF_FALSE;
   \                     ??MBS_FCxx_Handler_16: (+1)
   \   000000A8   0x2000             MOVS     R0,#+0
    307                           }
    308                           break;
   \                     ??MBS_FCxx_Handler_17: (+1)
   \   000000AA   0xE01C             B.N      ??MBS_FCxx_Handler_1
    309          #endif
    310          
    311          #if (MODBUS_CFG_FC16_EN == DEF_ENABLED)
    312                      case MODBUS_FC16_HOLDING_REG_WR_MULTIPLE:
    313                           if (pch->WrEn == DEF_TRUE) {
   \                     ??MBS_FCxx_Handler_8: (+1)
   \   000000AC   0x7860             LDRB     R0,[R4, #+1]
   \   000000AE   0x2801             CMP      R0,#+1
   \   000000B0   0xD103             BNE.N    ??MBS_FCxx_Handler_18
    314                               send_reply  = MBS_FC16_HoldingRegWrMultiple(pch);
   \   000000B2   0x0020             MOVS     R0,R4
   \   000000B4   0x.... 0x....      BL       MBS_FC16_HoldingRegWrMultiple
   \   000000B8   0xE000             B.N      ??MBS_FCxx_Handler_19
    315                           } else {
    316                               send_reply  = DEF_FALSE;
   \                     ??MBS_FCxx_Handler_18: (+1)
   \   000000BA   0x2000             MOVS     R0,#+0
    317                           }
    318                           break;
   \                     ??MBS_FCxx_Handler_19: (+1)
   \   000000BC   0xE013             B.N      ??MBS_FCxx_Handler_1
    319          #endif
    320          
    321          #if (MODBUS_CFG_FC20_EN == DEF_ENABLED)
    322                      case MODBUS_FC20_FILE_RD:
    323                           send_reply  = MBS_FC20_FileRd(pch);
   \                     ??MBS_FCxx_Handler_9: (+1)
   \   000000BE   0x0020             MOVS     R0,R4
   \   000000C0   0x.... 0x....      BL       MBS_FC20_FileRd
    324                           break;
   \   000000C4   0xE00F             B.N      ??MBS_FCxx_Handler_1
    325          #endif
    326          
    327          #if (MODBUS_CFG_FC21_EN == DEF_ENABLED)
    328                      case MODBUS_FC21_FILE_WR:
    329                           if (pch->WrEn == DEF_TRUE) {
   \                     ??MBS_FCxx_Handler_10: (+1)
   \   000000C6   0x7860             LDRB     R0,[R4, #+1]
   \   000000C8   0x2801             CMP      R0,#+1
   \   000000CA   0xD103             BNE.N    ??MBS_FCxx_Handler_20
    330                               send_reply = MBS_FC21_FileWr(pch);
   \   000000CC   0x0020             MOVS     R0,R4
   \   000000CE   0x.... 0x....      BL       MBS_FC21_FileWr
   \   000000D2   0xE000             B.N      ??MBS_FCxx_Handler_21
    331                           } else {
    332                               send_reply = DEF_FALSE;
   \                     ??MBS_FCxx_Handler_20: (+1)
   \   000000D4   0x2000             MOVS     R0,#+0
    333                           }
    334                           break;
   \                     ??MBS_FCxx_Handler_21: (+1)
   \   000000D6   0xE006             B.N      ??MBS_FCxx_Handler_1
    335          #endif
    336          
    337          #if MODBUS_FC43_EN > 0 // Read Device ID
    338                     case MODBUS_FC43_READ_DEV_ID:
    339                        send_reply  = MBS_FC43_readDeviceID(pch);
    340                      break;
    341          #endif
    342          
    343          #if MODBUS_FC100_EN > 0 // Scattered Read
    344                      case MODBUS_FC100_SCATTERED_READ:
    345                         send_reply = MBS_FC100_scatteredRead(pch);
    346                      break;
    347          #endif
    348          
    349                      default:                                         /* Function code not implemented, set error response. */
    350                           pch->Err   = MODBUS_ERR_ILLEGAL_FC;
   \                     ??MBS_FCxx_Handler_11: (+1)
   \   000000D8   0x2001             MOVS     R0,#+1
   \   000000DA   0x82E0             STRH     R0,[R4, #+22]
    351                           MBS_ErrRespSet(pch,
    352                                          MODBUS_ERR_ILLEGAL_FC);
   \   000000DC   0x2101             MOVS     R1,#+1
   \   000000DE   0x0020             MOVS     R0,R4
   \   000000E0   0x.... 0x....      BL       MBS_ErrRespSet
    353                           //COM_incDiaCtr(COM_ILLEGALOPCODE);
    354                           send_reply = DEF_TRUE;
   \   000000E4   0x2001             MOVS     R0,#+1
    355                           break;
    356                  }
    357              }
    358              else
    359              {
    360                 //COM_incDiaCtr( COM_PACKETSTOOTHERS );
    361              }
    362          
    363              if (MBS_RX_FRAME_ADDR == 0 ||
    364                  (MBS_RX_FRAME_ADDR == MB_getPseudo ( ) ) ) {     /* Was the command received a 'broadcast'?   */
   \                     ??MBS_FCxx_Handler_1: (+1)
   \   000000E6   0xF894 0x1444      LDRB     R1,[R4, #+1092]
   \   000000EA   0x2900             CMP      R1,#+0
   \   000000EC   0xD00B             BEQ.N    ??MBS_FCxx_Handler_22
   \   000000EE   0xF894 0x1444      LDRB     R1,[R4, #+1092]
   \   000000F2   0xF894 0x2446      LDRB     R2,[R4, #+1094]
   \   000000F6   0xF894 0x3445      LDRB     R3,[R4, #+1093]
   \   000000FA   0xEB12 0x2203      ADDS     R2,R2,R3, LSL #+8
   \   000000FE   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000100   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000102   0x4291             CMP      R1,R2
   \   00000104   0xD101             BNE.N    ??MBS_FCxx_Handler_23
    365                  return (DEF_FALSE);                              /* Yes, don't reply                           */
   \                     ??MBS_FCxx_Handler_22: (+1)
   \   00000106   0x2000             MOVS     R0,#+0
   \   00000108   0xE000             B.N      ??MBS_FCxx_Handler_24
    366              } else {
    367                  return (send_reply);                             /* No,  reply according to the outcome of the command    */
   \                     ??MBS_FCxx_Handler_23: (+1)
   \   0000010A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??MBS_FCxx_Handler_24: (+1)
   \   0000010C   0xBD10             POP      {R4,PC}          ;; return
    368              }
    369          }
    370          #endif
    371          
    372          /*$PAGE*/
    373          /*
    374          *********************************************************************************************************
    375          *                                           MBS_FC01_CoilRd()
    376          *
    377          * Description : Responds to a request to read the status of any number of coils.
    378          *
    379          * Argument(s) : pch       Is a pointer to the Modbus channel's data structure.
    380          *
    381          * Return(s)   : DEF_TRUE      If a response needs to be sent
    382          *               DEF_FALSE     If not
    383          *
    384          * Caller(s)   : MBS_FCxx_Handler()
    385          *
    386          * Note(s)     : none
    387          *********************************************************************************************************
    388          */
    389          
    390          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED)
    391          #if (MODBUS_CFG_FC01_EN  == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    392          static  CPU_BOOLEAN  MBS_FC01_CoilRd (MODBUS_CH  *pch)
    393          {
   \                     MBS_FC01_CoilRd: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
    394              CPU_INT08U     *presp;
    395              CPU_INT16U      coil;
    396              CPU_BOOLEAN     coil_val;
    397              CPU_INT16U      err;
    398              CPU_INT16U      nbr_coils;
    399              CPU_INT16U      nbr_bytes;
    400              CPU_INT08U      bit_mask;
    401              CPU_INT16U      ix;
    402          
    403          
    404              if (pch->RxFrameNDataBytes != 4) {                           /* 4 data bytes for this message.                           */
   \   00000006   0xF8B4 0x0644      LDRH     R0,[R4, #+1604]
   \   0000000A   0x2804             CMP      R0,#+4
   \   0000000C   0xD001             BEQ.N    ??MBS_FC01_CoilRd_0
    405                  return (DEF_FALSE);                                      /* Tell caller that we DON'T need to send a response        */
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xE076             B.N      ??MBS_FC01_CoilRd_1
    406              }
    407              coil      = MBS_RX_DATA_START;                               /* Get the starting address of the desired coils            */
   \                     ??MBS_FC01_CoilRd_0: (+1)
   \   00000012   0xF894 0x0446      LDRB     R0,[R4, #+1094]
   \   00000016   0xF894 0x1447      LDRB     R1,[R4, #+1095]
   \   0000001A   0xEB11 0x2500      ADDS     R5,R1,R0, LSL #+8
    408              nbr_coils = MBS_RX_DATA_POINTS;                              /* Find out how many coils                                  */
   \   0000001E   0xF894 0x0448      LDRB     R0,[R4, #+1096]
   \   00000022   0xF894 0x1449      LDRB     R1,[R4, #+1097]
   \   00000026   0xEB11 0x2600      ADDS     R6,R1,R0, LSL #+8
    409              if (nbr_coils == 0 || nbr_coils > 2000) {                    /* Make sure we don't exceed the allowed limit per request  */
   \   0000002A   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000002C   0x2E00             CMP      R6,#+0
   \   0000002E   0xD003             BEQ.N    ??MBS_FC01_CoilRd_2
   \   00000030   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000032   0xF5B6 0x6FFA      CMP      R6,#+2000
   \   00000036   0xDD07             BLE.N    ??MBS_FC01_CoilRd_3
    410                  pch->Err = MODBUS_ERR_FC01_01;
   \                     ??MBS_FC01_CoilRd_2: (+1)
   \   00000038   0x2065             MOVS     R0,#+101
   \   0000003A   0x82E0             STRH     R0,[R4, #+22]
    411                  MBS_ErrRespSet(pch,
    412                                 MODBUS_ERR_ILLEGAL_DATA_QTY);
   \   0000003C   0x2103             MOVS     R1,#+3
   \   0000003E   0x0020             MOVS     R0,R4
   \   00000040   0x.... 0x....      BL       MBS_ErrRespSet
    413                  return (DEF_TRUE);                                       /* Tell caller that we need to send a response              */
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0xE05B             B.N      ??MBS_FC01_CoilRd_1
    414              }
    415              nbr_bytes              = ((nbr_coils - 1) / 8) + 1;          /* Find #bytes needed for response.                         */
   \                     ??MBS_FC01_CoilRd_3: (+1)
   \   00000048   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000004A   0x1E70             SUBS     R0,R6,#+1
   \   0000004C   0x2108             MOVS     R1,#+8
   \   0000004E   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000052   0x1C40             ADDS     R0,R0,#+1
    416              pch->TxFrameNDataBytes = nbr_bytes + 1;                      /* Number of data bytes + byte count.                       */
   \   00000054   0x1C41             ADDS     R1,R0,#+1
   \   00000056   0xF8A4 0x184E      STRH     R1,[R4, #+2126]
    417              presp                  = &pch->TxFrameData[0];               /* Clear bytes in response                                  */
   \   0000005A   0xF204 0x674E      ADDW     R7,R4,#+1614
    418              for (ix = 0; ix < (nbr_bytes + 3); ix++) {
   \   0000005E   0xF05F 0x0800      MOVS     R8,#+0
   \   00000062   0xE004             B.N      ??MBS_FC01_CoilRd_4
    419                  *presp++ = 0x00;
   \                     ??MBS_FC01_CoilRd_5: (+1)
   \   00000064   0x2100             MOVS     R1,#+0
   \   00000066   0x7039             STRB     R1,[R7, #+0]
   \   00000068   0x1C7F             ADDS     R7,R7,#+1
    420              }
   \   0000006A   0xF118 0x0801      ADDS     R8,R8,#+1
   \                     ??MBS_FC01_CoilRd_4: (+1)
   \   0000006E   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000072   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000074   0x1CC1             ADDS     R1,R0,#+3
   \   00000076   0x4588             CMP      R8,R1
   \   00000078   0xDBF4             BLT.N    ??MBS_FC01_CoilRd_5
    421              bit_mask = 0x01;                                             /* Start with bit 0 in response byte data mask.             */
   \   0000007A   0xF05F 0x0901      MOVS     R9,#+1
    422              ix       =    0;                                             /* Initialize loop counter.                                 */
   \   0000007E   0xF05F 0x0800      MOVS     R8,#+0
    423              presp    = &pch->TxFrameData[0];                             /* Reset the pointer to the start of the response           */
   \   00000082   0xF204 0x674E      ADDW     R7,R4,#+1614
    424              *presp++ = MBS_RX_FRAME_ADDR;                                /* Prepare response packet                                  */
   \   00000086   0xF894 0x1444      LDRB     R1,[R4, #+1092]
   \   0000008A   0x7039             STRB     R1,[R7, #+0]
   \   0000008C   0x1C7F             ADDS     R7,R7,#+1
    425              *presp++ = MBS_RX_FRAME_FC;
   \   0000008E   0xF894 0x1445      LDRB     R1,[R4, #+1093]
   \   00000092   0x7039             STRB     R1,[R7, #+0]
   \   00000094   0x1C7F             ADDS     R7,R7,#+1
    426              *presp++ = (CPU_INT08U)nbr_bytes;                            /* Set number of data bytes in response message.            */
   \   00000096   0x7038             STRB     R0,[R7, #+0]
   \   00000098   0x1C7F             ADDS     R7,R7,#+1
   \   0000009A   0xE001             B.N      ??MBS_FC01_CoilRd_6
    427              while (ix < nbr_coils) {                                     /* Loop through each COIL requested.                        */
    428                  coil_val = MB_CoilRd(coil,                               /* Get the current value of the coil                        */
    429                                       &err);
    430                  switch (err) {
    431                      case MODBUS_ERR_NONE:
    432                           if (coil_val == MODBUS_COIL_ON) {               /* Only set data response bit if COIL is on.                */
    433                               *presp |= bit_mask;
    434                           }
    435                           coil++;
    436                           ix++;                                           /* Increment COIL counter.                                  */
    437                           if ((ix % 8) == 0) {                            /* Determine if 8 data bits have been filled.               */
    438                               bit_mask   = 0x01;                          /* Reset the data mask.                                     */
    439                               presp++;                                    /* Increment data frame index.                              */
    440                           } else {                                        /* Still in same data byte, so                              */
    441                               bit_mask <<= 1;                             /* Shift the data mask to the next higher bit position.     */
   \                     ??MBS_FC01_CoilRd_7: (+1)
   \   0000009C   0xEA5F 0x0949      LSLS     R9,R9,#+1
    442                           }
    443                           break;
   \                     ??MBS_FC01_CoilRd_8: (+1)
   \                     ??MBS_FC01_CoilRd_6: (+1)
   \   000000A0   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000000A4   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000A6   0x45B0             CMP      R8,R6
   \   000000A8   0xD227             BCS.N    ??MBS_FC01_CoilRd_9
   \   000000AA   0x4669             MOV      R1,SP
   \   000000AC   0x0028             MOVS     R0,R5
   \   000000AE   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000B0   0x.... 0x....      BL       MB_CoilRd
   \   000000B4   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   \   000000B8   0x2900             CMP      R1,#+0
   \   000000BA   0xD116             BNE.N    ??MBS_FC01_CoilRd_10
   \   000000BC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000BE   0x2801             CMP      R0,#+1
   \   000000C0   0xD103             BNE.N    ??MBS_FC01_CoilRd_11
   \   000000C2   0x7838             LDRB     R0,[R7, #+0]
   \   000000C4   0xEA59 0x0000      ORRS     R0,R9,R0
   \   000000C8   0x7038             STRB     R0,[R7, #+0]
   \                     ??MBS_FC01_CoilRd_11: (+1)
   \   000000CA   0x1C6D             ADDS     R5,R5,#+1
   \   000000CC   0xF118 0x0801      ADDS     R8,R8,#+1
   \   000000D0   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000000D4   0x2008             MOVS     R0,#+8
   \   000000D6   0xFB98 0xF1F0      SDIV     R1,R8,R0
   \   000000DA   0xFB01 0x8110      MLS      R1,R1,R0,R8
   \   000000DE   0x2900             CMP      R1,#+0
   \   000000E0   0xD1DC             BNE.N    ??MBS_FC01_CoilRd_7
   \   000000E2   0xF05F 0x0901      MOVS     R9,#+1
   \   000000E6   0x1C7F             ADDS     R7,R7,#+1
   \   000000E8   0xE7DA             B.N      ??MBS_FC01_CoilRd_8
    444          
    445                      case MODBUS_ERR_RANGE:
    446                      default:
    447                           pch->Err = MODBUS_ERR_FC01_02;
   \                     ??MBS_FC01_CoilRd_10: (+1)
   \   000000EA   0x2066             MOVS     R0,#+102
   \   000000EC   0x82E0             STRH     R0,[R4, #+22]
    448                           MBS_ErrRespSet(pch,
    449                                          MODBUS_ERR_ILLEGAL_DATA_ADDR);
   \   000000EE   0x2102             MOVS     R1,#+2
   \   000000F0   0x0020             MOVS     R0,R4
   \   000000F2   0x.... 0x....      BL       MBS_ErrRespSet
    450                           return (DEF_TRUE);                              /* Tell caller that we need to send a response              */
   \   000000F6   0x2001             MOVS     R0,#+1
   \   000000F8   0xE002             B.N      ??MBS_FC01_CoilRd_1
    451                  }
    452              }
    453              pch->Err = MODBUS_ERR_NONE;
   \                     ??MBS_FC01_CoilRd_9: (+1)
   \   000000FA   0x2000             MOVS     R0,#+0
   \   000000FC   0x82E0             STRH     R0,[R4, #+22]
    454              return (DEF_TRUE);                                           /* Tell caller that we need to send a response              */
   \   000000FE   0x2001             MOVS     R0,#+1
   \                     ??MBS_FC01_CoilRd_1: (+1)
   \   00000100   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    455          }
    456          #endif
    457          #endif
    458          
    459          /*$PAGE*/
    460          /*
    461          *********************************************************************************************************
    462          *                                            MBS_FC02_DIRd()
    463          *
    464          * Description : Responds to a request to read the status of any number of Discrete Inputs (DIs).
    465          *
    466          * Argument(s) : pch       Is a pointer to the Modbus channel's data structure.
    467          *
    468          * Return(s)   : DEF_TRUE      If a response needs to be sent
    469          *               DEF_FALSE     If not
    470          *
    471          * Caller(s)   : MBS_FCxx_Handler()
    472          *
    473          * Note(s)     : none
    474          *********************************************************************************************************
    475          */
    476          
    477          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED)
    478          #if (MODBUS_CFG_FC02_EN  == DEF_ENABLED)
    479          static  CPU_BOOLEAN  MBS_FC02_DIRd (MODBUS_CH  *pch)
    480          {
    481              CPU_INT08U     *presp;
    482              CPU_INT16U      di;
    483              CPU_BOOLEAN     di_val;
    484              CPU_INT16U      err;
    485              CPU_INT16U      nbr_di;
    486              CPU_INT16U      nbr_bytes;
    487              CPU_INT08U      bit_mask;
    488              CPU_INT16U      ix;
    489          
    490          
    491              if (pch->RxFrameNDataBytes != 4) {                           /* 4 data bytes for this message.                           */
    492                  return (DEF_FALSE);                                      /* Tell caller that we DON'T need to send a response        */
    493              }
    494              di     = MBS_RX_DATA_START;                                  /* Get the starting address of the desired DIs              */
    495              nbr_di = MBS_RX_DATA_POINTS;                                 /* Find out how many DIs                                    */
    496              if (nbr_di == 0 || nbr_di > 2000) {                          /* Make sure we don't exceed the allowed limit per request  */
    497                  pch->Err = MODBUS_ERR_FC02_01;
    498                  MBS_ErrRespSet(pch,
    499                                 MODBUS_ERR_ILLEGAL_DATA_QTY);
    500                  return (DEF_TRUE);                                       /* Tell caller that we need to send a response              */
    501              }
    502              nbr_bytes             = ((nbr_di - 1) / 8) + 1;              /* Find #bytes needed for response.                         */
    503              pch->TxFrameNDataBytes = nbr_bytes + 1;                      /* Number of data bytes + byte count.                       */
    504              presp                 = &pch->TxFrameData[0];                /* Clear bytes in response                                  */
    505              for (ix = 0; ix < (nbr_bytes + 3); ix++) {
    506                  *presp++ = 0x00;
    507              }
    508              bit_mask = 0x01;                                             /* Start with bit 0 in response byte data mask.             */
    509              ix       =    0;                                             /* Initialize loop counter.                                 */
    510              presp    = &pch->TxFrameData[0];                             /* Reset the pointer to the start of the response           */
    511              *presp++ =  MBS_RX_FRAME_ADDR;                               /* Prepare response packet                                  */
    512              *presp++ =  MBS_RX_FRAME_FC;
    513              *presp++ = (CPU_INT08U)nbr_bytes;                            /* Set number of data bytes in response message.            */
    514              while (ix < nbr_di) {                                        /* Loop through each DI requested.                          */
    515                  di_val = MB_DIRd(di,                                     /* Get the current value of the DI                          */
    516                                   &err);
    517                  switch (err) {
    518                      case MODBUS_ERR_NONE:
    519                           if (di_val == MODBUS_COIL_ON) {                 /* Only set data response bit if DI is on.                  */
    520                               *presp |= bit_mask;
    521                           }
    522                           di++;
    523                           ix++;                                           /* Increment DI counter.                                    */
    524                           if ((ix % 8) == 0) {                            /* Determine if 8 data bits have been filled.               */
    525                               bit_mask   = 0x01;                          /* Reset the data mask.                                     */
    526                               presp++;                                    /* Increment data frame index.                              */
    527                           } else {                                        /* Still in same data byte, so                              */
    528                               bit_mask <<= 1;                             /* Shift the data mask to the next higher bit position.     */
    529                           }
    530                           break;
    531          
    532                      case MODBUS_ERR_RANGE:
    533                      default:
    534                           pch->Err = MODBUS_ERR_FC02_02;
    535                           MBS_ErrRespSet(pch,
    536                                          MODBUS_ERR_ILLEGAL_DATA_ADDR);
    537                           return (DEF_TRUE);                              /* Tell caller that we need to send a response              */
    538                  }
    539              }
    540              pch->Err = MODBUS_ERR_NONE;
    541              return (DEF_TRUE);                                           /* Tell caller that we need to send a response              */
    542          }
    543          #endif
    544          #endif
    545          
    546          /*$PAGE*/
    547          /*
    548          *********************************************************************************************************
    549          *                                        MBS_FC03_HoldingRegRd()
    550          *
    551          * Description : Obtains the contents of the specified holding registers.
    552          *
    553          * Argument(s) : pch       Is a pointer to the Modbus channel's data structure.
    554          *
    555          * Return(s)   : DEF_TRUE      If a response needs to be sent
    556          *               DEF_FALSE     If not
    557          *
    558          * Caller(s)   : MBS_FCxx_Handler()
    559          *
    560          * Note(s)     : none
    561          *********************************************************************************************************
    562          */
    563          
    564          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED)
    565          #if (MODBUS_CFG_FC03_EN  == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    566          static  CPU_BOOLEAN  MBS_FC03_HoldingRegRd (MODBUS_CH  *pch)
    567          {
   \                     MBS_FC03_HoldingRegRd: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    568              CPU_INT08U    *presp;
    569              CPU_INT16U     err;
    570              CPU_INT16U     reg;
    571              CPU_INT16U     nbr_regs;
    572              CPU_INT16U     nbr_bytes;
    573              CPU_INT16U     reg_val_16;
    574          #if (MODBUS_CFG_FP_EN == DEF_ENABLED)
    575              CPU_INT08U     ix;
    576              CPU_FP32       reg_val_fp;
    577              CPU_INT08U    *pfp;
    578          #endif
    579          
    580          
    581              if (pch->RxFrameNDataBytes != 4) {                           /* Nbr of data bytes must be 4.                             */
   \   00000004   0xF8B4 0x0644      LDRH     R0,[R4, #+1604]
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xD001             BEQ.N    ??MBS_FC03_HoldingRegRd_0
    582                  return (DEF_FALSE);                                      /* Tell caller that we DON'T need to send a response        */
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xE053             B.N      ??MBS_FC03_HoldingRegRd_1
    583              }
    584              reg       = MBS_RX_DATA_START;
   \                     ??MBS_FC03_HoldingRegRd_0: (+1)
   \   00000010   0xF894 0x0446      LDRB     R0,[R4, #+1094]
   \   00000014   0xF894 0x1447      LDRB     R1,[R4, #+1095]
   \   00000018   0xEB11 0x2500      ADDS     R5,R1,R0, LSL #+8
    585              nbr_regs  = MBS_RX_DATA_POINTS;
   \   0000001C   0xF894 0x0448      LDRB     R0,[R4, #+1096]
   \   00000020   0xF894 0x1449      LDRB     R1,[R4, #+1097]
   \   00000024   0xEB11 0x2600      ADDS     R6,R1,R0, LSL #+8
    586              
    587          #if SE_MODBUS_CODE > 0
    588          
    589              MB_DATA_holdingRegRd(pch, &err);
    590              // will not get this error, responds with NA value if register does not exist
    591              if(err == MODBUS_ERR_RANGE)
    592              {
    593                 pch->Err = MODBUS_ERR_FC03_01;
    594                 MBS_ErrRespSet(pch, MODBUS_ERR_ILLEGAL_DATA_ADDR);
    595                 return (DEF_TRUE);
    596              }
    597              //pch->Err = MODBUS_ERR_NONE;
    598              //return (DEF_TRUE); 
    599          
    600          #else // ALL SE_MODBUS_CODE code above here
    601          #if (MODBUS_CFG_FP_EN == DEF_ENABLED)
    602              if (reg < MODBUS_CFG_FP_START_IX) {                          /* See if we want integer registers                         */
    603                  if (nbr_regs == 0 || nbr_regs > 125) {                   /* Make sure we don't exceed the allowed limit per request  */
    604                      pch->Err = MODBUS_ERR_FC03_03;
    605                      MBS_ErrRespSet(pch, 
    606                                     MODBUS_ERR_ILLEGAL_DATA_QTY);
    607                      return (DEF_TRUE);                                   /* Tell caller that we need to send a response              */
    608                  }
    609                  nbr_bytes = (CPU_INT08U)(nbr_regs * sizeof(CPU_INT16U)); /* Find #bytes needed for response.                         */
    610              } else {
    611                  if (nbr_regs == 0 || nbr_regs > 62) {                    /* Make sure we don't exceed the allowed limit per request  */
    612                      pch->Err = MODBUS_ERR_FC03_04;
    613                      MBS_ErrRespSet(pch, 
    614                                     MODBUS_ERR_ILLEGAL_DATA_QTY);
    615                      return (DEF_TRUE);                                   /* Tell caller that we need to send a response              */
    616                  }
    617                  nbr_bytes = (CPU_INT08U)(nbr_regs * sizeof(CPU_FP32));   /* Find #bytes needed for response.                         */
    618              }
    619          #else
    620              if (nbr_regs == 0 || nbr_regs > 125) {                       /* Make sure we don't exceed the allowed limit per request  */
   \   00000028   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000002A   0x2E00             CMP      R6,#+0
   \   0000002C   0xD002             BEQ.N    ??MBS_FC03_HoldingRegRd_2
   \   0000002E   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000030   0x2E7E             CMP      R6,#+126
   \   00000032   0xDB08             BLT.N    ??MBS_FC03_HoldingRegRd_3
    621                  pch->Err = MODBUS_ERR_FC03_03;                     
   \                     ??MBS_FC03_HoldingRegRd_2: (+1)
   \   00000034   0xF240 0x102F      MOVW     R0,#+303
   \   00000038   0x82E0             STRH     R0,[R4, #+22]
    622                  MBS_ErrRespSet(pch,                                
    623                                 MODBUS_ERR_ILLEGAL_DATA_QTY);       
   \   0000003A   0x2103             MOVS     R1,#+3
   \   0000003C   0x0020             MOVS     R0,R4
   \   0000003E   0x.... 0x....      BL       MBS_ErrRespSet
    624                  return (DEF_TRUE);                                       /* Tell caller that we need to send a response              */
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0xE038             B.N      ??MBS_FC03_HoldingRegRd_1
    625              }                                                      
    626              nbr_bytes = (CPU_INT08U)(nbr_regs * sizeof(CPU_INT16U));     /* Find #bytes needed for response.                         */
   \                     ??MBS_FC03_HoldingRegRd_3: (+1)
   \   00000046   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000048   0x0070             LSLS     R0,R6,#+1
   \   0000004A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
    627          #endif
    628              pch->TxFrameNDataBytes = nbr_bytes + 1;                      /* Number of data bytes + byte count.                       */
   \   0000004C   0x1C41             ADDS     R1,R0,#+1
   \   0000004E   0xF8A4 0x184E      STRH     R1,[R4, #+2126]
    629              presp                 = &pch->TxFrameData[0];                /* Reset the pointer to the start of the response           */
   \   00000052   0xF204 0x674E      ADDW     R7,R4,#+1614
    630              *presp++              =  MBS_RX_FRAME_ADDR;
   \   00000056   0xF894 0x1444      LDRB     R1,[R4, #+1092]
   \   0000005A   0x7039             STRB     R1,[R7, #+0]
   \   0000005C   0x1C7F             ADDS     R7,R7,#+1
    631              *presp++              =  MBS_RX_FRAME_FC;
   \   0000005E   0xF894 0x1445      LDRB     R1,[R4, #+1093]
   \   00000062   0x7039             STRB     R1,[R7, #+0]
   \   00000064   0x1C7F             ADDS     R7,R7,#+1
    632              *presp++              = (CPU_INT08U)nbr_bytes;               /* Set number of data bytes in response message             */
   \   00000066   0x7038             STRB     R0,[R7, #+0]
   \   00000068   0x1C7F             ADDS     R7,R7,#+1
   \   0000006A   0xE008             B.N      ??MBS_FC03_HoldingRegRd_4
    633              while (nbr_regs > 0) {                                       /* Loop through each register requested.                    */
    634                  if (reg < MODBUS_CFG_FP_START_IX) {                      /* See if we want an integer register                       */
    635                      reg_val_16 = MB_HoldingRegRd(reg,                    /* Yes, get its value                                       */
    636                                                   &err);             
    637                      switch (err) {
    638                          case MODBUS_ERR_NONE:
    639                               *presp++ = (CPU_INT08U)((reg_val_16 >> 8) & 0x00FF); /*      Get MSB first.                             */
   \                     ??MBS_FC03_HoldingRegRd_5: (+1)
   \   0000006C   0x0001             MOVS     R1,R0
   \   0000006E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000070   0x0A09             LSRS     R1,R1,#+8
   \   00000072   0x7039             STRB     R1,[R7, #+0]
   \   00000074   0x1C7F             ADDS     R7,R7,#+1
    640                               *presp++ = (CPU_INT08U)(reg_val_16 & 0x00FF);        /*      Get LSB next.                              */
   \   00000076   0x7038             STRB     R0,[R7, #+0]
   \   00000078   0x1C7F             ADDS     R7,R7,#+1
    641                               break;
    642          
    643                          case MODBUS_ERR_RANGE:
    644                          default:
    645                               pch->Err = MODBUS_ERR_FC03_01;
    646                               MBS_ErrRespSet(pch, 
    647                                              MODBUS_ERR_ILLEGAL_DATA_ADDR);
    648                               return (DEF_TRUE);
    649                      }
    650                  } else {
    651          #if (MODBUS_CFG_FP_EN == DEF_ENABLED)
    652                      reg_val_fp = MB_HoldingRegRdFP(reg,                  /* No,  get the value of the FP register                    */
    653                                                     &err);           
    654                      switch (err) {
    655                          case MODBUS_ERR_NONE:
    656                               pfp = (CPU_INT08U *)&reg_val_fp;            /* Point to the FP register                                 */
    657          #if (CPU_CFG_ENDIAN_TYPE == CPU_ENDIAN_TYPE_BIG)
    658                               for (ix = 0; ix < sizeof(CPU_FP32); ix++) { /* Copy value to response buffer                            */
    659                                   *presp++ = *pfp++;
    660                               }
    661          #else
    662                               pfp += sizeof(CPU_FP32) - 1;
    663                               for (ix = 0; ix < sizeof(CPU_FP32); ix++) {
    664                                   *presp++ = *pfp--;
    665                               }
    666          #endif
    667                               break;
    668          
    669                          case MODBUS_ERR_RANGE:
    670                          default:
    671                               pch->Err = MODBUS_ERR_FC03_02;
    672                               MBS_ErrRespSet(pch, 
    673                                              MODBUS_ERR_ILLEGAL_DATA_ADDR);
    674                               return (DEF_TRUE);
    675                      }
    676          #endif
    677                  }
    678                  reg++;                                                   /* Increment current register number                        */
   \                     ??MBS_FC03_HoldingRegRd_6: (+1)
   \   0000007A   0x1C6D             ADDS     R5,R5,#+1
    679                  nbr_regs--;
   \   0000007C   0x1E76             SUBS     R6,R6,#+1
   \                     ??MBS_FC03_HoldingRegRd_4: (+1)
   \   0000007E   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000080   0x2E00             CMP      R6,#+0
   \   00000082   0xD016             BEQ.N    ??MBS_FC03_HoldingRegRd_7
   \   00000084   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000086   0xF64F 0x70DC      MOVW     R0,#+65500
   \   0000008A   0x4285             CMP      R5,R0
   \   0000008C   0xDAF5             BGE.N    ??MBS_FC03_HoldingRegRd_6
   \   0000008E   0x4669             MOV      R1,SP
   \   00000090   0x0028             MOVS     R0,R5
   \   00000092   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000094   0x.... 0x....      BL       MB_HoldingRegRd
   \   00000098   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   \   0000009C   0x2900             CMP      R1,#+0
   \   0000009E   0xD0E5             BEQ.N    ??MBS_FC03_HoldingRegRd_5
   \   000000A0   0xF240 0x102D      MOVW     R0,#+301
   \   000000A4   0x82E0             STRH     R0,[R4, #+22]
   \   000000A6   0x2102             MOVS     R1,#+2
   \   000000A8   0x0020             MOVS     R0,R4
   \   000000AA   0x.... 0x....      BL       MBS_ErrRespSet
   \   000000AE   0x2001             MOVS     R0,#+1
   \   000000B0   0xE002             B.N      ??MBS_FC03_HoldingRegRd_1
    680              }
    681          #endif //SE_MODBUS_CODE
    682              pch->Err = MODBUS_ERR_NONE;
   \                     ??MBS_FC03_HoldingRegRd_7: (+1)
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0x82E0             STRH     R0,[R4, #+22]
    683              return (DEF_TRUE);                                           /* Tell caller that we need to send a response              */
   \   000000B6   0x2001             MOVS     R0,#+1
   \                     ??MBS_FC03_HoldingRegRd_1: (+1)
   \   000000B8   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    684          }
    685          #endif
    686          #endif
    687          
    688          /*$PAGE*/
    689          /*
    690          *********************************************************************************************************
    691          *                                          MBS_FC04_InRegRd()
    692          *
    693          * Description : Obtains the contents of the specified input registers.
    694          *
    695          * Argument(s) : pch       Is a pointer to the Modbus channel's data structure.
    696          *
    697          * Return(s)   : DEF_TRUE      If a response needs to be sent
    698          *               DEF_FALSE     If not
    699          *
    700          * Caller(s)   : MBS_FCxx_Handler()
    701          *
    702          * Note(s)     : none
    703          *********************************************************************************************************
    704          */
    705          
    706          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED)
    707          #if (MODBUS_CFG_FC04_EN  == DEF_ENABLED)
    708          static  CPU_BOOLEAN  MBS_FC04_InRegRd (MODBUS_CH  *pch)
    709          {
    710              CPU_INT08U    *presp;
    711              CPU_INT16U     err;
    712              CPU_INT16U     reg;
    713              CPU_INT16U     nbr_regs;
    714              CPU_INT16U     nbr_bytes;
    715              CPU_INT16U     reg_val_16;
    716          #if (MODBUS_CFG_FP_EN == DEF_ENABLED)
    717              CPU_INT08U     ix;
    718              CPU_FP32       reg_val_fp;
    719              CPU_INT08U    *pfp;
    720          #endif
    721          
    722          
    723              if (pch->RxFrameNDataBytes != 4) {                           /* Nbr of data bytes must be 4.                             */
    724                  return (DEF_FALSE);                                      /* Tell caller that we DON'T need to send a response        */
    725              }
    726              reg       = MBS_RX_DATA_START;
    727              nbr_regs  = MBS_RX_DATA_POINTS;
    728          
    729          #if SE_MODBUS_CODE > 0
    730          
    731              MB_DATA_inRegRd(pch, &err);
    732          
    733              if(err == MODBUS_ERR_RANGE)
    734              {
    735                 pch->Err = MODBUS_ERR_FC04_01;
    736                 MBS_ErrRespSet(pch, MODBUS_ERR_ILLEGAL_DATA_ADDR);
    737                 return (DEF_TRUE);
    738              }
    739              pch->Err = MODBUS_ERR_NONE;
    740              return (DEF_TRUE);
    741          
    742          #else // ALL SE_MODBUS_CODE code above here
    743          #if (MODBUS_CFG_FP_EN == DEF_ENABLED)
    744              if (reg < MODBUS_CFG_FP_START_IX) {                          /* See if we want integer registers                         */
    745                  if (nbr_regs == 0 || nbr_regs > 125) {                   /* Make sure we don't exceed the allowed limit per request  */
    746                      pch->Err = MODBUS_ERR_FC04_03;
    747                      MBS_ErrRespSet(pch,
    748                                     MODBUS_ERR_ILLEGAL_DATA_QTY);
    749                      return (DEF_TRUE);                                   /* Tell caller that we need to send a response              */
    750                  }
    751                  nbr_bytes = (CPU_INT08U)(nbr_regs * sizeof(CPU_INT16U)); /* Find #bytes needed for response.                         */
    752              } else {
    753                  if (nbr_regs == 0 || nbr_regs > 62) {                    /* Make sure we don't exceed the allowed limit per request  */
    754                      pch->Err = MODBUS_ERR_FC04_04;
    755                      MBS_ErrRespSet(pch,
    756                                     MODBUS_ERR_ILLEGAL_DATA_QTY);
    757                      return (DEF_TRUE);                                   /* Tell caller that we need to send a response              */
    758                  }
    759                  nbr_bytes = (CPU_INT08U)(nbr_regs * sizeof(CPU_FP32));   /* Find #bytes needed for response.                         */
    760              }
    761          #else
    762              if (nbr_regs == 0 || nbr_regs > 125) {                       /* Make sure we don't exceed the allowed limit per request  */
    763                  pch->Err = MODBUS_ERR_FC04_03;
    764                  MBS_ErrRespSet(pch,
    765                                 MODBUS_ERR_ILLEGAL_DATA_QTY);
    766                  return (DEF_TRUE);                                       /* Tell caller that we need to send a response              */
    767              }
    768              nbr_bytes = (CPU_INT08U)(nbr_regs * sizeof(CPU_INT16U));     /* Find #bytes needed for response.                         */
    769          #endif
    770              pch->TxFrameNDataBytes = nbr_bytes + 1;                      /* Number of data bytes + byte count.                       */
    771              presp                 = &pch->TxFrameData[0];                /* Reset the pointer to the start of the response           */
    772              *presp++              =  MBS_RX_FRAME_ADDR;                  /* Prepare response packet                                  */
    773              *presp++              =  MBS_RX_FRAME_FC;
    774              *presp++              = (CPU_INT08U)nbr_bytes;               /* Set number of data bytes in response message             */
    775              while (nbr_regs > 0) {                                       /* Loop through each register requested.                    */
    776                  if (reg < MODBUS_CFG_FP_START_IX) {                      /* See if we want an integer register                       */
    777                      reg_val_16 = MB_InRegRd(reg,                         /* Yes, get its value                                       */
    778                                              &err);
    779                      switch (err) {
    780                          case MODBUS_ERR_NONE:
    781                               *presp++ = (CPU_INT08U)((reg_val_16 >> 8) & 0x00FF); /*      Get MSB first.                             */
    782                               *presp++ = (CPU_INT08U)(reg_val_16 & 0x00FF);        /*      Get LSB next.                              */
    783                               break;
    784          
    785                          case MODBUS_ERR_RANGE:
    786                          default:
    787                               pch->Err = MODBUS_ERR_FC04_01;
    788                               MBS_ErrRespSet(pch,
    789                                              MODBUS_ERR_ILLEGAL_DATA_ADDR);
    790                               return (DEF_TRUE);
    791                      }
    792                  } else {
    793          #if (MODBUS_CFG_FP_EN == DEF_ENABLED)
    794                      reg_val_fp = MB_InRegRdFP(reg,                       /* No,  get the value of the FP register                    */
    795                                                &err);
    796                      switch (err) {
    797                          case MODBUS_ERR_NONE:
    798                               pfp = (CPU_INT08U *)&reg_val_fp;            /* Point to the FP register                                 */
    799          #if CPU_CFG_ENDIAN_TYPE == CPU_ENDIAN_TYPE_BIG
    800                               for (ix = 0; ix < sizeof(CPU_FP32); ix++) { /* Copy value to response buffer                            */
    801                                   *presp++ = *pfp++;
    802                               }
    803          #else
    804                               pfp += sizeof(CPU_FP32) - 1;
    805                               for (ix = 0; ix < sizeof(CPU_FP32); ix++) {
    806                                   *presp++ = *pfp--;
    807                               }
    808          #endif
    809                               break;
    810          
    811                          case MODBUS_ERR_RANGE:
    812                          default:
    813                               pch->Err = MODBUS_ERR_FC04_02;
    814                               MBS_ErrRespSet(pch,
    815                                              MODBUS_ERR_ILLEGAL_DATA_ADDR);
    816                               return (DEF_TRUE);
    817                      }
    818          #endif
    819                  }
    820                  reg++;                                                   /* Increment current register number                        */
    821                  nbr_regs--;
    822              }
    823          #endif //SE_MODBUS_CODE
    824              pch->Err = MODBUS_ERR_NONE;
    825              return (DEF_TRUE);                                           /* Tell caller that we need to send a response              */
    826          }
    827          #endif
    828          #endif
    829          
    830          /*$PAGE*/
    831          /*
    832          *********************************************************************************************************
    833          *                                           MBS_FC05_CoilWr()
    834          *
    835          * Description : Responds to a request to force a coil to a specified state.
    836          *
    837          * Argument(s) : pch       Is a pointer to the Modbus channel's data structure.
    838          *
    839          * Return(s)   : DEF_TRUE      If a response needs to be sent
    840          *               DEF_FALSE     If not
    841          *
    842          * Caller(s)   : MBS_FCxx_Handler()
    843          *
    844          * Note(s)     : none
    845          *********************************************************************************************************
    846          */
    847          
    848          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED)
    849          #if (MODBUS_CFG_FC05_EN  == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    850          static  CPU_BOOLEAN  MBS_FC05_CoilWr (MODBUS_CH  *pch)
    851          {
   \                     MBS_FC05_CoilWr: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    852              CPU_INT08U     *prx_data;
    853              CPU_INT08U     *ptx_data;
    854              CPU_INT08U      i;
    855              CPU_INT16U      coil;
    856              CPU_BOOLEAN     coil_val;
    857              CPU_INT16U      temp;
    858              CPU_INT16U      err;
    859          
    860          
    861              if (pch->RxFrameNDataBytes != 4) {                           /* Nbr of data bytes must be 4.                             */
   \   00000006   0xF8B4 0x0644      LDRH     R0,[R4, #+1604]
   \   0000000A   0x2804             CMP      R0,#+4
   \   0000000C   0xD001             BEQ.N    ??MBS_FC05_CoilWr_0
    862                  return (DEF_FALSE);                                      /* Tell caller that we DON'T need to send a response        */
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xE04C             B.N      ??MBS_FC05_CoilWr_1
    863              }
    864              coil = MBS_RX_DATA_START;                                    /* Get the desired coil number                              */
   \                     ??MBS_FC05_CoilWr_0: (+1)
   \   00000012   0xF894 0x0446      LDRB     R0,[R4, #+1094]
   \   00000016   0xF894 0x1447      LDRB     R1,[R4, #+1095]
   \   0000001A   0xEB11 0x2000      ADDS     R0,R1,R0, LSL #+8
    865              temp = MBS_RX_DATA_COIL;
   \   0000001E   0xF894 0x1448      LDRB     R1,[R4, #+1096]
   \   00000022   0xF894 0x2449      LDRB     R2,[R4, #+1097]
   \   00000026   0xEB12 0x2101      ADDS     R1,R2,R1, LSL #+8
    866              if (pch->WrEn == DEF_TRUE) {
   \   0000002A   0x7862             LDRB     R2,[R4, #+1]
   \   0000002C   0x2A01             CMP      R2,#+1
   \   0000002E   0xD11A             BNE.N    ??MBS_FC05_CoilWr_2
    867                  if (temp == MODBUS_COIL_OFF_CODE) {                      /* See if coil needs to be OFF?                             */
   \   00000030   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000032   0x2900             CMP      R1,#+0
   \   00000034   0xD101             BNE.N    ??MBS_FC05_CoilWr_3
    868                      coil_val = 0;                                        /* Yes, Turn coil OFF                                       */
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0xE000             B.N      ??MBS_FC05_CoilWr_4
    869                  } else {
    870                      coil_val = 1;                                        /* No,  Turn coil ON                                        */
   \                     ??MBS_FC05_CoilWr_3: (+1)
   \   0000003A   0x2101             MOVS     R1,#+1
    871                  }
    872                  MB_CoilWr(coil,                                          /* Force coil                                               */
    873                            coil_val,
    874                            &err);
   \                     ??MBS_FC05_CoilWr_4: (+1)
   \   0000003C   0x466A             MOV      R2,SP
   \   0000003E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000040   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000042   0x.... 0x....      BL       MB_CoilWr
    875                  switch (err) {
   \   00000046   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD103             BNE.N    ??MBS_FC05_CoilWr_5
    876                      case MODBUS_ERR_NONE:                                /* We simply echoe back with the command received           */
    877                           pch->WrCtr++;
   \   0000004E   0x6860             LDR      R0,[R4, #+4]
   \   00000050   0x1C40             ADDS     R0,R0,#+1
   \   00000052   0x6060             STR      R0,[R4, #+4]
    878                           break;
   \   00000054   0xE00E             B.N      ??MBS_FC05_CoilWr_6
    879          
    880                      case MODBUS_ERR_RANGE:
    881                      default:
    882                           pch->Err = MODBUS_ERR_FC05_01;
   \                     ??MBS_FC05_CoilWr_5: (+1)
   \   00000056   0xF240 0x10F5      MOVW     R0,#+501
   \   0000005A   0x82E0             STRH     R0,[R4, #+22]
    883                           MBS_ErrRespSet(pch,
    884                                          MODBUS_ERR_ILLEGAL_DATA_ADDR);
   \   0000005C   0x2102             MOVS     R1,#+2
   \   0000005E   0x0020             MOVS     R0,R4
   \   00000060   0x.... 0x....      BL       MBS_ErrRespSet
    885                           break;
   \   00000064   0xE006             B.N      ??MBS_FC05_CoilWr_6
    886                  }
    887              } else {
    888                  pch->Err = MODBUS_ERR_FC05_02;
   \                     ??MBS_FC05_CoilWr_2: (+1)
   \   00000066   0xF44F 0x70FB      MOV      R0,#+502
   \   0000006A   0x82E0             STRH     R0,[R4, #+22]
    889                  MBS_ErrRespSet(pch,                                      /* Writes are not enabled                                   */
    890                                 MODBUS_ERR_ILLEGAL_DATA_VAL);
   \   0000006C   0x2104             MOVS     R1,#+4
   \   0000006E   0x0020             MOVS     R0,R4
   \   00000070   0x.... 0x....      BL       MBS_ErrRespSet
    891              }
    892              pch->TxFrameNDataBytes = 4;
   \                     ??MBS_FC05_CoilWr_6: (+1)
   \   00000074   0x2004             MOVS     R0,#+4
   \   00000076   0xF8A4 0x084E      STRH     R0,[R4, #+2126]
    893              MBS_TX_FRAME_ADDR = MBS_RX_FRAME_ADDR;                       /* Prepare response packet                                  */
   \   0000007A   0xF894 0x0444      LDRB     R0,[R4, #+1092]
   \   0000007E   0xF884 0x064E      STRB     R0,[R4, #+1614]
    894              MBS_TX_FRAME_FC   = MBS_RX_FRAME_FC;
   \   00000082   0xF894 0x0445      LDRB     R0,[R4, #+1093]
   \   00000086   0xF884 0x064F      STRB     R0,[R4, #+1615]
    895              prx_data          = &pch->RxFrameData[2];                    /* Copy four data bytes from the receive packet             */
   \   0000008A   0xF204 0x4046      ADDW     R0,R4,#+1094
    896              ptx_data          = &pch->TxFrameData[2];
   \   0000008E   0xF514 0x61CA      ADDS     R1,R4,#+1616
    897              for (i = 0; i < 4; i++) {
   \   00000092   0x2200             MOVS     R2,#+0
   \   00000094   0xE004             B.N      ??MBS_FC05_CoilWr_7
    898                  *ptx_data++ = *prx_data++;
   \                     ??MBS_FC05_CoilWr_8: (+1)
   \   00000096   0x7803             LDRB     R3,[R0, #+0]
   \   00000098   0x700B             STRB     R3,[R1, #+0]
   \   0000009A   0x1C40             ADDS     R0,R0,#+1
   \   0000009C   0x1C49             ADDS     R1,R1,#+1
    899              }
   \   0000009E   0x1C52             ADDS     R2,R2,#+1
   \                     ??MBS_FC05_CoilWr_7: (+1)
   \   000000A0   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000A2   0x2A04             CMP      R2,#+4
   \   000000A4   0xDBF7             BLT.N    ??MBS_FC05_CoilWr_8
    900              pch->Err = MODBUS_ERR_NONE;
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0x82E0             STRH     R0,[R4, #+22]
    901              return (DEF_TRUE);                                           /* Tell caller that we need to send a response              */
   \   000000AA   0x2001             MOVS     R0,#+1
   \                     ??MBS_FC05_CoilWr_1: (+1)
   \   000000AC   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    902          }
    903          #endif
    904          #endif
    905          
    906          /*$PAGE*/
    907          /*
    908          *********************************************************************************************************
    909          *                                        MBS_FC06_HoldingRegWr()
    910          *
    911          * Description : Responds to a request to set a single register.
    912          *
    913          * Argument(s) : pch       Is a pointer to the Modbus channel's data structure.
    914          *
    915          * Return(s)   : DEF_TRUE      If a response needs to be sent
    916          *               DEF_FALSE     If not
    917          *
    918          * Caller(s)   : MBS_FCxx_Handler()
    919          *
    920          * Note(s)     : none
    921          *********************************************************************************************************
    922          */
    923          
    924          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED)
    925          #if (MODBUS_CFG_FC06_EN  == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    926          static  CPU_BOOLEAN  MBS_FC06_HoldingRegWr (MODBUS_CH *pch)
    927          {
   \                     MBS_FC06_HoldingRegWr: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    928              CPU_INT08U    *prx_data;
    929              CPU_INT08U    *ptx_data;
    930              CPU_INT08U     i;
    931              CPU_INT08U     max;
    932              CPU_INT16U     err;
    933              CPU_INT16U     reg;
    934              CPU_INT16U     reg_val_16;
    935          #if (MODBUS_CFG_FP_EN == DEF_ENABLED)
    936              CPU_FP32       reg_val_fp;
    937              CPU_INT08U    *pfp;
    938          #endif
    939          
    940          
    941              if (pch->RxFrameNDataBytes != 4) {                           /* Nbr of data bytes must be 4.                             */
   \   00000004   0xF8B4 0x0644      LDRH     R0,[R4, #+1604]
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xD001             BEQ.N    ??MBS_FC06_HoldingRegWr_0
    942                  return (DEF_FALSE);
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xE049             B.N      ??MBS_FC06_HoldingRegWr_1
    943              }
    944              pch->TxFrameNDataBytes = pch->RxFrameNDataBytes;
   \                     ??MBS_FC06_HoldingRegWr_0: (+1)
   \   00000010   0xF8B4 0x0644      LDRH     R0,[R4, #+1604]
   \   00000014   0xF8A4 0x084E      STRH     R0,[R4, #+2126]
    945              reg =  MBS_RX_DATA_START;
   \   00000018   0xF894 0x0446      LDRB     R0,[R4, #+1094]
   \   0000001C   0xF894 0x1447      LDRB     R1,[R4, #+1095]
   \   00000020   0xEB11 0x2500      ADDS     R5,R1,R0, LSL #+8
    946          #if SE_MODBUS_CODE > 0
    947          
    948              MB_DATA_holdingRegWr(pch, &err);
    949          
    950              //
    951              if(err == MODBUS_ERR_RANGE)
    952              {
    953                 pch->Err = MODBUS_ERR_FC06_01;
    954                 MBS_ErrRespSet(pch, MODBUS_ERR_ILLEGAL_DATA_ADDR);
    955                 return (DEF_TRUE);
    956              }
    957          
    958              pch->WrCtr++;
    959              MBS_TX_FRAME_ADDR = MBS_RX_FRAME_ADDR;                       /* Prepare response packet (duplicate Rx frame)             */
    960              MBS_TX_FRAME_FC   = MBS_RX_FRAME_FC;
    961              prx_data          = &pch->RxFrameData[2];                    /* Copy received register address and data to response      */
    962              ptx_data          = &pch->TxFrameData[2];
    963          
    964              max = sizeof(CPU_INT16U) + 2;
    965          
    966              for (i = 0; i < max; i++) {
    967                  *ptx_data++ = *prx_data++;
    968              }
    969          
    970          
    971          #else // ALL SE_MODBUS_CODE code above here
    972          #if (MODBUS_CFG_FP_EN == DEF_ENABLED)
    973              if (reg < MODBUS_CFG_FP_START_IX) {
    974                  reg_val_16 = MBS_RX_DATA_REG;
    975                  MB_HoldingRegWr(reg,                                     /* Write to integer register                                */
    976                                  reg_val_16,
    977                                  &err);
    978              } else {
    979                  prx_data = &pch->RxFrameData[4];                         /* Point to data in the received frame.                     */
    980                  pfp      = (CPU_INT08U *)&reg_val_fp;
    981          #if CPU_CFG_ENDIAN_TYPE == CPU_ENDIAN_TYPE_BIG
    982                  for (i = 0; i < sizeof(CPU_FP32); i++) {
    983                      *pfp++ = *prx_data++;
    984                  }
    985          #else
    986                  prx_data += sizeof(CPU_FP32) - 1;
    987                  for (i = 0; i < sizeof(CPU_FP32); i++) {
    988                      *pfp++ = *prx_data--;
    989                  }
    990          #endif
    991                  MB_HoldingRegWrFP(reg,                                   /* Write to floating point register                         */
    992                                    reg_val_fp,
    993                                    &err);
    994              }
    995          #else
    996              reg_val_16 = MBS_RX_DATA_REG;
   \   00000024   0xF894 0x0448      LDRB     R0,[R4, #+1096]
   \   00000028   0xF894 0x1449      LDRB     R1,[R4, #+1097]
   \   0000002C   0xEB11 0x2100      ADDS     R1,R1,R0, LSL #+8
    997              MB_HoldingRegWr(reg,                                         /* Write to integer register                                */
    998                              reg_val_16,
    999                              &err);
   \   00000030   0x466A             MOV      R2,SP
   \   00000032   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000034   0x0028             MOVS     R0,R5
   \   00000036   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000038   0x.... 0x....      BL       MB_HoldingRegWr
   1000          #endif
   1001              switch (err) {
   \   0000003C   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD103             BNE.N    ??MBS_FC06_HoldingRegWr_2
   1002                  case MODBUS_ERR_NONE:                                    /* Reply with echoe of command received                     */
   1003                       pch->WrCtr++;
   \   00000044   0x6860             LDR      R0,[R4, #+4]
   \   00000046   0x1C40             ADDS     R0,R0,#+1
   \   00000048   0x6060             STR      R0,[R4, #+4]
   1004                       break;
   \   0000004A   0xE006             B.N      ??MBS_FC06_HoldingRegWr_3
   1005          
   1006                  case MODBUS_ERR_RANGE:
   1007                  default:
   1008                       pch->Err = MODBUS_ERR_FC06_01;
   \                     ??MBS_FC06_HoldingRegWr_2: (+1)
   \   0000004C   0xF240 0x2059      MOVW     R0,#+601
   \   00000050   0x82E0             STRH     R0,[R4, #+22]
   1009                       MBS_ErrRespSet(pch,
   1010                                      MODBUS_ERR_ILLEGAL_DATA_ADDR);
   \   00000052   0x2102             MOVS     R1,#+2
   \   00000054   0x0020             MOVS     R0,R4
   \   00000056   0x.... 0x....      BL       MBS_ErrRespSet
   1011                       break;
   1012              }
   1013              pch->TxFrameNDataBytes = 4;
   \                     ??MBS_FC06_HoldingRegWr_3: (+1)
   \   0000005A   0x2004             MOVS     R0,#+4
   \   0000005C   0xF8A4 0x084E      STRH     R0,[R4, #+2126]
   1014              MBS_TX_FRAME_ADDR = MBS_RX_FRAME_ADDR;                       /* Prepare response packet (duplicate Rx frame)             */
   \   00000060   0xF894 0x0444      LDRB     R0,[R4, #+1092]
   \   00000064   0xF884 0x064E      STRB     R0,[R4, #+1614]
   1015              MBS_TX_FRAME_FC   = MBS_RX_FRAME_FC;
   \   00000068   0xF894 0x0445      LDRB     R0,[R4, #+1093]
   \   0000006C   0xF884 0x064F      STRB     R0,[R4, #+1615]
   1016              prx_data          = &pch->RxFrameData[2];                    /* Copy received register address and data to response      */
   \   00000070   0xF204 0x4046      ADDW     R0,R4,#+1094
   1017              ptx_data          = &pch->TxFrameData[2];
   \   00000074   0xF514 0x61CA      ADDS     R1,R4,#+1616
   1018              if (reg < MODBUS_CFG_FP_START_IX) {
   \   00000078   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000007A   0xF64F 0x72DC      MOVW     R2,#+65500
   \   0000007E   0x4295             CMP      R5,R2
   \   00000080   0xDA01             BGE.N    ??MBS_FC06_HoldingRegWr_4
   1019                  max = sizeof(CPU_INT16U) + 2;
   \   00000082   0x2304             MOVS     R3,#+4
   \   00000084   0xE000             B.N      ??MBS_FC06_HoldingRegWr_5
   1020              } else {
   1021                  max = sizeof(CPU_FP32) + 2;
   \                     ??MBS_FC06_HoldingRegWr_4: (+1)
   \   00000086   0x2306             MOVS     R3,#+6
   1022              }
   1023              for (i = 0; i < max; i++) {
   \                     ??MBS_FC06_HoldingRegWr_5: (+1)
   \   00000088   0x2200             MOVS     R2,#+0
   \   0000008A   0xE004             B.N      ??MBS_FC06_HoldingRegWr_6
   1024                  *ptx_data++ = *prx_data++;
   \                     ??MBS_FC06_HoldingRegWr_7: (+1)
   \   0000008C   0x7805             LDRB     R5,[R0, #+0]
   \   0000008E   0x700D             STRB     R5,[R1, #+0]
   \   00000090   0x1C40             ADDS     R0,R0,#+1
   \   00000092   0x1C49             ADDS     R1,R1,#+1
   1025              }
   \   00000094   0x1C52             ADDS     R2,R2,#+1
   \                     ??MBS_FC06_HoldingRegWr_6: (+1)
   \   00000096   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000098   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000009A   0x429A             CMP      R2,R3
   \   0000009C   0xD3F6             BCC.N    ??MBS_FC06_HoldingRegWr_7
   1026          #endif //SE_MODBUS_CODE
   1027              pch->Err = MODBUS_ERR_NONE;
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x82E0             STRH     R0,[R4, #+22]
   1028              return (DEF_TRUE);
   \   000000A2   0x2001             MOVS     R0,#+1
   \                     ??MBS_FC06_HoldingRegWr_1: (+1)
   \   000000A4   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1029          }
   1030          #endif
   1031          #endif
   1032          
   1033          /*
   1034          *********************************************************************************************************
   1035          *                                           MBS_FC08_Loopback()
   1036          *
   1037          * Description : The LOOPBACK function contains various diagnostic codes that perform specific actions.
   1038          *               This function processes individual diagnostic requests and formats the response message
   1039          *               frame accordingly.  Unimplemented diagnostic codes will return an Illegal Data Value
   1040          *               Exception Response Code (03).
   1041          *
   1042          * Argument(s) : pch       Is a pointer to the Modbus channel's data structure.
   1043          *
   1044          * Return(s)   : DEF_TRUE      If a response needs to be sent
   1045          *               DEF_FALSE     If not
   1046          *
   1047          * Caller(s)   : MBS_FCxx_Handler()
   1048          *
   1049          * Note(s)     : none
   1050          *********************************************************************************************************
   1051          */
   1052          
   1053          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED)
   1054          #if (MODBUS_CFG_FC08_EN  == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   1055          static  CPU_BOOLEAN  MBS_FC08_Loopback (MODBUS_CH  *pch)
   1056          {
   \                     MBS_FC08_Loopback: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1057              CPU_INT16U  diagcode;
   1058          
   1059          
   1060              if (pch->RxFrameNDataBytes != 4) {                           /* Nbr of data bytes must be 4.                             */
   \   00000004   0xF8B4 0x0644      LDRH     R0,[R4, #+1604]
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xD001             BEQ.N    ??MBS_FC08_Loopback_0
   1061                  return (DEF_FALSE);
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xE075             B.N      ??MBS_FC08_Loopback_1
   1062              }
   1063              diagcode           = MBS_RX_DIAG_CODE;
   \                     ??MBS_FC08_Loopback_0: (+1)
   \   00000010   0xF894 0x0446      LDRB     R0,[R4, #+1094]
   \   00000014   0xF894 0x1447      LDRB     R1,[R4, #+1095]
   \   00000018   0xEB11 0x2000      ADDS     R0,R1,R0, LSL #+8
   1064              MBS_TX_FRAME_ADDR  = MBS_RX_FRAME_ADDR;                      /* Prepare response packet                                  */
   \   0000001C   0xF894 0x1444      LDRB     R1,[R4, #+1092]
   \   00000020   0xF884 0x164E      STRB     R1,[R4, #+1614]
   1065              MBS_TX_FRAME_FC    = MBS_RX_FRAME_FC;
   \   00000024   0xF894 0x1445      LDRB     R1,[R4, #+1093]
   \   00000028   0xF884 0x164F      STRB     R1,[R4, #+1615]
   1066              MBS_TX_DIAG_CODE_H = MBS_RX_DIAG_CODE_H;
   \   0000002C   0xF894 0x1446      LDRB     R1,[R4, #+1094]
   \   00000030   0xF884 0x1650      STRB     R1,[R4, #+1616]
   1067              MBS_TX_DIAG_CODE_L = MBS_RX_DIAG_CODE_L;
   \   00000034   0xF894 0x1447      LDRB     R1,[R4, #+1095]
   \   00000038   0xF884 0x1651      STRB     R1,[R4, #+1617]
   1068              switch (diagcode) {
   \   0000003C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD00C             BEQ.N    ??MBS_FC08_Loopback_2
   \   00000042   0x280A             CMP      R0,#+10
   \   00000044   0xD015             BEQ.N    ??MBS_FC08_Loopback_3
   \   00000046   0x280B             CMP      R0,#+11
   \   00000048   0xD019             BEQ.N    ??MBS_FC08_Loopback_4
   \   0000004A   0x280C             CMP      R0,#+12
   \   0000004C   0xD022             BEQ.N    ??MBS_FC08_Loopback_5
   \   0000004E   0x280D             CMP      R0,#+13
   \   00000050   0xD02B             BEQ.N    ??MBS_FC08_Loopback_6
   \   00000052   0x280E             CMP      R0,#+14
   \   00000054   0xD034             BEQ.N    ??MBS_FC08_Loopback_7
   \   00000056   0x280F             CMP      R0,#+15
   \   00000058   0xD03D             BEQ.N    ??MBS_FC08_Loopback_8
   \   0000005A   0xE047             B.N      ??MBS_FC08_Loopback_9
   1069                  case MODBUS_FC08_LOOPBACK_QUERY:                         /* Return Query function code - no need to do anything.     */
   1070                       MBS_TX_DIAG_DATA_H = MBS_RX_DIAG_DATA_H;
   \                     ??MBS_FC08_Loopback_2: (+1)
   \   0000005C   0xF894 0x0448      LDRB     R0,[R4, #+1096]
   \   00000060   0xF884 0x0652      STRB     R0,[R4, #+1618]
   1071                       MBS_TX_DIAG_DATA_L = MBS_RX_DIAG_DATA_L;
   \   00000064   0xF894 0x0449      LDRB     R0,[R4, #+1097]
   \   00000068   0xF884 0x0653      STRB     R0,[R4, #+1619]
   1072                       pch->Err           = MODBUS_ERR_NONE;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x82E0             STRH     R0,[R4, #+22]
   1073                       break;
   \   00000070   0xE043             B.N      ??MBS_FC08_Loopback_10
   1074          
   1075                  case MODBUS_FC08_LOOPBACK_CLR_CTR:
   1076          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED) && \
   1077              (MODBUS_CFG_FC08_EN  == DEF_ENABLED)
   1078                       MBS_StatInit(pch);                                  /* Initialize the system counters, echo response back.      */
   \                     ??MBS_FC08_Loopback_3: (+1)
   \   00000072   0x0020             MOVS     R0,R4
   \   00000074   0x.... 0x....      BL       MBS_StatInit
   1079          #endif
   1080                       pch->Err = MODBUS_ERR_NONE;
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0x82E0             STRH     R0,[R4, #+22]
   1081                       break;
   \   0000007C   0xE03D             B.N      ??MBS_FC08_Loopback_10
   1082          
   1083                  case MODBUS_FC08_LOOPBACK_BUS_MSG_CTR:                   /* Return the message count in diag information field.      */
   1084                       MBS_TX_DIAG_DATA_H = (CPU_INT08U)((pch->StatMsgCtr & 0xFF00) >> 8);
   \                     ??MBS_FC08_Loopback_4: (+1)
   \   0000007E   0x8BE0             LDRH     R0,[R4, #+30]
   \   00000080   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000082   0x0A00             LSRS     R0,R0,#+8
   \   00000084   0xF884 0x0652      STRB     R0,[R4, #+1618]
   1085                       MBS_TX_DIAG_DATA_L = (CPU_INT08U) (pch->StatMsgCtr & 0x00FF);
   \   00000088   0x8BE0             LDRH     R0,[R4, #+30]
   \   0000008A   0xF884 0x0653      STRB     R0,[R4, #+1619]
   1086                       pch->Err           = MODBUS_ERR_NONE;
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0x82E0             STRH     R0,[R4, #+22]
   1087                       break;
   \   00000092   0xE032             B.N      ??MBS_FC08_Loopback_10
   1088          
   1089                  case MODBUS_FC08_LOOPBACK_BUS_CRC_CTR:                   /* Return the CRC error count in diag information field.    */
   1090                       MBS_TX_DIAG_DATA_H = (CPU_INT08U)((pch->StatCRCErrCtr & 0xFF00) >> 8);
   \                     ??MBS_FC08_Loopback_5: (+1)
   \   00000094   0x8C20             LDRH     R0,[R4, #+32]
   \   00000096   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000098   0x0A00             LSRS     R0,R0,#+8
   \   0000009A   0xF884 0x0652      STRB     R0,[R4, #+1618]
   1091                       MBS_TX_DIAG_DATA_L = (CPU_INT08U) (pch->StatCRCErrCtr & 0x00FF);
   \   0000009E   0x8C20             LDRH     R0,[R4, #+32]
   \   000000A0   0xF884 0x0653      STRB     R0,[R4, #+1619]
   1092                       pch->Err           = MODBUS_ERR_NONE;
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0x82E0             STRH     R0,[R4, #+22]
   1093                       break;
   \   000000A8   0xE027             B.N      ??MBS_FC08_Loopback_10
   1094          
   1095                  case MODBUS_FC08_LOOPBACK_BUS_EXCEPT_CTR:                /* Return exception count in diag information field.        */
   1096                       MBS_TX_DIAG_DATA_H = (CPU_INT08U)((pch->StatExceptCtr & 0xFF00) >> 8);
   \                     ??MBS_FC08_Loopback_6: (+1)
   \   000000AA   0x8C60             LDRH     R0,[R4, #+34]
   \   000000AC   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000AE   0x0A00             LSRS     R0,R0,#+8
   \   000000B0   0xF884 0x0652      STRB     R0,[R4, #+1618]
   1097                       MBS_TX_DIAG_DATA_L = (CPU_INT08U) (pch->StatExceptCtr & 0x00FF);
   \   000000B4   0x8C60             LDRH     R0,[R4, #+34]
   \   000000B6   0xF884 0x0653      STRB     R0,[R4, #+1619]
   1098                       pch->Err           = MODBUS_ERR_NONE;
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0x82E0             STRH     R0,[R4, #+22]
   1099                       break;
   \   000000BE   0xE01C             B.N      ??MBS_FC08_Loopback_10
   1100          
   1101                  case MODBUS_FC08_LOOPBACK_SLAVE_MSG_CTR:                 /* Return slave message count in diag information field.    */
   1102                       MBS_TX_DIAG_DATA_H = (CPU_INT08U)((pch->StatSlaveMsgCtr & 0xFF00) >> 8);
   \                     ??MBS_FC08_Loopback_7: (+1)
   \   000000C0   0x8CA0             LDRH     R0,[R4, #+36]
   \   000000C2   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000C4   0x0A00             LSRS     R0,R0,#+8
   \   000000C6   0xF884 0x0652      STRB     R0,[R4, #+1618]
   1103                       MBS_TX_DIAG_DATA_L = (CPU_INT08U) (pch->StatSlaveMsgCtr & 0x00FF);
   \   000000CA   0x8CA0             LDRH     R0,[R4, #+36]
   \   000000CC   0xF884 0x0653      STRB     R0,[R4, #+1619]
   1104                       pch->Err           = MODBUS_ERR_NONE;
   \   000000D0   0x2000             MOVS     R0,#+0
   \   000000D2   0x82E0             STRH     R0,[R4, #+22]
   1105                       break;
   \   000000D4   0xE011             B.N      ??MBS_FC08_Loopback_10
   1106          
   1107                  case MODBUS_FC08_LOOPBACK_SLAVE_NO_RESP_CTR:             /* Return no response count in diag information field.      */
   1108                       MBS_TX_DIAG_DATA_H = (CPU_INT08U)((pch->StatNoRespCtr & 0xFF00) >> 8);
   \                     ??MBS_FC08_Loopback_8: (+1)
   \   000000D6   0x8CE0             LDRH     R0,[R4, #+38]
   \   000000D8   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000DA   0x0A00             LSRS     R0,R0,#+8
   \   000000DC   0xF884 0x0652      STRB     R0,[R4, #+1618]
   1109                       MBS_TX_DIAG_DATA_L = (CPU_INT08U) (pch->StatNoRespCtr & 0x00FF);
   \   000000E0   0x8CE0             LDRH     R0,[R4, #+38]
   \   000000E2   0xF884 0x0653      STRB     R0,[R4, #+1619]
   1110                       pch->Err           = MODBUS_ERR_NONE;
   \   000000E6   0x2000             MOVS     R0,#+0
   \   000000E8   0x82E0             STRH     R0,[R4, #+22]
   1111                       break;
   \   000000EA   0xE006             B.N      ??MBS_FC08_Loopback_10
   1112          
   1113                  default:
   1114                       pch->Err = MODBUS_ERR_FC08_01;
   \                     ??MBS_FC08_Loopback_9: (+1)
   \   000000EC   0xF240 0x3021      MOVW     R0,#+801
   \   000000F0   0x82E0             STRH     R0,[R4, #+22]
   1115                       MBS_ErrRespSet(pch,
   1116                                      MODBUS_ERR_ILLEGAL_DATA_VAL);
   \   000000F2   0x2104             MOVS     R1,#+4
   \   000000F4   0x0020             MOVS     R0,R4
   \   000000F6   0x.... 0x....      BL       MBS_ErrRespSet
   1117                       break;
   1118              }
   1119              return (DEF_TRUE);                                           /* Tell caller that we need to send a response              */
   \                     ??MBS_FC08_Loopback_10: (+1)
   \   000000FA   0x2001             MOVS     R0,#+1
   \                     ??MBS_FC08_Loopback_1: (+1)
   \   000000FC   0xBD10             POP      {R4,PC}          ;; return
   1120          }
   1121          #endif
   1122          #endif
   1123          
   1124          /*$PAGE*/
   1125          /*
   1126          *********************************************************************************************************
   1127          *                                       MBS_FC15_CoilWrMultiple()
   1128          *
   1129          * Description : Processes the MODBUS "Force Multiple COILS" command and writes the COIL states.
   1130          *
   1131          * Argument(s) : pch       Is a pointer to the Modbus channel's data structure.
   1132          *
   1133          * Return(s)   : DEF_TRUE      If a response needs to be sent
   1134          *               DEF_FALSE     If not
   1135          *
   1136          * Caller(s)   : MBS_FCxx_Handler()
   1137          *
   1138          * Note(s)     : none
   1139          *********************************************************************************************************
   1140          */
   1141          
   1142          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED)
   1143          #if (MODBUS_CFG_FC15_EN  == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   1144          static  CPU_BOOLEAN  MBS_FC15_CoilWrMultiple (MODBUS_CH  *pch)
   1145          {
   \                     MBS_FC15_CoilWrMultiple: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   1146              CPU_INT16U    ix;
   1147              CPU_INT16U    coil;
   1148              CPU_INT16U    nbr_coils;
   1149              CPU_INT16U    nbr_bytes;
   1150              CPU_INT08U    data_ix;
   1151              CPU_BOOLEAN   coil_val;
   1152              CPU_INT08U    temp;
   1153              CPU_INT16U    err;
   1154          
   1155          
   1156              if (pch->WrEn == DEF_TRUE) {
   \   00000006   0x7860             LDRB     R0,[R4, #+1]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xF040 0x8082      BNE.W    ??MBS_FC15_CoilWrMultiple_0
   1157                  if (pch->RxFrameNDataBytes < 6) {                        /* Minimum Nbr of data bytes must be 6.                     */
   \   0000000E   0xF8B4 0x0644      LDRH     R0,[R4, #+1604]
   \   00000012   0x2806             CMP      R0,#+6
   \   00000014   0xDA01             BGE.N    ??MBS_FC15_CoilWrMultiple_1
   1158                      return (DEF_FALSE);                                  /* Tell caller that we DON'T need to send a response        */
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE083             B.N      ??MBS_FC15_CoilWrMultiple_2
   1159                  }
   1160                  coil      = MBS_RX_DATA_START;
   \                     ??MBS_FC15_CoilWrMultiple_1: (+1)
   \   0000001A   0xF894 0x0446      LDRB     R0,[R4, #+1094]
   \   0000001E   0xF894 0x1447      LDRB     R1,[R4, #+1095]
   \   00000022   0xEB11 0x2600      ADDS     R6,R1,R0, LSL #+8
   1161                  nbr_coils = MBS_RX_DATA_POINTS;
   \   00000026   0xF894 0x0448      LDRB     R0,[R4, #+1096]
   \   0000002A   0xF894 0x1449      LDRB     R1,[R4, #+1097]
   \   0000002E   0xEB11 0x2700      ADDS     R7,R1,R0, LSL #+8
   1162                  nbr_bytes = MBS_RX_DATA_BYTES;                           /* Get the byte count for the data.                         */
   \   00000032   0xF894 0x044A      LDRB     R0,[R4, #+1098]
   1163                  if (((((nbr_coils - 1) / 8) + 1) ==  nbr_bytes) &&       /* Be sure #bytes valid for number COILS.                   */
   1164                      (pch->RxFrameNDataBytes  == (nbr_bytes + 5))) {
   \   00000036   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000038   0x1E79             SUBS     R1,R7,#+1
   \   0000003A   0x2208             MOVS     R2,#+8
   \   0000003C   0xFB91 0xF1F2      SDIV     R1,R1,R2
   \   00000040   0x1C49             ADDS     R1,R1,#+1
   \   00000042   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000044   0x4281             CMP      R1,R0
   \   00000046   0xD15B             BNE.N    ??MBS_FC15_CoilWrMultiple_3
   \   00000048   0xF8B4 0x1644      LDRH     R1,[R4, #+1604]
   \   0000004C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000004E   0x1D40             ADDS     R0,R0,#+5
   \   00000050   0x4281             CMP      R1,R0
   \   00000052   0xD155             BNE.N    ??MBS_FC15_CoilWrMultiple_3
   1165                      ix      = 0;                                         /* Initialize COIL/loop counter variable.                   */
   \   00000054   0xF05F 0x0900      MOVS     R9,#+0
   1166                      data_ix = 7;                                         /* The 1st COIL data byte is 5th element in data frame.     */
   \   00000058   0xF05F 0x0807      MOVS     R8,#+7
   \   0000005C   0xE003             B.N      ??MBS_FC15_CoilWrMultiple_4
   1167                      while (ix < nbr_coils) {                             /* Loop through each COIL to be forced.                     */
   1168                          if ((ix % 8) == 0) {                             /* Move to the next data byte after every eight bits.       */
   1169                              temp = pch->RxFrameData[data_ix++];
   1170                          }
   1171                          if (temp & 0x01) {                               /* Get LSBit                                                */
   1172                              coil_val = MODBUS_COIL_ON;
   1173                          } else {
   1174                              coil_val = MODBUS_COIL_OFF;
   1175                          }
   1176                          MB_CoilWr(coil + ix,
   1177                                    coil_val,
   1178                                    &err);
   1179                          switch (err) {
   1180                              case MODBUS_ERR_NONE:
   1181                                   break;                                  /* Continue with the next coil if no error                  */
   1182          
   1183                              case MODBUS_ERR_RANGE:
   1184                              default:
   1185                                   pch->Err = MODBUS_ERR_FC15_01;
   1186                                   MBS_ErrRespSet(pch,
   1187                                                  MODBUS_ERR_ILLEGAL_DATA_ADDR);
   1188                                   return (DEF_TRUE);                      /* Tell caller that we need to send a response              */
   1189                          }
   1190                          temp >>= 1;                                      /* Shift the data one bit position to the right.            */
   \                     ??MBS_FC15_CoilWrMultiple_5: (+1)
   \   0000005E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000060   0x086D             LSRS     R5,R5,#+1
   1191                          ix++;                                            /* Increment the COIL counter.                              */
   \   00000062   0xF119 0x0901      ADDS     R9,R9,#+1
   \                     ??MBS_FC15_CoilWrMultiple_4: (+1)
   \   00000066   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   0000006A   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000006C   0x45B9             CMP      R9,R7
   \   0000006E   0xD229             BCS.N    ??MBS_FC15_CoilWrMultiple_6
   \   00000070   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000074   0x2008             MOVS     R0,#+8
   \   00000076   0xFB99 0xF1F0      SDIV     R1,R9,R0
   \   0000007A   0xFB01 0x9110      MLS      R1,R1,R0,R9
   \   0000007E   0x2900             CMP      R1,#+0
   \   00000080   0xD107             BNE.N    ??MBS_FC15_CoilWrMultiple_7
   \   00000082   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000086   0xEB18 0x0004      ADDS     R0,R8,R4
   \   0000008A   0xF890 0x5444      LDRB     R5,[R0, #+1092]
   \   0000008E   0xF118 0x0801      ADDS     R8,R8,#+1
   \                     ??MBS_FC15_CoilWrMultiple_7: (+1)
   \   00000092   0x07E8             LSLS     R0,R5,#+31
   \   00000094   0xD501             BPL.N    ??MBS_FC15_CoilWrMultiple_8
   \   00000096   0x2101             MOVS     R1,#+1
   \   00000098   0xE000             B.N      ??MBS_FC15_CoilWrMultiple_9
   \                     ??MBS_FC15_CoilWrMultiple_8: (+1)
   \   0000009A   0x2100             MOVS     R1,#+0
   \                     ??MBS_FC15_CoilWrMultiple_9: (+1)
   \   0000009C   0x466A             MOV      R2,SP
   \   0000009E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000A0   0xEB19 0x0006      ADDS     R0,R9,R6
   \   000000A4   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000A6   0x.... 0x....      BL       MB_CoilWr
   \   000000AA   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   000000AE   0x2800             CMP      R0,#+0
   \   000000B0   0xD0D5             BEQ.N    ??MBS_FC15_CoilWrMultiple_5
   \   000000B2   0xF240 0x50DD      MOVW     R0,#+1501
   \   000000B6   0x82E0             STRH     R0,[R4, #+22]
   \   000000B8   0x2102             MOVS     R1,#+2
   \   000000BA   0x0020             MOVS     R0,R4
   \   000000BC   0x.... 0x....      BL       MBS_ErrRespSet
   \   000000C0   0x2001             MOVS     R0,#+1
   \   000000C2   0xE02E             B.N      ??MBS_FC15_CoilWrMultiple_2
   1192                      }
   1193                  } else {
   1194                      pch->Err = MODBUS_ERR_FC15_02;
   1195                      MBS_ErrRespSet(pch,
   1196                                     MODBUS_ERR_ILLEGAL_DATA_VAL);
   1197                      return (DEF_TRUE);                                   /* Tell caller that we need to send a response              */
   1198                  }
   1199                  pch->TxFrameNDataBytes = 4;                              /* Don't echo the whole message back!                       */
   \                     ??MBS_FC15_CoilWrMultiple_6: (+1)
   \   000000C4   0x2004             MOVS     R0,#+4
   \   000000C6   0xF8A4 0x084E      STRH     R0,[R4, #+2126]
   1200                  MBS_TX_FRAME_ADDR      = MBS_RX_FRAME_ADDR;              /* Prepare response packet                                  */
   \   000000CA   0xF894 0x0444      LDRB     R0,[R4, #+1092]
   \   000000CE   0xF884 0x064E      STRB     R0,[R4, #+1614]
   1201                  MBS_TX_FRAME_FC        = MBS_RX_FRAME_FC;
   \   000000D2   0xF894 0x0445      LDRB     R0,[R4, #+1093]
   \   000000D6   0xF884 0x064F      STRB     R0,[R4, #+1615]
   1202                  MBS_TX_DATA_START_H    = MBS_RX_DATA_START_H;
   \   000000DA   0xF894 0x0446      LDRB     R0,[R4, #+1094]
   \   000000DE   0xF884 0x0650      STRB     R0,[R4, #+1616]
   1203                  MBS_TX_DATA_START_L    = MBS_RX_DATA_START_L;
   \   000000E2   0xF894 0x0447      LDRB     R0,[R4, #+1095]
   \   000000E6   0xF884 0x0651      STRB     R0,[R4, #+1617]
   1204                  MBS_TX_DATA_POINTS_H   = MBS_RX_DATA_POINTS_H;
   \   000000EA   0xF894 0x0448      LDRB     R0,[R4, #+1096]
   \   000000EE   0xF884 0x0652      STRB     R0,[R4, #+1618]
   1205                  MBS_TX_DATA_POINTS_L   = MBS_RX_DATA_POINTS_L;
   \   000000F2   0xF894 0x0449      LDRB     R0,[R4, #+1097]
   \   000000F6   0xF884 0x0653      STRB     R0,[R4, #+1619]
   1206                  pch->Err               = MODBUS_ERR_NONE;
   \   000000FA   0x2000             MOVS     R0,#+0
   \   000000FC   0x82E0             STRH     R0,[R4, #+22]
   \   000000FE   0xE00F             B.N      ??MBS_FC15_CoilWrMultiple_10
   \                     ??MBS_FC15_CoilWrMultiple_3: (+1)
   \   00000100   0xF240 0x50DE      MOVW     R0,#+1502
   \   00000104   0x82E0             STRH     R0,[R4, #+22]
   \   00000106   0x2104             MOVS     R1,#+4
   \   00000108   0x0020             MOVS     R0,R4
   \   0000010A   0x.... 0x....      BL       MBS_ErrRespSet
   \   0000010E   0x2001             MOVS     R0,#+1
   \   00000110   0xE007             B.N      ??MBS_FC15_CoilWrMultiple_2
   1207              } else {
   1208                  pch->Err               = MODBUS_ERR_FC15_03;              /* Number of bytes incorrect for number of COILS.           */
   \                     ??MBS_FC15_CoilWrMultiple_0: (+1)
   \   00000112   0xF240 0x50DF      MOVW     R0,#+1503
   \   00000116   0x82E0             STRH     R0,[R4, #+22]
   1209                  MBS_ErrRespSet(pch,
   1210                                 MODBUS_ERR_ILLEGAL_DATA_VAL);
   \   00000118   0x2104             MOVS     R1,#+4
   \   0000011A   0x0020             MOVS     R0,R4
   \   0000011C   0x.... 0x....      BL       MBS_ErrRespSet
   1211              }
   1212              return (DEF_TRUE);                                            /* Tell caller that we need to send a response              */
   \                     ??MBS_FC15_CoilWrMultiple_10: (+1)
   \   00000120   0x2001             MOVS     R0,#+1
   \                     ??MBS_FC15_CoilWrMultiple_2: (+1)
   \   00000122   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1213          }
   1214          #endif
   1215          #endif
   1216          
   1217          /*$PAGE*/
   1218          /*
   1219          *********************************************************************************************************
   1220          *                                    MBS_FC16_HoldingRegWrMultiple()
   1221          *
   1222          * Description : This function is called to write to multiple holding registers.  If the address of the
   1223          *               rquest exceeds or is equal to MODBUS_CFG_FP_START_IX, then the command would write to
   1224          *               multiple 'floating-point' according to the 'Daniels Flow Meter' extensions.  This means
   1225          *               that each register requested is considered as a 32-bit IEEE-754 floating-point format.
   1226          *
   1227          * Argument(s) : pch       Is a pointer to the Modbus channel's data structure.
   1228          *
   1229          * Return(s)   : DEF_TRUE      If a response needs to be sent
   1230          *               DEF_FALSE     If not
   1231          *
   1232          * Caller(s)   : MBS_FCxx_Handler()
   1233          *
   1234          * Note(s)     : none
   1235          *********************************************************************************************************
   1236          */
   1237          
   1238          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED)
   1239          #if (MODBUS_CFG_FC16_EN  == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   1240          static  CPU_BOOLEAN  MBS_FC16_HoldingRegWrMultiple (MODBUS_CH *pch)
   1241          {
   \                     MBS_FC16_HoldingRegWrMultiple: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1242              CPU_INT08U     *prx_data;
   1243              CPU_INT16U      err;
   1244              CPU_INT16U      reg;
   1245              CPU_INT16U      reg_val_16;
   1246              CPU_INT16U      nbr_regs;
   1247              CPU_INT16U      nbr_bytes;
   1248              CPU_INT08U      data_size;
   1249          #if (MODBUS_CFG_FP_EN == DEF_ENABLED)
   1250              CPU_INT08U      i;
   1251              CPU_FP32        reg_val_fp;
   1252              CPU_INT08U     *pfp;
   1253          #endif
   1254          
   1255          
   1256              reg       = MBS_RX_DATA_START;
   \   00000004   0xF894 0x0446      LDRB     R0,[R4, #+1094]
   \   00000008   0xF894 0x1447      LDRB     R1,[R4, #+1095]
   \   0000000C   0xEB11 0x2500      ADDS     R5,R1,R0, LSL #+8
   1257              nbr_regs  = MBS_RX_DATA_POINTS;
   \   00000010   0xF894 0x0448      LDRB     R0,[R4, #+1096]
   \   00000014   0xF894 0x1449      LDRB     R1,[R4, #+1097]
   \   00000018   0xEB11 0x2700      ADDS     R7,R1,R0, LSL #+8
   1258          #if SE_MODBUS_CODE > 0
   1259          
   1260              MB_DATA_holdingRegWrMultiple(pch, &err);
   1261              
   1262              switch(err)
   1263              {
   1264                 case MODBUS_ERR_RANGE:
   1265                    pch->Err = MODBUS_ERR_FC16_03;
   1266                    MBS_ErrRespSet(pch, MODBUS_ERR_ILLEGAL_DATA_ADDR);
   1267                    return (DEF_TRUE);
   1268                 case MODBUS_ERR_ILLEGAL_DATA_QTY:
   1269                    pch->Err = MODBUS_ERR_FC16_01;
   1270                    MBS_ErrRespSet(pch, MODBUS_ERR_ILLEGAL_DATA_QTY);
   1271                    return (DEF_TRUE);
   1272                 case MODBUS_ERR_ILLEGAL_DATA_VAL:
   1273                    pch->Err = MODBUS_ERR_FC16_02;
   1274                     MBS_ErrRespSet(pch, MODBUS_ERR_ILLEGAL_DATA_VAL);
   1275                     return (DEF_TRUE); 
   1276                 default:
   1277                    break;
   1278          
   1279              }
   1280          
   1281          #else // ALL SE_MODBUS_CODE code above here
   1282          #if (MODBUS_CFG_FP_EN == DEF_ENABLED)
   1283              if (reg < MODBUS_CFG_FP_START_IX) {
   1284                  if (nbr_regs == 0 || nbr_regs > 125) {                   /* Make sure we don't exceed the allowed limit per request  */
   1285                      pch->Err = MODBUS_ERR_FC16_04;
   1286                      MBS_ErrRespSet(pch, 
   1287                                     MODBUS_ERR_ILLEGAL_DATA_QTY);
   1288                      return (DEF_TRUE);                                   /* Tell caller that we need to send a response              */
   1289                  }
   1290                  data_size  = sizeof(CPU_INT16U);
   1291              } else {
   1292                  if (nbr_regs == 0 || nbr_regs > 62) {                    /* Make sure we don't exceed the allowed limit per request  */
   1293                      pch->Err = MODBUS_ERR_FC16_05;
   1294                      MBS_ErrRespSet(pch, 
   1295                                     MODBUS_ERR_ILLEGAL_DATA_QTY);
   1296                      return (DEF_TRUE);                                   /* Tell caller that we need to send a response              */
   1297                  }
   1298                  data_size  = sizeof(CPU_FP32);
   1299              }
   1300          #else
   1301              if (nbr_regs == 0 || nbr_regs > 125) {                       /* Make sure we don't exceed the allowed limit per request  */
   \   0000001C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000001E   0x2F00             CMP      R7,#+0
   \   00000020   0xD002             BEQ.N    ??MBS_FC16_HoldingRegWrMultiple_0
   \   00000022   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000024   0x2F7E             CMP      R7,#+126
   \   00000026   0xDB08             BLT.N    ??MBS_FC16_HoldingRegWrMultiple_1
   1302                  pch->Err = MODBUS_ERR_FC16_04;                    
   \                     ??MBS_FC16_HoldingRegWrMultiple_0: (+1)
   \   00000028   0xF240 0x6044      MOVW     R0,#+1604
   \   0000002C   0x82E0             STRH     R0,[R4, #+22]
   1303                  MBS_ErrRespSet(pch,                               
   1304                                 MODBUS_ERR_ILLEGAL_DATA_QTY);      
   \   0000002E   0x2103             MOVS     R1,#+3
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       MBS_ErrRespSet
   1305                  return (DEF_TRUE);                                       /* Tell caller that we need to send a response              */
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0xE060             B.N      ??MBS_FC16_HoldingRegWrMultiple_2
   1306              }                                                     
   1307              data_size  = sizeof(CPU_INT16U);
   \                     ??MBS_FC16_HoldingRegWrMultiple_1: (+1)
   \   0000003A   0x2102             MOVS     R1,#+2
   1308          #endif
   1309          
   1310              prx_data  = &pch->RxFrameData[6];                            /* Point to number of bytes in request frame                */
   \   0000003C   0xF204 0x464A      ADDW     R6,R4,#+1098
   1311              nbr_bytes = (CPU_INT16U)*prx_data++;
   \   00000040   0x7830             LDRB     R0,[R6, #+0]
   \   00000042   0x1C76             ADDS     R6,R6,#+1
   1312              if ((pch->RxFrameNDataBytes - 5) != nbr_bytes) {             /* Compare actual number of bytes to what they say.         */
   \   00000044   0xF8B4 0x2644      LDRH     R2,[R4, #+1604]
   \   00000048   0x1F52             SUBS     R2,R2,#+5
   \   0000004A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000004C   0x4282             CMP      R2,R0
   \   0000004E   0xD008             BEQ.N    ??MBS_FC16_HoldingRegWrMultiple_3
   1313                  pch->Err = MODBUS_ERR_FC16_01;
   \   00000050   0xF240 0x6041      MOVW     R0,#+1601
   \   00000054   0x82E0             STRH     R0,[R4, #+22]
   1314                  MBS_ErrRespSet(pch, 
   1315                                 MODBUS_ERR_ILLEGAL_DATA_QTY);
   \   00000056   0x2103             MOVS     R1,#+3
   \   00000058   0x0020             MOVS     R0,R4
   \   0000005A   0x.... 0x....      BL       MBS_ErrRespSet
   1316                  return (DEF_TRUE);
   \   0000005E   0x2001             MOVS     R0,#+1
   \   00000060   0xE04C             B.N      ??MBS_FC16_HoldingRegWrMultiple_2
   1317              }
   1318              if ((nbr_bytes / nbr_regs) != (CPU_INT16U)data_size) {
   \                     ??MBS_FC16_HoldingRegWrMultiple_3: (+1)
   \   00000062   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000064   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000066   0xFB90 0xF0F7      SDIV     R0,R0,R7
   \   0000006A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000006C   0x4288             CMP      R0,R1
   \   0000006E   0xD00D             BEQ.N    ??MBS_FC16_HoldingRegWrMultiple_4
   1319                  pch->Err = MODBUS_ERR_FC16_02;
   \   00000070   0xF240 0x6042      MOVW     R0,#+1602
   \   00000074   0x82E0             STRH     R0,[R4, #+22]
   1320                  MBS_ErrRespSet(pch, 
   1321                                 MODBUS_ERR_ILLEGAL_DATA_VAL);
   \   00000076   0x2104             MOVS     R1,#+4
   \   00000078   0x0020             MOVS     R0,R4
   \   0000007A   0x.... 0x....      BL       MBS_ErrRespSet
   1322                  return (DEF_TRUE);                                       /* Tell caller that we need to send a response              */
   \   0000007E   0x2001             MOVS     R0,#+1
   \   00000080   0xE03C             B.N      ??MBS_FC16_HoldingRegWrMultiple_2
   1323              }
   1324              while (nbr_regs > 0) {
   1325          #if (MODBUS_CFG_FP_EN == DEF_ENABLED)
   1326                  if (reg < MODBUS_CFG_FP_START_IX) {
   1327                      reg_val_16  = ((CPU_INT16U)*prx_data++) << 8;        /* Get MSB first.                                           */
   1328                      reg_val_16 +=  (CPU_INT16U)*prx_data++;              /* Add in the LSB.                                          */
   1329                      MB_HoldingRegWr(reg, 
   1330                                      reg_val_16, 
   1331                                      &err);
   1332                  } else {
   1333                      pfp = (CPU_INT08U *)&reg_val_fp;
   1334          #if CPU_CFG_ENDIAN_TYPE == CPU_ENDIAN_TYPE_BIG
   1335                      for (i = 0; i < sizeof(CPU_FP32); i++) {
   1336                          *pfp++   = *prx_data++;
   1337                      }
   1338          #else
   1339                      pfp += sizeof(CPU_FP32) - 1;
   1340                      for (i = 0; i < sizeof(CPU_FP32); i++) {
   1341                          *pfp--   = *prx_data++;
   1342                      }
   1343          #endif
   1344                      MB_HoldingRegWrFP(reg, 
   1345                                        reg_val_fp, 
   1346                                        &err);
   1347                  }
   1348          #else        
   1349                  reg_val_16  = ((CPU_INT16U)*prx_data++) << 8;            /* Get MSB first.                                           */
   1350                  reg_val_16 +=  (CPU_INT16U)*prx_data++;                  /* Add in the LSB.                                          */
   1351                  MB_HoldingRegWr(reg,                               
   1352                                  reg_val_16,                        
   1353                                  &err);                             
   1354          #endif
   1355                  
   1356                  switch (err) {                                           /* See if any errors in writing the data                    */
   1357                      case MODBUS_ERR_NONE:                                /* Reply with echoe of command received                     */
   1358                           pch->WrCtr++;
   \                     ??MBS_FC16_HoldingRegWrMultiple_5: (+1)
   \   00000082   0x6860             LDR      R0,[R4, #+4]
   \   00000084   0x1C40             ADDS     R0,R0,#+1
   \   00000086   0x6060             STR      R0,[R4, #+4]
   1359                           reg++;
   \   00000088   0x1C6D             ADDS     R5,R5,#+1
   1360                           nbr_regs--;
   \   0000008A   0x1E7F             SUBS     R7,R7,#+1
   1361                           break;
   \                     ??MBS_FC16_HoldingRegWrMultiple_4: (+1)
   \   0000008C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000008E   0x2F00             CMP      R7,#+0
   \   00000090   0xD018             BEQ.N    ??MBS_FC16_HoldingRegWrMultiple_6
   \   00000092   0x7830             LDRB     R0,[R6, #+0]
   \   00000094   0x0201             LSLS     R1,R0,#+8
   \   00000096   0x1C76             ADDS     R6,R6,#+1
   \   00000098   0x7830             LDRB     R0,[R6, #+0]
   \   0000009A   0x1841             ADDS     R1,R0,R1
   \   0000009C   0x1C76             ADDS     R6,R6,#+1
   \   0000009E   0x466A             MOV      R2,SP
   \   000000A0   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000A2   0x0028             MOVS     R0,R5
   \   000000A4   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000A6   0x.... 0x....      BL       MB_HoldingRegWr
   \   000000AA   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   000000AE   0x2800             CMP      R0,#+0
   \   000000B0   0xD0E7             BEQ.N    ??MBS_FC16_HoldingRegWrMultiple_5
   1362          
   1363                      case MODBUS_ERR_RANGE:
   1364                      default:
   1365                           pch->Err = MODBUS_ERR_FC16_03;
   \   000000B2   0xF240 0x6043      MOVW     R0,#+1603
   \   000000B6   0x82E0             STRH     R0,[R4, #+22]
   1366                           MBS_ErrRespSet(pch, 
   1367                                          MODBUS_ERR_ILLEGAL_DATA_ADDR);
   \   000000B8   0x2102             MOVS     R1,#+2
   \   000000BA   0x0020             MOVS     R0,R4
   \   000000BC   0x.... 0x....      BL       MBS_ErrRespSet
   1368                           return (DEF_TRUE);                              /* Tell caller that we need to send a response              */
   \   000000C0   0x2001             MOVS     R0,#+1
   \   000000C2   0xE01B             B.N      ??MBS_FC16_HoldingRegWrMultiple_2
   1369                  }
   1370              }
   1371          #endif //SE_MODBUS_CODE
   1372              pch->TxFrameNDataBytes = 4;                                  /* Don't echo the whole message back!                       */
   \                     ??MBS_FC16_HoldingRegWrMultiple_6: (+1)
   \   000000C4   0x2004             MOVS     R0,#+4
   \   000000C6   0xF8A4 0x084E      STRH     R0,[R4, #+2126]
   1373              MBS_TX_FRAME_ADDR      = MBS_RX_FRAME_ADDR;                  /* Prepare response packet                                  */
   \   000000CA   0xF894 0x0444      LDRB     R0,[R4, #+1092]
   \   000000CE   0xF884 0x064E      STRB     R0,[R4, #+1614]
   1374              MBS_TX_FRAME_FC        = MBS_RX_FRAME_FC;
   \   000000D2   0xF894 0x0445      LDRB     R0,[R4, #+1093]
   \   000000D6   0xF884 0x064F      STRB     R0,[R4, #+1615]
   1375              MBS_TX_DATA_START_H    = MBS_RX_DATA_START_H;
   \   000000DA   0xF894 0x0446      LDRB     R0,[R4, #+1094]
   \   000000DE   0xF884 0x0650      STRB     R0,[R4, #+1616]
   1376              MBS_TX_DATA_START_L    = MBS_RX_DATA_START_L;
   \   000000E2   0xF894 0x0447      LDRB     R0,[R4, #+1095]
   \   000000E6   0xF884 0x0651      STRB     R0,[R4, #+1617]
   1377              MBS_TX_DATA_POINTS_H   = MBS_RX_DATA_POINTS_H;
   \   000000EA   0xF894 0x0448      LDRB     R0,[R4, #+1096]
   \   000000EE   0xF884 0x0652      STRB     R0,[R4, #+1618]
   1378              MBS_TX_DATA_POINTS_L   = MBS_RX_DATA_POINTS_L;
   \   000000F2   0xF894 0x0449      LDRB     R0,[R4, #+1097]
   \   000000F6   0xF884 0x0653      STRB     R0,[R4, #+1619]
   1379              return (DEF_TRUE);                                           /* Tell caller that we need to send a response              */
   \   000000FA   0x2001             MOVS     R0,#+1
   \                     ??MBS_FC16_HoldingRegWrMultiple_2: (+1)
   \   000000FC   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1380          }
   1381          #endif
   1382          #endif
   1383          
   1384          /*$PAGE*/
   1385          /*
   1386          *********************************************************************************************************
   1387          *                                          MBS_FC20_FileRd()
   1388          *
   1389          * Description : Read a record from a file.
   1390          *
   1391          * Argument(s) : pch       Is a pointer to the Modbus channel's data structure.
   1392          *
   1393          * Return(s)   : DEF_TRUE      If a response needs to be sent
   1394          *               DEF_FALSE     If not
   1395          *
   1396          * Caller(s)   : MBS_FCxx_Handler()
   1397          *
   1398          * Note(s)     : (1) The current version of this software only supports ONE Sub-request at a time.
   1399          *********************************************************************************************************
   1400          */
   1401          
   1402          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED)
   1403          #if (MODBUS_CFG_FC20_EN  == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   1404          static  CPU_BOOLEAN  MBS_FC20_FileRd (MODBUS_CH  *pch)
   1405          {
   \                     MBS_FC20_FileRd: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x0004             MOVS     R4,R0
   1406              CPU_INT08U    *presp;
   1407              CPU_INT16U     file_nbr;
   1408              CPU_INT16U     record_nbr;
   1409              CPU_INT16U     record_len;
   1410              CPU_INT16U     cmd_len;
   1411              CPU_INT08U     cmd_type;
   1412              CPU_INT16U     err;
   1413              CPU_INT16U     reg_val;
   1414              CPU_INT16U     ix;
   1415          
   1416          
   1417              cmd_len = pch->RxFrameData[2];                                           /* Get the number of bytes in the command received          */
   \   00000008   0xF894 0x0446      LDRB     R0,[R4, #+1094]
   1418              if (cmd_len < 7 || cmd_len > 245) {                                      /* Make sure the byte count Rx'd is within expected range   */
   \   0000000C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000000E   0x1FC0             SUBS     R0,R0,#+7
   \   00000010   0x28EF             CMP      R0,#+239
   \   00000012   0xD308             BCC.N    ??MBS_FC20_FileRd_0
   1419                  pch->Err = MODBUS_ERR_FC20_01;
   \   00000014   0xF240 0x70D1      MOVW     R0,#+2001
   \   00000018   0x82E0             STRH     R0,[R4, #+22]
   1420                  MBS_ErrRespSet(pch,
   1421                                 MODBUS_ERR_ILLEGAL_DATA_QTY);
   \   0000001A   0x2103             MOVS     R1,#+3
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       MBS_ErrRespSet
   1422                  return (DEF_TRUE);                                                   /* Tell caller that we need to send a response              */
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xE08E             B.N      ??MBS_FC20_FileRd_1
   1423              }
   1424              cmd_type    =  pch->RxFrameData[3];                                      /* Get the reference type                                   */
   \                     ??MBS_FC20_FileRd_0: (+1)
   \   00000026   0xF894 0x0447      LDRB     R0,[R4, #+1095]
   1425              file_nbr    = ((CPU_INT16U)pch->RxFrameData[4] << 8)                     /* Get the file number                                      */
   1426                          +  (CPU_INT16U)pch->RxFrameData[5];
   \   0000002A   0xF894 0x1448      LDRB     R1,[R4, #+1096]
   \   0000002E   0xF894 0x2449      LDRB     R2,[R4, #+1097]
   \   00000032   0xEB12 0x2501      ADDS     R5,R2,R1, LSL #+8
   1427              record_nbr  = ((CPU_INT16U)pch->RxFrameData[6] << 8)                     /* Get the record number                                    */
   1428                          +  (CPU_INT16U)pch->RxFrameData[7];
   \   00000036   0xF894 0x144A      LDRB     R1,[R4, #+1098]
   \   0000003A   0xF894 0x244B      LDRB     R2,[R4, #+1099]
   \   0000003E   0xEB12 0x2601      ADDS     R6,R2,R1, LSL #+8
   1429              record_len  = ((CPU_INT16U)pch->RxFrameData[8] << 8)                     /* Get the record length                                    */
   1430                          +  (CPU_INT16U)pch->RxFrameData[9];
   \   00000042   0xF894 0x144C      LDRB     R1,[R4, #+1100]
   \   00000046   0xF894 0x244D      LDRB     R2,[R4, #+1101]
   \   0000004A   0xEB12 0x2701      ADDS     R7,R2,R1, LSL #+8
   1431              presp       = &pch->TxFrameData[0];                                      /* Point to first location in response buffer               */
   \   0000004E   0xF204 0x684E      ADDW     R8,R4,#+1614
   1432              *presp++    = MBS_RX_FRAME_ADDR;                                         /* Reply back with the node address                         */
   \   00000052   0xF894 0x1444      LDRB     R1,[R4, #+1092]
   \   00000056   0xF888 0x1000      STRB     R1,[R8, #+0]
   \   0000005A   0xF118 0x0801      ADDS     R8,R8,#+1
   1433              *presp++    = MBS_RX_FRAME_FC;                                           /* Include the function code                                */
   \   0000005E   0xF894 0x1445      LDRB     R1,[R4, #+1093]
   \   00000062   0xF888 0x1000      STRB     R1,[R8, #+0]
   \   00000066   0xF118 0x0801      ADDS     R8,R8,#+1
   1434              if (cmd_type == 6) {                                                     /* File type should ALWAYS be 6.                            */
   \   0000006A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006C   0x2806             CMP      R0,#+6
   \   0000006E   0xD161             BNE.N    ??MBS_FC20_FileRd_2
   1435                  pch->TxFrameNDataBytes = record_len * sizeof(CPU_INT16U) + 3;        /* Determine the total number of data bytes in the Tx frame */
   \   00000070   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000072   0x0078             LSLS     R0,R7,#+1
   \   00000074   0x1CC0             ADDS     R0,R0,#+3
   \   00000076   0xF8A4 0x084E      STRH     R0,[R4, #+2126]
   1436                  *presp++               = (CPU_INT08U)(pch->TxFrameNDataBytes - 1);   /* Total byte count (excluding byte count)                  */
   \   0000007A   0xF8B4 0x084E      LDRH     R0,[R4, #+2126]
   \   0000007E   0x1E40             SUBS     R0,R0,#+1
   \   00000080   0xF888 0x0000      STRB     R0,[R8, #+0]
   \   00000084   0xF118 0x0801      ADDS     R8,R8,#+1
   1437                  *presp++               = (CPU_INT08U)(pch->TxFrameNDataBytes - 2);   /* Sub request byte count (excluding sub-request byte cnt)  */
   \   00000088   0xF8B4 0x084E      LDRH     R0,[R4, #+2126]
   \   0000008C   0x1E80             SUBS     R0,R0,#+2
   \   0000008E   0xF888 0x0000      STRB     R0,[R8, #+0]
   \   00000092   0xF118 0x0801      ADDS     R8,R8,#+1
   1438                  *presp++               = 6;                                          /* Reference type is ALWAYS 6.                              */
   \   00000096   0x2006             MOVS     R0,#+6
   \   00000098   0xF888 0x0000      STRB     R0,[R8, #+0]
   \   0000009C   0xF118 0x0801      ADDS     R8,R8,#+1
   1439                  ix                     = 0;                                          /* Initialize the index into the record                     */
   \   000000A0   0xF05F 0x0900      MOVS     R9,#+0
   \   000000A4   0xE00D             B.N      ??MBS_FC20_FileRd_3
   1440                  while (record_len > 0) {
   1441                      reg_val = MB_FileRd(file_nbr,                                    /* Get one value from the file                              */
   1442                                          record_nbr,
   1443                                          ix,
   1444                                          record_len,
   1445                                          &err);
   1446                      switch (err) {
   1447                          case MODBUS_ERR_NONE:
   1448                               *presp++ = (CPU_INT08U)(reg_val >> 8);                  /* Store high byte of record data                           */
   \                     ??MBS_FC20_FileRd_4: (+1)
   \   000000A6   0x0001             MOVS     R1,R0
   \   000000A8   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000AA   0x0A09             LSRS     R1,R1,#+8
   \   000000AC   0xF888 0x1000      STRB     R1,[R8, #+0]
   \   000000B0   0xF118 0x0801      ADDS     R8,R8,#+1
   1449                               *presp++ = (CPU_INT08U)(reg_val & 0x00FF);              /* Store low  byte of record data                           */
   \   000000B4   0xF888 0x0000      STRB     R0,[R8, #+0]
   \   000000B8   0xF118 0x0801      ADDS     R8,R8,#+1
   1450                               break;
   1451          
   1452                          case MODBUS_ERR_FILE:
   1453                               pch->Err = MODBUS_ERR_FC20_02;
   1454                               MBS_ErrRespSet(pch,
   1455                                              MODBUS_ERR_ILLEGAL_DATA_ADDR);
   1456                               return (DEF_TRUE);                                      /* Tell caller that we need to send a response              */
   1457          
   1458                          case MODBUS_ERR_RECORD:
   1459                               pch->Err = MODBUS_ERR_FC20_03;
   1460                               MBS_ErrRespSet(pch,
   1461                                              MODBUS_ERR_ILLEGAL_DATA_ADDR);
   1462                               return (DEF_TRUE);                                      /* Tell caller that we need to send a response              */
   1463          
   1464                          case MODBUS_ERR_IX:
   1465                          default:
   1466                               pch->Err = MODBUS_ERR_FC20_04;
   1467                               MBS_ErrRespSet(pch,
   1468                                              MODBUS_ERR_ILLEGAL_DATA_ADDR);
   1469                               return (DEF_TRUE);                                      /* Tell caller that we need to send a response              */
   1470                      }
   1471                      ix++;
   \   000000BC   0xF119 0x0901      ADDS     R9,R9,#+1
   1472                      record_len--;
   \   000000C0   0x1E7F             SUBS     R7,R7,#+1
   \                     ??MBS_FC20_FileRd_3: (+1)
   \   000000C2   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000C4   0x2F00             CMP      R7,#+0
   \   000000C6   0xD031             BEQ.N    ??MBS_FC20_FileRd_5
   \   000000C8   0xA801             ADD      R0,SP,#+4
   \   000000CA   0x9000             STR      R0,[SP, #+0]
   \   000000CC   0x003B             MOVS     R3,R7
   \   000000CE   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000000D0   0x464A             MOV      R2,R9
   \   000000D2   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000000D4   0x0031             MOVS     R1,R6
   \   000000D6   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000D8   0x0028             MOVS     R0,R5
   \   000000DA   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000DC   0x.... 0x....      BL       MB_FileRd
   \   000000E0   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   000000E4   0x2900             CMP      R1,#+0
   \   000000E6   0xD0DE             BEQ.N    ??MBS_FC20_FileRd_4
   \   000000E8   0xF640 0x72A1      MOVW     R2,#+4001
   \   000000EC   0x1A89             SUBS     R1,R1,R2
   \   000000EE   0xD002             BEQ.N    ??MBS_FC20_FileRd_6
   \   000000F0   0x1E49             SUBS     R1,R1,#+1
   \   000000F2   0xD009             BEQ.N    ??MBS_FC20_FileRd_7
   \   000000F4   0xE011             B.N      ??MBS_FC20_FileRd_8
   \                     ??MBS_FC20_FileRd_6: (+1)
   \   000000F6   0xF240 0x70D2      MOVW     R0,#+2002
   \   000000FA   0x82E0             STRH     R0,[R4, #+22]
   \   000000FC   0x2102             MOVS     R1,#+2
   \   000000FE   0x0020             MOVS     R0,R4
   \   00000100   0x.... 0x....      BL       MBS_ErrRespSet
   \   00000104   0x2001             MOVS     R0,#+1
   \   00000106   0xE01D             B.N      ??MBS_FC20_FileRd_1
   \                     ??MBS_FC20_FileRd_7: (+1)
   \   00000108   0xF240 0x70D3      MOVW     R0,#+2003
   \   0000010C   0x82E0             STRH     R0,[R4, #+22]
   \   0000010E   0x2102             MOVS     R1,#+2
   \   00000110   0x0020             MOVS     R0,R4
   \   00000112   0x.... 0x....      BL       MBS_ErrRespSet
   \   00000116   0x2001             MOVS     R0,#+1
   \   00000118   0xE014             B.N      ??MBS_FC20_FileRd_1
   \                     ??MBS_FC20_FileRd_8: (+1)
   \   0000011A   0xF240 0x70D4      MOVW     R0,#+2004
   \   0000011E   0x82E0             STRH     R0,[R4, #+22]
   \   00000120   0x2102             MOVS     R1,#+2
   \   00000122   0x0020             MOVS     R0,R4
   \   00000124   0x.... 0x....      BL       MBS_ErrRespSet
   \   00000128   0x2001             MOVS     R0,#+1
   \   0000012A   0xE00B             B.N      ??MBS_FC20_FileRd_1
   1473                  }
   1474              } else {
   1475                  pch->Err = MODBUS_ERR_FC20_05;
   1476                  MBS_ErrRespSet(pch,
   1477                                 MODBUS_ERR_ILLEGAL_DATA_ADDR);
   1478                  return (DEF_TRUE);                                                   /* Tell caller that we need to send a response              */
   1479              }
   1480              pch->Err = MODBUS_ERR_NONE;
   \                     ??MBS_FC20_FileRd_5: (+1)
   \   0000012C   0x2000             MOVS     R0,#+0
   \   0000012E   0x82E0             STRH     R0,[R4, #+22]
   1481              return (DEF_TRUE);                                                       /* Tell caller that we need to send a response              */
   \   00000130   0x2001             MOVS     R0,#+1
   \   00000132   0xE007             B.N      ??MBS_FC20_FileRd_1
   \                     ??MBS_FC20_FileRd_2: (+1)
   \   00000134   0xF240 0x70D5      MOVW     R0,#+2005
   \   00000138   0x82E0             STRH     R0,[R4, #+22]
   \   0000013A   0x2102             MOVS     R1,#+2
   \   0000013C   0x0020             MOVS     R0,R4
   \   0000013E   0x.... 0x....      BL       MBS_ErrRespSet
   \   00000142   0x2001             MOVS     R0,#+1
   \                     ??MBS_FC20_FileRd_1: (+1)
   \   00000144   0xE8BD 0x83FE      POP      {R1-R9,PC}       ;; return
   1482          }
   1483          #endif
   1484          #endif
   1485          
   1486          /*$PAGE*/
   1487          /*
   1488          *********************************************************************************************************
   1489          *                                       MBS_FC21_FileWr()
   1490          *
   1491          * Description : Write a record to a file.
   1492          *
   1493          * Argument(s) : pch       Is a pointer to the Modbus channel's data structure.
   1494          *
   1495          * Return(s)   : DEF_TRUE      If a response needs to be sent
   1496          *               DEF_FALSE     If not
   1497          *
   1498          * Caller(s)   : MBS_FCxx_Handler().
   1499          *
   1500          * Note(s)     : (1) The current version of this software only supports ONE Sub-request at a time.
   1501          *********************************************************************************************************
   1502          */
   1503          
   1504          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED)
   1505          #if (MODBUS_CFG_FC21_EN  == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   1506          static  CPU_BOOLEAN  MBS_FC21_FileWr (MODBUS_CH  *pch)
   1507          {
   \                     MBS_FC21_FileWr: (+1)
   \   00000000   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   1508              CPU_INT08U    *prx_data;
   1509              CPU_INT08U    *pcmd;
   1510              CPU_INT08U    *presp;
   1511              CPU_INT16U     file_nbr;
   1512              CPU_INT16U     record_nbr;
   1513              CPU_INT16U     record_len;
   1514              CPU_INT16U     cmd_len;
   1515              CPU_INT08U     cmd_type;
   1516              CPU_INT16U     err;
   1517              CPU_INT08U     max;
   1518              CPU_INT16U     reg_val;
   1519              CPU_INT16U     ix;
   1520          
   1521          
   1522              cmd_len = pch->RxFrameData[2];
   \   00000006   0xF894 0x0446      LDRB     R0,[R4, #+1094]
   1523              if (cmd_len < 7 || cmd_len > 245) {                                    /* Make sure the byte count Rx'd is within expected range   */
   \   0000000A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000000C   0x1FC0             SUBS     R0,R0,#+7
   \   0000000E   0x28EF             CMP      R0,#+239
   \   00000010   0xD308             BCC.N    ??MBS_FC21_FileWr_0
   1524                  pch->Err = MODBUS_ERR_FC21_01;
   \   00000012   0xF640 0x0035      MOVW     R0,#+2101
   \   00000016   0x82E0             STRH     R0,[R4, #+22]
   1525                  MBS_ErrRespSet(pch,
   1526                                 MODBUS_ERR_ILLEGAL_DATA_QTY);
   \   00000018   0x2103             MOVS     R1,#+3
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       MBS_ErrRespSet
   1527                  return (DEF_TRUE);                                                 /* Tell caller that we need to send a response              */
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xE084             B.N      ??MBS_FC21_FileWr_1
   1528              }
   1529              cmd_type    =  pch->RxFrameData[3];                                    /* Get the reference type                                   */
   \                     ??MBS_FC21_FileWr_0: (+1)
   \   00000024   0xF894 0x0447      LDRB     R0,[R4, #+1095]
   1530              file_nbr    = ((CPU_INT16U)pch->RxFrameData[4] << 8)                   /* Get the file number                                      */
   1531                          +  (CPU_INT16U)pch->RxFrameData[5];
   \   00000028   0xF894 0x1448      LDRB     R1,[R4, #+1096]
   \   0000002C   0xF894 0x2449      LDRB     R2,[R4, #+1097]
   \   00000030   0xEB12 0x2701      ADDS     R7,R2,R1, LSL #+8
   1532              record_nbr  = ((CPU_INT16U)pch->RxFrameData[6] << 8)                   /* Get the record number                                    */
   1533                          + (CPU_INT16U)pch->RxFrameData[7];
   \   00000034   0xF894 0x144A      LDRB     R1,[R4, #+1098]
   \   00000038   0xF894 0x244B      LDRB     R2,[R4, #+1099]
   \   0000003C   0xEB12 0x2801      ADDS     R8,R2,R1, LSL #+8
   1534              record_len  = ((CPU_INT16U)pch->RxFrameData[8] << 8)                   /* Get the record length                                    */
   1535                          + (CPU_INT16U)pch->RxFrameData[9];
   \   00000040   0xF894 0x144C      LDRB     R1,[R4, #+1100]
   \   00000044   0xF894 0x244D      LDRB     R2,[R4, #+1101]
   \   00000048   0xEB12 0x2501      ADDS     R5,R2,R1, LSL #+8
   1536              prx_data    = &pch->RxFrameData[10];                                   /* Point to first data byte                                 */
   \   0000004C   0xF204 0x494E      ADDW     R9,R4,#+1102
   1537          
   1538              if (cmd_type == 6) {                                                   /* File type should ALWAYS be 6.                            */
   \   00000050   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000052   0x2806             CMP      R0,#+6
   \   00000054   0xD147             BNE.N    ??MBS_FC21_FileWr_2
   1539                  ix = 0;                                                            /* Initialize the index into the record                     */
   \   00000056   0x2600             MOVS     R6,#+0
   \   00000058   0xE004             B.N      ??MBS_FC21_FileWr_3
   1540                  while (record_len > 0) {
   1541                      reg_val  = ((CPU_INT16U)*prx_data++ << 8) & 0xFF00;            /* Get data to write to file                                */
   1542                      reg_val |=  (CPU_INT16U)*prx_data++ & 0x00FF;
   1543                      MB_FileWr(file_nbr,                                            /* Write one value to the file                              */
   1544                                record_nbr,
   1545                                ix,
   1546                                record_len,
   1547                                reg_val,
   1548                                &err);
   1549                      switch (err) {
   1550                          case MODBUS_ERR_NONE:
   1551                               pch->WrCtr++;
   \                     ??MBS_FC21_FileWr_4: (+1)
   \   0000005A   0x6860             LDR      R0,[R4, #+4]
   \   0000005C   0x1C40             ADDS     R0,R0,#+1
   \   0000005E   0x6060             STR      R0,[R4, #+4]
   1552                               break;
   1553          
   1554                          case MODBUS_ERR_FILE:
   1555                               pch->Err = MODBUS_ERR_FC21_02;
   1556                               MBS_ErrRespSet(pch,
   1557                                              MODBUS_ERR_ILLEGAL_DATA_ADDR);
   1558                               return (DEF_TRUE);                                    /* Tell caller that we need to send a response              */
   1559          
   1560                          case MODBUS_ERR_RECORD:
   1561                               pch->Err = MODBUS_ERR_FC21_03;
   1562                               MBS_ErrRespSet(pch,
   1563                                              MODBUS_ERR_ILLEGAL_DATA_ADDR);
   1564                               return (DEF_TRUE);                                    /* Tell caller that we need to send a response              */
   1565          
   1566                          case MODBUS_ERR_IX:
   1567                          default:
   1568                               pch->Err = MODBUS_ERR_FC21_04;
   1569                               MBS_ErrRespSet(pch,
   1570                                              MODBUS_ERR_ILLEGAL_DATA_ADDR);
   1571                               return (DEF_TRUE);                                    /* Tell caller that we need to send a response              */
   1572                      }
   1573                      ix++;
   \   00000060   0x1C76             ADDS     R6,R6,#+1
   1574                      record_len--;
   \   00000062   0x1E6D             SUBS     R5,R5,#+1
   \                     ??MBS_FC21_FileWr_3: (+1)
   \   00000064   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000066   0x2D00             CMP      R5,#+0
   \   00000068   0xD044             BEQ.N    ??MBS_FC21_FileWr_5
   \   0000006A   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   0000006E   0x0200             LSLS     R0,R0,#+8
   \   00000070   0xF119 0x0901      ADDS     R9,R9,#+1
   \   00000074   0xF899 0x1000      LDRB     R1,[R9, #+0]
   \   00000078   0x4308             ORRS     R0,R1,R0
   \   0000007A   0xF119 0x0901      ADDS     R9,R9,#+1
   \   0000007E   0xA902             ADD      R1,SP,#+8
   \   00000080   0x9101             STR      R1,[SP, #+4]
   \   00000082   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000084   0x9000             STR      R0,[SP, #+0]
   \   00000086   0x002B             MOVS     R3,R5
   \   00000088   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000008A   0x0032             MOVS     R2,R6
   \   0000008C   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000008E   0x4641             MOV      R1,R8
   \   00000090   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000092   0x0038             MOVS     R0,R7
   \   00000094   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000096   0x.... 0x....      BL       MB_FileWr
   \   0000009A   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD0DB             BEQ.N    ??MBS_FC21_FileWr_4
   \   000000A2   0xF640 0x71A1      MOVW     R1,#+4001
   \   000000A6   0x1A40             SUBS     R0,R0,R1
   \   000000A8   0xD002             BEQ.N    ??MBS_FC21_FileWr_6
   \   000000AA   0x1E40             SUBS     R0,R0,#+1
   \   000000AC   0xD009             BEQ.N    ??MBS_FC21_FileWr_7
   \   000000AE   0xE011             B.N      ??MBS_FC21_FileWr_8
   \                     ??MBS_FC21_FileWr_6: (+1)
   \   000000B0   0xF640 0x0036      MOVW     R0,#+2102
   \   000000B4   0x82E0             STRH     R0,[R4, #+22]
   \   000000B6   0x2102             MOVS     R1,#+2
   \   000000B8   0x0020             MOVS     R0,R4
   \   000000BA   0x.... 0x....      BL       MBS_ErrRespSet
   \   000000BE   0x2001             MOVS     R0,#+1
   \   000000C0   0xE035             B.N      ??MBS_FC21_FileWr_1
   \                     ??MBS_FC21_FileWr_7: (+1)
   \   000000C2   0xF640 0x0037      MOVW     R0,#+2103
   \   000000C6   0x82E0             STRH     R0,[R4, #+22]
   \   000000C8   0x2102             MOVS     R1,#+2
   \   000000CA   0x0020             MOVS     R0,R4
   \   000000CC   0x.... 0x....      BL       MBS_ErrRespSet
   \   000000D0   0x2001             MOVS     R0,#+1
   \   000000D2   0xE02C             B.N      ??MBS_FC21_FileWr_1
   \                     ??MBS_FC21_FileWr_8: (+1)
   \   000000D4   0xF640 0x0038      MOVW     R0,#+2104
   \   000000D8   0x82E0             STRH     R0,[R4, #+22]
   \   000000DA   0x2102             MOVS     R1,#+2
   \   000000DC   0x0020             MOVS     R0,R4
   \   000000DE   0x.... 0x....      BL       MBS_ErrRespSet
   \   000000E2   0x2001             MOVS     R0,#+1
   \   000000E4   0xE023             B.N      ??MBS_FC21_FileWr_1
   1575                  }
   1576              } else {
   1577                  pch->Err = MODBUS_ERR_FC21_05;
   \                     ??MBS_FC21_FileWr_2: (+1)
   \   000000E6   0xF640 0x0039      MOVW     R0,#+2105
   \   000000EA   0x82E0             STRH     R0,[R4, #+22]
   1578                  MBS_ErrRespSet(pch,
   1579                                 MODBUS_ERR_ILLEGAL_DATA_ADDR);
   \   000000EC   0x2102             MOVS     R1,#+2
   \   000000EE   0x0020             MOVS     R0,R4
   \   000000F0   0x.... 0x....      BL       MBS_ErrRespSet
   1580              }
   1581              record_len = ((CPU_INT16U)pch->RxFrameData[8] << 8) + (CPU_INT16U)pch->RxFrameData[9];    /* Get the record length                 */
   \                     ??MBS_FC21_FileWr_5: (+1)
   \   000000F4   0xF894 0x044C      LDRB     R0,[R4, #+1100]
   \   000000F8   0xF894 0x144D      LDRB     R1,[R4, #+1101]
   \   000000FC   0xEB11 0x2500      ADDS     R5,R1,R0, LSL #+8
   1582              pcmd       = &pch->RxFrameData[0];
   \   00000100   0xF204 0x4044      ADDW     R0,R4,#+1092
   1583              presp      = &pch->TxFrameData[0];                                     /* Point to first location in response buffer               */
   \   00000104   0xF204 0x614E      ADDW     R1,R4,#+1614
   1584              max        = (record_len * 2) + 9;
   \   00000108   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000010A   0x006A             LSLS     R2,R5,#+1
   \   0000010C   0x3209             ADDS     R2,R2,#+9
   1585              for (ix = 0; ix < max; ix++) {                                         /* Copy the request into the transmit packet                */
   \   0000010E   0x2600             MOVS     R6,#+0
   \   00000110   0xE004             B.N      ??MBS_FC21_FileWr_9
   1586                  *presp++ = *pcmd++;
   \                     ??MBS_FC21_FileWr_10: (+1)
   \   00000112   0x7803             LDRB     R3,[R0, #+0]
   \   00000114   0x700B             STRB     R3,[R1, #+0]
   \   00000116   0x1C40             ADDS     R0,R0,#+1
   \   00000118   0x1C49             ADDS     R1,R1,#+1
   1587              }
   \   0000011A   0x1C76             ADDS     R6,R6,#+1
   \                     ??MBS_FC21_FileWr_9: (+1)
   \   0000011C   0x0013             MOVS     R3,R2
   \   0000011E   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000120   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000122   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000124   0x429E             CMP      R6,R3
   \   00000126   0xD3F4             BCC.N    ??MBS_FC21_FileWr_10
   1588              pch->Err = MODBUS_ERR_NONE;
   \   00000128   0x2000             MOVS     R0,#+0
   \   0000012A   0x82E0             STRH     R0,[R4, #+22]
   1589              return (DEF_TRUE);                                                     /* Tell caller that we need to send a response              */
   \   0000012C   0x2001             MOVS     R0,#+1
   \                     ??MBS_FC21_FileWr_1: (+1)
   \   0000012E   0xE8BD 0x83FE      POP      {R1-R9,PC}       ;; return
   1590          }
   1591          #endif
   1592          #endif
   1593          
   1594          
   1595          /*******************************************************************************
   1596          *                                      READ DEVICE ID
   1597          *
   1598          * Description : Obtains the contents of the devide ID registers.
   1599          * Argument(s) : pch       Is a pointer to the Modbus channel's data structure.
   1600          *
   1601          * Return(s)   : TRUE      If a response needs to be sent
   1602          *               FALSE     If not
   1603          *******************************************************************************/
   1604          
   1605          #if MODBUS_CFG_SLAVE_EN > 0
   1606          #if MODBUS_FC43_EN  > 0
   1607          static  CPU_BOOLEAN  MBS_FC43_readDeviceID (MODBUS_CH  *pch)
   1608          {
   1609              CPU_INT08U    *presp;
   1610              CPU_INT16U     err;
   1611              CPU_INT16U     reg;
   1612              CPU_INT16U     nbr_regs;
   1613              CPU_INT16U     nbr_bytes;
   1614              CPU_INT16U     reg_val_16;
   1615          #if MODBUS_FP_EN > 0
   1616              CPU_INT08U     ix;
   1617              CPU_FP32       reg_val_fp;
   1618              CPU_INT08U    *pfp;
   1619          #endif
   1620          
   1621          /* Nbr of data bytes must be 3. */
   1622              if (pch->RxFrameNDataBytes != 3)
   1623              {
   1624                  return (DEF_FALSE);
   1625              }
   1626          
   1627              return(DEF_FALSE);// TODO REMOVE THIS ONCE CODE IS IMPLEMENTED
   1628          // SE TODO implement device ID code
   1629          
   1630              // check for MEI type
   1631          
   1632              // check Object ID
   1633          
   1634              // validate ID category
   1635          
   1636              // setup reply
   1637          
   1638              //1st 4 byte are same as request
   1639          
   1640              // build packect based on id category supported
   1641          }
   1642          #endif
   1643          #endif
   1644          
   1645          
   1646          /*******************************************************************************
   1647          *                                      SCATTERED READ
   1648          *
   1649          * Description : Obtains the contents of various registers.
   1650          * Argument(s) : pch       Is a pointer to the Modbus channel's data structure.
   1651          *
   1652          * Return(s)   : TRUE      If a response needs to be sent
   1653          *               FALSE     If not
   1654          *******************************************************************************/
   1655          
   1656          #if MODBUS_CFG_SLAVE_EN > 0
   1657          #if MODBUS_FC100_EN  > 0
   1658          static  CPU_BOOLEAN  MBS_FC100_scatteredRead (MODBUS_CH  *pch)
   1659          {
   1660              CPU_INT08U    *presp;
   1661              CPU_INT16U     err;
   1662              CPU_INT16U     reg;
   1663              CPU_INT16U     nbr_regs;
   1664              CPU_INT16U     nbr_bytes;
   1665              CPU_INT16U     reg_val_16;
   1666          #if MODBUS_FP_EN > 0
   1667              CPU_INT08U     ix;
   1668              CPU_FP32       reg_val_fp;
   1669              CPU_INT08U    *pfp;
   1670          #endif
   1671          
   1672          /* Nbr of data bytes must be Query data length + 5. */
   1673              if (pch->RxFrameNDataBytes != pch->RxFrameData[2] + MBS_FC100_DATA_BYTES )
   1674              {
   1675                  return (DEF_FALSE);
   1676              }
   1677          
   1678              return(DEF_FALSE);// TODO REMOVE THIS ONCE CODE IS IMPLEMENTED
   1679          
   1680          
   1681              // check for max number of reg
   1682          
   1683          
   1684          
   1685              // setup reply
   1686          
   1687              //1st 4 byte are same as request
   1688          
   1689              // build packect
   1690          }
   1691          #endif
   1692          #endif
   1693          
   1694          /*$PAGE*/
   1695          /*
   1696          *********************************************************************************************************
   1697          *                                            MBS_StatInit()
   1698          *
   1699          * Description : This function is used to initialize/reset the MODBUS statistics/communications counters.
   1700          *
   1701          * Argument(s) : pch      Is a pointer to the Modbus channel's data structure.
   1702          *
   1703          * Return(s)   : none.
   1704          *
   1705          * Caller(s)   : MB_Init()
   1706          *               MBS_FC08_Loopback()
   1707          *
   1708          * Note(s)     : none.
   1709          *********************************************************************************************************
   1710          */
   1711          
   1712          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED) && \
   1713              (MODBUS_CFG_FC08_EN  == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   1714          void  MBS_StatInit (MODBUS_CH  *pch)
   1715          {
   1716              pch->StatMsgCtr      = 0;                       /* Initialize all MODBUS event counters.                     */
   \                     MBS_StatInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x83C1             STRH     R1,[R0, #+30]
   1717              pch->StatCRCErrCtr   = 0;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x8401             STRH     R1,[R0, #+32]
   1718              pch->StatExceptCtr   = 0;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x8441             STRH     R1,[R0, #+34]
   1719              pch->StatSlaveMsgCtr = 0;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x8481             STRH     R1,[R0, #+36]
   1720              pch->StatNoRespCtr   = 0;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x84C1             STRH     R1,[R0, #+38]
   1721          }
   \   00000014   0x4770             BX       LR               ;; return
   1722          #endif
   1723          
   1724          /*
   1725          *********************************************************************************************************
   1726          *                                           MBS_RxTask()
   1727          *
   1728          * Description : Handle either Modbus ASCII or Modbus RTU received packets.
   1729          *
   1730          * Argument(s) : ch       Specifies the Modbus channel that needs servicing.
   1731          *
   1732          * Return(s)   : none.
   1733          *
   1734          * Caller(s)   : MB_RxTask()
   1735          *
   1736          * Note(s)     : none.
   1737          *********************************************************************************************************
   1738          */
   1739          
   1740          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   1741          void  MBS_RxTask (MODBUS_CH *pch)
   1742          {
   \                     MBS_RxTask: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1743              if (pch != (MODBUS_CH *)0) {
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD004             BEQ.N    ??MBS_RxTask_0
   1744          #if (MODBUS_CFG_ASCII_EN == DEF_ENABLED)
   1745                  if (pch->Mode == MODBUS_MODE_ASCII) {
   1746                      MBS_ASCII_Task(pch);
   1747                  }
   1748          #endif
   1749          
   1750          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)
   1751                  if (pch->Mode == MODBUS_MODE_RTU) {
   \   00000006   0x7CC1             LDRB     R1,[R0, #+19]
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD101             BNE.N    ??MBS_RxTask_0
   1752                      MBS_RTU_Task(pch);
   \   0000000C   0x.... 0x....      BL       MBS_RTU_Task
   1753                  }
   1754          #endif
   1755              }
   1756          }
   \                     ??MBS_RxTask_0: (+1)
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
   1757          #endif
   1758          
   1759          /*$PAGE*/
   1760          /*
   1761          *********************************************************************************************************
   1762          *                                           MBS_ASCII_Task()
   1763          *
   1764          * Description : Received a packet that should be encoded for Modbus ASCII mode.  Process request.
   1765          *
   1766          * Argument(s) : pch         Is a pointer to the Modbus channel's data structure.
   1767          *
   1768          * Return(s)   : none.
   1769          *
   1770          * Caller(s)   : MBS_RxTask()
   1771          *
   1772          * Note(s)     : none.
   1773          *********************************************************************************************************
   1774          */
   1775          
   1776          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED) && \
   1777              (MODBUS_CFG_ASCII_EN == DEF_ENABLED)
   1778          static  void  MBS_ASCII_Task (MODBUS_CH  *pch)
   1779          {
   1780              CPU_BOOLEAN   ok;
   1781              CPU_INT16U    calc_lrc;                               /* Used for LRC                                                    */
   1782              CPU_BOOLEAN   send_reply;
   1783          
   1784          
   1785              pch->StatMsgCtr++;
   1786              if (pch->RxBufByteCtr >= MODBUS_ASCII_MIN_MSG_SIZE) {
   1787                  ok = MB_ASCII_Rx(pch);                            /* Extract received command from .RxBuf[] & move to .RxFrameData[] */
   1788                  if (ok == DEF_TRUE) {
   1789                      calc_lrc = MB_ASCII_RxCalcLRC(pch);           /* Calculate LRC on received ASCII packet                          */
   1790                      if (calc_lrc != pch->RxFrameCRC) {            /* If sum of all data plus received LRC is not the same            */
   1791                          pch->StatCRCErrCtr++;                     /* then the frame was not received properly.                       */
   1792                          pch->StatNoRespCtr++;
   1793                          //COM_incDiaCtr(COM_BADCRC);
   1794                          //COM_incDiaCtr(COM_TIMEOUT);
   1795                      } else {
   1796                          send_reply = MBS_FCxx_Handler(pch);       /* Execute received command and formulate a response               */
   1797                          if (send_reply == DEF_TRUE) {
   1798                              MB_ASCII_Tx(pch);                     /* Send back reply.                                                */
   1799                          } else {
   1800                              pch->StatNoRespCtr++;
   1801                              //COM_incDiaCtr(COM_TIMEOUT);
   1802                          }
   1803                      }
   1804                  } else {
   1805                      pch->StatNoRespCtr++;
   1806                      //COM_incDiaCtr(COM_TIMEOUT);
   1807                  }
   1808              }
   1809              pch->RxBufByteCtr = 0;
   1810              pch->RxBufPtr     = &pch->RxBuf[0];
   1811          }
   1812          #endif
   1813          
   1814          
   1815          
   1816          /*$PAGE*/
   1817          /*
   1818          *********************************************************************************************************
   1819          *                                            MBS_RTU_Task()
   1820          *
   1821          * Description : This function processes a packet received on the Modbus channel assuming that it's an RTU
   1822          *               packet.
   1823          *
   1824          * Argument(s) : pch      Is a pointer to the Modbus channel's data structure.
   1825          *
   1826          * Return(s)   : none.
   1827          *
   1828          * Caller(s)   : MBS_RTU_Task().
   1829          *
   1830          * Note(s)     : none.
   1831          //redmorningcn:20180426  接收任务
   1832          //调整:1、将接收数据置调前，漏帧情况。
   1833          	   2、新增非modbus协议接口函数MBN_FCxx_Handler，可进行非modbus协议处理。数据=pch->RxFrameData+pch->RxFrameCRC，数据长度 = pch->RxFrameNDataBytes+2
   1834                 3、非modbus协议通过MODBUS_CFG_NOMODBUS_EN 控制是非支持modbus协议，DEF_ENABLED的为允许。
   1835          *********************************************************************************************************
   1836          */
   1837          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED) && \
   1838              (MODBUS_CFG_RTU_EN   == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   1839          static  void  MBS_RTU_Task (MODBUS_CH  *pch)
   1840          {
   \                     MBS_RTU_Task: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1841              CPU_BOOLEAN   ok;
   1842              CPU_INT16U    calc_crc;                            /* Used for CRC                                                    */
   1843              CPU_BOOLEAN   send_reply;
   1844          
   1845              pch->StatMsgCtr++;
   \   00000004   0x8BE0             LDRH     R0,[R4, #+30]
   \   00000006   0x1C40             ADDS     R0,R0,#+1
   \   00000008   0x83E0             STRH     R0,[R4, #+30]
   1846              if (pch->RxBufByteCtr >= MODBUS_RTU_MIN_MSG_SIZE) {
   \   0000000A   0x8E20             LDRH     R0,[R4, #+48]
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xDB2D             BLT.N    ??MBS_RTU_Task_0
   1847                  ok = MB_RTU_Rx(pch);                           /* Extract received command from .RxBuf[] & move to .RxFrameData[] */
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       MB_RTU_Rx
   1848          
   1849          		//redmorningcn	数据读取后，直接置标识位，便于后续数据接收。
   1850          		pch->RxBufByteCtr = 0;
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x8621             STRH     R1,[R4, #+48]
   1851          	    pch->RxBufPtr     = &pch->RxBuf[0];
   \   0000001A   0xF114 0x0138      ADDS     R1,R4,#+56
   \   0000001E   0x6361             STR      R1,[R4, #+52]
   1852          		
   1853                  if (ok == DEF_TRUE) {
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xD127             BNE.N    ??MBS_RTU_Task_1
   1854          			
   1855                  //redmorningcn 20180424  MB_RTU_RX（）完成MODBUS数据读取，数据存在于 pch->RxFrameData（不含crc校验）中，数据数据长度
   1856                  //pch->RxFrameNDataBytes（不含CRC校验），为适应扩展为非MODBUS协议，在此，将CRC也存放到pch->RxFrameData，长度pch->RxFrameNDataBytes+2
   1857          #if (MODBUS_CFG_NOMODBUS_EN == DEF_ENABLED)
   1858                  extern  CPU_BOOLEAN  MBN_FCxx_Handler (MODBUS_CH  *pch);
   1859          		send_reply = MBN_FCxx_Handler(pch);    /* 非MODBUS数据接收操作，数据=pch->RxFrameData+pch->RxFrameCRC，数据长度 = pch->RxFrameNDataBytes+2 */
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0x.... 0x....      BL       MBN_FCxx_Handler
   1860                  if( send_reply )                       //协议解析正确，后续不执行。                  
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD121             BNE.N    ??MBS_RTU_Task_2
   1861                      return;
   1862          #endif
   1863          	//redmorningcn 20180424
   1864          		
   1865          ////////////////////////////////////////////MODBUS协议
   1866          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED)
   1867          
   1868          #if (CVI_WORKBENCH == DEF_ENABLED)	
   1869          			CPU_INT08U     *pblock;					    //解决CVI的debug
   1870          			pblock =  &pch->RxFrameData[0];			    //解决CVI的debug （空幅值）		
   1871          #endif
   1872          			calc_crc = MB_RTU_RxCalcCRC(pch);          /* Do our own calculation of the CRC.                              */
   \                     ??MBS_RTU_Task_3: (+1)
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       MB_RTU_RxCalcCRC
   1873                      if (calc_crc != pch->RxFrameCRC) {         /* If the calculated CRC does not match the CRC received,          */
   \   00000038   0xF8B4 0x1646      LDRH     R1,[R4, #+1606]
   \   0000003C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000003E   0x4288             CMP      R0,R1
   \   00000040   0xD006             BEQ.N    ??MBS_RTU_Task_4
   1874                          pch->StatCRCErrCtr++;                  /* then the frame is bad.                                          */
   \   00000042   0x8C20             LDRH     R0,[R4, #+32]
   \   00000044   0x1C40             ADDS     R0,R0,#+1
   \   00000046   0x8420             STRH     R0,[R4, #+32]
   1875                          pch->StatNoRespCtr++;
   \   00000048   0x8CE0             LDRH     R0,[R4, #+38]
   \   0000004A   0x1C40             ADDS     R0,R0,#+1
   \   0000004C   0x84E0             STRH     R0,[R4, #+38]
   \   0000004E   0xE012             B.N      ??MBS_RTU_Task_1
   1876                          //COM_incDiaCtr(COM_BADCRC);
   1877                          //COM_incDiaCtr(COM_TIMEOUT);
   1878                      } else {
   1879                          send_reply = MBS_FCxx_Handler(pch);    /* Execute received command and formulate a response               */
   \                     ??MBS_RTU_Task_4: (+1)
   \   00000050   0x0020             MOVS     R0,R4
   \   00000052   0x.... 0x....      BL       MBS_FCxx_Handler
   1880                          if (send_reply == DEF_TRUE) {
   \   00000056   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000058   0x2801             CMP      R0,#+1
   \   0000005A   0xD103             BNE.N    ??MBS_RTU_Task_5
   1881                              MB_RTU_Tx(pch);                    /* Send back reply.                                                */
   \   0000005C   0x0020             MOVS     R0,R4
   \   0000005E   0x.... 0x....      BL       MB_RTU_Tx
   \   00000062   0xE008             B.N      ??MBS_RTU_Task_1
   1882                          } else {
   1883                              pch->StatNoRespCtr++;
   \                     ??MBS_RTU_Task_5: (+1)
   \   00000064   0x8CE0             LDRH     R0,[R4, #+38]
   \   00000066   0x1C40             ADDS     R0,R0,#+1
   \   00000068   0x84E0             STRH     R0,[R4, #+38]
   \   0000006A   0xE004             B.N      ??MBS_RTU_Task_1
   1884                              //COM_incDiaCtr(COM_TIMEOUT);
   1885                          }
   1886                      }
   1887                  }
   1888          #endif		
   1889              }
   1890          	else	   			//原无else
   1891          	{
   1892          	    pch->RxBufByteCtr = 0;
   \                     ??MBS_RTU_Task_0: (+1)
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x8620             STRH     R0,[R4, #+48]
   1893          	    pch->RxBufPtr     = &pch->RxBuf[0];
   \   00000070   0xF114 0x0038      ADDS     R0,R4,#+56
   \   00000074   0x6360             STR      R0,[R4, #+52]
   1894          	}
   1895          }
   \                     ??MBS_RTU_Task_1: (+1)
   \                     ??MBS_RTU_Task_2: (+1)
   \   00000076   0xBD10             POP      {R4,PC}          ;; return
   1896          #endif
   1897          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   MBS_ErrRespSet
      32   MBS_FC01_CoilRd
        32   -> MBS_ErrRespSet
        32   -> MB_CoilRd
      24   MBS_FC03_HoldingRegRd
        24   -> MBS_ErrRespSet
        24   -> MB_HoldingRegRd
      16   MBS_FC05_CoilWr
        16   -> MBS_ErrRespSet
        16   -> MB_CoilWr
      16   MBS_FC06_HoldingRegWr
        16   -> MBS_ErrRespSet
        16   -> MB_HoldingRegWr
       8   MBS_FC08_Loopback
         8   -> MBS_ErrRespSet
         8   -> MBS_StatInit
      32   MBS_FC15_CoilWrMultiple
        32   -> MBS_ErrRespSet
        32   -> MB_CoilWr
      24   MBS_FC16_HoldingRegWrMultiple
        24   -> MBS_ErrRespSet
        24   -> MB_HoldingRegWr
      40   MBS_FC20_FileRd
        40   -> MBS_ErrRespSet
        40   -> MB_FileRd
      40   MBS_FC21_FileWr
        40   -> MBS_ErrRespSet
        40   -> MB_FileWr
       8   MBS_FCxx_Handler
         8   -> MBS_ErrRespSet
         8   -> MBS_FC01_CoilRd
         8   -> MBS_FC03_HoldingRegRd
         8   -> MBS_FC05_CoilWr
         8   -> MBS_FC06_HoldingRegWr
         8   -> MBS_FC08_Loopback
         8   -> MBS_FC15_CoilWrMultiple
         8   -> MBS_FC16_HoldingRegWrMultiple
         8   -> MBS_FC20_FileRd
         8   -> MBS_FC21_FileWr
       8   MBS_RTU_Task
         8   -> MBN_FCxx_Handler
         8   -> MBS_FCxx_Handler
         8   -> MB_RTU_Rx
         8   -> MB_RTU_RxCalcCRC
         8   -> MB_RTU_Tx
       8   MBS_RxTask
         8   -> MBS_RTU_Task
       0   MBS_StatInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      38  MBS_ErrRespSet
     260  MBS_FC01_CoilRd
     186  MBS_FC03_HoldingRegRd
     174  MBS_FC05_CoilWr
     166  MBS_FC06_HoldingRegWr
     254  MBS_FC08_Loopback
     294  MBS_FC15_CoilWrMultiple
     254  MBS_FC16_HoldingRegWrMultiple
     328  MBS_FC20_FileRd
     306  MBS_FC21_FileWr
     270  MBS_FCxx_Handler
     120  MBS_RTU_Task
      18  MBS_RxTask
      22  MBS_StatInit

 
 2 690 bytes in section .text
 
 2 690 bytes of CODE memory

Errors: none
Warnings: none
