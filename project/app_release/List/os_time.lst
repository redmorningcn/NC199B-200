###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       11/Jul/2018  11:13:10
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC210\NC210-200处理板\source\Software\uCOS-III\Source\os_time.c
#    Command line =  
#        F:\iar\NC210\NC210-200处理板\source\Software\uCOS-III\Source\os_time.c
#        -D USE_STDPERIPH_DRIVER -D APP_RELEASE -lCN
#        F:\iar\NC210\NC210-200处理板\project\app_release\List -o
#        F:\iar\NC210\NC210-200处理板\project\app_release\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC210\NC210-200处理板\project\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\config\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\task\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\user\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\OS\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\Ports\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\driver\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-LIB\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Source\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\ST\STM32\inc\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Ports\STM32\STM32F103\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Source\
#        -Ol --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC210\NC210-200处理板\project\app_release\List\os_time.lst
#    Object file  =  
#        F:\iar\NC210\NC210-200处理板\project\app_release\Obj\os_time.o
#
###############################################################################

F:\iar\NC210\NC210-200处理板\source\Software\uCOS-III\Source\os_time.c
      1          /*
      2          ************************************************************************************************************************
      3          *                                                      uC/OS-III
      4          *                                                 The Real-Time Kernel
      5          *
      6          *                                  (c) Copyright 2009-2016; Micrium, Inc.; Weston, FL
      7          *                           All rights reserved.  Protected by international copyright laws.
      8          *
      9          *                                                   TIME MANAGEMENT
     10          *
     11          * File    : OS_TIME.C
     12          * By      : JJL
     13          * Version : V3.06.00
     14          *
     15          * LICENSING TERMS:
     16          * ---------------
     17          *           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or
     18          *           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
     19          *           product then, you need to contact Micrium to properly license uC/OS-III for its use in your
     20          *           application/product.   We provide ALL the source code for your convenience and to help you
     21          *           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use
     22          *           it commercially without paying a licensing fee.
     23          *
     24          *           Knowledge of the source code may NOT be used to develop a similar product.
     25          *
     26          *           Please help us continue to provide the embedded community with the finest software available.
     27          *           Your honesty is greatly appreciated.
     28          *
     29          *           You can find our product's user manual, API reference, release notes and
     30          *           more information at https://doc.micrium.com.
     31          *           You can contact us at www.micrium.com.
     32          ************************************************************************************************************************
     33          */
     34          
     35          #define  MICRIUM_SOURCE
     36          #include "os.h"
     37          
     38          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     39          const  CPU_CHAR  *os_time__c = "$Id: $";
     40          #endif
     41          
     42          /*
     43          ************************************************************************************************************************
     44          *                                                  DELAY TASK 'n' TICKS
     45          *
     46          * Description: This function is called to delay execution of the currently running task until the specified number of
     47          *              system ticks expires.  This, of course, directly equates to delaying the current task for some time to
     48          *              expire.  No delay will result if the specified delay is 0.  If the specified delay is greater than 0
     49          *              then, a context switch will result.
     50          *
     51          * Arguments  : dly       is a value in 'clock ticks' that the task will either delay for or, the target match value
     52          *                        of the tick counter (OSTickCtr).  Note that specifying 0 means the task is not to delay.
     53          *
     54          *                        depending on the option argument, the task will wake up when OSTickCtr reaches:
     55          *
     56          *                            OS_OPT_TIME_DLY      : OSTickCtr + dly
     57          *                            OS_OPT_TIME_TIMEOUT  : OSTickCtr + dly
     58          *                            OS_OPT_TIME_MATCH    : dly
     59          *                            OS_OPT_TIME_PERIODIC : OSTCBCurPtr->TickCtrPrev + dly
     60          *
     61          *              opt       specifies whether 'dly' represents absolute or relative time; default option marked with *** :
     62          *
     63          *                        *** OS_OPT_TIME_DLY        specifies a relative time from the current value of OSTickCtr.
     64          *                            OS_OPT_TIME_TIMEOUT    same as OS_OPT_TIME_DLY.
     65          *                            OS_OPT_TIME_MATCH      indicates that 'dly' specifies the absolute value that OSTickCtr
     66          *                                                   must reach before the task will be resumed.
     67          *                            OS_OPT_TIME_PERIODIC   indicates that 'dly' specifies the periodic value that OSTickCtr
     68          *                                                   must reach before the task will be resumed.
     69          *
     70          *              p_err     is a pointer to a variable that will contain an error code from this call.
     71          *
     72          *                            OS_ERR_NONE              The call was successful and the delay occurred
     73          *                            OS_ERR_OPT_INVALID       If you specified an invalid option for this function
     74          *                            OS_ERR_OS_NOT_RUNNING    If uC/OS-III is not running yet
     75          *                            OS_ERR_SCHED_LOCKED      Can't delay when the scheduler is locked
     76          *                            OS_ERR_TIME_DLY_ISR      If you called this function from an ISR
     77          *                            OS_ERR_TIME_ZERO_DLY     If you specified a delay of zero
     78          *
     79          * Returns    : none
     80          *
     81          * Note(s)    : none
     82          ************************************************************************************************************************
     83          */
     84          

   \                                 In section .text, align 2, keep-with-next
     85          void  OSTimeDly (OS_TICK   dly,
     86                           OS_OPT    opt,
     87                           OS_ERR   *p_err)
     88          {
   \                     OSTimeDly: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0014             MOVS     R4,R2
     89          #if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
     90              CPU_SR_ALLOC();
   \   00000008   0x2700             MOVS     R7,#+0
     91          #endif
     92          
     93          
     94          #ifdef OS_SAFETY_CRITICAL
     95              if (p_err == DEF_NULL) {
     96                  OS_SAFETY_CRITICAL_EXCEPTION();
     97                  return;
     98              }
     99          #endif
    100          
    101          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
    102              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
   \   0000000A   0x....             LDR.N    R0,??DataTable5
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD003             BEQ.N    ??OSTimeDly_0
    103                 *p_err = OS_ERR_TIME_DLY_ISR;
   \   00000012   0xF247 0x2075      MOVW     R0,#+29301
   \   00000016   0x8020             STRH     R0,[R4, #+0]
    104                  return;
   \   00000018   0xE03D             B.N      ??OSTimeDly_1
    105              }
    106          #endif
    107          
    108          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
    109              if (OSRunning != OS_STATE_OS_RUNNING) {
    110                 *p_err = OS_ERR_OS_NOT_RUNNING;
    111                  return;
    112              }
    113          #endif
    114          
    115              if (OSSchedLockNestingCtr > 0u) {                           /* Can't delay when the scheduler is locked             */
   \                     ??OSTimeDly_0: (+1)
   \   0000001A   0x....             LDR.N    R0,??DataTable5_1
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD003             BEQ.N    ??OSTimeDly_2
    116                 *p_err = OS_ERR_SCHED_LOCKED;
   \   00000022   0xF646 0x5063      MOVW     R0,#+28003
   \   00000026   0x8020             STRH     R0,[R4, #+0]
    117                  return;
   \   00000028   0xE035             B.N      ??OSTimeDly_1
    118              }
    119          
    120              switch (opt) {
   \                     ??OSTimeDly_2: (+1)
   \   0000002A   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000002C   0x0030             MOVS     R0,R6
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD005             BEQ.N    ??OSTimeDly_3
   \   00000032   0x2802             CMP      R0,#+2
   \   00000034   0xD003             BEQ.N    ??OSTimeDly_3
   \   00000036   0x2804             CMP      R0,#+4
   \   00000038   0xD01D             BEQ.N    ??OSTimeDly_4
   \   0000003A   0x2808             CMP      R0,#+8
   \   0000003C   0xD11C             BNE.N    ??OSTimeDly_5
    121                  case OS_OPT_TIME_DLY:
    122                  case OS_OPT_TIME_TIMEOUT:
    123                  case OS_OPT_TIME_PERIODIC:
    124                       if (dly == 0u) {                                   /* 0 means no delay!                                    */
   \                     ??OSTimeDly_3: (+1)
   \   0000003E   0x2D00             CMP      R5,#+0
   \   00000040   0xD103             BNE.N    ??OSTimeDly_6
    125                          *p_err = OS_ERR_TIME_ZERO_DLY;
   \   00000042   0xF247 0x207E      MOVW     R0,#+29310
   \   00000046   0x8020             STRH     R0,[R4, #+0]
    126                           return;
   \   00000048   0xE025             B.N      ??OSTimeDly_1
    127                       }
    128                       break;
    129          
    130                  case OS_OPT_TIME_MATCH:
    131                       break;
    132          
    133                  default:
    134                      *p_err = OS_ERR_OPT_INVALID;
    135                       return;
    136              }
    137          
    138          #if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
    139              CPU_CRITICAL_ENTER();
   \                     ??OSTimeDly_6: (+1)
   \                     ??OSTimeDly_7: (+1)
   \   0000004A   0x.... 0x....      BL       CPU_SR_Save
   \   0000004E   0x0007             MOVS     R7,R0
   \   00000050   0x.... 0x....      BL       CPU_IntDisMeasStart
    140              OS_TickListInsertDly(OSTCBCurPtr,
    141                                   dly,
    142                                   opt,
    143                                   p_err);
   \   00000054   0x0023             MOVS     R3,R4
   \   00000056   0x0032             MOVS     R2,R6
   \   00000058   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000005A   0x0029             MOVS     R1,R5
   \   0000005C   0x....             LDR.N    R0,??DataTable5_2
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0x.... 0x....      BL       OS_TickListInsertDly
    144              if (*p_err != OS_ERR_NONE) {
   \   00000064   0x8820             LDRH     R0,[R4, #+0]
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD00A             BEQ.N    ??OSTimeDly_8
    145                   CPU_CRITICAL_EXIT();
   \   0000006A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000006E   0x0038             MOVS     R0,R7
   \   00000070   0x.... 0x....      BL       CPU_SR_Restore
    146                   return;
   \   00000074   0xE00F             B.N      ??OSTimeDly_1
    147              }
   \                     ??OSTimeDly_4: (+1)
   \   00000076   0xE7E8             B.N      ??OSTimeDly_7
   \                     ??OSTimeDly_5: (+1)
   \   00000078   0xF645 0x6025      MOVW     R0,#+24101
   \   0000007C   0x8020             STRH     R0,[R4, #+0]
   \   0000007E   0xE00A             B.N      ??OSTimeDly_1
    148          
    149              OS_TRACE_TASK_DLY(dly);
    150              OS_RdyListRemove(OSTCBCurPtr);                              /* Remove current task from ready list                  */
   \                     ??OSTimeDly_8: (+1)
   \   00000080   0x....             LDR.N    R0,??DataTable5_2
   \   00000082   0x6800             LDR      R0,[R0, #+0]
   \   00000084   0x.... 0x....      BL       OS_RdyListRemove
    151              CPU_CRITICAL_EXIT();
   \   00000088   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000008C   0x0038             MOVS     R0,R7
   \   0000008E   0x.... 0x....      BL       CPU_SR_Restore
    152              OSSched();                                                  /* Find next task to run!                               */
   \   00000092   0x.... 0x....      BL       OSSched
    153          #endif
    154          }
   \                     ??OSTimeDly_1: (+1)
   \   00000096   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    155          
    156          
    157          /*
    158          ************************************************************************************************************************
    159          *                                             DELAY TASK FOR SPECIFIED TIME
    160          *
    161          * Description: This function is called to delay execution of the currently running task until some time expires.  This
    162          *              call allows you to specify the delay time in HOURS, MINUTES, SECONDS and MILLISECONDS instead of ticks.
    163          *
    164          * Arguments  : hours     specifies the number of hours that the task will be delayed (max. is 999 if the tick rate is
    165          *                        1000 Hz or less otherwise, a higher value would overflow a 32-bit unsigned counter).
    166          *
    167          *              minutes   specifies the number of minutes (max. 59 if 'opt' is OS_OPT_TIME_HMSM_STRICT)
    168          *
    169          *              seconds   specifies the number of seconds (max. 59 if 'opt' is OS_OPT_TIME_HMSM_STRICT)
    170          *
    171          *              milli     specifies the number of milliseconds (max. 999 if 'opt' is OS_OPT_TIME_HMSM_STRICT)
    172          *
    173          *              opt       specifies time delay bit-field options logically OR'd; default options marked with *** :
    174          *
    175          *                        *** OS_OPT_TIME_DLY        specifies a relative time from the current value of OSTickCtr.
    176          *                            OS_OPT_TIME_TIMEOUT    same as OS_OPT_TIME_DLY.
    177          *                            OS_OPT_TIME_MATCH      indicates that the delay specifies the absolute value that OSTickCtr
    178          *                                                   must reach before the task will be resumed.
    179          *                            OS_OPT_TIME_PERIODIC   indicates that the delay specifies the periodic value that OSTickCtr
    180          *                                                   must reach before the task will be resumed.
    181          *
    182          *                        *** OS_OPT_TIME_HMSM_STRICT            strictly allow only hours        (0...99)
    183          *                                                                                   minutes      (0...59)
    184          *                                                                                   seconds      (0...59)
    185          *                                                                                   milliseconds (0...999)
    186          *                            OS_OPT_TIME_HMSM_NON_STRICT        allow any value of  hours        (0...999)
    187          *                                                                                   minutes      (0...9999)
    188          *                                                                                   seconds      (0...65535)
    189          *                                                                                   milliseconds (0...4294967295)
    190          *
    191          *              p_err     is a pointer to a variable that will receive an error code from this call.
    192          *
    193          *                            OS_ERR_NONE                        If the function returns from the desired delay
    194          *                            OS_ERR_OPT_INVALID                 If you specified an invalid option for 'opt'
    195          *                            OS_ERR_OS_NOT_RUNNING              If uC/OS-III is not running yet
    196          *                            OS_ERR_SCHED_LOCKED                Can't delay when the scheduler is locked
    197          *                            OS_ERR_TIME_DLY_ISR                If called from an ISR
    198          *                            OS_ERR_TIME_INVALID_HOURS          If you didn't specify a valid value for 'hours'
    199          *                            OS_ERR_TIME_INVALID_MINUTES        If you didn't specify a valid value for 'minutes'
    200          *                            OS_ERR_TIME_INVALID_SECONDS        If you didn't specify a valid value for 'seconds'
    201          *                            OS_ERR_TIME_INVALID_MILLISECONDS   If you didn't specify a valid value for 'milli'
    202          *                            OS_ERR_TIME_ZERO_DLY               If hours, minutes, seconds and milli are all 0
    203          *
    204          * Returns    : none
    205          *
    206          * Note(s)    : 1) The resolution on the milliseconds depends on the tick rate.  For example, you can't do a 10 mS delay
    207          *                 if the ticker interrupts every 100 mS.  In this case, the delay would be set to 0.  The actual delay
    208          *                 is rounded to the nearest tick.
    209          *
    210          *              2) Although this function allows you to delay a task for many, many hours, it's not recommended to put
    211          *                 a task to sleep for that long.
    212          ************************************************************************************************************************
    213          */
    214          
    215          #if (OS_CFG_TIME_DLY_HMSM_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    216          void  OSTimeDlyHMSM (CPU_INT16U   hours,
    217                               CPU_INT16U   minutes,
    218                               CPU_INT16U   seconds,
    219                               CPU_INT32U   milli,
    220                               OS_OPT       opt,
    221                               OS_ERR      *p_err)
    222          {
   \                     OSTimeDlyHMSM: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    223          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
    224              CPU_BOOLEAN  opt_invalid;
    225              CPU_BOOLEAN  opt_non_strict;
    226          #endif
    227              OS_OPT       opt_time;
    228              OS_RATE_HZ   tick_rate;
    229              OS_TICK      ticks;
    230          #if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
    231              CPU_SR_ALLOC();
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0x9D07             LDR      R5,[SP, #+28]
    232          #endif
    233          
    234          
    235          
    236          #ifdef OS_SAFETY_CRITICAL
    237              if (p_err == DEF_NULL) {
    238                  OS_SAFETY_CRITICAL_EXCEPTION();
    239                  return;
    240              }
    241          #endif
    242          
    243          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
    244              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
   \   00000006   0x....             LDR.N    R4,??DataTable5
   \   00000008   0x7824             LDRB     R4,[R4, #+0]
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD003             BEQ.N    ??OSTimeDlyHMSM_0
    245                 *p_err = OS_ERR_TIME_DLY_ISR;
   \   0000000E   0xF247 0x2075      MOVW     R0,#+29301
   \   00000012   0x8028             STRH     R0,[R5, #+0]
    246                  return;
   \   00000014   0xE0B0             B.N      ??OSTimeDlyHMSM_1
    247              }
    248          #endif
    249          
    250          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
    251              if (OSRunning != OS_STATE_OS_RUNNING) {
    252                 *p_err = OS_ERR_OS_NOT_RUNNING;
    253                  return;
    254              }
    255          #endif
    256          
    257              if (OSSchedLockNestingCtr > 0u) {                           /* Can't delay when the scheduler is locked             */
   \                     ??OSTimeDlyHMSM_0: (+1)
   \   00000016   0x....             LDR.N    R4,??DataTable5_1
   \   00000018   0x7824             LDRB     R4,[R4, #+0]
   \   0000001A   0x2C00             CMP      R4,#+0
   \   0000001C   0xD003             BEQ.N    ??OSTimeDlyHMSM_2
    258                 *p_err = OS_ERR_SCHED_LOCKED;
   \   0000001E   0xF646 0x5063      MOVW     R0,#+28003
   \   00000022   0x8028             STRH     R0,[R5, #+0]
    259                  return;
   \   00000024   0xE0A8             B.N      ??OSTimeDlyHMSM_1
    260              }
   \                     ??OSTimeDlyHMSM_2: (+1)
   \   00000026   0x9C06             LDR      R4,[SP, #+24]
    261          
    262              opt_time = opt & OS_OPT_TIME_MASK;                          /* Retrieve time options only.                          */
   \   00000028   0xF014 0x060E      ANDS     R6,R4,#0xE
    263              switch (opt_time) {
   \   0000002C   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000002E   0x0037             MOVS     R7,R6
   \   00000030   0x2F00             CMP      R7,#+0
   \   00000032   0xD005             BEQ.N    ??OSTimeDlyHMSM_3
   \   00000034   0x2F02             CMP      R7,#+2
   \   00000036   0xD003             BEQ.N    ??OSTimeDlyHMSM_3
   \   00000038   0x2F04             CMP      R7,#+4
   \   0000003A   0xD017             BEQ.N    ??OSTimeDlyHMSM_4
   \   0000003C   0x2F08             CMP      R7,#+8
   \   0000003E   0xD116             BNE.N    ??OSTimeDlyHMSM_5
    264                  case OS_OPT_TIME_DLY:
    265                  case OS_OPT_TIME_TIMEOUT:
    266                  case OS_OPT_TIME_PERIODIC:
    267                       if (milli == 0u) {                                 /* Make sure we didn't specify a 0 delay                */
   \                     ??OSTimeDlyHMSM_3: (+1)
   \   00000040   0x2B00             CMP      R3,#+0
   \   00000042   0xD10C             BNE.N    ??OSTimeDlyHMSM_6
    268                           if (seconds == 0u) {
   \   00000044   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000046   0x2A00             CMP      R2,#+0
   \   00000048   0xD109             BNE.N    ??OSTimeDlyHMSM_6
    269                               if (minutes == 0u) {
   \   0000004A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000004C   0x2900             CMP      R1,#+0
   \   0000004E   0xD106             BNE.N    ??OSTimeDlyHMSM_6
    270                                   if (hours == 0u) {
   \   00000050   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD103             BNE.N    ??OSTimeDlyHMSM_6
    271                                      *p_err = OS_ERR_TIME_ZERO_DLY;
   \   00000056   0xF247 0x207E      MOVW     R0,#+29310
   \   0000005A   0x8028             STRH     R0,[R5, #+0]
    272                                       return;
   \   0000005C   0xE08C             B.N      ??OSTimeDlyHMSM_1
    273                                   }
    274                               }
    275                           }
    276                       }
    277                       break;
    278          
    279                  case OS_OPT_TIME_MATCH:
    280                       break;
    281          
    282                  default:
    283                      *p_err = OS_ERR_OPT_INVALID;
    284                       return;
    285              }
    286          
    287          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)                          /* Validate arguments to be within range                */
    288              opt_invalid = DEF_BIT_IS_SET_ANY(opt, ~OS_OPT_TIME_OPTS_MASK);
   \                     ??OSTimeDlyHMSM_6: (+1)
   \                     ??OSTimeDlyHMSM_7: (+1)
   \   0000005E   0xF64F 0x7CE1      MOVW     R12,#+65505
   \   00000062   0xEA14 0x0F0C      TST      R4,R12
   \   00000066   0xD106             BNE.N    ??OSTimeDlyHMSM_8
   \   00000068   0x2700             MOVS     R7,#+0
   \   0000006A   0xE005             B.N      ??OSTimeDlyHMSM_9
   \                     ??OSTimeDlyHMSM_4: (+1)
   \   0000006C   0xE7F7             B.N      ??OSTimeDlyHMSM_7
   \                     ??OSTimeDlyHMSM_5: (+1)
   \   0000006E   0xF645 0x6025      MOVW     R0,#+24101
   \   00000072   0x8028             STRH     R0,[R5, #+0]
   \   00000074   0xE080             B.N      ??OSTimeDlyHMSM_1
   \                     ??OSTimeDlyHMSM_8: (+1)
   \   00000076   0x2701             MOVS     R7,#+1
    289              if (opt_invalid == DEF_YES) {
   \                     ??OSTimeDlyHMSM_9: (+1)
   \   00000078   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000007A   0x2F01             CMP      R7,#+1
   \   0000007C   0xD103             BNE.N    ??OSTimeDlyHMSM_10
    290                 *p_err = OS_ERR_OPT_INVALID;
   \   0000007E   0xF645 0x6025      MOVW     R0,#+24101
   \   00000082   0x8028             STRH     R0,[R5, #+0]
    291                  return;
   \   00000084   0xE078             B.N      ??OSTimeDlyHMSM_1
    292              }
    293          
    294              opt_non_strict = DEF_BIT_IS_SET(opt, OS_OPT_TIME_HMSM_NON_STRICT);
   \                     ??OSTimeDlyHMSM_10: (+1)
   \   00000086   0xF3C4 0x1400      UBFX     R4,R4,#+4,#+1
   \   0000008A   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000008C   0xF014 0x0401      ANDS     R4,R4,#0x1
    295              if (opt_non_strict != DEF_YES) {
   \   00000090   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000092   0x2C01             CMP      R4,#+1
   \   00000094   0xD01B             BEQ.N    ??OSTimeDlyHMSM_11
    296                   if (milli   > 999u) {
   \   00000096   0xF5B3 0x7F7A      CMP      R3,#+1000
   \   0000009A   0xD303             BCC.N    ??OSTimeDlyHMSM_12
    297                      *p_err = OS_ERR_TIME_INVALID_MILLISECONDS;
   \   0000009C   0xF247 0x207B      MOVW     R0,#+29307
   \   000000A0   0x8028             STRH     R0,[R5, #+0]
    298                       return;
   \   000000A2   0xE069             B.N      ??OSTimeDlyHMSM_1
    299                   }
    300                   if (seconds > 59u) {
   \                     ??OSTimeDlyHMSM_12: (+1)
   \   000000A4   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000000A6   0x2A3C             CMP      R2,#+60
   \   000000A8   0xD303             BCC.N    ??OSTimeDlyHMSM_13
    301                      *p_err = OS_ERR_TIME_INVALID_SECONDS;
   \   000000AA   0xF247 0x207A      MOVW     R0,#+29306
   \   000000AE   0x8028             STRH     R0,[R5, #+0]
    302                       return;
   \   000000B0   0xE062             B.N      ??OSTimeDlyHMSM_1
    303                   }
    304                   if (minutes > 59u) {
   \                     ??OSTimeDlyHMSM_13: (+1)
   \   000000B2   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000B4   0x293C             CMP      R1,#+60
   \   000000B6   0xD303             BCC.N    ??OSTimeDlyHMSM_14
    305                      *p_err = OS_ERR_TIME_INVALID_MINUTES;
   \   000000B8   0xF247 0x2079      MOVW     R0,#+29305
   \   000000BC   0x8028             STRH     R0,[R5, #+0]
    306                       return;
   \   000000BE   0xE05B             B.N      ??OSTimeDlyHMSM_1
    307                   }
    308                   if (hours   > 99u) {
   \                     ??OSTimeDlyHMSM_14: (+1)
   \   000000C0   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000C2   0x2864             CMP      R0,#+100
   \   000000C4   0xD314             BCC.N    ??OSTimeDlyHMSM_15
    309                      *p_err = OS_ERR_TIME_INVALID_HOURS;
   \   000000C6   0xF247 0x2078      MOVW     R0,#+29304
   \   000000CA   0x8028             STRH     R0,[R5, #+0]
    310                       return;
   \   000000CC   0xE054             B.N      ??OSTimeDlyHMSM_1
    311                   }
    312              } else {
    313                   if (minutes > 9999u) {
   \                     ??OSTimeDlyHMSM_11: (+1)
   \   000000CE   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000D0   0xF242 0x7410      MOVW     R4,#+10000
   \   000000D4   0x42A1             CMP      R1,R4
   \   000000D6   0xD303             BCC.N    ??OSTimeDlyHMSM_16
    314                      *p_err = OS_ERR_TIME_INVALID_MINUTES;
   \   000000D8   0xF247 0x2079      MOVW     R0,#+29305
   \   000000DC   0x8028             STRH     R0,[R5, #+0]
    315                       return;
   \   000000DE   0xE04B             B.N      ??OSTimeDlyHMSM_1
    316                   }
    317                   if (hours   > 999u) {
   \                     ??OSTimeDlyHMSM_16: (+1)
   \   000000E0   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000E2   0xF5B0 0x7F7A      CMP      R0,#+1000
   \   000000E6   0xD303             BCC.N    ??OSTimeDlyHMSM_15
    318                      *p_err = OS_ERR_TIME_INVALID_HOURS;
   \   000000E8   0xF247 0x2078      MOVW     R0,#+29304
   \   000000EC   0x8028             STRH     R0,[R5, #+0]
    319                       return;
   \   000000EE   0xE043             B.N      ??OSTimeDlyHMSM_1
    320                   }
    321              }
    322          #endif
    323          
    324                                                                          /* Compute the total number of clock ticks required..   */
    325                                                                          /* .. (rounded to the nearest tick)                     */
    326              tick_rate = OSCfg_TickRate_Hz;
   \                     ??OSTimeDlyHMSM_15: (+1)
   \   000000F0   0x....             LDR.N    R4,??DataTable5_3
   \   000000F2   0x6824             LDR      R4,[R4, #+0]
    327              ticks     = ((((OS_TICK)hours * (OS_TICK)3600u) + ((OS_TICK)minutes * (OS_TICK)60u) + (OS_TICK)seconds) * tick_rate)
    328                        + ((tick_rate * ((OS_TICK)milli + ((OS_TICK)500u / tick_rate))) / (OS_TICK)1000u);
   \   000000F4   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000F6   0xF44F 0x6761      MOV      R7,#+3600
   \   000000FA   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000FC   0xF05F 0x0C3C      MOVS     R12,#+60
   \   00000100   0xFB0C 0xF101      MUL      R1,R12,R1
   \   00000104   0xFB07 0x1000      MLA      R0,R7,R0,R1
   \   00000108   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000010A   0x1810             ADDS     R0,R2,R0
   \   0000010C   0xF44F 0x71FA      MOV      R1,#+500
   \   00000110   0xFBB1 0xF1F4      UDIV     R1,R1,R4
   \   00000114   0x18C9             ADDS     R1,R1,R3
   \   00000116   0xFB01 0xF104      MUL      R1,R1,R4
   \   0000011A   0xF44F 0x727A      MOV      R2,#+1000
   \   0000011E   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   00000122   0xFB04 0x1700      MLA      R7,R4,R0,R1
    329          
    330              if (ticks > 0u) {
   \   00000126   0x2F00             CMP      R7,#+0
   \   00000128   0xD023             BEQ.N    ??OSTimeDlyHMSM_17
    331          #if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
    332                  CPU_CRITICAL_ENTER();
   \   0000012A   0x.... 0x....      BL       CPU_SR_Save
   \   0000012E   0x0004             MOVS     R4,R0
   \   00000130   0x.... 0x....      BL       CPU_IntDisMeasStart
    333                  OS_TickListInsertDly(OSTCBCurPtr,
    334                                       ticks,
    335                                       opt_time,
    336                                       p_err);
   \   00000134   0x002B             MOVS     R3,R5
   \   00000136   0x0032             MOVS     R2,R6
   \   00000138   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000013A   0x0039             MOVS     R1,R7
   \   0000013C   0x....             LDR.N    R0,??DataTable5_2
   \   0000013E   0x6800             LDR      R0,[R0, #+0]
   \   00000140   0x.... 0x....      BL       OS_TickListInsertDly
    337                  if (*p_err != OS_ERR_NONE) {
   \   00000144   0x8828             LDRH     R0,[R5, #+0]
   \   00000146   0x2800             CMP      R0,#+0
   \   00000148   0xD005             BEQ.N    ??OSTimeDlyHMSM_18
    338                       CPU_CRITICAL_EXIT();
   \   0000014A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000014E   0x0020             MOVS     R0,R4
   \   00000150   0x.... 0x....      BL       CPU_SR_Restore
    339                       return;
   \   00000154   0xE010             B.N      ??OSTimeDlyHMSM_1
    340                  }
    341          
    342                  OS_TRACE_TASK_DLY(ticks);
    343                  OS_RdyListRemove(OSTCBCurPtr);                          /* Remove current task from ready list                  */
   \                     ??OSTimeDlyHMSM_18: (+1)
   \   00000156   0x....             LDR.N    R0,??DataTable5_2
   \   00000158   0x6800             LDR      R0,[R0, #+0]
   \   0000015A   0x.... 0x....      BL       OS_RdyListRemove
    344                  CPU_CRITICAL_EXIT();
   \   0000015E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000162   0x0020             MOVS     R0,R4
   \   00000164   0x.... 0x....      BL       CPU_SR_Restore
    345                  OSSched();                                              /* Find next task to run!                               */
   \   00000168   0x.... 0x....      BL       OSSched
    346          #endif
    347                 *p_err = OS_ERR_NONE;
   \   0000016C   0x2000             MOVS     R0,#+0
   \   0000016E   0x8028             STRH     R0,[R5, #+0]
   \   00000170   0xE002             B.N      ??OSTimeDlyHMSM_19
    348              } else {
    349                 *p_err = OS_ERR_TIME_ZERO_DLY;
   \                     ??OSTimeDlyHMSM_17: (+1)
   \   00000172   0xF247 0x207E      MOVW     R0,#+29310
   \   00000176   0x8028             STRH     R0,[R5, #+0]
    350              }
    351          }
   \                     ??OSTimeDlyHMSM_19: (+1)
   \                     ??OSTimeDlyHMSM_1: (+1)
   \   00000178   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    352          #endif
    353          
    354          /*
    355          ************************************************************************************************************************
    356          *                                                RESUME A DELAYED TASK
    357          *
    358          * Description: This function is used resume a task that has been delayed through a call to either OSTimeDly() or
    359          *              OSTimeDlyHMSM().  Note that you cannot call this function to resume a task that is waiting for an event
    360          *              with timeout.
    361          *
    362          * Arguments  : p_tcb    is a pointer to the TCB of the task to resume.
    363          *
    364          *              p_err    is a pointer to a variable that will receive an error code
    365          *
    366          *                           OS_ERR_NONE                  Task has been resumed
    367          *                           OS_ERR_OS_NOT_RUNNING        If uC/OS-III is not running yet
    368          *                           OS_ERR_STATE_INVALID         Task is in an invalid state
    369          *                           OS_ERR_TASK_NOT_DLY          Task is not waiting for time to expire
    370          *                           OS_ERR_TASK_SUSPENDED        Task cannot be resumed, it was suspended by OSTaskSuspend()
    371          *                           OS_ERR_TCB_INVALID           If 'p_tcb' is a NULL pointer
    372          *                           OS_ERR_TIME_DLY_RESUME_ISR   If called from an ISR
    373          *
    374          * Returns    : none
    375          *
    376          * Note(s)    : none
    377          ************************************************************************************************************************
    378          */
    379          
    380          #if (OS_CFG_TIME_DLY_RESUME_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    381          void  OSTimeDlyResume (OS_TCB  *p_tcb,
    382                                 OS_ERR  *p_err)
    383          {
   \                     OSTimeDlyResume: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
    384              CPU_SR_ALLOC();
   \   00000006   0x2600             MOVS     R6,#+0
    385          
    386          
    387          
    388          #ifdef OS_SAFETY_CRITICAL
    389              if (p_err == DEF_NULL) {
    390                  OS_SAFETY_CRITICAL_EXCEPTION();
    391                  return;
    392              }
    393          #endif
    394          
    395          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
    396              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
   \   00000008   0x....             LDR.N    R0,??DataTable5
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD003             BEQ.N    ??OSTimeDlyResume_0
    397                 *p_err = OS_ERR_TIME_DLY_RESUME_ISR;
   \   00000010   0xF247 0x2076      MOVW     R0,#+29302
   \   00000014   0x8020             STRH     R0,[R4, #+0]
    398                  return;
   \   00000016   0xE04C             B.N      ??OSTimeDlyResume_1
    399              }
    400          #endif
    401          
    402          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)                          /* ---------------- VALIDATE ARGUMENTS ---------------- */
    403              if (p_tcb == DEF_NULL) {                                    /* User must supply a valid OS_TCB                      */
   \                     ??OSTimeDlyResume_0: (+1)
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD103             BNE.N    ??OSTimeDlyResume_2
    404                 *p_err = OS_ERR_TCB_INVALID;
   \   0000001C   0xF247 0x10AD      MOVW     R0,#+29101
   \   00000020   0x8020             STRH     R0,[R4, #+0]
    405                  return;
   \   00000022   0xE046             B.N      ??OSTimeDlyResume_1
    406              }
    407          #endif
    408          
    409          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
    410              if (OSRunning != OS_STATE_OS_RUNNING) {
    411                 *p_err = OS_ERR_OS_NOT_RUNNING;
    412                  return;
    413              }
    414          #endif
    415          
    416              CPU_CRITICAL_ENTER();
   \                     ??OSTimeDlyResume_2: (+1)
   \   00000024   0x.... 0x....      BL       CPU_SR_Save
   \   00000028   0x0006             MOVS     R6,R0
   \   0000002A   0x.... 0x....      BL       CPU_IntDisMeasStart
    417              switch (p_tcb->TaskState) {
   \   0000002E   0xF895 0x003E      LDRB     R0,[R5, #+62]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD00A             BEQ.N    ??OSTimeDlyResume_3
   \   00000036   0x2802             CMP      R0,#+2
   \   00000038   0xD008             BEQ.N    ??OSTimeDlyResume_3
   \   0000003A   0xD310             BCC.N    ??OSTimeDlyResume_4
   \   0000003C   0x2804             CMP      R0,#+4
   \   0000003E   0xD005             BEQ.N    ??OSTimeDlyResume_3
   \   00000040   0xD304             BCC.N    ??OSTimeDlyResume_3
   \   00000042   0x2806             CMP      R0,#+6
   \   00000044   0xD002             BEQ.N    ??OSTimeDlyResume_3
   \   00000046   0xD31B             BCC.N    ??OSTimeDlyResume_5
   \   00000048   0x2807             CMP      R0,#+7
   \   0000004A   0xD128             BNE.N    ??OSTimeDlyResume_6
    418                  case OS_TASK_STATE_RDY:                                 /* Cannot Abort delay if task is ready                  */
    419                  case OS_TASK_STATE_PEND:
    420                  case OS_TASK_STATE_PEND_TIMEOUT:
    421                  case OS_TASK_STATE_SUSPENDED:
    422                  case OS_TASK_STATE_PEND_SUSPENDED:
    423                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
    424                       CPU_CRITICAL_EXIT();
   \                     ??OSTimeDlyResume_3: (+1)
   \   0000004C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000050   0x0030             MOVS     R0,R6
   \   00000052   0x.... 0x....      BL       CPU_SR_Restore
    425                      *p_err = OS_ERR_TASK_NOT_DLY;
   \   00000056   0xF247 0x1051      MOVW     R0,#+29009
   \   0000005A   0x8020             STRH     R0,[R4, #+0]
    426                       break;
   \   0000005C   0xE027             B.N      ??OSTimeDlyResume_7
    427          
    428                  case OS_TASK_STATE_DLY:
    429                       p_tcb->TaskState = OS_TASK_STATE_RDY;
   \                     ??OSTimeDlyResume_4: (+1)
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xF885 0x003E      STRB     R0,[R5, #+62]
    430          #if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
    431                       OS_TickListRemove(p_tcb);                          /* Remove task from tick list                           */
   \   00000064   0x0028             MOVS     R0,R5
   \   00000066   0x.... 0x....      BL       OS_TickListRemove
    432                       OS_RdyListInsert(p_tcb);                           /* Add to ready list                                    */
   \   0000006A   0x0028             MOVS     R0,R5
   \   0000006C   0x.... 0x....      BL       OS_RdyListInsert
    433          #endif
    434                       CPU_CRITICAL_EXIT();
   \   00000070   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000074   0x0030             MOVS     R0,R6
   \   00000076   0x.... 0x....      BL       CPU_SR_Restore
    435                      *p_err = OS_ERR_NONE;
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x8020             STRH     R0,[R4, #+0]
    436                       break;
   \   0000007E   0xE016             B.N      ??OSTimeDlyResume_7
    437          
    438                  case OS_TASK_STATE_DLY_SUSPENDED:
    439                       p_tcb->TaskState = OS_TASK_STATE_SUSPENDED;
   \                     ??OSTimeDlyResume_5: (+1)
   \   00000080   0x2004             MOVS     R0,#+4
   \   00000082   0xF885 0x003E      STRB     R0,[R5, #+62]
    440          #if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
    441                       OS_TickListRemove(p_tcb);                          /* Remove task from tick list                           */
   \   00000086   0x0028             MOVS     R0,R5
   \   00000088   0x.... 0x....      BL       OS_TickListRemove
    442          #endif
    443                       CPU_CRITICAL_EXIT();
   \   0000008C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000090   0x0030             MOVS     R0,R6
   \   00000092   0x.... 0x....      BL       CPU_SR_Restore
    444                      *p_err            = OS_ERR_TASK_SUSPENDED;
   \   00000096   0xF247 0x105A      MOVW     R0,#+29018
   \   0000009A   0x8020             STRH     R0,[R4, #+0]
    445                       break;
   \   0000009C   0xE007             B.N      ??OSTimeDlyResume_7
    446          
    447                  default:
    448                       CPU_CRITICAL_EXIT();
   \                     ??OSTimeDlyResume_6: (+1)
   \   0000009E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000A2   0x0030             MOVS     R0,R6
   \   000000A4   0x.... 0x....      BL       CPU_SR_Restore
    449                      *p_err = OS_ERR_STATE_INVALID;
   \   000000A8   0xF646 0x602D      MOVW     R0,#+28205
   \   000000AC   0x8020             STRH     R0,[R4, #+0]
    450                       break;
    451              }
    452          
    453              OSSched();
   \                     ??OSTimeDlyResume_7: (+1)
   \   000000AE   0x.... 0x....      BL       OSSched
    454          }
   \                     ??OSTimeDlyResume_1: (+1)
   \   000000B2   0xBD70             POP      {R4-R6,PC}       ;; return
    455          #endif
    456          
    457          /*
    458          ************************************************************************************************************************
    459          *                                               GET CURRENT SYSTEM TIME
    460          *
    461          * Description: This function is used by your application to obtain the current value of the counter which keeps track of
    462          *              the number of clock ticks.
    463          *
    464          * Arguments  : p_err    is a pointer to a variable that will receive an error code
    465          *
    466          *                           OS_ERR_NONE           If the call was successful
    467          *
    468          * Returns    : The current value of OSTickCtr
    469          *
    470          * Note(s)    : none
    471          ************************************************************************************************************************
    472          */
    473          

   \                                 In section .text, align 2, keep-with-next
    474          OS_TICK  OSTimeGet (OS_ERR  *p_err)
    475          {
   \                     OSTimeGet: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    476              OS_TICK  ticks;
    477          #if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
    478              CPU_SR_ALLOC();
   \   00000004   0x2600             MOVS     R6,#+0
    479          #endif
    480          
    481          
    482          #ifdef OS_SAFETY_CRITICAL
    483              if (p_err == DEF_NULL) {
    484                  OS_SAFETY_CRITICAL_EXCEPTION();
    485                  return (0u);
    486              }
    487          #endif
    488          
    489          
    490          #if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
    491              CPU_CRITICAL_ENTER();
   \   00000006   0x.... 0x....      BL       CPU_SR_Save
   \   0000000A   0x0006             MOVS     R6,R0
   \   0000000C   0x.... 0x....      BL       CPU_IntDisMeasStart
    492          #if (OS_CFG_DYN_TICK_EN == DEF_ENABLED)
    493              if (OSRunning == OS_STATE_OS_RUNNING) {
    494                  ticks = BSP_OS_TickGet();
    495              } else {
    496                  ticks = OSTickCtr;
    497              }
    498          #else
    499              ticks = OSTickCtr;
   \   00000010   0x....             LDR.N    R0,??DataTable5_4
   \   00000012   0x6805             LDR      R5,[R0, #+0]
    500          #endif
    501              CPU_CRITICAL_EXIT();
   \   00000014   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000018   0x0030             MOVS     R0,R6
   \   0000001A   0x.... 0x....      BL       CPU_SR_Restore
    502          #else
    503              ticks = 0u;
    504          #endif
    505          
    506          
    507             *p_err = OS_ERR_NONE;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x8020             STRH     R0,[R4, #+0]
    508              return (ticks);
   \   00000022   0x0028             MOVS     R0,R5
   \   00000024   0xBD70             POP      {R4-R6,PC}       ;; return
    509          }
    510          
    511          /*
    512          ************************************************************************************************************************
    513          *                                                   SET SYSTEM CLOCK
    514          *
    515          * Description: This function sets the counter which keeps track of the number of clock ticks.
    516          *
    517          * Arguments  : ticks    is the desired tick value
    518          *
    519          *              p_err    is a pointer to a variable that will receive an error code
    520          *
    521          *                           OS_ERR_NONE           If the call was successful
    522          *
    523          * Returns    : none
    524          *
    525          * Note(s)    : none
    526          ************************************************************************************************************************
    527          */
    528          

   \                                 In section .text, align 2, keep-with-next
    529          void  OSTimeSet (OS_TICK   ticks,
    530                           OS_ERR   *p_err)
    531          {
   \                     OSTimeSet: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    532          #if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
    533              CPU_SR_ALLOC();
   \   00000006   0x2600             MOVS     R6,#+0
    534          #endif
    535          
    536          
    537          #ifdef OS_SAFETY_CRITICAL
    538              if (p_err == DEF_NULL) {
    539                  OS_SAFETY_CRITICAL_EXCEPTION();
    540                  return;
    541              }
    542          #endif
    543          
    544          #if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
    545              CPU_CRITICAL_ENTER();
   \   00000008   0x.... 0x....      BL       CPU_SR_Save
   \   0000000C   0x0006             MOVS     R6,R0
   \   0000000E   0x.... 0x....      BL       CPU_IntDisMeasStart
    546              OSTickCtr = ticks;
   \   00000012   0x....             LDR.N    R0,??DataTable5_4
   \   00000014   0x6004             STR      R4,[R0, #+0]
    547              CPU_CRITICAL_EXIT();
   \   00000016   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000001A   0x0030             MOVS     R0,R6
   \   0000001C   0x.... 0x....      BL       CPU_SR_Restore
    548          #endif
    549          
    550             *p_err     = OS_ERR_NONE;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x8028             STRH     R0,[R5, #+0]
    551          }
   \   00000024   0xBD70             POP      {R4-R6,PC}       ;; return
    552          
    553          
    554          /*
    555          ************************************************************************************************************************
    556          *                                                 PROCESS SYSTEM TICK
    557          *
    558          * Description: This function is used to signal to uC/OS-III the occurrence of a 'system tick' (also known as a
    559          *              'clock tick').  This function should be called by the tick ISR.
    560          *
    561          * Arguments  : none
    562          *
    563          * Returns    : none
    564          *
    565          * Note(s)    : none
    566          ************************************************************************************************************************
    567          */
    568          

   \                                 In section .text, align 2, keep-with-next
    569          void  OSTimeTick (void)
    570          {
   \                     OSTimeTick: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    571          #if ((OS_CFG_TASK_TICK_EN == DEF_ENABLED) || (OS_CFG_TMR_EN == DEF_ENABLED))
    572              OS_ERR  err;
    573          #endif
    574          
    575          
    576              if (OSRunning != OS_STATE_OS_RUNNING) {
   \   00000002   0x....             LDR.N    R0,??DataTable5_5
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD106             BNE.N    ??OSTimeTick_0
    577                  return;
    578              }
    579          
    580              OSTimeTickHook();                                           /* Call user definable hook                             */
   \                     ??OSTimeTick_1: (+1)
   \   0000000A   0x.... 0x....      BL       OSTimeTickHook
    581          
    582          #if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
    583          
    584             (void)OSTaskSemPost(&OSTickTaskTCB,                          /* Signal tick task                                     */
    585                                  OS_OPT_POST_NONE,
    586                                 &err);
   \   0000000E   0x466A             MOV      R2,SP
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x....             LDR.N    R0,??DataTable5_6
   \   00000014   0x.... 0x....      BL       OSTaskSemPost
    587          
    588          
    589          #if (OS_CFG_SCHED_ROUND_ROBIN_EN == DEF_ENABLED)
    590              OS_SchedRoundRobin(&OSRdyList[OSPrioCur]);
    591          #endif
    592          
    593          #if (OS_CFG_TMR_EN == DEF_ENABLED)
    594              OSTmrUpdateCtr--;
    595              if (OSTmrUpdateCtr == 0u) {
    596                  OSTmrUpdateCtr = OSTmrUpdateCnt;
    597                  (void)OSTaskSemPost(&OSTmrTaskTCB,                      /* Signal timer task                                    */
    598                                       OS_OPT_POST_NONE,
    599                                      &err);
    600              }
    601          #endif
    602          #endif
    603          }
   \                     ??OSTimeTick_0: (+1)
   \   00000018   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x........         DC32     OSCfg_TickRate_Hz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x........         DC32     OSTickCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x........         DC32     OSRunning

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x........         DC32     OSTickTaskTCB
    604          
    605          
    606          /*
    607          ************************************************************************************************************************
    608          *                                             PROCESS SYSTEM TICK (DYNAMIC)
    609          *
    610          * Description: This function is used to signal to uC/OS-III the occurrence of a 'system tick' (also known as a
    611          *              'clock tick').  This function should be called by the tick ISR.
    612          *
    613          * Arguments  : none
    614          *
    615          * Returns    : none
    616          *
    617          * Note(s)    : none
    618          ************************************************************************************************************************
    619          */
    620          
    621          #if (OS_CFG_DYN_TICK_EN == DEF_ENABLED)
    622          void OSTimeDynTick (OS_TICK ticks)
    623          {
    624              OS_ERR  err;
    625              CPU_SR_ALLOC();
    626          
    627          
    628              if (OSRunning != OS_STATE_OS_RUNNING) {
    629                  return;
    630              }
    631          
    632              OSTimeTickHook();
    633          
    634              CPU_CRITICAL_ENTER();
    635              OSTickCtrPend += ticks;
    636              CPU_CRITICAL_EXIT();
    637          
    638              (void)OSTaskSemPost(&OSTickTaskTCB,                          /* Signal tick task                                     */
    639                                   OS_OPT_POST_NONE,
    640                                  &err);
    641          
    642          }
    643          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   OSTimeDly
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OSSched
        24   -> OS_RdyListRemove
        24   -> OS_TickListInsertDly
      24   OSTimeDlyHMSM
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OSSched
        24   -> OS_RdyListRemove
        24   -> OS_TickListInsertDly
      16   OSTimeDlyResume
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> OSSched
        16   -> OS_RdyListInsert
        16   -> OS_TickListRemove
      16   OSTimeGet
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
      16   OSTimeSet
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
       8   OSTimeTick
         8   -> OSTaskSemPost
         8   -> OSTimeTickHook


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
     152  OSTimeDly
     378  OSTimeDlyHMSM
     180  OSTimeDlyResume
      38  OSTimeGet
      38  OSTimeSet
      26  OSTimeTick

 
 840 bytes in section .text
 
 840 bytes of CODE memory

Errors: none
Warnings: none
