###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       11/Jul/2018  11:13:10
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC210\NC210-200处理板\source\Software\uCOS-III\Source\os_task.c
#    Command line =  
#        F:\iar\NC210\NC210-200处理板\source\Software\uCOS-III\Source\os_task.c
#        -D USE_STDPERIPH_DRIVER -D APP_RELEASE -lCN
#        F:\iar\NC210\NC210-200处理板\project\app_release\List -o
#        F:\iar\NC210\NC210-200处理板\project\app_release\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC210\NC210-200处理板\project\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\config\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\task\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\user\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\OS\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\Ports\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\driver\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-LIB\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Source\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\ST\STM32\inc\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Ports\STM32\STM32F103\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Source\
#        -Ol --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC210\NC210-200处理板\project\app_release\List\os_task.lst
#    Object file  =  
#        F:\iar\NC210\NC210-200处理板\project\app_release\Obj\os_task.o
#
###############################################################################

F:\iar\NC210\NC210-200处理板\source\Software\uCOS-III\Source\os_task.c
      1          /*
      2          ************************************************************************************************************************
      3          *                                                      uC/OS-III
      4          *                                                 The Real-Time Kernel
      5          *
      6          *                                  (c) Copyright 2009-2016; Micrium, Inc.; Weston, FL
      7          *                           All rights reserved.  Protected by international copyright laws.
      8          *
      9          *                                                   TASK MANAGEMENT
     10          *
     11          * File    : OS_TASK.C
     12          * By      : JJL
     13          * Version : V3.06.00
     14          *
     15          * LICENSING TERMS:
     16          * ---------------
     17          *           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or
     18          *           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
     19          *           product then, you need to contact Micrium to properly license uC/OS-III for its use in your
     20          *           application/product.   We provide ALL the source code for your convenience and to help you
     21          *           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use
     22          *           it commercially without paying a licensing fee.
     23          *
     24          *           Knowledge of the source code may NOT be used to develop a similar product.
     25          *
     26          *           Please help us continue to provide the embedded community with the finest software available.
     27          *           Your honesty is greatly appreciated.
     28          *
     29          *           You can find our product's user manual, API reference, release notes and
     30          *           more information at https://doc.micrium.com.
     31          *           You can contact us at www.micrium.com.
     32          ************************************************************************************************************************
     33          */
     34          
     35          #define  MICRIUM_SOURCE
     36          #include "os.h"
     37          
     38          
     39          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     40          const  CPU_CHAR  *os_task__c = "$Id: $";
     41          #endif
     42          
     43          /*
     44          ************************************************************************************************************************
     45          *                                                CHANGE PRIORITY OF A TASK
     46          *
     47          * Description: This function allows you to change the priority of a task dynamically.  Note that the new
     48          *              priority MUST be available.
     49          *
     50          * Arguments  : p_tcb      is the TCB of the tack to change the priority for
     51          *
     52          *              prio_new   is the new priority
     53          *
     54          *              p_err      is a pointer to an error code returned by this function:
     55          *
     56          *                             OS_ERR_NONE                    Is the call was successful
     57          *                             OS_ERR_OS_NOT_RUNNING          If uC/OS-III is not running yet
     58          *                             OS_ERR_PRIO_INVALID            If the priority you specify is higher that the maximum allowed
     59          *                                                              (i.e. >= (OS_CFG_PRIO_MAX-1)) or already in use by a kernel
     60          *                                                              task
     61          *                             OS_ERR_STATE_INVALID           If the task is in an invalid state
     62          *                             OS_ERR_TASK_CHANGE_PRIO_ISR    If you tried to change the task's priority from an ISR
     63          *
     64          * Returns    : none
     65          *
     66          * Note(s)    : none
     67          ************************************************************************************************************************
     68          */
     69          
     70          #if (OS_CFG_TASK_CHANGE_PRIO_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
     71          void  OSTaskChangePrio (OS_TCB   *p_tcb,
     72                                  OS_PRIO   prio_new,
     73                                  OS_ERR   *p_err)
     74          {
   \                     OSTaskChangePrio: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0007             MOVS     R7,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0014             MOVS     R4,R2
     75          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
     76              OS_PRIO  prio_high;
     77          #endif
     78              CPU_SR_ALLOC();
   \   00000008   0x2600             MOVS     R6,#+0
     79          
     80          
     81          #ifdef OS_SAFETY_CRITICAL
     82              if (p_err == DEF_NULL) {
     83                  OS_SAFETY_CRITICAL_EXCEPTION();
     84                  return;
     85              }
     86          #endif
     87          
     88          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
     89              if ((p_tcb != DEF_NULL) && (p_tcb->TaskState == OS_TASK_STATE_DEL)) {
   \   0000000A   0x2F00             CMP      R7,#+0
   \   0000000C   0xD007             BEQ.N    ??OSTaskChangePrio_0
   \   0000000E   0xF897 0x003E      LDRB     R0,[R7, #+62]
   \   00000012   0x28FF             CMP      R0,#+255
   \   00000014   0xD103             BNE.N    ??OSTaskChangePrio_0
     90                 *p_err = OS_ERR_STATE_INVALID;
   \   00000016   0xF646 0x602D      MOVW     R0,#+28205
   \   0000001A   0x8020             STRH     R0,[R4, #+0]
     91                  return;
   \   0000001C   0xE04C             B.N      ??OSTaskChangePrio_1
     92              }
     93          #endif
     94          
     95          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
     96              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
   \                     ??OSTaskChangePrio_0: (+1)
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD003             BEQ.N    ??OSTaskChangePrio_2
     97                 *p_err = OS_ERR_TASK_CHANGE_PRIO_ISR;
   \   00000028   0xF247 0x1049      MOVW     R0,#+29001
   \   0000002C   0x8020             STRH     R0,[R4, #+0]
     98                  return;
   \   0000002E   0xE043             B.N      ??OSTaskChangePrio_1
     99              }
    100          #endif
    101          
    102              if (prio_new >= (OS_CFG_PRIO_MAX - 1u)) {                   /* Cannot set to Idle Task priority                     */
   \                     ??OSTaskChangePrio_2: (+1)
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x2D3F             CMP      R5,#+63
   \   00000034   0xD303             BCC.N    ??OSTaskChangePrio_3
    103                 *p_err = OS_ERR_PRIO_INVALID;
   \   00000036   0xF246 0x2073      MOVW     R0,#+25203
   \   0000003A   0x8020             STRH     R0,[R4, #+0]
    104                  return;
   \   0000003C   0xE03C             B.N      ??OSTaskChangePrio_1
    105              }
    106          
    107              CPU_CRITICAL_ENTER();
   \                     ??OSTaskChangePrio_3: (+1)
   \   0000003E   0x.... 0x....      BL       CPU_SR_Save
   \   00000042   0x0006             MOVS     R6,R0
   \   00000044   0x.... 0x....      BL       CPU_IntDisMeasStart
    108          
    109              if (p_tcb == DEF_NULL) {                                    /* Are we changing the priority of 'self'?              */
   \   00000048   0x2F00             CMP      R7,#+0
   \   0000004A   0xD110             BNE.N    ??OSTaskChangePrio_4
    110                  if (OSRunning != OS_STATE_OS_RUNNING) {
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000050   0x7800             LDRB     R0,[R0, #+0]
   \   00000052   0x2801             CMP      R0,#+1
   \   00000054   0xD008             BEQ.N    ??OSTaskChangePrio_5
    111                      CPU_CRITICAL_EXIT();
   \   00000056   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000005A   0x0030             MOVS     R0,R6
   \   0000005C   0x.... 0x....      BL       CPU_SR_Restore
    112                     *p_err = OS_ERR_OS_NOT_RUNNING;
   \   00000060   0xF645 0x6089      MOVW     R0,#+24201
   \   00000064   0x8020             STRH     R0,[R4, #+0]
    113                      return;
   \   00000066   0xE027             B.N      ??OSTaskChangePrio_1
    114                  }
    115                  p_tcb = OSTCBCurPtr;
   \                     ??OSTaskChangePrio_5: (+1)
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   0000006C   0x6807             LDR      R7,[R0, #+0]
    116              }
    117          
    118          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
    119              p_tcb->BasePrio = prio_new;                                 /* Update base priority                                 */
   \                     ??OSTaskChangePrio_4: (+1)
   \   0000006E   0xF887 0x5040      STRB     R5,[R7, #+64]
    120          
    121              if (p_tcb->MutexGrpHeadPtr != DEF_NULL) {                   /* Owning a mutex?                                      */
   \   00000072   0x6C78             LDR      R0,[R7, #+68]
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD00C             BEQ.N    ??OSTaskChangePrio_6
    122                  if (prio_new > p_tcb->Prio) {
   \   00000078   0xF897 0x003F      LDRB     R0,[R7, #+63]
   \   0000007C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000007E   0x42A8             CMP      R0,R5
   \   00000080   0xD207             BCS.N    ??OSTaskChangePrio_6
    123                      prio_high = OS_MutexGrpPrioFindHighest(p_tcb);
   \   00000082   0x0038             MOVS     R0,R7
   \   00000084   0x.... 0x....      BL       OS_MutexGrpPrioFindHighest
    124                      if (prio_new > prio_high) {
   \   00000088   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000008C   0x42A8             CMP      R0,R5
   \   0000008E   0xD200             BCS.N    ??OSTaskChangePrio_6
    125                          prio_new = prio_high;
   \   00000090   0x0005             MOVS     R5,R0
    126                      }
    127                  }
    128              }
    129          #endif
    130          
    131              OS_TaskChangePrio(p_tcb, prio_new);
   \                     ??OSTaskChangePrio_6: (+1)
   \   00000092   0x0029             MOVS     R1,R5
   \   00000094   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000096   0x0038             MOVS     R0,R7
   \   00000098   0x.... 0x....      BL       OS_TaskChangePrio
    132          
    133              OS_TRACE_TASK_PRIO_CHANGE(p_tcb, prio_new);
    134              CPU_CRITICAL_EXIT();
   \   0000009C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000A0   0x0030             MOVS     R0,R6
   \   000000A2   0x.... 0x....      BL       CPU_SR_Restore
    135          
    136              if (OSRunning == OS_STATE_OS_RUNNING) {
   \   000000A6   0x.... 0x....      LDR.W    R0,??DataTable14
   \   000000AA   0x7800             LDRB     R0,[R0, #+0]
   \   000000AC   0x2801             CMP      R0,#+1
   \   000000AE   0xD101             BNE.N    ??OSTaskChangePrio_7
    137                  OSSched();                                              /* Run highest priority task ready                      */
   \   000000B0   0x.... 0x....      BL       OSSched
    138              }
    139          
    140             *p_err = OS_ERR_NONE;
   \                     ??OSTaskChangePrio_7: (+1)
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0x8020             STRH     R0,[R4, #+0]
    141          }
   \                     ??OSTaskChangePrio_1: (+1)
   \   000000B8   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    142          #endif
    143          
    144          
    145          /*
    146          ************************************************************************************************************************
    147          *                                                    CREATE A TASK
    148          *
    149          * Description: This function is used to have uC/OS-III manage the execution of a task.  Tasks can either be created
    150          *              prior to the start of multitasking or by a running task.  A task cannot be created by an ISR.
    151          *
    152          * Arguments  : p_tcb          is a pointer to the task's TCB
    153          *
    154          *              p_name         is a pointer to an ASCII string to provide a name to the task.
    155          *
    156          *              p_task         is a pointer to the task's code
    157          *
    158          *              p_arg          is a pointer to an optional data area which can be used to pass parameters to
    159          *                             the task when the task first executes.  Where the task is concerned it thinks
    160          *                             it was invoked and passed the argument 'p_arg' as follows:
    161          *
    162          *                                 void Task (void *p_arg)
    163          *                                 {
    164          *                                     for (;;) {
    165          *                                         Task code;
    166          *                                     }
    167          *                                 }
    168          *
    169          *              prio           is the task's priority.  A unique priority MUST be assigned to each task and the
    170          *                             lower the number, the higher the priority.
    171          *
    172          *              p_stk_base     is a pointer to the base address of the stack (i.e. low address).
    173          *
    174          *              stk_limit      is the number of stack elements to set as 'watermark' limit for the stack.  This value
    175          *                             represents the number of CPU_STK entries left before the stack is full.  For example,
    176          *                             specifying 10% of the 'stk_size' value indicates that the stack limit will be reached
    177          *                             when the stack reaches 90% full.
    178          *
    179          *              stk_size       is the size of the stack in number of elements.  If CPU_STK is set to CPU_INT08U,
    180          *                             'stk_size' corresponds to the number of bytes available.  If CPU_STK is set to
    181          *                             CPU_INT16U, 'stk_size' contains the number of 16-bit entries available.  Finally, if
    182          *                             CPU_STK is set to CPU_INT32U, 'stk_size' contains the number of 32-bit entries
    183          *                             available on the stack.
    184          *
    185          *              q_size         is the maximum number of messages that can be sent to the task
    186          *
    187          *              time_quanta    amount of time (in ticks) for time slice when round-robin between tasks.  Specify 0 to use
    188          *                             the default.
    189          *
    190          *              p_ext          is a pointer to a user supplied memory location which is used as a TCB extension.
    191          *                             For example, this user memory can hold the contents of floating-point registers
    192          *                             during a context switch, the time each task takes to execute, the number of times
    193          *                             the task has been switched-in, etc.
    194          *
    195          *              opt            contains additional information (or options) about the behavior of the task.
    196          *                             See OS_OPT_TASK_xxx in OS.H.  Current choices are:
    197          *
    198          *                                 OS_OPT_TASK_NONE            No option selected
    199          *                                 OS_OPT_TASK_STK_CHK         Stack checking to be allowed for the task
    200          *                                 OS_OPT_TASK_STK_CLR         Clear the stack when the task is created
    201          *                                 OS_OPT_TASK_SAVE_FP         If the CPU has floating-point registers, save them
    202          *                                                             during a context switch.
    203          *                                 OS_OPT_TASK_NO_TLS          If the caller doesn't want or need TLS (Thread Local
    204          *                                                             Storage) support for the task.  If you do not include this
    205          *                                                             option, TLS will be supported by default.
    206          *
    207          *              p_err          is a pointer to an error code that will be set during this call.  The value pointer
    208          *                             to by 'p_err' can be:
    209          *
    210          *                                 OS_ERR_NONE                    If the function was successful
    211          *                                 OS_ERR_ILLEGAL_CREATE_RUN_TIME If you are trying to create the task after you called
    212          *                                                                   OSSafetyCriticalStart()
    213          *                                 OS_ERR_PRIO_INVALID            If the priority you specify is higher that the maximum
    214          *                                                                   allowed (i.e. >= OS_CFG_PRIO_MAX-1) or,
    215          *                                 OS_ERR_STAT_STK_SIZE_INVALID   If the stack was overflowed during stack init
    216          *                                 OS_ERR_STK_INVALID             If you specified a NULL pointer for 'p_stk_base'
    217          *                                 OS_ERR_STK_SIZE_INVALID        If you specified zero for the 'stk_size'
    218          *                                 OS_ERR_STK_LIMIT_INVALID       If you specified a 'stk_limit' greater than or equal
    219          *                                                                   to 'stk_size'
    220          *                                 OS_ERR_TASK_CREATE_ISR         If you tried to create a task from an ISR
    221          *                                 OS_ERR_TASK_INVALID            If you specified a NULL pointer for 'p_task'
    222          *                                 OS_ERR_TCB_INVALID             If you specified a NULL pointer for 'p_tcb'
    223          *
    224          * Returns    : none
    225          *
    226          * Note(s)    : 1) OSTaskCreate() will return with the error OS_ERR_STAT_STK_SIZE_INVALID when a stack overflow is detected
    227          *                 during stack initialization. In that specific case some memory may have been corrupted. It is
    228          *                 therefore recommended to treat OS_ERR_STAT_STK_SIZE_INVALID as a fatal error.
    229          ************************************************************************************************************************
    230          */
    231          

   \                                 In section .text, align 2, keep-with-next
    232          void  OSTaskCreate (OS_TCB        *p_tcb,
    233                              CPU_CHAR      *p_name,
    234                              OS_TASK_PTR    p_task,
    235                              void          *p_arg,
    236                              OS_PRIO        prio,
    237                              CPU_STK       *p_stk_base,
    238                              CPU_STK_SIZE   stk_limit,
    239                              CPU_STK_SIZE   stk_size,
    240                              OS_MSG_QTY     q_size,
    241                              OS_TICK        time_quanta,
    242                              void          *p_ext,
    243                              OS_OPT         opt,
    244                              OS_ERR        *p_err)
    245          {
   \                     OSTaskCreate: (+1)
   \   00000000   0xE92D 0x4FFA      PUSH     {R1,R3-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x0006             MOVS     R6,R0
   \   00000008   0x0017             MOVS     R7,R2
    246              CPU_STK_SIZE   i;
    247          #if (OS_CFG_TASK_REG_TBL_SIZE > 0u)
    248              OS_REG_ID      reg_nbr;
    249          #endif
    250          #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
    251              OS_TLS_ID      id;
    252          #endif
    253          
    254              CPU_STK       *p_sp;
    255              CPU_STK       *p_stk_limit;
    256              CPU_SR_ALLOC();
   \   0000000A   0x2400             MOVS     R4,#+0
   \   0000000C   0xF8DD 0xA058      LDR      R10,[SP, #+88]
    257          
    258          
    259          
    260          #ifdef OS_SAFETY_CRITICAL
    261              if (p_err == DEF_NULL) {
    262                  OS_SAFETY_CRITICAL_EXCEPTION();
    263                  return;
    264              }
    265          #endif
    266          
    267          #ifdef OS_SAFETY_CRITICAL_IEC61508
    268              if (OSSafetyCriticalStartFlag == DEF_TRUE) {
    269                 *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
    270                  return;
    271              }
    272          #endif
    273          
    274          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
    275              if (OSIntNestingCtr > 0u) {                                 /* --------- CANNOT CREATE A TASK FROM AN ISR --------- */
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD004             BEQ.N    ??OSTaskCreate_0
    276                  OS_TRACE_TASK_CREATE_FAILED(p_tcb);
    277                 *p_err = OS_ERR_TASK_CREATE_ISR;
   \   0000001A   0xF247 0x104A      MOVW     R0,#+29002
   \   0000001E   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    278                  return;
   \   00000022   0xE0BE             B.N      ??OSTaskCreate_1
    279              }
    280          #endif
    281          
    282          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)                          /* ---------------- VALIDATE ARGUMENTS ---------------- */
    283              if (p_tcb == DEF_NULL) {                                    /* User must supply a valid OS_TCB                      */
   \                     ??OSTaskCreate_0: (+1)
   \   00000024   0x2E00             CMP      R6,#+0
   \   00000026   0xD104             BNE.N    ??OSTaskCreate_2
    284                  OS_TRACE_TASK_CREATE_FAILED(p_tcb);
    285                 *p_err = OS_ERR_TCB_INVALID;
   \   00000028   0xF247 0x10AD      MOVW     R0,#+29101
   \   0000002C   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    286                  return;
   \   00000030   0xE0B7             B.N      ??OSTaskCreate_1
    287              }
    288              if (p_task == (OS_TASK_PTR)0u) {                            /* User must supply a valid task                        */
   \                     ??OSTaskCreate_2: (+1)
   \   00000032   0x0038             MOVS     R0,R7
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD104             BNE.N    ??OSTaskCreate_3
    289                  OS_TRACE_TASK_CREATE_FAILED(p_tcb);
    290                 *p_err = OS_ERR_TASK_INVALID;
   \   00000038   0xF247 0x104F      MOVW     R0,#+29007
   \   0000003C   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    291                  return;
   \   00000040   0xE0AF             B.N      ??OSTaskCreate_1
    292              }
   \                     ??OSTaskCreate_3: (+1)
   \   00000042   0xF8DD 0x803C      LDR      R8,[SP, #+60]
    293              if (p_stk_base == DEF_NULL) {                               /* User must supply a valid stack base address          */
   \   00000046   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000004A   0xD104             BNE.N    ??OSTaskCreate_4
    294                  OS_TRACE_TASK_CREATE_FAILED(p_tcb);
    295                 *p_err = OS_ERR_STK_INVALID;
   \   0000004C   0xF646 0x602F      MOVW     R0,#+28207
   \   00000050   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    296                  return;
   \   00000054   0xE0A5             B.N      ??OSTaskCreate_1
    297              }
   \                     ??OSTaskCreate_4: (+1)
   \   00000056   0xF8DD 0x9044      LDR      R9,[SP, #+68]
    298              if (stk_size < OSCfg_StkSizeMin) {                          /* User must supply a valid minimum stack size          */
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable15
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0x4581             CMP      R9,R0
   \   00000062   0xD204             BCS.N    ??OSTaskCreate_5
    299                  OS_TRACE_TASK_CREATE_FAILED(p_tcb);
    300                 *p_err = OS_ERR_STK_SIZE_INVALID;
   \   00000064   0xF646 0x6030      MOVW     R0,#+28208
   \   00000068   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    301                  return;
   \   0000006C   0xE099             B.N      ??OSTaskCreate_1
    302              }
   \                     ??OSTaskCreate_5: (+1)
   \   0000006E   0xF8DD 0xB040      LDR      R11,[SP, #+64]
    303              if (stk_limit >= stk_size) {                                /* User must supply a valid stack limit                 */
   \   00000072   0x45CB             CMP      R11,R9
   \   00000074   0xD304             BCC.N    ??OSTaskCreate_6
    304                  OS_TRACE_TASK_CREATE_FAILED(p_tcb);
    305                 *p_err = OS_ERR_STK_LIMIT_INVALID;
   \   00000076   0xF646 0x6031      MOVW     R0,#+28209
   \   0000007A   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    306                  return;
   \   0000007E   0xE090             B.N      ??OSTaskCreate_1
    307              }
   \                     ??OSTaskCreate_6: (+1)
   \   00000080   0x9C0E             LDR      R4,[SP, #+56]
    308              if ((prio  > (OS_CFG_PRIO_MAX - 2u)) &&                     /* Priority must be within 0 and OS_CFG_PRIO_MAX-1      */
    309                  (prio != (OS_CFG_PRIO_MAX - 1u))) {
   \   00000082   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000084   0x2C3F             CMP      R4,#+63
   \   00000086   0xD307             BCC.N    ??OSTaskCreate_7
   \   00000088   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000008A   0x2C3F             CMP      R4,#+63
   \   0000008C   0xD004             BEQ.N    ??OSTaskCreate_7
    310                  OS_TRACE_TASK_CREATE_FAILED(p_tcb);
    311                 *p_err = OS_ERR_PRIO_INVALID;
   \   0000008E   0xF246 0x2073      MOVW     R0,#+25203
   \   00000092   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    312                  return;
   \   00000096   0xE084             B.N      ??OSTaskCreate_1
    313              }
    314          #endif
    315          
    316              if (prio == (OS_CFG_PRIO_MAX - 1u)) {
   \                     ??OSTaskCreate_7: (+1)
   \   00000098   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000009A   0x2C3F             CMP      R4,#+63
   \   0000009C   0xD108             BNE.N    ??OSTaskCreate_8
    317          #if (OS_CFG_TASK_IDLE_EN == DEF_ENABLED)
    318                  if (p_tcb != &OSIdleTaskTCB) {
   \   0000009E   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   000000A2   0x4286             CMP      R6,R0
   \   000000A4   0xD004             BEQ.N    ??OSTaskCreate_8
    319                      OS_TRACE_TASK_CREATE_FAILED(p_tcb);
    320                     *p_err = OS_ERR_PRIO_INVALID;                        /* Not allowed to use same priority as idle task        */
   \   000000A6   0xF246 0x2073      MOVW     R0,#+25203
   \   000000AA   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    321                      return;
   \   000000AE   0xE078             B.N      ??OSTaskCreate_1
    322                  }
    323          #else
    324                  OS_TRACE_TASK_CREATE_FAILED(p_tcb);
    325                 *p_err = OS_ERR_PRIO_INVALID;                            /* Not allowed to use same priority as idle task        */
    326                  return;
    327          #endif
    328              }
    329          
    330              OS_TaskInitTCB(p_tcb);                                      /* Initialize the TCB to default values                 */
   \                     ??OSTaskCreate_8: (+1)
   \   000000B0   0x0030             MOVS     R0,R6
   \   000000B2   0x.... 0x....      BL       OS_TaskInitTCB
    331          
    332             *p_err = OS_ERR_NONE;
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0xF8AA 0x0000      STRH     R0,[R10, #+0]
   \   000000BC   0x9D15             LDR      R5,[SP, #+84]
    333                                                                          /* -------------- CLEAR THE TASK'S STACK -------------- */
    334              if (((opt & OS_OPT_TASK_STK_CHK) != 0u) ||                  /* See if stack checking has been enabled               */
    335                  ((opt & OS_OPT_TASK_STK_CLR) != 0u)) {                  /* See if stack needs to be cleared                     */
   \   000000BE   0x2103             MOVS     R1,#+3
   \   000000C0   0x420D             TST      R5,R1
   \   000000C2   0xD00B             BEQ.N    ??OSTaskCreate_9
    336                  if ((opt & OS_OPT_TASK_STK_CLR) != 0u) {
   \   000000C4   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000C6   0x07A8             LSLS     R0,R5,#+30
   \   000000C8   0xD508             BPL.N    ??OSTaskCreate_9
    337                      p_sp = p_stk_base;
   \   000000CA   0x4640             MOV      R0,R8
    338                      for (i = 0u; i < stk_size; i++) {                   /* Stack grows from HIGH to LOW memory                  */
   \   000000CC   0x2100             MOVS     R1,#+0
   \   000000CE   0xE003             B.N      ??OSTaskCreate_10
    339                         *p_sp = 0u;                                      /* Clear from bottom of stack and up!                   */
   \                     ??OSTaskCreate_11: (+1)
   \   000000D0   0x2200             MOVS     R2,#+0
   \   000000D2   0x6002             STR      R2,[R0, #+0]
    340                          p_sp++;
   \   000000D4   0x1D00             ADDS     R0,R0,#+4
    341                      }
   \   000000D6   0x1C49             ADDS     R1,R1,#+1
   \                     ??OSTaskCreate_10: (+1)
   \   000000D8   0x4549             CMP      R1,R9
   \   000000DA   0xD3F9             BCC.N    ??OSTaskCreate_11
    342                  }
    343              }
    344                                                                          /* ------ INITIALIZE THE STACK FRAME OF THE TASK ------ */
    345          #if (CPU_CFG_STK_GROWTH == CPU_STK_GROWTH_HI_TO_LO)
    346              p_stk_limit = p_stk_base + stk_limit;
   \                     ??OSTaskCreate_9: (+1)
   \   000000DC   0xEB18 0x0B8B      ADDS     R11,R8,R11, LSL #+2
    347          #else
    348              p_stk_limit = p_stk_base + (stk_size - 1u) - stk_limit;
    349          #endif
    350          
    351              p_sp = OSTaskStkInit(p_task,
    352                                   p_arg,
    353                                   p_stk_base,
    354                                   p_stk_limit,
    355                                   stk_size,
    356                                   opt);
   \   000000E0   0x0028             MOVS     R0,R5
   \   000000E2   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000E4   0x9001             STR      R0,[SP, #+4]
   \   000000E6   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \   000000EA   0x465B             MOV      R3,R11
   \   000000EC   0x4642             MOV      R2,R8
   \   000000EE   0x9904             LDR      R1,[SP, #+16]
   \   000000F0   0x0038             MOVS     R0,R7
   \   000000F2   0x.... 0x....      BL       OSTaskStkInit
    357          
    358          #if (CPU_CFG_STK_GROWTH == CPU_STK_GROWTH_HI_TO_LO)             /* Check if we overflown the stack during init          */
    359              if (p_sp < p_stk_base) {
   \   000000F6   0x4540             CMP      R0,R8
   \   000000F8   0xD204             BCS.N    ??OSTaskCreate_12
    360                 *p_err = OS_ERR_STAT_STK_SIZE_INVALID;
   \   000000FA   0xF646 0x602C      MOVW     R0,#+28204
   \   000000FE   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    361                  return;
   \   00000102   0xE04E             B.N      ??OSTaskCreate_1
    362              }
    363          #else
    364              if (p_sp > p_stk_base + stk_size) {
    365                 *p_err = OS_ERR_STAT_STK_SIZE_INVALID;
    366                  return;
    367              }
    368          #endif
    369          
    370          #if (OS_CFG_TASK_STK_REDZONE_EN == DEF_ENABLED)                 /* Initialize Redzoned stack                            */
    371              OS_TaskStkRedzoneInit(p_stk_base, stk_size);
    372          #endif
    373          
    374                                                                          /* ------------ INITIALIZE THE TCB FIELDS ------------- */
    375          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    376              p_tcb->TaskEntryAddr = p_task;                              /* Save task entry point address                        */
   \                     ??OSTaskCreate_12: (+1)
   \   00000104   0x62B7             STR      R7,[R6, #+40]
    377              p_tcb->TaskEntryArg  = p_arg;                               /* Save task entry argument                             */
   \   00000106   0x9904             LDR      R1,[SP, #+16]
   \   00000108   0x62F1             STR      R1,[R6, #+44]
    378          #endif
    379          
    380          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    381              p_tcb->NamePtr       = p_name;                              /* Save task name                                       */
   \   0000010A   0x9903             LDR      R1,[SP, #+12]
   \   0000010C   0x60B1             STR      R1,[R6, #+8]
    382          #else
    383              (void)p_name;
    384          #endif
    385          
    386              p_tcb->Prio          = prio;                                /* Save the task's priority                             */
   \   0000010E   0xF886 0x403F      STRB     R4,[R6, #+63]
    387          
    388          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
    389              p_tcb->BasePrio      = prio;                                /* Set the base priority                                */
   \   00000112   0xF886 0x4040      STRB     R4,[R6, #+64]
    390          #endif
    391          
    392              p_tcb->StkPtr        = p_sp;                                /* Save the new top-of-stack pointer                    */
   \   00000116   0x6030             STR      R0,[R6, #+0]
    393          #if ((OS_CFG_DBG_EN == DEF_ENABLED) || (OS_CFG_STAT_TASK_STK_CHK_EN == DEF_ENABLED))
    394              p_tcb->StkLimitPtr   = p_stk_limit;                         /* Save the stack limit pointer                         */
   \   00000118   0xF8C6 0xB00C      STR      R11,[R6, #+12]
    395          #endif
    396          
    397          #if (OS_CFG_SCHED_ROUND_ROBIN_EN == DEF_ENABLED)
    398              p_tcb->TimeQuanta    = time_quanta;                         /* Save the #ticks for time slice (0 means not sliced)  */
    399              if (time_quanta == 0u) {
    400                  p_tcb->TimeQuantaCtr = OSSchedRoundRobinDfltTimeQuanta;
    401              } else {
    402                  p_tcb->TimeQuantaCtr = time_quanta;
    403              }
    404          #else
    405              (void)time_quanta;
    406          #endif
    407          
    408              p_tcb->ExtPtr        = p_ext;                               /* Save pointer to TCB extension                        */
   \   0000011C   0x9814             LDR      R0,[SP, #+80]
   \   0000011E   0x6070             STR      R0,[R6, #+4]
    409          #if ((OS_CFG_DBG_EN == DEF_ENABLED) || (OS_CFG_STAT_TASK_STK_CHK_EN == DEF_ENABLED) || (OS_CFG_TASK_STK_REDZONE_EN == DEF_ENABLED))
    410              p_tcb->StkBasePtr    = p_stk_base;                          /* Save pointer to the base address of the stack        */
   \   00000120   0xF8C6 0x8024      STR      R8,[R6, #+36]
    411              p_tcb->StkSize       = stk_size;                            /* Save the stack size (in number of CPU_STK elements)  */
   \   00000124   0xF8C6 0x9048      STR      R9,[R6, #+72]
    412          #endif
    413              p_tcb->Opt           = opt;                                 /* Save task options                                    */
   \   00000128   0xF8A6 0x504C      STRH     R5,[R6, #+76]
    414          
    415          #if (OS_CFG_TASK_REG_TBL_SIZE > 0u)
    416              for (reg_nbr = 0u; reg_nbr < OS_CFG_TASK_REG_TBL_SIZE; reg_nbr++) {
   \   0000012C   0x2000             MOVS     R0,#+0
   \   0000012E   0xE005             B.N      ??OSTaskCreate_13
    417                  p_tcb->RegTbl[reg_nbr] = 0u;
   \                     ??OSTaskCreate_14: (+1)
   \   00000130   0x2100             MOVS     R1,#+0
   \   00000132   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000134   0xEB16 0x0280      ADDS     R2,R6,R0, LSL #+2
   \   00000138   0x6791             STR      R1,[R2, #+120]
    418              }
   \   0000013A   0x1C40             ADDS     R0,R0,#+1
   \                     ??OSTaskCreate_13: (+1)
   \   0000013C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000013E   0x2800             CMP      R0,#+0
   \   00000140   0xD0F6             BEQ.N    ??OSTaskCreate_14
    419          #endif
    420          
    421          #if (OS_CFG_TASK_Q_EN == DEF_ENABLED)
    422              OS_MsgQInit(&p_tcb->MsgQ,                                   /* Initialize the task's message queue                  */
    423                          q_size);
   \   00000142   0x9912             LDR      R1,[SP, #+72]
   \   00000144   0xF116 0x0068      ADDS     R0,R6,#+104
   \   00000148   0x.... 0x....      BL       OS_MsgQInit
    424          #else
    425              (void)q_size;
    426          #endif
    427          
    428              OSTaskCreateHook(p_tcb);                                    /* Call user defined hook                               */
   \   0000014C   0x0030             MOVS     R0,R6
   \   0000014E   0x.... 0x....      BL       OSTaskCreateHook
    429          
    430              OS_TRACE_TASK_CREATE(p_tcb);
    431              OS_TRACE_TASK_SEM_CREATE(p_tcb, p_name);
    432          #if (OS_CFG_TASK_Q_EN == DEF_ENABLED)
    433              OS_TRACE_TASK_MSG_Q_CREATE(&p_tcb->MsgQ, p_name);
    434          #endif
    435          
    436          #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
    437              for (id = 0u; id < OS_CFG_TLS_TBL_SIZE; id++) {
    438                  p_tcb->TLS_Tbl[id] = 0u;
    439              }
    440              OS_TLS_TaskCreate(p_tcb);                                   /* Call TLS hook                                        */
    441          #endif
    442                                                                          /* -------------- ADD TASK TO READY LIST -------------- */
    443              CPU_CRITICAL_ENTER();
   \   00000152   0x.... 0x....      BL       CPU_SR_Save
   \   00000156   0x0004             MOVS     R4,R0
   \   00000158   0x.... 0x....      BL       CPU_IntDisMeasStart
    444              OS_PrioInsert(p_tcb->Prio);
   \   0000015C   0xF896 0x003F      LDRB     R0,[R6, #+63]
   \   00000160   0x.... 0x....      BL       OS_PrioInsert
    445              OS_RdyListInsertTail(p_tcb);
   \   00000164   0x0030             MOVS     R0,R6
   \   00000166   0x.... 0x....      BL       OS_RdyListInsertTail
    446          
    447          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    448              OS_TaskDbgListAdd(p_tcb);
   \   0000016A   0x0030             MOVS     R0,R6
   \   0000016C   0x.... 0x....      BL       OS_TaskDbgListAdd
    449          #endif
    450          
    451              OSTaskQty++;                                                /* Increment the #tasks counter                         */
   \   00000170   0x.... 0x....      LDR.W    R0,??DataTable15_2
   \   00000174   0x8800             LDRH     R0,[R0, #+0]
   \   00000176   0x1C40             ADDS     R0,R0,#+1
   \   00000178   0x.... 0x....      LDR.W    R1,??DataTable15_2
   \   0000017C   0x8008             STRH     R0,[R1, #+0]
    452          
    453              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Return if multitasking has not started               */
   \   0000017E   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000182   0x7800             LDRB     R0,[R0, #+0]
   \   00000184   0x2801             CMP      R0,#+1
   \   00000186   0xD005             BEQ.N    ??OSTaskCreate_15
    454                  CPU_CRITICAL_EXIT();
   \   00000188   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000018C   0x0020             MOVS     R0,R4
   \   0000018E   0x.... 0x....      BL       CPU_SR_Restore
    455                  return;
   \   00000192   0xE006             B.N      ??OSTaskCreate_1
    456              }
    457          
    458              CPU_CRITICAL_EXIT();
   \                     ??OSTaskCreate_15: (+1)
   \   00000194   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000198   0x0020             MOVS     R0,R4
   \   0000019A   0x.... 0x....      BL       CPU_SR_Restore
    459          
    460              OSSched();
   \   0000019E   0x.... 0x....      BL       OSSched
    461          }
   \                     ??OSTaskCreate_1: (+1)
   \   000001A2   0xB005             ADD      SP,SP,#+20
   \   000001A4   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    462          
    463          
    464          /*
    465          ************************************************************************************************************************
    466          *                                                     DELETE A TASK
    467          *
    468          * Description: This function allows you to delete a task.  The calling task can delete itself by specifying a NULL
    469          *              pointer for 'p_tcb'.  The deleted task is returned to the dormant state and can be re-activated by
    470          *              creating the deleted task again.
    471          *
    472          * Arguments  : p_tcb      is the TCB of the tack to delete
    473          *
    474          *              p_err      is a pointer to an error code returned by this function:
    475          *
    476          *                             OS_ERR_NONE                    If the call is successful
    477          *                             OS_ERR_ILLEGAL_DEL_RUN_TIME    If you are trying to delete the task after you called
    478          *                                                              OSStart()
    479          *                             OS_ERR_OS_NOT_RUNNING          If uC/OS-III is not running yet
    480          *                             OS_ERR_STATE_INVALID           If the state of the task is invalid
    481          *                             OS_ERR_TASK_DEL_IDLE           If you attempted to delete uC/OS-III's idle task
    482          *                             OS_ERR_TASK_DEL_INVALID        If you attempted to delete uC/OS-III's ISR handler task
    483          *                             OS_ERR_TASK_DEL_ISR            If you tried to delete a task from an ISR
    484          *
    485          * Returns    : none
    486          *
    487          * Note(s)    : 1) 'p_err' gets set to OS_ERR_NONE before OSSched() to allow the returned err or code to be monitored even
    488          *                 for a task that is deleting itself. In this case, 'p_err' MUST point to a global variable that can be
    489          *                 accessed by another task.
    490          ************************************************************************************************************************
    491          */
    492          
    493          #if (OS_CFG_TASK_DEL_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    494          void  OSTaskDel (OS_TCB  *p_tcb,
    495                           OS_ERR  *p_err)
    496          {
   \                     OSTaskDel: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000C             MOVS     R4,R1
    497          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
    498              OS_TCB   *p_tcb_owner;
    499              OS_PRIO   prio_new;
    500          #endif
    501              CPU_SR_ALLOC();
   \   00000008   0x2600             MOVS     R6,#+0
    502          
    503          
    504          #ifdef OS_SAFETY_CRITICAL
    505              if (p_err == DEF_NULL) {
    506                  OS_SAFETY_CRITICAL_EXCEPTION();
    507                  return;
    508              }
    509          #endif
    510          
    511          #ifdef OS_SAFETY_CRITICAL_IEC61508
    512              if (OSSafetyCriticalStartFlag == DEF_TRUE) {
    513                 *p_err = OS_ERR_ILLEGAL_DEL_RUN_TIME;
    514                  return;
    515              }
    516          #endif
    517          
    518          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
    519              if (OSIntNestingCtr > 0u) {                                 /* See if trying to delete from ISR                     */
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable13
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD003             BEQ.N    ??OSTaskDel_0
    520                 *p_err = OS_ERR_TASK_DEL_ISR;
   \   00000014   0xF247 0x104E      MOVW     R0,#+29006
   \   00000018   0x8020             STRH     R0,[R4, #+0]
    521                  return;
   \   0000001A   0xE054             B.N      ??OSTaskDel_1
    522              }
    523          #endif
    524          
    525          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
    526              if (OSRunning != OS_STATE_OS_RUNNING) {
    527                 *p_err = OS_ERR_OS_NOT_RUNNING;
    528                  return;
    529              }
    530          #endif
    531          
    532          #if (OS_CFG_TASK_IDLE_EN == DEF_ENABLED)
    533              if (p_tcb == &OSIdleTaskTCB) {                              /* Not allowed to delete the idle task                  */
   \                     ??OSTaskDel_0: (+1)
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   00000020   0x4285             CMP      R5,R0
   \   00000022   0xD103             BNE.N    ??OSTaskDel_2
    534                 *p_err = OS_ERR_TASK_DEL_IDLE;
   \   00000024   0xF247 0x104C      MOVW     R0,#+29004
   \   00000028   0x8020             STRH     R0,[R4, #+0]
    535                  return;
   \   0000002A   0xE04C             B.N      ??OSTaskDel_1
    536              }
    537          #endif
    538          
    539              if (p_tcb == DEF_NULL) {                                    /* Delete 'Self'?                                       */
   \                     ??OSTaskDel_2: (+1)
   \   0000002C   0x2D00             CMP      R5,#+0
   \   0000002E   0xD10C             BNE.N    ??OSTaskDel_3
    540                  CPU_CRITICAL_ENTER();
   \   00000030   0x.... 0x....      BL       CPU_SR_Save
   \   00000034   0x0006             MOVS     R6,R0
   \   00000036   0x.... 0x....      BL       CPU_IntDisMeasStart
    541                  p_tcb  = OSTCBCurPtr;                                   /* Yes.                                                 */
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   0000003E   0x6805             LDR      R5,[R0, #+0]
    542                  CPU_CRITICAL_EXIT();
   \   00000040   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000044   0x0030             MOVS     R0,R6
   \   00000046   0x.... 0x....      BL       CPU_SR_Restore
    543              }
    544          
    545              CPU_CRITICAL_ENTER();
   \                     ??OSTaskDel_3: (+1)
   \   0000004A   0x.... 0x....      BL       CPU_SR_Save
   \   0000004E   0x0006             MOVS     R6,R0
   \   00000050   0x.... 0x....      BL       CPU_IntDisMeasStart
    546              switch (p_tcb->TaskState) {
   \   00000054   0xF895 0x003E      LDRB     R0,[R5, #+62]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD00B             BEQ.N    ??OSTaskDel_4
   \   0000005C   0x2802             CMP      R0,#+2
   \   0000005E   0xD039             BEQ.N    ??OSTaskDel_5
   \   00000060   0xD334             BCC.N    ??OSTaskDel_6
   \   00000062   0x2804             CMP      R0,#+4
   \   00000064   0xD031             BEQ.N    ??OSTaskDel_7
   \   00000066   0xD335             BCC.N    ??OSTaskDel_5
   \   00000068   0x2806             CMP      R0,#+6
   \   0000006A   0xD033             BEQ.N    ??OSTaskDel_5
   \   0000006C   0xD32E             BCC.N    ??OSTaskDel_6
   \   0000006E   0x2807             CMP      R0,#+7
   \   00000070   0xD030             BEQ.N    ??OSTaskDel_5
   \   00000072   0xE07F             B.N      ??OSTaskDel_8
    547                  case OS_TASK_STATE_RDY:
    548                       OS_RdyListRemove(p_tcb);
   \                     ??OSTaskDel_4: (+1)
   \   00000074   0x0028             MOVS     R0,R5
   \   00000076   0x.... 0x....      BL       OS_RdyListRemove
    549                       break;
    550          
    551                  case OS_TASK_STATE_SUSPENDED:
    552                       break;
    553          
    554                  case OS_TASK_STATE_DLY:                                 /* Task is only delayed, not on any wait list           */
    555                  case OS_TASK_STATE_DLY_SUSPENDED:
    556          #if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
    557                       OS_TickListRemove(p_tcb);
    558          #endif
    559                       break;
    560          
    561                  case OS_TASK_STATE_PEND:
    562                  case OS_TASK_STATE_PEND_SUSPENDED:
    563                  case OS_TASK_STATE_PEND_TIMEOUT:
    564                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
    565                       switch (p_tcb->PendOn) {                           /* See what we are pending on                           */
    566                           case OS_TASK_PEND_ON_NOTHING:
    567                           case OS_TASK_PEND_ON_TASK_Q:                   /* There is no wait list for these two                  */
    568                           case OS_TASK_PEND_ON_TASK_SEM:
    569                                break;
    570          
    571                           case OS_TASK_PEND_ON_FLAG:                     /* Remove from pend list                                */
    572                           case OS_TASK_PEND_ON_Q:
    573                           case OS_TASK_PEND_ON_SEM:
    574                                OS_PendListRemove(p_tcb);
    575                                break;
    576          
    577          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
    578                           case OS_TASK_PEND_ON_MUTEX:
    579                                p_tcb_owner = ((OS_MUTEX *)p_tcb->PendObjPtr)->OwnerTCBPtr;
    580                                prio_new = p_tcb_owner->Prio;
    581                                OS_PendListRemove(p_tcb);
    582                                if ((p_tcb_owner->Prio != p_tcb_owner->BasePrio) &&
    583                                    (p_tcb_owner->Prio == p_tcb->Prio)) { /* Has the owner inherited a priority?                  */
    584                                    prio_new = OS_MutexGrpPrioFindHighest(p_tcb_owner);
    585                                    prio_new = (prio_new > p_tcb_owner->BasePrio) ? p_tcb_owner->BasePrio : prio_new;
    586                                }
    587                                p_tcb->PendOn = OS_TASK_PEND_ON_NOTHING;
    588          
    589                                if (prio_new != p_tcb_owner->Prio) {
    590                                    OS_TaskChangePrio(p_tcb_owner, prio_new);
    591                                    OS_TRACE_MUTEX_TASK_PRIO_DISINHERIT(p_tcb_owner, p_tcb_owner->Prio);
    592                                }
    593                                break;
    594          #endif
    595          
    596                           default:
    597                                break;
    598                       }
    599          #if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
    600                       if ((p_tcb->TaskState == OS_TASK_STATE_PEND_TIMEOUT) ||
    601                           (p_tcb->TaskState == OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED)) {
    602                           OS_TickListRemove(p_tcb);
    603                       }
    604          #endif
    605                       break;
    606          
    607                  default:
    608                      CPU_CRITICAL_EXIT();
    609                     *p_err = OS_ERR_STATE_INVALID;
    610                      return;
    611              }
    612          
    613          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
    614              if(p_tcb->MutexGrpHeadPtr != DEF_NULL) {
   \                     ??OSTaskDel_9: (+1)
   \   0000007A   0x6C68             LDR      R0,[R5, #+68]
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD002             BEQ.N    ??OSTaskDel_10
    615                  OS_MutexGrpPostAll(p_tcb);
   \   00000080   0x0028             MOVS     R0,R5
   \   00000082   0x.... 0x....      BL       OS_MutexGrpPostAll
    616              }
    617          #endif
    618          
    619          #if (OS_CFG_TASK_Q_EN == DEF_ENABLED)
    620              (void)OS_MsgQFreeAll(&p_tcb->MsgQ);                         /* Free task's message queue messages                   */
   \                     ??OSTaskDel_10: (+1)
   \   00000086   0xF115 0x0068      ADDS     R0,R5,#+104
   \   0000008A   0x.... 0x....      BL       OS_MsgQFreeAll
    621          #endif
    622          
    623              OSTaskDelHook(p_tcb);                                       /* Call user defined hook                               */
   \   0000008E   0x0028             MOVS     R0,R5
   \   00000090   0x.... 0x....      BL       OSTaskDelHook
    624          
    625          #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
    626              OS_TLS_TaskDel(p_tcb);                                      /* Call TLS hook                                        */
    627          #endif
    628          
    629          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    630              OS_TaskDbgListRemove(p_tcb);
   \   00000094   0x0028             MOVS     R0,R5
   \   00000096   0x.... 0x....      BL       OS_TaskDbgListRemove
    631          #endif
    632          
    633              OSTaskQty--;                                                /* One less task being managed                          */
   \   0000009A   0x.... 0x....      LDR.W    R0,??DataTable15_2
   \   0000009E   0x8800             LDRH     R0,[R0, #+0]
   \   000000A0   0x1E40             SUBS     R0,R0,#+1
   \   000000A2   0x.... 0x....      LDR.W    R1,??DataTable15_2
   \   000000A6   0x8008             STRH     R0,[R1, #+0]
    634          
    635              OS_TRACE_TASK_DEL(p_tcb);
    636          
    637          #if (OS_CFG_TASK_STK_REDZONE_EN != DEF_ENABLED)                 /* Don't clear the TCB before checking the red-zone     */
    638              OS_TaskInitTCB(p_tcb);                                      /* Initialize the TCB to default values                 */
   \   000000A8   0x0028             MOVS     R0,R5
   \   000000AA   0x.... 0x....      BL       OS_TaskInitTCB
    639          #endif
    640              p_tcb->TaskState = (OS_STATE)OS_TASK_STATE_DEL;             /* Indicate that the task was deleted                   */
   \   000000AE   0x20FF             MOVS     R0,#+255
   \   000000B0   0xF885 0x003E      STRB     R0,[R5, #+62]
    641          
    642             *p_err = OS_ERR_NONE;                                        /* See Note #1.                                         */
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0x8020             STRH     R0,[R4, #+0]
    643              CPU_CRITICAL_EXIT();
   \   000000B8   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000BC   0x0030             MOVS     R0,R6
   \   000000BE   0x.... 0x....      BL       CPU_SR_Restore
    644          
    645              OSSched();                                                  /* Find new highest priority task                       */
   \   000000C2   0x.... 0x....      BL       OSSched
    646          }
   \                     ??OSTaskDel_1: (+1)
   \   000000C6   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   \                     ??OSTaskDel_7: (+1)
   \   000000CA   0xE7D6             B.N      ??OSTaskDel_9
   \                     ??OSTaskDel_6: (+1)
   \   000000CC   0x0028             MOVS     R0,R5
   \   000000CE   0x.... 0x....      BL       OS_TickListRemove
   \   000000D2   0xE7D2             B.N      ??OSTaskDel_9
   \                     ??OSTaskDel_5: (+1)
   \   000000D4   0xF895 0x003C      LDRB     R0,[R5, #+60]
   \   000000D8   0x2800             CMP      R0,#+0
   \   000000DA   0xD00B             BEQ.N    ??OSTaskDel_11
   \   000000DC   0x2801             CMP      R0,#+1
   \   000000DE   0xD00A             BEQ.N    ??OSTaskDel_12
   \   000000E0   0x2802             CMP      R0,#+2
   \   000000E2   0xD007             BEQ.N    ??OSTaskDel_11
   \   000000E4   0x2804             CMP      R0,#+4
   \   000000E6   0xD00A             BEQ.N    ??OSTaskDel_13
   \   000000E8   0x2805             CMP      R0,#+5
   \   000000EA   0xD004             BEQ.N    ??OSTaskDel_12
   \   000000EC   0x2806             CMP      R0,#+6
   \   000000EE   0xD002             BEQ.N    ??OSTaskDel_12
   \   000000F0   0x2807             CMP      R0,#+7
   \   000000F2   0xD133             BNE.N    ??OSTaskDel_14
   \                     ??OSTaskDel_11: (+1)
   \   000000F4   0xE032             B.N      ??OSTaskDel_15
   \                     ??OSTaskDel_12: (+1)
   \   000000F6   0x0028             MOVS     R0,R5
   \   000000F8   0x.... 0x....      BL       OS_PendListRemove
   \   000000FC   0xE02E             B.N      ??OSTaskDel_15
   \                     ??OSTaskDel_13: (+1)
   \   000000FE   0x6BA8             LDR      R0,[R5, #+56]
   \   00000100   0x6A47             LDR      R7,[R0, #+36]
   \   00000102   0xF897 0x803F      LDRB     R8,[R7, #+63]
   \   00000106   0x0028             MOVS     R0,R5
   \   00000108   0x.... 0x....      BL       OS_PendListRemove
   \   0000010C   0xF897 0x003F      LDRB     R0,[R7, #+63]
   \   00000110   0xF897 0x1040      LDRB     R1,[R7, #+64]
   \   00000114   0x4288             CMP      R0,R1
   \   00000116   0xD012             BEQ.N    ??OSTaskDel_16
   \   00000118   0xF897 0x003F      LDRB     R0,[R7, #+63]
   \   0000011C   0xF895 0x103F      LDRB     R1,[R5, #+63]
   \   00000120   0x4288             CMP      R0,R1
   \   00000122   0xD10C             BNE.N    ??OSTaskDel_16
   \   00000124   0x0038             MOVS     R0,R7
   \   00000126   0x.... 0x....      BL       OS_MutexGrpPrioFindHighest
   \   0000012A   0x4680             MOV      R8,R0
   \   0000012C   0xF897 0x0040      LDRB     R0,[R7, #+64]
   \   00000130   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000134   0x4540             CMP      R0,R8
   \   00000136   0xD202             BCS.N    ??OSTaskDel_17
   \   00000138   0xF897 0x8040      LDRB     R8,[R7, #+64]
   \   0000013C   0xE7FF             B.N      ??OSTaskDel_16
   \                     ??OSTaskDel_17: (+1)
   \                     ??OSTaskDel_16: (+1)
   \   0000013E   0x2000             MOVS     R0,#+0
   \   00000140   0xF885 0x003C      STRB     R0,[R5, #+60]
   \   00000144   0xF897 0x003F      LDRB     R0,[R7, #+63]
   \   00000148   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000014C   0x4580             CMP      R8,R0
   \   0000014E   0xD004             BEQ.N    ??OSTaskDel_18
   \   00000150   0x4641             MOV      R1,R8
   \   00000152   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000154   0x0038             MOVS     R0,R7
   \   00000156   0x.... 0x....      BL       OS_TaskChangePrio
   \                     ??OSTaskDel_18: (+1)
   \   0000015A   0xE7FF             B.N      ??OSTaskDel_15
   \                     ??OSTaskDel_14: (+1)
   \                     ??OSTaskDel_15: (+1)
   \   0000015C   0xF895 0x003E      LDRB     R0,[R5, #+62]
   \   00000160   0x2803             CMP      R0,#+3
   \   00000162   0xD003             BEQ.N    ??OSTaskDel_19
   \   00000164   0xF895 0x003E      LDRB     R0,[R5, #+62]
   \   00000168   0x2807             CMP      R0,#+7
   \   0000016A   0xD102             BNE.N    ??OSTaskDel_20
   \                     ??OSTaskDel_19: (+1)
   \   0000016C   0x0028             MOVS     R0,R5
   \   0000016E   0x.... 0x....      BL       OS_TickListRemove
   \                     ??OSTaskDel_20: (+1)
   \   00000172   0xE782             B.N      ??OSTaskDel_9
   \                     ??OSTaskDel_8: (+1)
   \   00000174   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000178   0x0030             MOVS     R0,R6
   \   0000017A   0x.... 0x....      BL       CPU_SR_Restore
   \   0000017E   0xF646 0x602D      MOVW     R0,#+28205
   \   00000182   0x8020             STRH     R0,[R4, #+0]
   \   00000184   0xE79F             B.N      ??OSTaskDel_1
    647          #endif
    648          
    649          
    650          /*
    651          ************************************************************************************************************************
    652          *                                                    FLUSH TASK's QUEUE
    653          *
    654          * Description: This function is used to flush the task's internal message queue.
    655          *
    656          * Arguments  : p_tcb       is a pointer to the task's OS_TCB.  Specifying a NULL pointer indicates that you wish to
    657          *                          flush the message queue of the calling task.
    658          *
    659          *              p_err       is a pointer to a variable that will contain an error code returned by this function.
    660          *
    661          *                              OS_ERR_NONE              Upon success
    662          *                              OS_ERR_FLUSH_ISR         If you called this function from an ISR
    663          *                              OS_ERR_OS_NOT_RUNNING    If uC/OS-III is not running yet
    664          *
    665          * Returns     : The number of entries freed from the queue
    666          *
    667          * Note(s)     : 1) You should use this function with great care because, when to flush the queue, you LOOSE the
    668          *                  references to what the queue entries are pointing to and thus, you could cause 'memory leaks'.  In
    669          *                  other words, the data you are pointing to that's being referenced by the queue entries should, most
    670          *                  likely, need to be de-allocated (i.e. freed).
    671          ************************************************************************************************************************
    672          */
    673          
    674          #if (OS_CFG_TASK_Q_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    675          OS_MSG_QTY  OSTaskQFlush (OS_TCB  *p_tcb,
    676                                    OS_ERR  *p_err)
    677          {
   \                     OSTaskQFlush: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
    678              OS_MSG_QTY  entries;
    679              CPU_SR_ALLOC();
   \   00000006   0x2600             MOVS     R6,#+0
    680          
    681          
    682          #ifdef OS_SAFETY_CRITICAL
    683              if (p_err == DEF_NULL) {
    684                  OS_SAFETY_CRITICAL_EXCEPTION();
    685                  return (0u);
    686              }
    687          #endif
    688          
    689          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
    690              if (OSIntNestingCtr > 0u) {                                 /* Can't flush a message queue from an ISR              */
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable13
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD004             BEQ.N    ??OSTaskQFlush_0
    691                 *p_err = OS_ERR_FLUSH_ISR;
   \   00000012   0xF44F 0x506C      MOV      R0,#+15104
   \   00000016   0x8020             STRH     R0,[R4, #+0]
    692                  return (0u);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE021             B.N      ??OSTaskQFlush_1
    693              }
    694          #endif
    695          
    696          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
    697              if (OSRunning != OS_STATE_OS_RUNNING) {
    698                 *p_err = OS_ERR_OS_NOT_RUNNING;
    699                  return (0u);
    700              }
    701          #endif
    702          
    703              if (p_tcb == DEF_NULL) {                                    /* Flush message queue of calling task?                 */
   \                     ??OSTaskQFlush_0: (+1)
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD10C             BNE.N    ??OSTaskQFlush_2
    704                  CPU_CRITICAL_ENTER();
   \   00000020   0x.... 0x....      BL       CPU_SR_Save
   \   00000024   0x0006             MOVS     R6,R0
   \   00000026   0x.... 0x....      BL       CPU_IntDisMeasStart
    705                  p_tcb = OSTCBCurPtr;
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   0000002E   0x6805             LDR      R5,[R0, #+0]
    706                  CPU_CRITICAL_EXIT();
   \   00000030   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000034   0x0030             MOVS     R0,R6
   \   00000036   0x.... 0x....      BL       CPU_SR_Restore
    707              }
    708          
    709              CPU_CRITICAL_ENTER();
   \                     ??OSTaskQFlush_2: (+1)
   \   0000003A   0x.... 0x....      BL       CPU_SR_Save
   \   0000003E   0x0006             MOVS     R6,R0
   \   00000040   0x.... 0x....      BL       CPU_IntDisMeasStart
    710              entries = OS_MsgQFreeAll(&p_tcb->MsgQ);                     /* Return all OS_MSGs to the OS_MSG pool                */
   \   00000044   0xF115 0x0068      ADDS     R0,R5,#+104
   \   00000048   0x.... 0x....      BL       OS_MsgQFreeAll
   \   0000004C   0x0005             MOVS     R5,R0
    711              CPU_CRITICAL_EXIT();
   \   0000004E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000052   0x0030             MOVS     R0,R6
   \   00000054   0x.... 0x....      BL       CPU_SR_Restore
    712             *p_err   = OS_ERR_NONE;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x8020             STRH     R0,[R4, #+0]
    713              return (entries);
   \   0000005C   0x0028             MOVS     R0,R5
   \   0000005E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSTaskQFlush_1: (+1)
   \   00000060   0xBD70             POP      {R4-R6,PC}       ;; return
    714          }
    715          #endif
    716          
    717          
    718          /*
    719          ************************************************************************************************************************
    720          *                                                  WAIT FOR A MESSAGE
    721          *
    722          * Description: This function causes the current task to wait for a message to be posted to it.
    723          *
    724          * Arguments  : timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will wait for a
    725          *                            message to arrive up to the amount of time specified by this argument.
    726          *                            If you specify 0, however, your task will wait forever or, until a message arrives.
    727          *
    728          *              opt           determines whether the user wants to block if the task's queue is empty or not:
    729          *
    730          *                                OS_OPT_PEND_BLOCKING
    731          *                                OS_OPT_PEND_NON_BLOCKING
    732          *
    733          *              p_msg_size    is a pointer to a variable that will receive the size of the message
    734          *
    735          *              p_ts          is a pointer to a variable that will receive the timestamp of when the message was
    736          *                            received.  If you pass a NULL pointer (i.e. (CPU_TS *)0) then you will not get the
    737          *                            timestamp.  In other words, passing a NULL pointer is valid and indicates that you don't
    738          *                            need the timestamp.
    739          *
    740          *              p_err         is a pointer to where an error message will be deposited.  Possible error
    741          *                            messages are:
    742          *
    743          *                                OS_ERR_NONE               The call was successful and your task received a message.
    744          *                                OS_ERR_OPT_INVALID        If you specified an invalid option
    745          *                                OS_ERR_OS_NOT_RUNNING     If uC/OS-III is not running yet
    746          *                                OS_ERR_PEND_ABORT         If the pend was aborted
    747          *                                OS_ERR_PEND_ISR           If you called this function from an ISR and the result
    748          *                                OS_ERR_PEND_WOULD_BLOCK   If you specified non-blocking but the queue was not empty
    749          *                                OS_ERR_PTR_INVALID        If 'p_msg_size' is NULL
    750          *                                OS_ERR_SCHED_LOCKED       If the scheduler is locked
    751          *                                OS_ERR_TIMEOUT            A message was not received within the specified timeout
    752          *                                                          would lead to a suspension
    753          *
    754          * Returns    : A pointer to the message received or a NULL pointer upon error.
    755          *
    756          * Note(s)    : 1) It is possible to receive NULL pointers when there are no errors.
    757          ************************************************************************************************************************
    758          */
    759          
    760          #if (OS_CFG_TASK_Q_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    761          void  *OSTaskQPend (OS_TICK       timeout,
    762                              OS_OPT        opt,
    763                              OS_MSG_SIZE  *p_msg_size,
    764                              CPU_TS       *p_ts,
    765                              OS_ERR       *p_err)
    766          {
   \                     OSTaskQPend: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    767              OS_MSG_Q  *p_msg_q;
    768              void      *p_void;
    769              CPU_SR_ALLOC();
   \   0000000C   0xF05F 0x0900      MOVS     R9,#+0
   \   00000010   0xF8DD 0x8020      LDR      R8,[SP, #+32]
    770          
    771          
    772          #ifdef OS_SAFETY_CRITICAL
    773              if (p_err == DEF_NULL) {
    774                  OS_SAFETY_CRITICAL_EXCEPTION();
    775                  return (DEF_NULL);
    776              }
    777          #endif
    778          
    779              OS_TRACE_TASK_MSG_Q_PEND_ENTER(&OSTCBCurPtr->MsgQ, timeout, opt, p_msg_size, p_ts);
    780          
    781          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
    782              if (OSIntNestingCtr > 0u) {                                 /* Can't Pend from an ISR                               */
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD005             BEQ.N    ??OSTaskQPend_0
    783                  OS_TRACE_TASK_MSG_Q_PEND_EXIT(OS_ERR_PEND_ISR);
    784                 *p_err = OS_ERR_PEND_ISR;
   \   0000001E   0xF246 0x10AE      MOVW     R0,#+25006
   \   00000022   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    785                  return (DEF_NULL);
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE0A3             B.N      ??OSTaskQPend_1
    786              }
    787          #endif
    788          
    789          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
    790              if (OSRunning != OS_STATE_OS_RUNNING) {
    791                  OS_TRACE_TASK_MSG_Q_PEND_EXIT(OS_ERR_OS_NOT_RUNNING);
    792                 *p_err = OS_ERR_OS_NOT_RUNNING;
    793                  return (DEF_NULL);
    794              }
    795          #endif
    796          
    797          
    798          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)                          /* ---------------- VALIDATE ARGUMENTS ---------------- */
    799              if (p_msg_size == DEF_NULL) {                               /* User must supply a valid destination for msg size    */
   \                     ??OSTaskQPend_0: (+1)
   \   0000002A   0x2E00             CMP      R6,#+0
   \   0000002C   0xD105             BNE.N    ??OSTaskQPend_2
    800                  OS_TRACE_TASK_MSG_Q_PEND_EXIT(OS_ERR_PTR_INVALID);
    801                 *p_err = OS_ERR_PTR_INVALID;
   \   0000002E   0xF246 0x20D5      MOVW     R0,#+25301
   \   00000032   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    802                  return (DEF_NULL);
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xE09B             B.N      ??OSTaskQPend_1
    803              }
    804              switch (opt) {                                              /* User must supply a valid option                      */
   \                     ??OSTaskQPend_2: (+1)
   \   0000003A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000003C   0x0028             MOVS     R0,R5
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD002             BEQ.N    ??OSTaskQPend_3
   \   00000042   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000046   0xD11D             BNE.N    ??OSTaskQPend_4
    805                  case OS_OPT_PEND_BLOCKING:
    806                  case OS_OPT_PEND_NON_BLOCKING:
    807                       break;
    808          
    809                  default:
    810                       OS_TRACE_TASK_MSG_Q_PEND_EXIT(OS_ERR_OPT_INVALID);
    811                      *p_err = OS_ERR_OPT_INVALID;
    812                       return (DEF_NULL);
    813              }
    814          #endif
    815          
    816              if (p_ts != DEF_NULL) {
   \                     ??OSTaskQPend_3: (+1)
   \   00000048   0x2F00             CMP      R7,#+0
   \   0000004A   0xD001             BEQ.N    ??OSTaskQPend_5
    817                 *p_ts = 0u;                                              /* Initialize the returned timestamp                    */
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x6038             STR      R0,[R7, #+0]
    818              }
    819          
    820              CPU_CRITICAL_ENTER();
   \                     ??OSTaskQPend_5: (+1)
   \   00000050   0x.... 0x....      BL       CPU_SR_Save
   \   00000054   0x4681             MOV      R9,R0
   \   00000056   0x.... 0x....      BL       CPU_IntDisMeasStart
    821              p_msg_q = &OSTCBCurPtr->MsgQ;                               /* Any message waiting in the message queue?            */
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable22
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0x3068             ADDS     R0,R0,#+104
    822              p_void  = OS_MsgQGet(p_msg_q,
    823                                   p_msg_size,
    824                                   p_ts,
    825                                   p_err);
   \   00000062   0x4643             MOV      R3,R8
   \   00000064   0x003A             MOVS     R2,R7
   \   00000066   0x0031             MOVS     R1,R6
   \   00000068   0x.... 0x....      BL       OS_MsgQGet
   \   0000006C   0x4682             MOV      R10,R0
    826              if (*p_err == OS_ERR_NONE) {
   \   0000006E   0xF8B8 0x0000      LDRH     R0,[R8, #+0]
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD10C             BNE.N    ??OSTaskQPend_6
    827          #if (OS_CFG_TASK_PROFILE_EN == DEF_ENABLED)
    828          #if (OS_CFG_TS_EN == DEF_ENABLED)
    829                  if (p_ts != DEF_NULL) {
    830                      OSTCBCurPtr->MsgQPendTime = OS_TS_GET() - *p_ts;
    831                      if (OSTCBCurPtr->MsgQPendTimeMax < OSTCBCurPtr->MsgQPendTime) {
    832                          OSTCBCurPtr->MsgQPendTimeMax = OSTCBCurPtr->MsgQPendTime;
    833                      }
    834                  }
    835          #endif
    836          #endif
    837                  OS_TRACE_TASK_MSG_Q_PEND(p_msg_q);
    838                  CPU_CRITICAL_EXIT();
   \   00000076   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000007A   0x4648             MOV      R0,R9
   \   0000007C   0x.... 0x....      BL       CPU_SR_Restore
    839                  OS_TRACE_TASK_MSG_Q_PEND_EXIT(OS_ERR_NONE);
    840                  return (p_void);                                        /* Yes, Return oldest message received                  */
   \   00000080   0x4650             MOV      R0,R10
   \   00000082   0xE076             B.N      ??OSTaskQPend_1
    841              }
   \                     ??OSTaskQPend_4: (+1)
   \   00000084   0xF645 0x6025      MOVW     R0,#+24101
   \   00000088   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0xE070             B.N      ??OSTaskQPend_1
    842          
    843              if ((opt & OS_OPT_PEND_NON_BLOCKING) != 0u) {               /* Caller wants to block if not available?              */
   \                     ??OSTaskQPend_6: (+1)
   \   00000090   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000092   0x0428             LSLS     R0,R5,#+16
   \   00000094   0xD50A             BPL.N    ??OSTaskQPend_7
    844                 *p_err = OS_ERR_PEND_WOULD_BLOCK;                        /* No                                                   */
   \   00000096   0xF246 0x10B0      MOVW     R0,#+25008
   \   0000009A   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    845                  CPU_CRITICAL_EXIT();
   \   0000009E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000A2   0x4648             MOV      R0,R9
   \   000000A4   0x.... 0x....      BL       CPU_SR_Restore
    846                  OS_TRACE_TASK_MSG_Q_PEND_FAILED(p_msg_q);
    847                  OS_TRACE_TASK_MSG_Q_PEND_EXIT(OS_ERR_PEND_WOULD_BLOCK);
    848                  return (DEF_NULL);
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0xE062             B.N      ??OSTaskQPend_1
    849              } else {                                                    /* Yes                                                  */
    850                  if (OSSchedLockNestingCtr > 0u) {                       /* Can't block when the scheduler is locked             */
   \                     ??OSTaskQPend_7: (+1)
   \   000000AC   0x.... 0x....      LDR.W    R0,??DataTable22_1
   \   000000B0   0x7800             LDRB     R0,[R0, #+0]
   \   000000B2   0x2800             CMP      R0,#+0
   \   000000B4   0xD00A             BEQ.N    ??OSTaskQPend_8
    851                      CPU_CRITICAL_EXIT();
   \   000000B6   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000BA   0x4648             MOV      R0,R9
   \   000000BC   0x.... 0x....      BL       CPU_SR_Restore
    852                      OS_TRACE_TASK_MSG_Q_PEND_FAILED(p_msg_q);
    853                      OS_TRACE_TASK_MSG_Q_PEND_EXIT(OS_ERR_SCHED_LOCKED);
    854                     *p_err = OS_ERR_SCHED_LOCKED;
   \   000000C0   0xF646 0x5063      MOVW     R0,#+28003
   \   000000C4   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    855                      return (DEF_NULL);
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0xE052             B.N      ??OSTaskQPend_1
    856                  }
    857              }
    858          
    859              OS_Pend(DEF_NULL,                                           /* Block task pending on Message                        */
    860                      OS_TASK_PEND_ON_TASK_Q,
    861                      timeout);
   \                     ??OSTaskQPend_8: (+1)
   \   000000CC   0x0022             MOVS     R2,R4
   \   000000CE   0x2102             MOVS     R1,#+2
   \   000000D0   0x2000             MOVS     R0,#+0
   \   000000D2   0x.... 0x....      BL       OS_Pend
    862              CPU_CRITICAL_EXIT();
   \   000000D6   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000DA   0x4648             MOV      R0,R9
   \   000000DC   0x.... 0x....      BL       CPU_SR_Restore
    863              OS_TRACE_TASK_MSG_Q_PEND_BLOCK(p_msg_q);
    864              OSSched();                                                  /* Find the next highest priority task ready to run     */
   \   000000E0   0x.... 0x....      BL       OSSched
    865          
    866              CPU_CRITICAL_ENTER();
   \   000000E4   0x.... 0x....      BL       CPU_SR_Save
   \   000000E8   0x4681             MOV      R9,R0
   \   000000EA   0x.... 0x....      BL       CPU_IntDisMeasStart
    867              switch (OSTCBCurPtr->PendStatus) {
   \   000000EE   0x.... 0x....      LDR.W    R0,??DataTable22
   \   000000F2   0x6800             LDR      R0,[R0, #+0]
   \   000000F4   0xF890 0x003D      LDRB     R0,[R0, #+61]
   \   000000F8   0x2800             CMP      R0,#+0
   \   000000FA   0xD002             BEQ.N    ??OSTaskQPend_9
   \   000000FC   0x2801             CMP      R0,#+1
   \   000000FE   0xD016             BEQ.N    ??OSTaskQPend_10
   \   00000100   0xE022             B.N      ??OSTaskQPend_11
    868                  case OS_STATUS_PEND_OK:                                 /* Extract message from TCB (Put there by Post)         */
    869                       p_void      = OSTCBCurPtr->MsgPtr;
   \                     ??OSTaskQPend_9: (+1)
   \   00000102   0x.... 0x....      LDR.W    R0,??DataTable22
   \   00000106   0x6800             LDR      R0,[R0, #+0]
   \   00000108   0xF8D0 0xA060      LDR      R10,[R0, #+96]
    870                      *p_msg_size  = OSTCBCurPtr->MsgSize;
   \   0000010C   0x.... 0x....      LDR.W    R0,??DataTable22
   \   00000110   0x6800             LDR      R0,[R0, #+0]
   \   00000112   0xF8B0 0x0064      LDRH     R0,[R0, #+100]
   \   00000116   0x8030             STRH     R0,[R6, #+0]
    871          #if (OS_CFG_TS_EN == DEF_ENABLED)
    872                       if (p_ts != DEF_NULL) {
   \   00000118   0x2F00             CMP      R7,#+0
   \   0000011A   0xD004             BEQ.N    ??OSTaskQPend_12
    873                          *p_ts = OSTCBCurPtr->TS;
   \   0000011C   0x.... 0x....      LDR.W    R0,??DataTable22
   \   00000120   0x6800             LDR      R0,[R0, #+0]
   \   00000122   0x6D00             LDR      R0,[R0, #+80]
   \   00000124   0x6038             STR      R0,[R7, #+0]
    874          #if (OS_CFG_TASK_PROFILE_EN == DEF_ENABLED)
    875                          OSTCBCurPtr->MsgQPendTime = OS_TS_GET() - OSTCBCurPtr->TS;
    876                          if (OSTCBCurPtr->MsgQPendTimeMax < OSTCBCurPtr->MsgQPendTime) {
    877                              OSTCBCurPtr->MsgQPendTimeMax = OSTCBCurPtr->MsgQPendTime;
    878                          }
    879          #endif
    880                       }
    881          #endif
    882                       OS_TRACE_TASK_MSG_Q_PEND(p_msg_q);
    883                      *p_err = OS_ERR_NONE;
   \                     ??OSTaskQPend_12: (+1)
   \   00000126   0x2000             MOVS     R0,#+0
   \   00000128   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    884                       break;
   \   0000012C   0xE01B             B.N      ??OSTaskQPend_13
    885          
    886                  case OS_STATUS_PEND_ABORT:                              /* Indicate that we aborted                             */
    887                       p_void     = DEF_NULL;
   \                     ??OSTaskQPend_10: (+1)
   \   0000012E   0xF05F 0x0A00      MOVS     R10,#+0
    888                      *p_msg_size = 0u;
   \   00000132   0x2000             MOVS     R0,#+0
   \   00000134   0x8030             STRH     R0,[R6, #+0]
    889                       if (p_ts != DEF_NULL) {
   \   00000136   0x2F00             CMP      R7,#+0
   \   00000138   0xD001             BEQ.N    ??OSTaskQPend_14
    890                          *p_ts = 0u;
   \   0000013A   0x2000             MOVS     R0,#+0
   \   0000013C   0x6038             STR      R0,[R7, #+0]
    891                       }
    892                       OS_TRACE_TASK_MSG_Q_PEND_FAILED(p_msg_q);
    893                      *p_err      =  OS_ERR_PEND_ABORT;
   \                     ??OSTaskQPend_14: (+1)
   \   0000013E   0xF246 0x10A9      MOVW     R0,#+25001
   \   00000142   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    894                       break;
   \   00000146   0xE00E             B.N      ??OSTaskQPend_13
    895          
    896                  case OS_STATUS_PEND_TIMEOUT:                            /* Indicate that we didn't get event within TO          */
    897                  default:
    898                       p_void     = DEF_NULL;
   \                     ??OSTaskQPend_11: (+1)
   \   00000148   0xF05F 0x0A00      MOVS     R10,#+0
    899                      *p_msg_size = 0u;
   \   0000014C   0x2000             MOVS     R0,#+0
   \   0000014E   0x8030             STRH     R0,[R6, #+0]
    900          #if (OS_CFG_TS_EN == DEF_ENABLED)
    901                       if (p_ts  != DEF_NULL) {
   \   00000150   0x2F00             CMP      R7,#+0
   \   00000152   0xD004             BEQ.N    ??OSTaskQPend_15
    902                          *p_ts = OSTCBCurPtr->TS;
   \   00000154   0x.... 0x....      LDR.W    R0,??DataTable22
   \   00000158   0x6800             LDR      R0,[R0, #+0]
   \   0000015A   0x6D00             LDR      R0,[R0, #+80]
   \   0000015C   0x6038             STR      R0,[R7, #+0]
    903                       }
    904          #endif
    905                       OS_TRACE_TASK_MSG_Q_PEND_FAILED(p_msg_q);
    906                      *p_err      =  OS_ERR_TIMEOUT;
   \                     ??OSTaskQPend_15: (+1)
   \   0000015E   0xF247 0x20D9      MOVW     R0,#+29401
   \   00000162   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    907                       break;
    908              }
    909              CPU_CRITICAL_EXIT();
   \                     ??OSTaskQPend_13: (+1)
   \   00000166   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000016A   0x4648             MOV      R0,R9
   \   0000016C   0x.... 0x....      BL       CPU_SR_Restore
    910              OS_TRACE_TASK_MSG_Q_PEND_EXIT(*p_err);
    911              return (p_void);                                            /* Return received message                              */
   \   00000170   0x4650             MOV      R0,R10
   \                     ??OSTaskQPend_1: (+1)
   \   00000172   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    912          }
    913          #endif
    914          
    915          
    916          /*
    917          ************************************************************************************************************************
    918          *                                              ABORT WAITING FOR A MESSAGE
    919          *
    920          * Description: This function aborts & readies the task specified.  This function should be used to fault-abort the wait
    921          *              for a message, rather than to normally post the message to the task via OSTaskQPost().
    922          *
    923          * Arguments  : p_tcb     is a pointer to the task to pend abort
    924          *
    925          *              opt       provides options for this function:
    926          *
    927          *                            OS_OPT_POST_NONE         No option specified
    928          *                            OS_OPT_POST_NO_SCHED     Indicates that the scheduler will not be called.
    929          *
    930          *              p_err     is a pointer to a variable that will contain an error code returned by this function.
    931          *
    932          *                            OS_ERR_NONE               If the task was readied and informed of the aborted wait
    933          *                            OS_ERR_OPT_INVALID        If you specified an invalid option
    934          *                            OS_ERR_OS_NOT_RUNNING     If uC/OS-III is not running yet
    935          *                            OS_ERR_PEND_ABORT_ISR     If you called this function from an ISR
    936          *                            OS_ERR_PEND_ABORT_NONE    If task was not pending on a message and thus there is nothing to
    937          *                                                      abort
    938          *                            OS_ERR_PEND_ABORT_SELF    If you passed a NULL pointer for 'p_tcb'
    939          *
    940          * Returns    : == DEF_FALSE   if task was not waiting for a message, or upon error.
    941          *              == DEF_TRUE    if task was waiting for a message and was readied and informed.
    942          *
    943          * Note(s)    : none
    944          ************************************************************************************************************************
    945          */
    946          
    947          #if (OS_CFG_TASK_Q_EN == DEF_ENABLED) && (OS_CFG_TASK_Q_PEND_ABORT_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    948          CPU_BOOLEAN  OSTaskQPendAbort (OS_TCB  *p_tcb,
    949                                         OS_OPT   opt,
    950                                         OS_ERR  *p_err)
    951          {
   \                     OSTaskQPendAbort: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0014             MOVS     R4,R2
    952              CPU_TS  ts;
    953              CPU_SR_ALLOC();
   \   00000008   0x2700             MOVS     R7,#+0
    954          
    955          
    956          #ifdef OS_SAFETY_CRITICAL
    957              if (p_err == DEF_NULL) {
    958                  OS_SAFETY_CRITICAL_EXCEPTION();
    959                  return (DEF_FALSE);
    960              }
    961          #endif
    962          
    963          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
    964              if (OSIntNestingCtr > 0u) {                                 /* See if called from ISR ...                           */
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable13
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD004             BEQ.N    ??OSTaskQPendAbort_0
    965                 *p_err = OS_ERR_PEND_ABORT_ISR;                          /* ... can't Pend Abort from an ISR                     */
   \   00000014   0xF246 0x10AA      MOVW     R0,#+25002
   \   00000018   0x8020             STRH     R0,[R4, #+0]
    966                  return (DEF_FALSE);
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE043             B.N      ??OSTaskQPendAbort_1
    967              }
    968          #endif
    969          
    970          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
    971              if (OSRunning != OS_STATE_OS_RUNNING) {
    972                 *p_err = OS_ERR_OS_NOT_RUNNING;
    973                  return (DEF_FALSE);
    974              }
    975          #endif
    976          
    977          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)                          /* ---------------- VALIDATE ARGUMENTS ---------------- */
    978              switch (opt) {                                              /* User must supply a valid option                      */
   \                     ??OSTaskQPendAbort_0: (+1)
   \   0000001E   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000020   0x0030             MOVS     R0,R6
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD002             BEQ.N    ??OSTaskQPendAbort_2
   \   00000026   0xF5B0 0x4F00      CMP      R0,#+32768
   \   0000002A   0xD115             BNE.N    ??OSTaskQPendAbort_3
    979                  case OS_OPT_POST_NONE:
    980                  case OS_OPT_POST_NO_SCHED:
    981                       break;
    982          
    983                  default:
    984                      *p_err = OS_ERR_OPT_INVALID;
    985                       return (DEF_FALSE);
    986              }
    987          #endif
    988          
    989              CPU_CRITICAL_ENTER();
   \                     ??OSTaskQPendAbort_2: (+1)
   \   0000002C   0x.... 0x....      BL       CPU_SR_Save
   \   00000030   0x0007             MOVS     R7,R0
   \   00000032   0x.... 0x....      BL       CPU_IntDisMeasStart
    990          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
    991              if ((p_tcb == DEF_NULL) ||                                  /* Pend abort self?                                     */
    992                  (p_tcb == OSTCBCurPtr)) {
   \   00000036   0x2D00             CMP      R5,#+0
   \   00000038   0xD004             BEQ.N    ??OSTaskQPendAbort_4
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable22
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x4285             CMP      R5,R0
   \   00000042   0xD10E             BNE.N    ??OSTaskQPendAbort_5
    993                  CPU_CRITICAL_EXIT();
   \                     ??OSTaskQPendAbort_4: (+1)
   \   00000044   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000048   0x0038             MOVS     R0,R7
   \   0000004A   0x.... 0x....      BL       CPU_SR_Restore
    994                 *p_err = OS_ERR_PEND_ABORT_SELF;                         /* ... doesn't make sense                               */
   \   0000004E   0xF246 0x10AC      MOVW     R0,#+25004
   \   00000052   0x8020             STRH     R0,[R4, #+0]
    995                  return (DEF_FALSE);
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xE026             B.N      ??OSTaskQPendAbort_1
    996              }
   \                     ??OSTaskQPendAbort_3: (+1)
   \   00000058   0xF645 0x6025      MOVW     R0,#+24101
   \   0000005C   0x8020             STRH     R0,[R4, #+0]
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xE021             B.N      ??OSTaskQPendAbort_1
    997          #endif
    998          
    999              if (p_tcb->PendOn != OS_TASK_PEND_ON_TASK_Q) {              /* Is task waiting for a message?                       */
   \                     ??OSTaskQPendAbort_5: (+1)
   \   00000062   0xF895 0x003C      LDRB     R0,[R5, #+60]
   \   00000066   0x2802             CMP      R0,#+2
   \   00000068   0xD009             BEQ.N    ??OSTaskQPendAbort_6
   1000                  CPU_CRITICAL_EXIT();                                    /* No                                                   */
   \   0000006A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000006E   0x0038             MOVS     R0,R7
   \   00000070   0x.... 0x....      BL       CPU_SR_Restore
   1001                 *p_err = OS_ERR_PEND_ABORT_NONE;
   \   00000074   0xF246 0x10AB      MOVW     R0,#+25003
   \   00000078   0x8020             STRH     R0,[R4, #+0]
   1002                  return (DEF_FALSE);
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0xE013             B.N      ??OSTaskQPendAbort_1
   1003              }
   1004          
   1005          #if (OS_CFG_TS_EN == DEF_ENABLED)
   1006              ts = OS_TS_GET();                                           /* Get timestamp of when the abort occurred             */
   \                     ??OSTaskQPendAbort_6: (+1)
   \   0000007E   0x.... 0x....      BL       CPU_TS_TmrRd
   1007          #else
   1008              ts = 0u;
   1009          #endif
   1010              OS_PendAbort(p_tcb,                                         /* Abort the pend                                       */
   1011                           ts,
   1012                           OS_STATUS_PEND_ABORT);
   \   00000082   0x2201             MOVS     R2,#+1
   \   00000084   0x0001             MOVS     R1,R0
   \   00000086   0x0028             MOVS     R0,R5
   \   00000088   0x.... 0x....      BL       OS_PendAbort
   1013              CPU_CRITICAL_EXIT();
   \   0000008C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000090   0x0038             MOVS     R0,R7
   \   00000092   0x.... 0x....      BL       CPU_SR_Restore
   1014              if ((opt & OS_OPT_POST_NO_SCHED) == 0u) {
   \   00000096   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000098   0x0430             LSLS     R0,R6,#+16
   \   0000009A   0xD401             BMI.N    ??OSTaskQPendAbort_7
   1015                  OSSched();                                              /* Run the scheduler                                    */
   \   0000009C   0x.... 0x....      BL       OSSched
   1016              }
   1017             *p_err = OS_ERR_NONE;
   \                     ??OSTaskQPendAbort_7: (+1)
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0x8020             STRH     R0,[R4, #+0]
   1018              return (DEF_TRUE);
   \   000000A4   0x2001             MOVS     R0,#+1
   \                     ??OSTaskQPendAbort_1: (+1)
   \   000000A6   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1019          }
   1020          #endif
   1021          
   1022          
   1023          /*
   1024          ************************************************************************************************************************
   1025          *                                               POST MESSAGE TO A TASK
   1026          *
   1027          * Description: This function sends a message to a task.
   1028          *
   1029          * Arguments  : p_tcb      is a pointer to the TCB of the task receiving a message.  If you specify a NULL pointer then
   1030          *                         the message will be posted to the task's queue of the calling task.  In other words, you'd be
   1031          *                         posting a message to yourself.
   1032          *
   1033          *              p_void     is a pointer to the message to send.
   1034          *
   1035          *              msg_size   is the size of the message sent (in bytes)
   1036          *
   1037          *              opt        specifies whether the post will be FIFO or LIFO:
   1038          *
   1039          *                             OS_OPT_POST_FIFO       Post at the end   of the queue
   1040          *                             OS_OPT_POST_LIFO       Post at the front of the queue
   1041          *
   1042          *                             OS_OPT_POST_NO_SCHED   Do not run the scheduler after the post
   1043          *
   1044          *                          Note(s): 1) OS_OPT_POST_NO_SCHED can be added with one of the other options.
   1045          *
   1046          *
   1047          *              p_err      is a pointer to a variable that will hold the error code associated
   1048          *                         with the outcome of this call.  Errors can be:
   1049          *
   1050          *                             OS_ERR_NONE              The call was successful and the message was sent
   1051          *                             OS_ERR_MSG_POOL_EMPTY    If there are no more OS_MSGs available from the pool
   1052          *                             OS_ERR_OPT_INVALID       If you specified an invalid option
   1053          *                             OS_ERR_OS_NOT_RUNNING    If uC/OS-III is not running yet
   1054          *                             OS_ERR_Q_MAX             If the queue is full
   1055          *                             OS_ERR_STATE_INVALID     If the task is in an invalid state.  This should never happen
   1056          *                                                      and if it does, would be considered a system failure
   1057          *
   1058          * Returns    : none
   1059          *
   1060          * Note(s)    : none
   1061          ************************************************************************************************************************
   1062          */
   1063          
   1064          #if (OS_CFG_TASK_Q_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   1065          void  OSTaskQPost (OS_TCB       *p_tcb,
   1066                             void         *p_void,
   1067                             OS_MSG_SIZE   msg_size,
   1068                             OS_OPT        opt,
   1069                             OS_ERR       *p_err)
   1070          {
   \                     OSTaskQPost: (+1)
   \   00000000   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   1071              CPU_TS  ts;
   1072              CPU_SR_ALLOC();
   \   0000000C   0xF05F 0x0A00      MOVS     R10,#+0
   \   00000010   0xF8DD 0x8028      LDR      R8,[SP, #+40]
   1073          
   1074          
   1075          #ifdef OS_SAFETY_CRITICAL
   1076              if (p_err == DEF_NULL) {
   1077                  OS_SAFETY_CRITICAL_EXCEPTION();
   1078                  return;
   1079              }
   1080          #endif
   1081          
   1082              OS_TRACE_TASK_MSG_Q_POST_ENTER(&p_tcb->MsgQ, p_void, msg_size, opt);
   1083          
   1084          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
   1085              if (OSRunning != OS_STATE_OS_RUNNING) {
   1086                  OS_TRACE_TASK_MSG_Q_POST_EXIT(OS_ERR_OS_NOT_RUNNING);
   1087                 *p_err = OS_ERR_OS_NOT_RUNNING;
   1088                  return;
   1089              }
   1090          #endif
   1091          
   1092          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)                          /* ---------------- VALIDATE ARGUMENTS ---------------- */
   1093              switch (opt) {                                              /* User must supply a valid option                      */
   \   00000014   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000016   0x0038             MOVS     R0,R7
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD008             BEQ.N    ??OSTaskQPost_0
   \   0000001C   0x2810             CMP      R0,#+16
   \   0000001E   0xD006             BEQ.N    ??OSTaskQPost_0
   \   00000020   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000024   0xD003             BEQ.N    ??OSTaskQPost_0
   \   00000026   0xF248 0x0110      MOVW     R1,#+32784
   \   0000002A   0x4288             CMP      R0,R1
   \   0000002C   0xD132             BNE.N    ??OSTaskQPost_1
   1094                  case OS_OPT_POST_FIFO:
   1095                  case OS_OPT_POST_LIFO:
   1096                  case OS_OPT_POST_FIFO | OS_OPT_POST_NO_SCHED:
   1097                  case OS_OPT_POST_LIFO | OS_OPT_POST_NO_SCHED:
   1098                       break;
   1099          
   1100                  default:
   1101                       OS_TRACE_TASK_MSG_Q_POST_FAILED(&p_tcb->MsgQ);
   1102                       OS_TRACE_TASK_MSG_Q_POST_EXIT(OS_ERR_OPT_INVALID);
   1103                      *p_err = OS_ERR_OPT_INVALID;
   1104                       return;
   1105              }
   1106          #endif
   1107          
   1108          #if (OS_CFG_TS_EN == DEF_ENABLED)
   1109              ts = OS_TS_GET();                                           /* Get timestamp                                        */
   \                     ??OSTaskQPost_0: (+1)
   \   0000002E   0x.... 0x....      BL       CPU_TS_TmrRd
   \   00000032   0x4681             MOV      R9,R0
   1110          #else
   1111              ts = 0u;
   1112          #endif
   1113          
   1114              OS_TRACE_TASK_MSG_Q_POST(&p_tcb->MsgQ);
   1115          
   1116             *p_err = OS_ERR_NONE;                                        /* Assume we won't have any errors                      */
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   1117              CPU_CRITICAL_ENTER();
   \   0000003A   0x.... 0x....      BL       CPU_SR_Save
   \   0000003E   0x4682             MOV      R10,R0
   \   00000040   0x.... 0x....      BL       CPU_IntDisMeasStart
   1118              if (p_tcb == DEF_NULL) {                                    /* Post msg to 'self'?                                  */
   \   00000044   0x2C00             CMP      R4,#+0
   \   00000046   0xD102             BNE.N    ??OSTaskQPost_2
   1119                  p_tcb = OSTCBCurPtr;
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable22
   \   0000004C   0x6804             LDR      R4,[R0, #+0]
   1120              }
   1121              switch (p_tcb->TaskState) {
   \                     ??OSTaskQPost_2: (+1)
   \   0000004E   0xF894 0x003E      LDRB     R0,[R4, #+62]
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD00B             BEQ.N    ??OSTaskQPost_3
   \   00000056   0x2802             CMP      R0,#+2
   \   00000058   0xD021             BEQ.N    ??OSTaskQPost_4
   \   0000005A   0xD308             BCC.N    ??OSTaskQPost_3
   \   0000005C   0x2804             CMP      R0,#+4
   \   0000005E   0xD006             BEQ.N    ??OSTaskQPost_3
   \   00000060   0xD31D             BCC.N    ??OSTaskQPost_4
   \   00000062   0x2806             CMP      R0,#+6
   \   00000064   0xD01B             BEQ.N    ??OSTaskQPost_4
   \   00000066   0xD302             BCC.N    ??OSTaskQPost_3
   \   00000068   0x2807             CMP      R0,#+7
   \   0000006A   0xD018             BEQ.N    ??OSTaskQPost_4
   \   0000006C   0xE042             B.N      ??OSTaskQPost_5
   1122                  case OS_TASK_STATE_RDY:
   1123                  case OS_TASK_STATE_DLY:
   1124                  case OS_TASK_STATE_SUSPENDED:
   1125                  case OS_TASK_STATE_DLY_SUSPENDED:
   1126                       OS_MsgQPut(&p_tcb->MsgQ,                           /* Deposit the message in the queue                     */
   1127                                  p_void,
   1128                                  msg_size,
   1129                                  opt,
   1130                                  ts,
   1131                                  p_err);
   \                     ??OSTaskQPost_3: (+1)
   \   0000006E   0xF8CD 0x8004      STR      R8,[SP, #+4]
   \   00000072   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \   00000076   0x003B             MOVS     R3,R7
   \   00000078   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000007A   0x0032             MOVS     R2,R6
   \   0000007C   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000007E   0x0029             MOVS     R1,R5
   \   00000080   0xF114 0x0068      ADDS     R0,R4,#+104
   \   00000084   0x.... 0x....      BL       OS_MsgQPut
   1132                       CPU_CRITICAL_EXIT();
   \   00000088   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000008C   0x4650             MOV      R0,R10
   \   0000008E   0x.... 0x....      BL       CPU_SR_Restore
   1133                       break;
   \   00000092   0xE038             B.N      ??OSTaskQPost_6
   \                     ??OSTaskQPost_1: (+1)
   \   00000094   0xF645 0x6025      MOVW     R0,#+24101
   \   00000098   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   \   0000009C   0xE033             B.N      ??OSTaskQPost_7
   1134          
   1135                  case OS_TASK_STATE_PEND:
   1136                  case OS_TASK_STATE_PEND_TIMEOUT:
   1137                  case OS_TASK_STATE_PEND_SUSPENDED:
   1138                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
   1139                       if (p_tcb->PendOn == OS_TASK_PEND_ON_TASK_Q) {     /* Is task waiting for a message to be sent to it?      */
   \                     ??OSTaskQPost_4: (+1)
   \   0000009E   0xF894 0x003C      LDRB     R0,[R4, #+60]
   \   000000A2   0x2802             CMP      R0,#+2
   \   000000A4   0xD113             BNE.N    ??OSTaskQPost_8
   1140                           OS_Post(DEF_NULL,
   1141                                   p_tcb,
   1142                                   p_void,
   1143                                   msg_size,
   1144                                   ts);
   \   000000A6   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \   000000AA   0x0033             MOVS     R3,R6
   \   000000AC   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   000000AE   0x002A             MOVS     R2,R5
   \   000000B0   0x0021             MOVS     R1,R4
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0x.... 0x....      BL       OS_Post
   1145                           CPU_CRITICAL_EXIT();
   \   000000B8   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000BC   0x4650             MOV      R0,R10
   \   000000BE   0x.... 0x....      BL       CPU_SR_Restore
   1146                           if ((opt & OS_OPT_POST_NO_SCHED) == 0u) {
   \   000000C2   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000C4   0x0438             LSLS     R0,R7,#+16
   \   000000C6   0xD414             BMI.N    ??OSTaskQPost_9
   1147                               OSSched();                                 /* Run the scheduler                                    */
   \   000000C8   0x.... 0x....      BL       OSSched
   \   000000CC   0xE011             B.N      ??OSTaskQPost_9
   1148                           }
   1149                       } else {
   1150                           OS_MsgQPut(&p_tcb->MsgQ,                       /* No,  Task is pending on something else ...           */
   1151                                      p_void,                             /* ... Deposit the message in the task's queue          */
   1152                                      msg_size,
   1153                                      opt,
   1154                                      ts,
   1155                                      p_err);
   \                     ??OSTaskQPost_8: (+1)
   \   000000CE   0xF8CD 0x8004      STR      R8,[SP, #+4]
   \   000000D2   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \   000000D6   0x003B             MOVS     R3,R7
   \   000000D8   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   000000DA   0x0032             MOVS     R2,R6
   \   000000DC   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000000DE   0x0029             MOVS     R1,R5
   \   000000E0   0xF114 0x0068      ADDS     R0,R4,#+104
   \   000000E4   0x.... 0x....      BL       OS_MsgQPut
   1156                           CPU_CRITICAL_EXIT();
   \   000000E8   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000EC   0x4650             MOV      R0,R10
   \   000000EE   0x.... 0x....      BL       CPU_SR_Restore
   1157                       }
   1158                       break;
   \                     ??OSTaskQPost_9: (+1)
   \   000000F2   0xE008             B.N      ??OSTaskQPost_6
   1159          
   1160                  default:
   1161                       CPU_CRITICAL_EXIT();
   \                     ??OSTaskQPost_5: (+1)
   \   000000F4   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000F8   0x4650             MOV      R0,R10
   \   000000FA   0x.... 0x....      BL       CPU_SR_Restore
   1162                      *p_err = OS_ERR_STATE_INVALID;
   \   000000FE   0xF646 0x602D      MOVW     R0,#+28205
   \   00000102   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   1163                       break;
   1164              }
   1165          
   1166              OS_TRACE_TASK_MSG_Q_POST_EXIT(*p_err);
   1167          }
   \                     ??OSTaskQPost_6: (+1)
   \                     ??OSTaskQPost_7: (+1)
   \   00000106   0xE8BD 0x87F3      POP      {R0,R1,R4-R10,PC}  ;; return
   1168          #endif
   1169          
   1170          
   1171          /*
   1172          ************************************************************************************************************************
   1173          *                                       GET THE CURRENT VALUE OF A TASK REGISTER
   1174          *
   1175          * Description: This function is called to obtain the current value of a task register.  Task registers are application
   1176          *              specific and can be used to store task specific values such as 'error numbers' (i.e. errno), statistics,
   1177          *              etc.
   1178          *
   1179          * Arguments  : p_tcb     is a pointer to the OS_TCB of the task you want to read the register from.  If 'p_tcb' is a
   1180          *                        NULL pointer then you will get the register of the current task.
   1181          *
   1182          *              id        is the 'id' of the desired task variable.  Note that the 'id' must be less than
   1183          *                        OS_CFG_TASK_REG_TBL_SIZE
   1184          *
   1185          *              p_err     is a pointer to a variable that will hold an error code related to this call.
   1186          *
   1187          *                            OS_ERR_NONE               If the call was successful
   1188          *                            OS_ERR_REG_ID_INVALID     If the 'id' is not between 0 and OS_CFG_TASK_REG_TBL_SIZE-1
   1189          *
   1190          * Returns    : The current value of the task's register or 0 if an error is detected.
   1191          *
   1192          * Note(s)    : none
   1193          ************************************************************************************************************************
   1194          */
   1195          
   1196          #if (OS_CFG_TASK_REG_TBL_SIZE > 0u)

   \                                 In section .text, align 2, keep-with-next
   1197          OS_REG  OSTaskRegGet (OS_TCB     *p_tcb,
   1198                                OS_REG_ID   id,
   1199                                OS_ERR     *p_err)
   1200          {
   \                     OSTaskRegGet: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0014             MOVS     R4,R2
   1201              OS_REG     value;
   1202              CPU_SR_ALLOC();
   \   00000008   0x2700             MOVS     R7,#+0
   1203          
   1204          
   1205          
   1206          #ifdef OS_SAFETY_CRITICAL
   1207              if (p_err == DEF_NULL) {
   1208                  OS_SAFETY_CRITICAL_EXCEPTION();
   1209                  return (0u);
   1210              }
   1211          #endif
   1212          
   1213          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
   1214              if (id >= OS_CFG_TASK_REG_TBL_SIZE) {
   \   0000000A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000000C   0x2E00             CMP      R6,#+0
   \   0000000E   0xD004             BEQ.N    ??OSTaskRegGet_0
   1215                 *p_err = OS_ERR_REG_ID_INVALID;
   \   00000010   0xF646 0x1079      MOVW     R0,#+27001
   \   00000014   0x8020             STRH     R0,[R4, #+0]
   1216                  return (0u);
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE015             B.N      ??OSTaskRegGet_1
   1217              }
   1218          #endif
   1219          
   1220              CPU_CRITICAL_ENTER();
   \                     ??OSTaskRegGet_0: (+1)
   \   0000001A   0x.... 0x....      BL       CPU_SR_Save
   \   0000001E   0x0007             MOVS     R7,R0
   \   00000020   0x.... 0x....      BL       CPU_IntDisMeasStart
   1221              if (p_tcb == DEF_NULL) {
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD102             BNE.N    ??OSTaskRegGet_2
   1222                  p_tcb = OSTCBCurPtr;
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable22
   \   0000002C   0x6805             LDR      R5,[R0, #+0]
   1223              }
   1224              value = p_tcb->RegTbl[id];
   \                     ??OSTaskRegGet_2: (+1)
   \   0000002E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000030   0xEB15 0x0086      ADDS     R0,R5,R6, LSL #+2
   \   00000034   0x6F85             LDR      R5,[R0, #+120]
   1225              CPU_CRITICAL_EXIT();
   \   00000036   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000003A   0x0038             MOVS     R0,R7
   \   0000003C   0x.... 0x....      BL       CPU_SR_Restore
   1226             *p_err = OS_ERR_NONE;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x8020             STRH     R0,[R4, #+0]
   1227              return (value);
   \   00000044   0x0028             MOVS     R0,R5
   \                     ??OSTaskRegGet_1: (+1)
   \   00000046   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1228          }
   1229          #endif
   1230          
   1231          
   1232          /*
   1233          ************************************************************************************************************************
   1234          *                                    ALLOCATE THE NEXT AVAILABLE TASK REGISTER ID
   1235          *
   1236          * Description: This function is called to obtain a task register ID.  This function thus allows task registers IDs to be
   1237          *              allocated dynamically instead of statically.
   1238          *
   1239          * Arguments  : p_err       is a pointer to a variable that will hold an error code related to this call.
   1240          *
   1241          *                            OS_ERR_NONE               If the call was successful
   1242          *                            OS_ERR_NO_MORE_ID_AVAIL   If you are attempting to assign more task register IDs than you
   1243          *                                                          have available through OS_CFG_TASK_REG_TBL_SIZE
   1244          *
   1245          * Returns    : The next available task register 'id' or OS_CFG_TASK_REG_TBL_SIZE if an error is detected.
   1246          *
   1247          * Note(s)    : none
   1248          ************************************************************************************************************************
   1249          */
   1250          
   1251          #if (OS_CFG_TASK_REG_TBL_SIZE > 0u)

   \                                 In section .text, align 2, keep-with-next
   1252          OS_REG_ID  OSTaskRegGetID (OS_ERR  *p_err)
   1253          {
   \                     OSTaskRegGetID: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1254              OS_REG_ID  id;
   1255              CPU_SR_ALLOC();
   \   00000004   0x2500             MOVS     R5,#+0
   1256          
   1257          
   1258          
   1259          #ifdef OS_SAFETY_CRITICAL
   1260              if (p_err == DEF_NULL) {
   1261                  OS_SAFETY_CRITICAL_EXCEPTION();
   1262                  return ((OS_REG_ID)OS_CFG_TASK_REG_TBL_SIZE);
   1263              }
   1264          #endif
   1265          
   1266              CPU_CRITICAL_ENTER();
   \   00000006   0x.... 0x....      BL       CPU_SR_Save
   \   0000000A   0x0005             MOVS     R5,R0
   \   0000000C   0x.... 0x....      BL       CPU_IntDisMeasStart
   1267              if (OSTaskRegNextAvailID >= OS_CFG_TASK_REG_TBL_SIZE) {     /* See if we exceeded the number of IDs available       */
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable22_3
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD009             BEQ.N    ??OSTaskRegGetID_0
   1268                 *p_err = OS_ERR_NO_MORE_ID_AVAIL;                        /* Yes, cannot allocate more task register IDs          */
   \   0000001A   0xF645 0x10DA      MOVW     R0,#+23002
   \   0000001E   0x8020             STRH     R0,[R4, #+0]
   1269                  CPU_CRITICAL_EXIT();
   \   00000020   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000024   0x0028             MOVS     R0,R5
   \   00000026   0x.... 0x....      BL       CPU_SR_Restore
   1270                  return (OS_CFG_TASK_REG_TBL_SIZE);
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xE012             B.N      ??OSTaskRegGetID_1
   1271              }
   1272          
   1273              id = OSTaskRegNextAvailID;                                  /* Assign the next available ID                         */
   \                     ??OSTaskRegGetID_0: (+1)
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable22_3
   \   00000032   0x7806             LDRB     R6,[R0, #+0]
   1274              OSTaskRegNextAvailID++;                                     /* Increment available ID for next request              */
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable22_3
   \   00000038   0x7800             LDRB     R0,[R0, #+0]
   \   0000003A   0x1C40             ADDS     R0,R0,#+1
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable22_3
   \   00000040   0x7008             STRB     R0,[R1, #+0]
   1275              CPU_CRITICAL_EXIT();
   \   00000042   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000046   0x0028             MOVS     R0,R5
   \   00000048   0x.... 0x....      BL       CPU_SR_Restore
   1276             *p_err = OS_ERR_NONE;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x8020             STRH     R0,[R4, #+0]
   1277              return (id);
   \   00000050   0x0030             MOVS     R0,R6
   \   00000052   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??OSTaskRegGetID_1: (+1)
   \   00000054   0xBD70             POP      {R4-R6,PC}       ;; return
   1278          }
   1279          #endif
   1280          
   1281          
   1282          /*
   1283          ************************************************************************************************************************
   1284          *                                       SET THE CURRENT VALUE OF A TASK REGISTER
   1285          *
   1286          * Description: This function is called to change the current value of a task register.  Task registers are application
   1287          *              specific and can be used to store task specific values such as 'error numbers' (i.e. errno), statistics,
   1288          *              etc.
   1289          *
   1290          * Arguments  : p_tcb     is a pointer to the OS_TCB of the task you want to set the register for.  If 'p_tcb' is a NULL
   1291          *                        pointer then you will change the register of the current task.
   1292          *
   1293          *              id        is the 'id' of the desired task register.  Note that the 'id' must be less than
   1294          *                        OS_CFG_TASK_REG_TBL_SIZE
   1295          *
   1296          *              value     is the desired value for the task register.
   1297          *
   1298          *              p_err     is a pointer to a variable that will hold an error code related to this call.
   1299          *
   1300          *                            OS_ERR_NONE               If the call was successful
   1301          *                            OS_ERR_REG_ID_INVALID     If the 'id' is not between 0 and OS_CFG_TASK_REG_TBL_SIZE-1
   1302          *
   1303          * Returns    : none
   1304          *
   1305          * Note(s)    : none
   1306          ************************************************************************************************************************
   1307          */
   1308          
   1309          #if (OS_CFG_TASK_REG_TBL_SIZE > 0u)

   \                                 In section .text, align 2, keep-with-next
   1310          void  OSTaskRegSet (OS_TCB     *p_tcb,
   1311                              OS_REG_ID   id,
   1312                              OS_REG      value,
   1313                              OS_ERR     *p_err)
   1314          {
   \                     OSTaskRegSet: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0017             MOVS     R7,R2
   \   0000000A   0x001C             MOVS     R4,R3
   1315              CPU_SR_ALLOC();
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   1316          
   1317          
   1318          
   1319          #ifdef OS_SAFETY_CRITICAL
   1320              if (p_err == DEF_NULL) {
   1321                  OS_SAFETY_CRITICAL_EXCEPTION();
   1322                  return;
   1323              }
   1324          #endif
   1325          
   1326          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
   1327              if (id >= OS_CFG_TASK_REG_TBL_SIZE) {
   \   00000010   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000012   0x2E00             CMP      R6,#+0
   \   00000014   0xD003             BEQ.N    ??OSTaskRegSet_0
   1328                 *p_err = OS_ERR_REG_ID_INVALID;
   \   00000016   0xF646 0x1079      MOVW     R0,#+27001
   \   0000001A   0x8020             STRH     R0,[R4, #+0]
   1329                  return;
   \   0000001C   0xE014             B.N      ??OSTaskRegSet_1
   1330              }
   1331          #endif
   1332          
   1333              CPU_CRITICAL_ENTER();
   \                     ??OSTaskRegSet_0: (+1)
   \   0000001E   0x.... 0x....      BL       CPU_SR_Save
   \   00000022   0x4680             MOV      R8,R0
   \   00000024   0x.... 0x....      BL       CPU_IntDisMeasStart
   1334              if (p_tcb == DEF_NULL) {
   \   00000028   0x2D00             CMP      R5,#+0
   \   0000002A   0xD102             BNE.N    ??OSTaskRegSet_2
   1335                  p_tcb = OSTCBCurPtr;
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable22
   \   00000030   0x6805             LDR      R5,[R0, #+0]
   1336              }
   1337              p_tcb->RegTbl[id] = value;
   \                     ??OSTaskRegSet_2: (+1)
   \   00000032   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000034   0xEB15 0x0086      ADDS     R0,R5,R6, LSL #+2
   \   00000038   0x6787             STR      R7,[R0, #+120]
   1338              CPU_CRITICAL_EXIT();
   \   0000003A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000003E   0x4640             MOV      R0,R8
   \   00000040   0x.... 0x....      BL       CPU_SR_Restore
   1339             *p_err             = OS_ERR_NONE;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x8020             STRH     R0,[R4, #+0]
   1340          }
   \                     ??OSTaskRegSet_1: (+1)
   \   00000048   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1341          #endif
   1342          
   1343          
   1344          /*
   1345          ************************************************************************************************************************
   1346          *                                               RESUME A SUSPENDED TASK
   1347          *
   1348          * Description: This function is called to resume a previously suspended task.  This is the only call that will remove an
   1349          *              explicit task suspension.
   1350          *
   1351          * Arguments  : p_tcb      Is a pointer to the task's OS_TCB to resume
   1352          *
   1353          *              p_err      Is a pointer to a variable that will contain an error code returned by this function
   1354          *
   1355          *                             OS_ERR_NONE                  If the requested task is resumed
   1356          *                             OS_ERR_OS_NOT_RUNNING        If uC/OS-III is not running yet
   1357          *                             OS_ERR_STATE_INVALID         If the task is in an invalid state
   1358          *                             OS_ERR_TASK_NOT_SUSPENDED    If the task to resume has not been suspended
   1359          *                             OS_ERR_TASK_RESUME_ISR       If you called this function from an ISR
   1360          *                             OS_ERR_TASK_RESUME_SELF      You cannot resume 'self'
   1361          *
   1362          * Returns    : none
   1363          *
   1364          * Note(s)    : none
   1365          ************************************************************************************************************************
   1366          */
   1367          
   1368          #if (OS_CFG_TASK_SUSPEND_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   1369          void  OSTaskResume (OS_TCB  *p_tcb,
   1370                              OS_ERR  *p_err)
   1371          {
   \                     OSTaskResume: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
   1372              CPU_SR_ALLOC();
   \   00000006   0x2600             MOVS     R6,#+0
   1373          
   1374          
   1375          #ifdef OS_SAFETY_CRITICAL
   1376              if (p_err == DEF_NULL) {
   1377                  OS_SAFETY_CRITICAL_EXCEPTION();
   1378                  return;
   1379              }
   1380          #endif
   1381          
   1382          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
   1383              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable13
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD003             BEQ.N    ??OSTaskResume_0
   1384                 *p_err = OS_ERR_TASK_RESUME_ISR;
   \   00000012   0xF247 0x1055      MOVW     R0,#+29013
   \   00000016   0x8020             STRH     R0,[R4, #+0]
   1385                  return;
   \   00000018   0xE038             B.N      ??OSTaskResume_1
   1386              }
   1387          #endif
   1388          
   1389          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
   1390              if (OSRunning != OS_STATE_OS_RUNNING) {
   1391                 *p_err = OS_ERR_OS_NOT_RUNNING;
   1392                  return;
   1393              }
   1394          #endif
   1395          
   1396          
   1397          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
   1398              CPU_CRITICAL_ENTER();
   \                     ??OSTaskResume_0: (+1)
   \   0000001A   0x.... 0x....      BL       CPU_SR_Save
   \   0000001E   0x0006             MOVS     R6,R0
   \   00000020   0x.... 0x....      BL       CPU_IntDisMeasStart
   1399              if ((p_tcb == DEF_NULL) ||                                  /* We cannot resume 'self'                              */
   1400                  (p_tcb == OSTCBCurPtr)) {
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD004             BEQ.N    ??OSTaskResume_2
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable22
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x4285             CMP      R5,R0
   \   00000030   0xD108             BNE.N    ??OSTaskResume_3
   1401                  CPU_CRITICAL_EXIT();
   \                     ??OSTaskResume_2: (+1)
   \   00000032   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000036   0x0030             MOVS     R0,R6
   \   00000038   0x.... 0x....      BL       CPU_SR_Restore
   1402                 *p_err  = OS_ERR_TASK_RESUME_SELF;
   \   0000003C   0xF247 0x1057      MOVW     R0,#+29015
   \   00000040   0x8020             STRH     R0,[R4, #+0]
   1403                  return;
   \   00000042   0xE023             B.N      ??OSTaskResume_1
   1404              }
   1405              CPU_CRITICAL_EXIT();
   \                     ??OSTaskResume_3: (+1)
   \   00000044   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000048   0x0030             MOVS     R0,R6
   \   0000004A   0x.... 0x....      BL       CPU_SR_Restore
   1406          #endif
   1407          
   1408              CPU_CRITICAL_ENTER();
   \   0000004E   0x.... 0x....      BL       CPU_SR_Save
   \   00000052   0x0006             MOVS     R6,R0
   \   00000054   0x.... 0x....      BL       CPU_IntDisMeasStart
   1409             *p_err  = OS_ERR_NONE;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x8020             STRH     R0,[R4, #+0]
   1410              switch (p_tcb->TaskState) {
   \   0000005C   0xF895 0x003E      LDRB     R0,[R5, #+62]
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0x2803             CMP      R0,#+3
   \   00000064   0xD908             BLS.N    ??OSTaskResume_4
   \   00000066   0x1F00             SUBS     R0,R0,#+4
   \   00000068   0xD011             BEQ.N    ??OSTaskResume_5
   \   0000006A   0x1E40             SUBS     R0,R0,#+1
   \   0000006C   0xD024             BEQ.N    ??OSTaskResume_6
   \   0000006E   0x1E40             SUBS     R0,R0,#+1
   \   00000070   0xD034             BEQ.N    ??OSTaskResume_7
   \   00000072   0x1E40             SUBS     R0,R0,#+1
   \   00000074   0xD044             BEQ.N    ??OSTaskResume_8
   \   00000076   0xE055             B.N      ??OSTaskResume_9
   1411                  case OS_TASK_STATE_RDY:
   1412                  case OS_TASK_STATE_DLY:
   1413                  case OS_TASK_STATE_PEND:
   1414                  case OS_TASK_STATE_PEND_TIMEOUT:
   1415                       CPU_CRITICAL_EXIT();
   \                     ??OSTaskResume_4: (+1)
   \   00000078   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000007C   0x0030             MOVS     R0,R6
   \   0000007E   0x.... 0x....      BL       CPU_SR_Restore
   1416                      *p_err = OS_ERR_TASK_NOT_SUSPENDED;
   \   00000082   0xF247 0x1053      MOVW     R0,#+29011
   \   00000086   0x8020             STRH     R0,[R4, #+0]
   1417                       break;
   1418          
   1419                  case OS_TASK_STATE_SUSPENDED:
   1420                       p_tcb->SuspendCtr--;
   1421                       if (p_tcb->SuspendCtr == 0u) {
   1422                           p_tcb->TaskState = OS_TASK_STATE_RDY;
   1423                           OS_RdyListInsert(p_tcb);                       /* Insert the task in the ready list                    */
   1424                       }
   1425                       CPU_CRITICAL_EXIT();
   1426                       break;
   1427          
   1428                  case OS_TASK_STATE_DLY_SUSPENDED:
   1429                       p_tcb->SuspendCtr--;
   1430                       if (p_tcb->SuspendCtr == 0u) {
   1431                           p_tcb->TaskState = OS_TASK_STATE_DLY;
   1432                       }
   1433                       CPU_CRITICAL_EXIT();
   1434                       break;
   1435          
   1436                  case OS_TASK_STATE_PEND_SUSPENDED:
   1437                       p_tcb->SuspendCtr--;
   1438                       if (p_tcb->SuspendCtr == 0u) {
   1439                           p_tcb->TaskState = OS_TASK_STATE_PEND;
   1440                       }
   1441                       CPU_CRITICAL_EXIT();
   1442                       break;
   1443          
   1444                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
   1445                       p_tcb->SuspendCtr--;
   1446                       if (p_tcb->SuspendCtr == 0u) {
   1447                           p_tcb->TaskState = OS_TASK_STATE_PEND_TIMEOUT;
   1448                       }
   1449                       CPU_CRITICAL_EXIT();
   1450                       break;
   1451          
   1452                  default:
   1453                       CPU_CRITICAL_EXIT();
   1454                      *p_err = OS_ERR_STATE_INVALID;
   1455                       return;
   1456              }
   1457          
   1458              OS_TRACE_TASK_RESUME(p_tcb);
   1459              OSSched();
   \                     ??OSTaskResume_10: (+1)
   \   00000088   0x.... 0x....      BL       OSSched
   1460          }
   \                     ??OSTaskResume_1: (+1)
   \   0000008C   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??OSTaskResume_5: (+1)
   \   0000008E   0xF895 0x0086      LDRB     R0,[R5, #+134]
   \   00000092   0x1E40             SUBS     R0,R0,#+1
   \   00000094   0xF885 0x0086      STRB     R0,[R5, #+134]
   \   00000098   0xF895 0x0086      LDRB     R0,[R5, #+134]
   \   0000009C   0x2800             CMP      R0,#+0
   \   0000009E   0xD105             BNE.N    ??OSTaskResume_11
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0xF885 0x003E      STRB     R0,[R5, #+62]
   \   000000A6   0x0028             MOVS     R0,R5
   \   000000A8   0x.... 0x....      BL       OS_RdyListInsert
   \                     ??OSTaskResume_11: (+1)
   \   000000AC   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000B0   0x0030             MOVS     R0,R6
   \   000000B2   0x.... 0x....      BL       CPU_SR_Restore
   \   000000B6   0xE7E7             B.N      ??OSTaskResume_10
   \                     ??OSTaskResume_6: (+1)
   \   000000B8   0xF895 0x0086      LDRB     R0,[R5, #+134]
   \   000000BC   0x1E40             SUBS     R0,R0,#+1
   \   000000BE   0xF885 0x0086      STRB     R0,[R5, #+134]
   \   000000C2   0xF895 0x0086      LDRB     R0,[R5, #+134]
   \   000000C6   0x2800             CMP      R0,#+0
   \   000000C8   0xD102             BNE.N    ??OSTaskResume_12
   \   000000CA   0x2001             MOVS     R0,#+1
   \   000000CC   0xF885 0x003E      STRB     R0,[R5, #+62]
   \                     ??OSTaskResume_12: (+1)
   \   000000D0   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000D4   0x0030             MOVS     R0,R6
   \   000000D6   0x.... 0x....      BL       CPU_SR_Restore
   \   000000DA   0xE7D5             B.N      ??OSTaskResume_10
   \                     ??OSTaskResume_7: (+1)
   \   000000DC   0xF895 0x0086      LDRB     R0,[R5, #+134]
   \   000000E0   0x1E40             SUBS     R0,R0,#+1
   \   000000E2   0xF885 0x0086      STRB     R0,[R5, #+134]
   \   000000E6   0xF895 0x0086      LDRB     R0,[R5, #+134]
   \   000000EA   0x2800             CMP      R0,#+0
   \   000000EC   0xD102             BNE.N    ??OSTaskResume_13
   \   000000EE   0x2002             MOVS     R0,#+2
   \   000000F0   0xF885 0x003E      STRB     R0,[R5, #+62]
   \                     ??OSTaskResume_13: (+1)
   \   000000F4   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000F8   0x0030             MOVS     R0,R6
   \   000000FA   0x.... 0x....      BL       CPU_SR_Restore
   \   000000FE   0xE7C3             B.N      ??OSTaskResume_10
   \                     ??OSTaskResume_8: (+1)
   \   00000100   0xF895 0x0086      LDRB     R0,[R5, #+134]
   \   00000104   0x1E40             SUBS     R0,R0,#+1
   \   00000106   0xF885 0x0086      STRB     R0,[R5, #+134]
   \   0000010A   0xF895 0x0086      LDRB     R0,[R5, #+134]
   \   0000010E   0x2800             CMP      R0,#+0
   \   00000110   0xD102             BNE.N    ??OSTaskResume_14
   \   00000112   0x2003             MOVS     R0,#+3
   \   00000114   0xF885 0x003E      STRB     R0,[R5, #+62]
   \                     ??OSTaskResume_14: (+1)
   \   00000118   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000011C   0x0030             MOVS     R0,R6
   \   0000011E   0x.... 0x....      BL       CPU_SR_Restore
   \   00000122   0xE7B1             B.N      ??OSTaskResume_10
   \                     ??OSTaskResume_9: (+1)
   \   00000124   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000128   0x0030             MOVS     R0,R6
   \   0000012A   0x.... 0x....      BL       CPU_SR_Restore
   \   0000012E   0xF646 0x602D      MOVW     R0,#+28205
   \   00000132   0x8020             STRH     R0,[R4, #+0]
   \   00000134   0xE7AA             B.N      ??OSTaskResume_1
   1461          #endif
   1462          
   1463          
   1464          /*
   1465          ************************************************************************************************************************
   1466          *                                              WAIT FOR A TASK SEMAPHORE
   1467          *
   1468          * Description: This function is called to block the current task until a signal is sent by another task or ISR.
   1469          *
   1470          * Arguments  : timeout       is the amount of time you are will to wait for the signal
   1471          *
   1472          *              opt           determines whether the user wants to block if a semaphore post was not received:
   1473          *
   1474          *                                OS_OPT_PEND_BLOCKING
   1475          *                                OS_OPT_PEND_NON_BLOCKING
   1476          *
   1477          *              p_ts          is a pointer to a variable that will receive the timestamp of when the semaphore was posted
   1478          *                            or pend aborted.  If you pass a NULL pointer (i.e. (CPU_TS *)0) then you will not get the
   1479          *                            timestamp.  In other words, passing a NULL pointer is valid and indicates that you don't
   1480          *                            need the timestamp.
   1481          *
   1482          *              p_err         is a pointer to an error code that will be set by this function
   1483          *
   1484          *                                OS_ERR_NONE                The call was successful and your task received a message
   1485          *                                OS_ERR_OPT_INVALID         You specified an invalid option
   1486          *                                OS_ERR_OS_NOT_RUNNING      If uC/OS-III is not running yet
   1487          *                                OS_ERR_PEND_ABORT          If the pend was aborted
   1488          *                                OS_ERR_PEND_ISR            If you called this function from an ISR
   1489          *                                OS_ERR_PEND_WOULD_BLOCK    If you specified non-blocking but no signal was received
   1490          *                                OS_ERR_SCHED_LOCKED        If the scheduler is locked
   1491          *                                OS_ERR_STATUS_INVALID      If the pend status is invalid
   1492          *                                OS_ERR_TIMEOUT             A message was not received within the specified timeout
   1493          *
   1494          * Returns    : The current count of signals the task received, 0 if none.
   1495          *
   1496          * Note(s)    : none
   1497          ************************************************************************************************************************
   1498          */
   1499          

   \                                 In section .text, align 2, keep-with-next
   1500          OS_SEM_CTR  OSTaskSemPend (OS_TICK   timeout,
   1501                                     OS_OPT    opt,
   1502                                     CPU_TS   *p_ts,
   1503                                     OS_ERR   *p_err)
   1504          {
   \                     OSTaskSemPend: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0006             MOVS     R6,R0
   \   00000006   0x000F             MOVS     R7,R1
   \   00000008   0x0015             MOVS     R5,R2
   \   0000000A   0x001C             MOVS     R4,R3
   1505              OS_SEM_CTR    ctr;
   1506              CPU_SR_ALLOC();
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   1507          
   1508          
   1509          #if (OS_CFG_TS_EN == DEF_DISABLED)
   1510              (void)p_ts;                                                 /* Prevent compiler warning for not using 'ts'          */
   1511          #endif
   1512          
   1513          #ifdef OS_SAFETY_CRITICAL
   1514              if (p_err == DEF_NULL) {
   1515                  OS_SAFETY_CRITICAL_EXCEPTION();
   1516                  return (0u);
   1517              }
   1518          #endif
   1519          
   1520              OS_TRACE_TASK_SEM_PEND_ENTER(OSTCBCurPtr, timeout, opt, p_ts);
   1521          
   1522          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
   1523              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
   \   00000010   0x....             LDR.N    R0,??DataTable13
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD004             BEQ.N    ??OSTaskSemPend_0
   1524                  OS_TRACE_TASK_SEM_PEND_FAILED(OSTCBCurPtr);
   1525                  OS_TRACE_TASK_SEM_PEND_EXIT(OS_ERR_PEND_ISR);
   1526                 *p_err = OS_ERR_PEND_ISR;
   \   00000018   0xF246 0x10AE      MOVW     R0,#+25006
   \   0000001C   0x8020             STRH     R0,[R4, #+0]
   1527                  return (0u);
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xE09E             B.N      ??OSTaskSemPend_1
   1528              }
   1529          #endif
   1530          
   1531          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
   1532              if (OSRunning != OS_STATE_OS_RUNNING) {
   1533                  OS_TRACE_TASK_SEM_PEND_EXIT(OS_ERR_OS_NOT_RUNNING);
   1534                 *p_err = OS_ERR_OS_NOT_RUNNING;
   1535                  return (0u);
   1536              }
   1537          #endif
   1538          
   1539          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
   1540              switch (opt) {                                              /* Validate 'opt'                                       */
   \                     ??OSTaskSemPend_0: (+1)
   \   00000022   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000024   0x0038             MOVS     R0,R7
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD002             BEQ.N    ??OSTaskSemPend_2
   \   0000002A   0xF5B0 0x4F00      CMP      R0,#+32768
   \   0000002E   0xD11B             BNE.N    ??OSTaskSemPend_3
   1541                  case OS_OPT_PEND_BLOCKING:
   1542                  case OS_OPT_PEND_NON_BLOCKING:
   1543                       break;
   1544          
   1545                  default:
   1546                       OS_TRACE_TASK_SEM_PEND_FAILED(OSTCBCurPtr);
   1547                       OS_TRACE_TASK_SEM_PEND_EXIT(OS_ERR_OPT_INVALID);
   1548                      *p_err = OS_ERR_OPT_INVALID;
   1549                       return (0u);
   1550              }
   1551          #endif
   1552          
   1553              CPU_CRITICAL_ENTER();
   \                     ??OSTaskSemPend_2: (+1)
   \   00000030   0x.... 0x....      BL       CPU_SR_Save
   \   00000034   0x4680             MOV      R8,R0
   \   00000036   0x.... 0x....      BL       CPU_IntDisMeasStart
   1554              if (OSTCBCurPtr->SemCtr > 0u) {                             /* See if task already been signaled                    */
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable22
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x6D40             LDR      R0,[R0, #+84]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD115             BNE.N    ??OSTaskSemPend_4
   1555                  OSTCBCurPtr->SemCtr--;
   1556                  ctr = OSTCBCurPtr->SemCtr;
   1557          #if (OS_CFG_TS_EN == DEF_ENABLED)
   1558                  if (p_ts != DEF_NULL) {
   1559                     *p_ts  = OSTCBCurPtr->TS;
   1560                  }
   1561          #if (OS_CFG_TASK_PROFILE_EN == DEF_ENABLED)
   1562          #if (OS_CFG_TS_EN == DEF_ENABLED)
   1563                  OSTCBCurPtr->SemPendTime = OS_TS_GET() - OSTCBCurPtr->TS;
   1564                  if (OSTCBCurPtr->SemPendTimeMax < OSTCBCurPtr->SemPendTime) {
   1565                      OSTCBCurPtr->SemPendTimeMax = OSTCBCurPtr->SemPendTime;
   1566                  }
   1567          #endif
   1568          #endif
   1569          #endif
   1570                  OS_TRACE_TASK_SEM_PEND(OSTCBCurPtr);
   1571                  CPU_CRITICAL_EXIT();
   1572                  OS_TRACE_TASK_SEM_PEND_EXIT(OS_ERR_NONE);
   1573                 *p_err = OS_ERR_NONE;
   1574                  return (ctr);
   1575              }
   1576          
   1577              if ((opt & OS_OPT_PEND_NON_BLOCKING) != 0u) {               /* Caller wants to block if not available?              */
   \   00000046   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000048   0x0438             LSLS     R0,R7,#+16
   \   0000004A   0xD52F             BPL.N    ??OSTaskSemPend_5
   1578                  CPU_CRITICAL_EXIT();
   \   0000004C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000050   0x4640             MOV      R0,R8
   \   00000052   0x.... 0x....      BL       CPU_SR_Restore
   1579          #if (OS_CFG_TS_EN == DEF_ENABLED)
   1580                  if (p_ts != DEF_NULL) {
   \   00000056   0x2D00             CMP      R5,#+0
   \   00000058   0xD001             BEQ.N    ??OSTaskSemPend_6
   1581                      *p_ts  = 0u;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x6028             STR      R0,[R5, #+0]
   1582                  }
   1583          #endif
   1584                  OS_TRACE_TASK_SEM_PEND_FAILED(OSTCBCurPtr);
   1585                  OS_TRACE_TASK_SEM_PEND_EXIT(OS_ERR_PEND_WOULD_BLOCK);
   1586                 *p_err = OS_ERR_PEND_WOULD_BLOCK;                        /* No                                                   */
   \                     ??OSTaskSemPend_6: (+1)
   \   0000005E   0xF246 0x10B0      MOVW     R0,#+25008
   \   00000062   0x8020             STRH     R0,[R4, #+0]
   1587                  return (0u);
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xE07B             B.N      ??OSTaskSemPend_1
   1588              } else {                                                    /* Yes                                                  */
   \                     ??OSTaskSemPend_3: (+1)
   \   00000068   0xF645 0x6025      MOVW     R0,#+24101
   \   0000006C   0x8020             STRH     R0,[R4, #+0]
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0xE076             B.N      ??OSTaskSemPend_1
   \                     ??OSTaskSemPend_4: (+1)
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable22
   \   00000076   0x6800             LDR      R0,[R0, #+0]
   \   00000078   0x6D40             LDR      R0,[R0, #+84]
   \   0000007A   0x1E40             SUBS     R0,R0,#+1
   \   0000007C   0x.... 0x....      LDR.W    R1,??DataTable22
   \   00000080   0x6809             LDR      R1,[R1, #+0]
   \   00000082   0x6548             STR      R0,[R1, #+84]
   \   00000084   0x.... 0x....      LDR.W    R0,??DataTable22
   \   00000088   0x6800             LDR      R0,[R0, #+0]
   \   0000008A   0x6D46             LDR      R6,[R0, #+84]
   \   0000008C   0x2D00             CMP      R5,#+0
   \   0000008E   0xD004             BEQ.N    ??OSTaskSemPend_7
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable22
   \   00000094   0x6800             LDR      R0,[R0, #+0]
   \   00000096   0x6D00             LDR      R0,[R0, #+80]
   \   00000098   0x6028             STR      R0,[R5, #+0]
   \                     ??OSTaskSemPend_7: (+1)
   \   0000009A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000009E   0x4640             MOV      R0,R8
   \   000000A0   0x.... 0x....      BL       CPU_SR_Restore
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0x8020             STRH     R0,[R4, #+0]
   \   000000A8   0x0030             MOVS     R0,R6
   \   000000AA   0xE059             B.N      ??OSTaskSemPend_1
   1589                  if (OSSchedLockNestingCtr > 0u) {                       /* Can't pend when the scheduler is locked              */
   \                     ??OSTaskSemPend_5: (+1)
   \   000000AC   0x.... 0x....      LDR.W    R0,??DataTable22_1
   \   000000B0   0x7800             LDRB     R0,[R0, #+0]
   \   000000B2   0x2800             CMP      R0,#+0
   \   000000B4   0xD00D             BEQ.N    ??OSTaskSemPend_8
   1590          #if (OS_CFG_TS_EN == DEF_ENABLED)
   1591                      if (p_ts != DEF_NULL) {
   \   000000B6   0x2D00             CMP      R5,#+0
   \   000000B8   0xD001             BEQ.N    ??OSTaskSemPend_9
   1592                         *p_ts  = 0u;
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0x6028             STR      R0,[R5, #+0]
   1593                      }
   1594          #endif
   1595                      CPU_CRITICAL_EXIT();
   \                     ??OSTaskSemPend_9: (+1)
   \   000000BE   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000C2   0x4640             MOV      R0,R8
   \   000000C4   0x.... 0x....      BL       CPU_SR_Restore
   1596                      OS_TRACE_TASK_SEM_PEND_FAILED(OSTCBCurPtr);
   1597                      OS_TRACE_TASK_SEM_PEND_EXIT(OS_ERR_SCHED_LOCKED);
   1598                     *p_err = OS_ERR_SCHED_LOCKED;
   \   000000C8   0xF646 0x5063      MOVW     R0,#+28003
   \   000000CC   0x8020             STRH     R0,[R4, #+0]
   1599                      return (0u);
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0xE046             B.N      ??OSTaskSemPend_1
   1600                  }
   1601              }
   1602          
   1603              OS_Pend(DEF_NULL,                                           /* Block task pending on Signal                         */
   1604                      OS_TASK_PEND_ON_TASK_SEM,
   1605                      timeout);
   \                     ??OSTaskSemPend_8: (+1)
   \   000000D2   0x0032             MOVS     R2,R6
   \   000000D4   0x2107             MOVS     R1,#+7
   \   000000D6   0x2000             MOVS     R0,#+0
   \   000000D8   0x.... 0x....      BL       OS_Pend
   1606              CPU_CRITICAL_EXIT();
   \   000000DC   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000E0   0x4640             MOV      R0,R8
   \   000000E2   0x.... 0x....      BL       CPU_SR_Restore
   1607              OS_TRACE_TASK_SEM_PEND_BLOCK(OSTCBCurPtr);
   1608              OSSched();                                                  /* Find next highest priority task ready to run         */
   \   000000E6   0x.... 0x....      BL       OSSched
   1609          
   1610              CPU_CRITICAL_ENTER();
   \   000000EA   0x.... 0x....      BL       CPU_SR_Save
   \   000000EE   0x4680             MOV      R8,R0
   \   000000F0   0x.... 0x....      BL       CPU_IntDisMeasStart
   1611              switch (OSTCBCurPtr->PendStatus) {                          /* See if we timed-out or aborted                       */
   \   000000F4   0x.... 0x....      LDR.W    R0,??DataTable22
   \   000000F8   0x6800             LDR      R0,[R0, #+0]
   \   000000FA   0xF890 0x003D      LDRB     R0,[R0, #+61]
   \   000000FE   0x2800             CMP      R0,#+0
   \   00000100   0xD004             BEQ.N    ??OSTaskSemPend_10
   \   00000102   0x2801             CMP      R0,#+1
   \   00000104   0xD00C             BEQ.N    ??OSTaskSemPend_11
   \   00000106   0x2803             CMP      R0,#+3
   \   00000108   0xD015             BEQ.N    ??OSTaskSemPend_12
   \   0000010A   0xE01C             B.N      ??OSTaskSemPend_13
   1612                  case OS_STATUS_PEND_OK:
   1613          #if (OS_CFG_TS_EN == DEF_ENABLED)
   1614                       if (p_ts != DEF_NULL) {
   \                     ??OSTaskSemPend_10: (+1)
   \   0000010C   0x2D00             CMP      R5,#+0
   \   0000010E   0xD004             BEQ.N    ??OSTaskSemPend_14
   1615                          *p_ts                    =  OSTCBCurPtr->TS;
   \   00000110   0x.... 0x....      LDR.W    R0,??DataTable22
   \   00000114   0x6800             LDR      R0,[R0, #+0]
   \   00000116   0x6D00             LDR      R0,[R0, #+80]
   \   00000118   0x6028             STR      R0,[R5, #+0]
   1616          #if (OS_CFG_TASK_PROFILE_EN == DEF_ENABLED)
   1617          #if (OS_CFG_TS_EN == DEF_ENABLED)
   1618                          OSTCBCurPtr->SemPendTime = OS_TS_GET() - OSTCBCurPtr->TS;
   1619                          if (OSTCBCurPtr->SemPendTimeMax < OSTCBCurPtr->SemPendTime) {
   1620                              OSTCBCurPtr->SemPendTimeMax = OSTCBCurPtr->SemPendTime;
   1621                          }
   1622          #endif
   1623          #endif
   1624                       }
   1625          #endif
   1626                       OS_TRACE_TASK_SEM_PEND(OSTCBCurPtr);
   1627                      *p_err = OS_ERR_NONE;
   \                     ??OSTaskSemPend_14: (+1)
   \   0000011A   0x2000             MOVS     R0,#+0
   \   0000011C   0x8020             STRH     R0,[R4, #+0]
   1628                       break;
   \   0000011E   0xE015             B.N      ??OSTaskSemPend_15
   1629          
   1630                  case OS_STATUS_PEND_ABORT:
   1631          #if (OS_CFG_TS_EN == DEF_ENABLED)
   1632                       if (p_ts != DEF_NULL) {
   \                     ??OSTaskSemPend_11: (+1)
   \   00000120   0x2D00             CMP      R5,#+0
   \   00000122   0xD004             BEQ.N    ??OSTaskSemPend_16
   1633                          *p_ts = OSTCBCurPtr->TS;
   \   00000124   0x.... 0x....      LDR.W    R0,??DataTable22
   \   00000128   0x6800             LDR      R0,[R0, #+0]
   \   0000012A   0x6D00             LDR      R0,[R0, #+80]
   \   0000012C   0x6028             STR      R0,[R5, #+0]
   1634                       }
   1635          #endif
   1636                       OS_TRACE_TASK_SEM_PEND_FAILED(OSTCBCurPtr);
   1637                      *p_err = OS_ERR_PEND_ABORT;                         /* Indicate that we aborted                             */
   \                     ??OSTaskSemPend_16: (+1)
   \   0000012E   0xF246 0x10A9      MOVW     R0,#+25001
   \   00000132   0x8020             STRH     R0,[R4, #+0]
   1638                       break;
   \   00000134   0xE00A             B.N      ??OSTaskSemPend_15
   1639          
   1640                  case OS_STATUS_PEND_TIMEOUT:
   1641          #if (OS_CFG_TS_EN == DEF_ENABLED)
   1642                       if (p_ts != DEF_NULL) {
   \                     ??OSTaskSemPend_12: (+1)
   \   00000136   0x2D00             CMP      R5,#+0
   \   00000138   0xD001             BEQ.N    ??OSTaskSemPend_17
   1643                          *p_ts = 0u;
   \   0000013A   0x2000             MOVS     R0,#+0
   \   0000013C   0x6028             STR      R0,[R5, #+0]
   1644                       }
   1645          #endif
   1646                       OS_TRACE_TASK_SEM_PEND_FAILED(OSTCBCurPtr);
   1647                      *p_err = OS_ERR_TIMEOUT;                            /* Indicate that we didn't get event within TO          */
   \                     ??OSTaskSemPend_17: (+1)
   \   0000013E   0xF247 0x20D9      MOVW     R0,#+29401
   \   00000142   0x8020             STRH     R0,[R4, #+0]
   1648                       break;
   \   00000144   0xE002             B.N      ??OSTaskSemPend_15
   1649          
   1650                  default:
   1651                       OS_TRACE_TASK_SEM_PEND_FAILED(OSTCBCurPtr);
   1652                      *p_err = OS_ERR_STATUS_INVALID;
   \                     ??OSTaskSemPend_13: (+1)
   \   00000146   0xF646 0x602E      MOVW     R0,#+28206
   \   0000014A   0x8020             STRH     R0,[R4, #+0]
   1653                       break;
   1654              }
   1655              ctr = OSTCBCurPtr->SemCtr;
   \                     ??OSTaskSemPend_15: (+1)
   \   0000014C   0x.... 0x....      LDR.W    R0,??DataTable22
   \   00000150   0x6800             LDR      R0,[R0, #+0]
   \   00000152   0x6D46             LDR      R6,[R0, #+84]
   1656              CPU_CRITICAL_EXIT();
   \   00000154   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000158   0x4640             MOV      R0,R8
   \   0000015A   0x.... 0x....      BL       CPU_SR_Restore
   1657              OS_TRACE_TASK_SEM_PEND_EXIT(*p_err);
   1658              return (ctr);
   \   0000015E   0x0030             MOVS     R0,R6
   \                     ??OSTaskSemPend_1: (+1)
   \   00000160   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1659          }
   1660          
   1661          
   1662          /*
   1663          ************************************************************************************************************************
   1664          *                                               ABORT WAITING FOR A SIGNAL
   1665          *
   1666          * Description: This function aborts & readies the task specified.  This function should be used to fault-abort the wait
   1667          *              for a signal, rather than to normally post the signal to the task via OSTaskSemPost().
   1668          *
   1669          * Arguments  : p_tcb     is a pointer to the task to pend abort
   1670          *
   1671          *              opt       provides options for this function:
   1672          *
   1673          *                            OS_OPT_POST_NONE         No option selected
   1674          *                            OS_OPT_POST_NO_SCHED     Indicates that the scheduler will not be called.
   1675          *
   1676          *              p_err     is a pointer to a variable that will contain an error code returned by this function.
   1677          *
   1678          *                            OS_ERR_NONE               If the task was readied and informed of the aborted wait
   1679          *                            OS_ERR_OPT_INVALID        You specified an invalid option
   1680          *                            OS_ERR_OS_NOT_RUNNING     If uC/OS-III is not running yet
   1681          *                            OS_ERR_PEND_ABORT_ISR     If you tried calling this function from an ISR
   1682          *                            OS_ERR_PEND_ABORT_NONE    If the task was not waiting for a signal
   1683          *                            OS_ERR_PEND_ABORT_SELF    If you attempted to pend abort the calling task.  This is not
   1684          *                                                      possible since the calling task cannot be pending because it's
   1685          *                                                      running
   1686          *
   1687          * Returns    : == DEF_FALSE   if task was not waiting for a message, or upon error.
   1688          *              == DEF_TRUE    if task was waiting for a message and was readied and informed.
   1689          *
   1690          * Note(s)    : none
   1691          ************************************************************************************************************************
   1692          */
   1693          
   1694          #if (OS_CFG_TASK_SEM_PEND_ABORT_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   1695          CPU_BOOLEAN  OSTaskSemPendAbort (OS_TCB  *p_tcb,
   1696                                           OS_OPT   opt,
   1697                                           OS_ERR  *p_err)
   1698          {
   \                     OSTaskSemPendAbort: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0014             MOVS     R4,R2
   1699              CPU_TS  ts;
   1700              CPU_SR_ALLOC();
   \   00000008   0x2700             MOVS     R7,#+0
   1701          
   1702          
   1703          
   1704          #ifdef OS_SAFETY_CRITICAL
   1705              if (p_err == DEF_NULL) {
   1706                  OS_SAFETY_CRITICAL_EXCEPTION();
   1707                  return (DEF_FALSE);
   1708              }
   1709          #endif
   1710          
   1711          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
   1712              if (OSIntNestingCtr > 0u) {                                 /* See if called from ISR ...                           */
   \   0000000A   0x....             LDR.N    R0,??DataTable13
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD004             BEQ.N    ??OSTaskSemPendAbort_0
   1713                 *p_err = OS_ERR_PEND_ABORT_ISR;                          /* ... can't Pend Abort from an ISR                     */
   \   00000012   0xF246 0x10AA      MOVW     R0,#+25002
   \   00000016   0x8020             STRH     R0,[R4, #+0]
   1714                  return (DEF_FALSE);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE04D             B.N      ??OSTaskSemPendAbort_1
   1715              }
   1716          #endif
   1717          
   1718          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
   1719              if (OSRunning != OS_STATE_OS_RUNNING) {
   1720                 *p_err = OS_ERR_OS_NOT_RUNNING;
   1721                  return (DEF_FALSE);
   1722              }
   1723          #endif
   1724          
   1725          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
   1726              switch (opt) {                                              /* Validate 'opt'                                       */
   \                     ??OSTaskSemPendAbort_0: (+1)
   \   0000001C   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000001E   0x0030             MOVS     R0,R6
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD002             BEQ.N    ??OSTaskSemPendAbort_2
   \   00000024   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000028   0xD115             BNE.N    ??OSTaskSemPendAbort_3
   1727                  case OS_OPT_POST_NONE:
   1728                  case OS_OPT_POST_NO_SCHED:
   1729                       break;
   1730          
   1731                  default:
   1732                      *p_err = OS_ERR_OPT_INVALID;
   1733                       return (DEF_FALSE);
   1734              }
   1735          #endif
   1736          
   1737              CPU_CRITICAL_ENTER();
   \                     ??OSTaskSemPendAbort_2: (+1)
   \   0000002A   0x.... 0x....      BL       CPU_SR_Save
   \   0000002E   0x0007             MOVS     R7,R0
   \   00000030   0x.... 0x....      BL       CPU_IntDisMeasStart
   1738              if ((p_tcb == DEF_NULL) ||                                  /* Pend abort self?                                     */
   1739                  (p_tcb == OSTCBCurPtr)) {
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD004             BEQ.N    ??OSTaskSemPendAbort_4
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable22
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x4285             CMP      R5,R0
   \   00000040   0xD10E             BNE.N    ??OSTaskSemPendAbort_5
   1740                  CPU_CRITICAL_EXIT();                                    /* ... doesn't make sense!                              */
   \                     ??OSTaskSemPendAbort_4: (+1)
   \   00000042   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000046   0x0038             MOVS     R0,R7
   \   00000048   0x.... 0x....      BL       CPU_SR_Restore
   1741                 *p_err = OS_ERR_PEND_ABORT_SELF;
   \   0000004C   0xF246 0x10AC      MOVW     R0,#+25004
   \   00000050   0x8020             STRH     R0,[R4, #+0]
   1742                  return (DEF_FALSE);
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xE030             B.N      ??OSTaskSemPendAbort_1
   1743              }
   \                     ??OSTaskSemPendAbort_3: (+1)
   \   00000056   0xF645 0x6025      MOVW     R0,#+24101
   \   0000005A   0x8020             STRH     R0,[R4, #+0]
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0xE02B             B.N      ??OSTaskSemPendAbort_1
   1744          
   1745              if (p_tcb->PendOn != OS_TASK_PEND_ON_TASK_SEM) {            /* Is task waiting for a signal?                        */
   \                     ??OSTaskSemPendAbort_5: (+1)
   \   00000060   0xF895 0x003C      LDRB     R0,[R5, #+60]
   \   00000064   0x2807             CMP      R0,#+7
   \   00000066   0xD009             BEQ.N    ??OSTaskSemPendAbort_6
   1746                  CPU_CRITICAL_EXIT();
   \   00000068   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000006C   0x0038             MOVS     R0,R7
   \   0000006E   0x.... 0x....      BL       CPU_SR_Restore
   1747                 *p_err = OS_ERR_PEND_ABORT_NONE;
   \   00000072   0xF246 0x10AB      MOVW     R0,#+25003
   \   00000076   0x8020             STRH     R0,[R4, #+0]
   1748                  return (DEF_FALSE);
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xE01D             B.N      ??OSTaskSemPendAbort_1
   1749              }
   1750              CPU_CRITICAL_EXIT();
   \                     ??OSTaskSemPendAbort_6: (+1)
   \   0000007C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000080   0x0038             MOVS     R0,R7
   \   00000082   0x.... 0x....      BL       CPU_SR_Restore
   1751          
   1752              CPU_CRITICAL_ENTER();
   \   00000086   0x.... 0x....      BL       CPU_SR_Save
   \   0000008A   0x0007             MOVS     R7,R0
   \   0000008C   0x.... 0x....      BL       CPU_IntDisMeasStart
   1753          #if (OS_CFG_TS_EN == DEF_ENABLED)
   1754              ts = OS_TS_GET();
   \   00000090   0x.... 0x....      BL       CPU_TS_TmrRd
   1755          #else
   1756              ts = 0u;
   1757          #endif
   1758              OS_PendAbort(p_tcb,                                         /* Abort the pend                                       */
   1759                           ts,
   1760                           OS_STATUS_PEND_ABORT);
   \   00000094   0x2201             MOVS     R2,#+1
   \   00000096   0x0001             MOVS     R1,R0
   \   00000098   0x0028             MOVS     R0,R5
   \   0000009A   0x.... 0x....      BL       OS_PendAbort
   1761              CPU_CRITICAL_EXIT();
   \   0000009E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000A2   0x0038             MOVS     R0,R7
   \   000000A4   0x.... 0x....      BL       CPU_SR_Restore
   1762              if ((opt & OS_OPT_POST_NO_SCHED) == 0u) {
   \   000000A8   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000AA   0x0430             LSLS     R0,R6,#+16
   \   000000AC   0xD401             BMI.N    ??OSTaskSemPendAbort_7
   1763                  OSSched();                                              /* Run the scheduler                                    */
   \   000000AE   0x.... 0x....      BL       OSSched
   1764              }
   1765             *p_err = OS_ERR_NONE;
   \                     ??OSTaskSemPendAbort_7: (+1)
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0x8020             STRH     R0,[R4, #+0]
   1766              return (DEF_TRUE);
   \   000000B6   0x2001             MOVS     R0,#+1
   \                     ??OSTaskSemPendAbort_1: (+1)
   \   000000B8   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1767          }
   1768          #endif
   1769          
   1770          
   1771          /*
   1772          ************************************************************************************************************************
   1773          *                                                    SIGNAL A TASK
   1774          *
   1775          * Description: This function is called to signal a task waiting for a signal.
   1776          *
   1777          * Arguments  : p_tcb     is the pointer to the TCB of the task to signal.  A NULL pointer indicates that you are sending
   1778          *                        a signal to yourself.
   1779          *
   1780          *              opt       determines the type of POST performed:
   1781          *
   1782          *                             OS_OPT_POST_NONE         No option
   1783          *                             OS_OPT_POST_NO_SCHED     Do not call the scheduler
   1784          *
   1785          *              p_err     is a pointer to an error code returned by this function:
   1786          *
   1787          *                            OS_ERR_NONE              If the requested task is signaled
   1788          *                            OS_ERR_OPT_INVALID       If you specified an invalid option
   1789          *                            OS_ERR_OS_NOT_RUNNING    If uC/OS-III is not running yet
   1790          *                            OS_ERR_SEM_OVF           If the post would cause the semaphore count to overflow
   1791          *                            OS_ERR_STATE_INVALID     If the task is in an invalid state.  This should never happen
   1792          *                                                     and if it does, would be considered a system failure
   1793          *
   1794          * Returns    : The current value of the task's signal counter or 0 if called from an ISR
   1795          *
   1796          * Note(s)    : none
   1797          ************************************************************************************************************************
   1798          */
   1799          

   \                                 In section .text, align 2, keep-with-next
   1800          OS_SEM_CTR  OSTaskSemPost (OS_TCB  *p_tcb,
   1801                                     OS_OPT   opt,
   1802                                     OS_ERR  *p_err)
   1803          {
   \                     OSTaskSemPost: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0007             MOVS     R7,R0
   \   00000008   0x000C             MOVS     R4,R1
   \   0000000A   0x0015             MOVS     R5,R2
   1804              OS_SEM_CTR  ctr;
   1805              CPU_TS      ts;
   1806              CPU_SR_ALLOC();
   \   0000000C   0x2600             MOVS     R6,#+0
   1807          
   1808          
   1809          #ifdef OS_SAFETY_CRITICAL
   1810              if (p_err == DEF_NULL) {
   1811                  OS_SAFETY_CRITICAL_EXCEPTION();
   1812                  return (0u);
   1813              }
   1814          #endif
   1815          
   1816              OS_TRACE_TASK_SEM_POST_ENTER(p_tcb, opt);
   1817          
   1818          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
   1819              if (OSRunning != OS_STATE_OS_RUNNING) {
   1820                  OS_TRACE_TASK_SEM_POST_EXIT(OS_ERR_OS_NOT_RUNNING);
   1821                 *p_err = OS_ERR_OS_NOT_RUNNING;
   1822                  return (0u);
   1823              }
   1824          #endif
   1825          
   1826          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
   1827              switch (opt) {                                              /* Validate 'opt'                                       */
   \   0000000E   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD002             BEQ.N    ??OSTaskSemPost_0
   \   00000016   0xF5B0 0x4F00      CMP      R0,#+32768
   \   0000001A   0xD12E             BNE.N    ??OSTaskSemPost_1
   1828                  case OS_OPT_POST_NONE:
   1829                  case OS_OPT_POST_NO_SCHED:
   1830                       break;
   1831          
   1832                  default:
   1833                       OS_TRACE_TASK_SEM_POST_FAILED(p_tcb);
   1834                       OS_TRACE_TASK_SEM_POST_EXIT(OS_ERR_OPT_INVALID);
   1835                      *p_err =  OS_ERR_OPT_INVALID;
   1836                       return (0u);
   1837              }
   1838          #endif
   1839          
   1840          #if (OS_CFG_TS_EN == DEF_ENABLED)
   1841              ts = OS_TS_GET();                                           /* Get timestamp                                        */
   \                     ??OSTaskSemPost_0: (+1)
   \   0000001C   0x.... 0x....      BL       CPU_TS_TmrRd
   \   00000020   0x4680             MOV      R8,R0
   1842          #else
   1843              ts = 0u;
   1844          #endif
   1845          
   1846              OS_TRACE_TASK_SEM_POST(p_tcb);
   1847          
   1848              CPU_CRITICAL_ENTER();
   \   00000022   0x.... 0x....      BL       CPU_SR_Save
   \   00000026   0x0006             MOVS     R6,R0
   \   00000028   0x.... 0x....      BL       CPU_IntDisMeasStart
   1849              if (p_tcb == DEF_NULL) {                                    /* Post signal to 'self'?                               */
   \   0000002C   0x2F00             CMP      R7,#+0
   \   0000002E   0xD102             BNE.N    ??OSTaskSemPost_2
   1850                  p_tcb = OSTCBCurPtr;
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable22
   \   00000034   0x6807             LDR      R7,[R0, #+0]
   1851              }
   1852          #if (OS_CFG_TS_EN == DEF_ENABLED)
   1853              p_tcb->TS = ts;
   \                     ??OSTaskSemPost_2: (+1)
   \   00000036   0xF8C7 0x8050      STR      R8,[R7, #+80]
   1854          #endif
   1855             *p_err     = OS_ERR_NONE;                                    /* Assume we won't have any errors                      */
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x8028             STRH     R0,[R5, #+0]
   1856              switch (p_tcb->TaskState) {
   \   0000003E   0xF897 0x003E      LDRB     R0,[R7, #+62]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD00B             BEQ.N    ??OSTaskSemPost_3
   \   00000046   0x2802             CMP      R0,#+2
   \   00000048   0xD026             BEQ.N    ??OSTaskSemPost_4
   \   0000004A   0xD308             BCC.N    ??OSTaskSemPost_3
   \   0000004C   0x2804             CMP      R0,#+4
   \   0000004E   0xD006             BEQ.N    ??OSTaskSemPost_3
   \   00000050   0xD322             BCC.N    ??OSTaskSemPost_4
   \   00000052   0x2806             CMP      R0,#+6
   \   00000054   0xD020             BEQ.N    ??OSTaskSemPost_4
   \   00000056   0xD302             BCC.N    ??OSTaskSemPost_3
   \   00000058   0x2807             CMP      R0,#+7
   \   0000005A   0xD01D             BEQ.N    ??OSTaskSemPost_4
   \   0000005C   0xE04C             B.N      ??OSTaskSemPost_5
   1857                  case OS_TASK_STATE_RDY:
   1858                  case OS_TASK_STATE_DLY:
   1859                  case OS_TASK_STATE_SUSPENDED:
   1860                  case OS_TASK_STATE_DLY_SUSPENDED:
   1861                       if (p_tcb->SemCtr == (OS_SEM_CTR)-1) {
   \                     ??OSTaskSemPost_3: (+1)
   \   0000005E   0x6D78             LDR      R0,[R7, #+84]
   \   00000060   0xF110 0x0F01      CMN      R0,#+1
   \   00000064   0xD10E             BNE.N    ??OSTaskSemPost_6
   1862                           CPU_CRITICAL_EXIT();
   \   00000066   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000006A   0x0030             MOVS     R0,R6
   \   0000006C   0x.... 0x....      BL       CPU_SR_Restore
   1863                          *p_err = OS_ERR_SEM_OVF;
   \   00000070   0xF646 0x50C5      MOVW     R0,#+28101
   \   00000074   0x8028             STRH     R0,[R5, #+0]
   1864                           OS_TRACE_SEM_POST_EXIT(*p_err);
   1865                           return (0u);
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xE048             B.N      ??OSTaskSemPost_7
   1866                       }
   \                     ??OSTaskSemPost_1: (+1)
   \   0000007A   0xF645 0x6025      MOVW     R0,#+24101
   \   0000007E   0x8028             STRH     R0,[R5, #+0]
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xE043             B.N      ??OSTaskSemPost_7
   1867                       p_tcb->SemCtr++;                                   /* Task signaled is not pending on anything             */
   \                     ??OSTaskSemPost_6: (+1)
   \   00000084   0x6D78             LDR      R0,[R7, #+84]
   \   00000086   0x1C40             ADDS     R0,R0,#+1
   \   00000088   0x6578             STR      R0,[R7, #+84]
   1868                       ctr = p_tcb->SemCtr;
   \   0000008A   0x6D7D             LDR      R5,[R7, #+84]
   1869                       CPU_CRITICAL_EXIT();
   \   0000008C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000090   0x0030             MOVS     R0,R6
   \   00000092   0x.... 0x....      BL       CPU_SR_Restore
   1870                       break;
   \   00000096   0xE038             B.N      ??OSTaskSemPost_8
   1871          
   1872                  case OS_TASK_STATE_PEND:
   1873                  case OS_TASK_STATE_PEND_TIMEOUT:
   1874                  case OS_TASK_STATE_PEND_SUSPENDED:
   1875                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
   1876                       if (p_tcb->PendOn == OS_TASK_PEND_ON_TASK_SEM) {   /* Is task signaled waiting for a signal?               */
   \                     ??OSTaskSemPost_4: (+1)
   \   00000098   0xF897 0x003C      LDRB     R0,[R7, #+60]
   \   0000009C   0x2807             CMP      R0,#+7
   \   0000009E   0xD113             BNE.N    ??OSTaskSemPost_9
   1877                           OS_Post(DEF_NULL,                              /* Task is pending on signal                            */
   1878                                   p_tcb,
   1879                                   DEF_NULL,
   1880                                   0u,
   1881                                   ts);
   \   000000A0   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   000000A4   0x2300             MOVS     R3,#+0
   \   000000A6   0x2200             MOVS     R2,#+0
   \   000000A8   0x0039             MOVS     R1,R7
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0x.... 0x....      BL       OS_Post
   1882                           ctr = p_tcb->SemCtr;
   \   000000B0   0x6D7D             LDR      R5,[R7, #+84]
   1883                           CPU_CRITICAL_EXIT();
   \   000000B2   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000B6   0x0030             MOVS     R0,R6
   \   000000B8   0x.... 0x....      BL       CPU_SR_Restore
   1884                           if ((opt & OS_OPT_POST_NO_SCHED) == 0u) {
   \   000000BC   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000BE   0x0420             LSLS     R0,R4,#+16
   \   000000C0   0xD419             BMI.N    ??OSTaskSemPost_10
   1885                               OSSched();                                 /* Run the scheduler                                    */
   \   000000C2   0x.... 0x....      BL       OSSched
   \   000000C6   0xE016             B.N      ??OSTaskSemPost_10
   1886                           }
   1887                       } else {
   1888                           if (p_tcb->SemCtr == (OS_SEM_CTR)-1) {
   \                     ??OSTaskSemPost_9: (+1)
   \   000000C8   0x6D78             LDR      R0,[R7, #+84]
   \   000000CA   0xF110 0x0F01      CMN      R0,#+1
   \   000000CE   0xD109             BNE.N    ??OSTaskSemPost_11
   1889                               CPU_CRITICAL_EXIT();
   \   000000D0   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000D4   0x0030             MOVS     R0,R6
   \   000000D6   0x.... 0x....      BL       CPU_SR_Restore
   1890                              *p_err = OS_ERR_SEM_OVF;
   \   000000DA   0xF646 0x50C5      MOVW     R0,#+28101
   \   000000DE   0x8028             STRH     R0,[R5, #+0]
   1891                               OS_TRACE_SEM_POST_EXIT(*p_err);
   1892                               return (0u);
   \   000000E0   0x2000             MOVS     R0,#+0
   \   000000E2   0xE013             B.N      ??OSTaskSemPost_7
   1893                           }
   1894                           p_tcb->SemCtr++;                               /* No,  Task signaled is NOT pending on semaphore ...   */
   \                     ??OSTaskSemPost_11: (+1)
   \   000000E4   0x6D78             LDR      R0,[R7, #+84]
   \   000000E6   0x1C40             ADDS     R0,R0,#+1
   \   000000E8   0x6578             STR      R0,[R7, #+84]
   1895                           ctr = p_tcb->SemCtr;                           /* ... it must be waiting on something else             */
   \   000000EA   0x6D7D             LDR      R5,[R7, #+84]
   1896                           CPU_CRITICAL_EXIT();
   \   000000EC   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000F0   0x0030             MOVS     R0,R6
   \   000000F2   0x.... 0x....      BL       CPU_SR_Restore
   1897                       }
   1898                       break;
   \                     ??OSTaskSemPost_10: (+1)
   \   000000F6   0xE008             B.N      ??OSTaskSemPost_8
   1899          
   1900                  default:
   1901                       CPU_CRITICAL_EXIT();
   \                     ??OSTaskSemPost_5: (+1)
   \   000000F8   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000FC   0x0030             MOVS     R0,R6
   \   000000FE   0x.... 0x....      BL       CPU_SR_Restore
   1902                      *p_err = OS_ERR_STATE_INVALID;
   \   00000102   0xF646 0x602D      MOVW     R0,#+28205
   \   00000106   0x8028             STRH     R0,[R5, #+0]
   1903                       ctr   = 0u;
   \   00000108   0x2500             MOVS     R5,#+0
   1904                       break;
   1905              }
   1906          
   1907              OS_TRACE_TASK_SEM_POST_EXIT(*p_err);
   1908          
   1909              return (ctr);
   \                     ??OSTaskSemPost_8: (+1)
   \   0000010A   0x0028             MOVS     R0,R5
   \                     ??OSTaskSemPost_7: (+1)
   \   0000010C   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   1910          }
   1911          
   1912          
   1913          /*
   1914          ************************************************************************************************************************
   1915          *                                            SET THE SIGNAL COUNTER OF A TASK
   1916          *
   1917          * Description: This function is called to clear the signal counter
   1918          *
   1919          * Arguments  : p_tcb      is the pointer to the TCB of the task to clear the counter.  If you specify a NULL pointer
   1920          *                         then the signal counter of the current task will be cleared.
   1921          *
   1922          *              cnt        is the desired value of the semaphore counter
   1923          *
   1924          *              p_err      is a pointer to an error code returned by this function
   1925          *
   1926          *                             OS_ERR_NONE             If the signal counter of the requested task is set
   1927          *                             OS_ERR_SET_ISR          If the function was called from an ISR
   1928          *                             OS_ERR_TASK_WAITING     One or more tasks were waiting on the semaphore
   1929          *
   1930          * Returns    : none
   1931          *
   1932          * Note(s)    : none
   1933          ************************************************************************************************************************
   1934          */
   1935          

   \                                 In section .text, align 2, keep-with-next
   1936          OS_SEM_CTR  OSTaskSemSet (OS_TCB      *p_tcb,
   1937                                    OS_SEM_CTR   cnt,
   1938                                    OS_ERR      *p_err)
   1939          {
   \                     OSTaskSemSet: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0006             MOVS     R6,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0014             MOVS     R4,R2
   1940              OS_SEM_CTR  ctr;
   1941              CPU_SR_ALLOC();
   \   0000000A   0x2700             MOVS     R7,#+0
   1942          
   1943          
   1944          
   1945          #ifdef OS_SAFETY_CRITICAL
   1946              if (p_err == DEF_NULL) {
   1947                  OS_SAFETY_CRITICAL_EXCEPTION();
   1948                  return (0u);
   1949              }
   1950          #endif
   1951          
   1952          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
   1953              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable22_4
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD004             BEQ.N    ??OSTaskSemSet_0
   1954                 *p_err = OS_ERR_SET_ISR;
   \   00000016   0xF646 0x50C6      MOVW     R0,#+28102
   \   0000001A   0x8020             STRH     R0,[R4, #+0]
   1955                  return (0u);
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE026             B.N      ??OSTaskSemSet_1
   1956              }
   1957          #endif
   1958          
   1959              CPU_CRITICAL_ENTER();
   \                     ??OSTaskSemSet_0: (+1)
   \   00000020   0x.... 0x....      BL       CPU_SR_Save
   \   00000024   0x0007             MOVS     R7,R0
   \   00000026   0x.... 0x....      BL       CPU_IntDisMeasStart
   1960              if (p_tcb == DEF_NULL) {
   \   0000002A   0x2E00             CMP      R6,#+0
   \   0000002C   0xD102             BNE.N    ??OSTaskSemSet_2
   1961                  p_tcb = OSTCBCurPtr;
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable22
   \   00000032   0x6806             LDR      R6,[R0, #+0]
   1962              }
   1963          
   1964              if (((p_tcb->TaskState   & OS_TASK_STATE_PEND) != 0u) &&    /* Not allowed when a task is waiting.                  */
   1965                   (p_tcb->PendOn == OS_TASK_PEND_ON_TASK_SEM)) {
   \                     ??OSTaskSemSet_2: (+1)
   \   00000034   0xF896 0x003E      LDRB     R0,[R6, #+62]
   \   00000038   0x0780             LSLS     R0,R0,#+30
   \   0000003A   0xD50D             BPL.N    ??OSTaskSemSet_3
   \   0000003C   0xF896 0x003C      LDRB     R0,[R6, #+60]
   \   00000040   0x2807             CMP      R0,#+7
   \   00000042   0xD109             BNE.N    ??OSTaskSemSet_3
   1966                  CPU_CRITICAL_EXIT();
   \   00000044   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000048   0x0038             MOVS     R0,R7
   \   0000004A   0x.... 0x....      BL       CPU_SR_Restore
   1967                 *p_err = OS_ERR_TASK_WAITING;
   \   0000004E   0xF247 0x105F      MOVW     R0,#+29023
   \   00000052   0x8020             STRH     R0,[R4, #+0]
   1968                  return (0u);
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xE00A             B.N      ??OSTaskSemSet_1
   1969              }
   1970          
   1971              ctr           = p_tcb->SemCtr;
   \                     ??OSTaskSemSet_3: (+1)
   \   00000058   0xF8D6 0x8054      LDR      R8,[R6, #+84]
   1972              p_tcb->SemCtr = (OS_SEM_CTR)cnt;
   \   0000005C   0x6575             STR      R5,[R6, #+84]
   1973              CPU_CRITICAL_EXIT();
   \   0000005E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000062   0x0038             MOVS     R0,R7
   \   00000064   0x.... 0x....      BL       CPU_SR_Restore
   1974             *p_err         =  OS_ERR_NONE;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x8020             STRH     R0,[R4, #+0]
   1975              return (ctr);
   \   0000006C   0x4640             MOV      R0,R8
   \                     ??OSTaskSemSet_1: (+1)
   \   0000006E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1976          }
   1977          
   1978          
   1979          /*
   1980          ************************************************************************************************************************
   1981          *                                                    STACK CHECKING
   1982          *
   1983          * Description: This function is called to calculate the amount of free memory left on the specified task's stack.
   1984          *
   1985          * Arguments  : p_tcb       is a pointer to the TCB of the task to check.  If you specify a NULL pointer then
   1986          *                          you are specifying that you want to check the stack of the current task.
   1987          *
   1988          *              p_free      is a pointer to a variable that will receive the number of free 'entries' on the task's stack.
   1989          *
   1990          *              p_used      is a pointer to a variable that will receive the number of used 'entries' on the task's stack.
   1991          *
   1992          *              p_err       is a pointer to a variable that will contain an error code.
   1993          *
   1994          *                              OS_ERR_NONE               Upon success
   1995          *                              OS_ERR_PTR_INVALID        If either 'p_free' or 'p_used' are NULL pointers
   1996          *                              OS_ERR_TASK_NOT_EXIST     If the stack pointer of the task is a NULL pointer
   1997          *                              OS_ERR_TASK_OPT           If you did NOT specified OS_OPT_TASK_STK_CHK when the task
   1998          *                                                        was created
   1999          *                              OS_ERR_TASK_STK_CHK_ISR   You called this function from an ISR
   2000          *
   2001          * Returns    : none
   2002          *
   2003          * Note(s)    : none
   2004          ************************************************************************************************************************
   2005          */
   2006          
   2007          #if (OS_CFG_STAT_TASK_STK_CHK_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   2008          void  OSTaskStkChk (OS_TCB        *p_tcb,
   2009                              CPU_STK_SIZE  *p_free,
   2010                              CPU_STK_SIZE  *p_used,
   2011                              OS_ERR        *p_err)
   2012          {
   \                     OSTaskStkChk: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   2013              CPU_STK_SIZE  free_stk;
   2014              CPU_STK      *p_stk;
   2015              CPU_SR_ALLOC();
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   2016          
   2017          
   2018          #ifdef OS_SAFETY_CRITICAL
   2019              if (p_err == DEF_NULL) {
   2020                  OS_SAFETY_CRITICAL_EXCEPTION();
   2021                  return;
   2022              }
   2023          #endif
   2024          
   2025          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
   2026              if (OSIntNestingCtr > 0u) {                                 /* See if trying to check stack from ISR                */
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable22_4
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD003             BEQ.N    ??OSTaskStkChk_0
   2027                 *p_err = OS_ERR_TASK_STK_CHK_ISR;
   \   0000001A   0xF247 0x1059      MOVW     R0,#+29017
   \   0000001E   0x8038             STRH     R0,[R7, #+0]
   2028                  return;
   \   00000020   0xE049             B.N      ??OSTaskStkChk_1
   2029              }
   2030          #endif
   2031          
   2032          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
   2033              if (p_free == DEF_NULL) {                                   /* User must specify valid destinations for the sizes   */
   \                     ??OSTaskStkChk_0: (+1)
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xD103             BNE.N    ??OSTaskStkChk_2
   2034                 *p_err = OS_ERR_PTR_INVALID;
   \   00000026   0xF246 0x20D5      MOVW     R0,#+25301
   \   0000002A   0x8038             STRH     R0,[R7, #+0]
   2035                  return;
   \   0000002C   0xE043             B.N      ??OSTaskStkChk_1
   2036              }
   2037          
   2038              if (p_used == DEF_NULL) {
   \                     ??OSTaskStkChk_2: (+1)
   \   0000002E   0x2E00             CMP      R6,#+0
   \   00000030   0xD103             BNE.N    ??OSTaskStkChk_3
   2039                 *p_err = OS_ERR_PTR_INVALID;
   \   00000032   0xF246 0x20D5      MOVW     R0,#+25301
   \   00000036   0x8038             STRH     R0,[R7, #+0]
   2040                  return;
   \   00000038   0xE03D             B.N      ??OSTaskStkChk_1
   2041              }
   2042          #endif
   2043          
   2044              CPU_CRITICAL_ENTER();
   \                     ??OSTaskStkChk_3: (+1)
   \   0000003A   0x.... 0x....      BL       CPU_SR_Save
   \   0000003E   0x4680             MOV      R8,R0
   \   00000040   0x.... 0x....      BL       CPU_IntDisMeasStart
   2045              if (p_tcb == DEF_NULL) {                                    /* Check the stack of the current task?                 */
   \   00000044   0x2C00             CMP      R4,#+0
   \   00000046   0xD102             BNE.N    ??OSTaskStkChk_4
   2046                  p_tcb = OSTCBCurPtr;                                    /* Yes                                                  */
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable22
   \   0000004C   0x6804             LDR      R4,[R0, #+0]
   2047              }
   2048          
   2049              if (p_tcb->StkPtr == DEF_NULL) {                            /* Make sure task exist                                 */
   \                     ??OSTaskStkChk_4: (+1)
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD10C             BNE.N    ??OSTaskStkChk_5
   2050                  CPU_CRITICAL_EXIT();
   \   00000054   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000058   0x4640             MOV      R0,R8
   \   0000005A   0x.... 0x....      BL       CPU_SR_Restore
   2051                 *p_free = 0u;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x6028             STR      R0,[R5, #+0]
   2052                 *p_used = 0u;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x6030             STR      R0,[R6, #+0]
   2053                 *p_err  = OS_ERR_TASK_NOT_EXIST;
   \   00000066   0xF247 0x1052      MOVW     R0,#+29010
   \   0000006A   0x8038             STRH     R0,[R7, #+0]
   2054                  return;
   \   0000006C   0xE023             B.N      ??OSTaskStkChk_1
   2055              }
   2056          
   2057              if ((p_tcb->Opt & OS_OPT_TASK_STK_CHK) == 0u) {             /* Make sure stack checking option is set               */
   \                     ??OSTaskStkChk_5: (+1)
   \   0000006E   0xF894 0x004C      LDRB     R0,[R4, #+76]
   \   00000072   0x07C0             LSLS     R0,R0,#+31
   \   00000074   0xD40C             BMI.N    ??OSTaskStkChk_6
   2058                  CPU_CRITICAL_EXIT();
   \   00000076   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000007A   0x4640             MOV      R0,R8
   \   0000007C   0x.... 0x....      BL       CPU_SR_Restore
   2059                 *p_free = 0u;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0x6028             STR      R0,[R5, #+0]
   2060                 *p_used = 0u;
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x6030             STR      R0,[R6, #+0]
   2061                 *p_err  = OS_ERR_TASK_OPT;
   \   00000088   0xF247 0x1054      MOVW     R0,#+29012
   \   0000008C   0x8038             STRH     R0,[R7, #+0]
   2062                  return;
   \   0000008E   0xE012             B.N      ??OSTaskStkChk_1
   2063              }
   2064              CPU_CRITICAL_EXIT();
   \                     ??OSTaskStkChk_6: (+1)
   \   00000090   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000094   0x4640             MOV      R0,R8
   \   00000096   0x.... 0x....      BL       CPU_SR_Restore
   2065          
   2066              free_stk = 0u;
   \   0000009A   0x2000             MOVS     R0,#+0
   2067          #if (CPU_CFG_STK_GROWTH == CPU_STK_GROWTH_HI_TO_LO)
   2068              p_stk = p_tcb->StkBasePtr;                                  /* Start at the lowest memory and go up                 */
   \   0000009C   0x6A61             LDR      R1,[R4, #+36]
   \   0000009E   0xE001             B.N      ??OSTaskStkChk_7
   2069          #if (OS_CFG_TASK_STK_REDZONE_EN == DEF_ENABLED)
   2070              p_stk += OS_CFG_TASK_STK_REDZONE_DEPTH;
   2071          #endif
   2072              while (*p_stk == 0u) {                                      /* Compute the number of zero entries on the stk        */
   2073                  p_stk++;
   \                     ??OSTaskStkChk_8: (+1)
   \   000000A0   0x1D09             ADDS     R1,R1,#+4
   2074                  free_stk++;
   \   000000A2   0x1C40             ADDS     R0,R0,#+1
   2075              }
   \                     ??OSTaskStkChk_7: (+1)
   \   000000A4   0x680A             LDR      R2,[R1, #+0]
   \   000000A6   0x2A00             CMP      R2,#+0
   \   000000A8   0xD0FA             BEQ.N    ??OSTaskStkChk_8
   2076          #else
   2077              p_stk = p_tcb->StkBasePtr + p_tcb->StkSize - 1u;            /* Start at the highest memory and go down              */
   2078          #if (OS_CFG_TASK_STK_REDZONE_EN == DEF_ENABLED)
   2079              p_stk -= OS_CFG_TASK_STK_REDZONE_DEPTH;
   2080          #endif
   2081              while (*p_stk == 0u) {
   2082                  free_stk++;
   2083                  p_stk--;
   2084              }
   2085          #endif
   2086          #if (OS_CFG_TASK_STK_REDZONE_EN == DEF_ENABLED)
   2087              free_stk -= OS_CFG_TASK_STK_REDZONE_DEPTH;                  /* Compensate for stack elements used by Redzone.       */
   2088          #endif
   2089             *p_free = free_stk;
   \   000000AA   0x6028             STR      R0,[R5, #+0]
   2090             *p_used = (p_tcb->StkSize - free_stk);                       /* Compute number of entries used on the stack          */
   \   000000AC   0x6CA1             LDR      R1,[R4, #+72]
   \   000000AE   0x1A08             SUBS     R0,R1,R0
   \   000000B0   0x6030             STR      R0,[R6, #+0]
   2091             *p_err  = OS_ERR_NONE;
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0x8038             STRH     R0,[R7, #+0]
   2092          }
   \                     ??OSTaskStkChk_1: (+1)
   \   000000B6   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   2093          #endif
   2094          
   2095          
   2096          /*
   2097          ************************************************************************************************************************
   2098          *                                            CHECK THE STACK REDZONE OF A TASK
   2099          *
   2100          * Description: Verify a task's stack redzone.
   2101          *
   2102          * Arguments  : p_tcb     is a pointer to the TCB of the task to check or null for the current task.
   2103          *
   2104          * Returns    : If the stack is corrupted (DEF_FAIL) or not (DEF_OK).
   2105          *
   2106          * Note(s)    : These functions are INTERNAL to uC/OS-III and your application should not call it.
   2107          ************************************************************************************************************************
   2108          */
   2109          
   2110          #if (OS_CFG_TASK_STK_REDZONE_EN == DEF_ENABLED)
   2111          CPU_BOOLEAN  OSTaskStkRedzoneChk (OS_TCB  *p_tcb)
   2112          {
   2113              CPU_BOOLEAN  stk_status;
   2114          
   2115          
   2116              if (p_tcb == DEF_NULL) {
   2117                  p_tcb = OSTCBCurPtr;
   2118              }
   2119                                                                          /* Check if SP is valid:                                */
   2120                                                                          /*   StkBase <= SP < (StkBase + StkSize)                */
   2121              if ((p_tcb->StkPtr <   p_tcb->StkBasePtr) ||
   2122                  (p_tcb->StkPtr >= (p_tcb->StkBasePtr + p_tcb->StkSize))) {
   2123                  return (DEF_FAIL);
   2124              }
   2125          
   2126              stk_status = OS_TaskStkRedzoneChk(p_tcb->StkBasePtr, p_tcb->StkSize);
   2127          
   2128              return (stk_status);
   2129          }
   2130          #endif
   2131          
   2132          
   2133          /*
   2134          ************************************************************************************************************************
   2135          *                                                   SUSPEND A TASK
   2136          *
   2137          * Description: This function is called to suspend a task.  The task can be the calling task if 'p_tcb' is a NULL pointer
   2138          *              or the pointer to the TCB of the calling task.
   2139          *
   2140          * Arguments  : p_tcb    is a pointer to the TCB to suspend.
   2141          *                       If p_tcb is a NULL pointer then, suspend the current task.
   2142          *
   2143          *              p_err    is a pointer to a variable that will receive an error code from this function.
   2144          *
   2145          *                           OS_ERR_NONE                        If the requested task is suspended
   2146          *                           OS_ERR_OS_NOT_RUNNING              If uC/OS-III is not running yet
   2147          *                           OS_ERR_SCHED_LOCKED                You can't suspend the current task is the scheduler is
   2148          *                                                                  locked
   2149          *                           OS_ERR_STATE_INVALID               If the task is in an invalid state
   2150          *                           OS_ERR_TASK_SUSPEND_CTR_OVF        If the nesting counter overflowed.
   2151          *                           OS_ERR_TASK_SUSPEND_ISR            If you called this function from an ISR
   2152          *                           OS_ERR_TASK_SUSPEND_IDLE           If you attempted to suspend the idle task which is not
   2153          *                                                                  allowed
   2154          *                           OS_ERR_TASK_SUSPEND_INT_HANDLER    If you attempted to suspend the idle task which is not
   2155          *                                                                  allowed
   2156          *
   2157          * Returns    : none
   2158          *
   2159          * Note(s)    : 1) You should use this function with great care.  If you suspend a task that is waiting for an event
   2160          *                 (i.e. a message, a semaphore, a queue ...) you will prevent this task from running when the event
   2161          *                 arrives.
   2162          ************************************************************************************************************************
   2163          */
   2164          
   2165          #if (OS_CFG_TASK_SUSPEND_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   2166          void   OSTaskSuspend (OS_TCB  *p_tcb,
   2167                                OS_ERR  *p_err)
   2168          {
   \                     OSTaskSuspend: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0006             MOVS     R6,R0
   \   00000004   0x000C             MOVS     R4,R1
   2169              CPU_SR_ALLOC();
   \   00000006   0x2500             MOVS     R5,#+0
   2170          
   2171          
   2172          #ifdef OS_SAFETY_CRITICAL
   2173              if (p_err == DEF_NULL) {
   2174                  OS_SAFETY_CRITICAL_EXCEPTION();
   2175                  return;
   2176              }
   2177          #endif
   2178          
   2179          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
   2180              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable22_4
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD003             BEQ.N    ??OSTaskSuspend_0
   2181                 *p_err = OS_ERR_TASK_SUSPEND_ISR;
   \   00000012   0xF247 0x105D      MOVW     R0,#+29021
   \   00000016   0x8020             STRH     R0,[R4, #+0]
   2182                  return;
   \   00000018   0xE053             B.N      ??OSTaskSuspend_1
   2183              }
   2184          #endif
   2185          
   2186          #if (OS_CFG_TASK_IDLE_EN == DEF_ENABLED)
   2187              if (p_tcb == &OSIdleTaskTCB) {                              /* Make sure not suspending the idle task               */
   \                     ??OSTaskSuspend_0: (+1)
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable22_5
   \   0000001E   0x4286             CMP      R6,R0
   \   00000020   0xD103             BNE.N    ??OSTaskSuspend_2
   2188                 *p_err = OS_ERR_TASK_SUSPEND_IDLE;
   \   00000022   0xF247 0x105B      MOVW     R0,#+29019
   \   00000026   0x8020             STRH     R0,[R4, #+0]
   2189                  return;
   \   00000028   0xE04B             B.N      ??OSTaskSuspend_1
   2190              }
   2191          #endif
   2192          
   2193              OS_TRACE_TASK_SUSPEND(p_tcb);
   2194          
   2195              CPU_CRITICAL_ENTER();
   \                     ??OSTaskSuspend_2: (+1)
   \   0000002A   0x.... 0x....      BL       CPU_SR_Save
   \   0000002E   0x0005             MOVS     R5,R0
   \   00000030   0x.... 0x....      BL       CPU_IntDisMeasStart
   2196              if (p_tcb == DEF_NULL) {                                    /* See if specified to suspend self                     */
   \   00000034   0x2E00             CMP      R6,#+0
   \   00000036   0xD10F             BNE.N    ??OSTaskSuspend_3
   2197                  if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Can't suspend self when the kernel isn't running     */
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable22_6
   \   0000003C   0x7800             LDRB     R0,[R0, #+0]
   \   0000003E   0x2801             CMP      R0,#+1
   \   00000040   0xD008             BEQ.N    ??OSTaskSuspend_4
   2198                      CPU_CRITICAL_EXIT();
   \   00000042   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000046   0x0028             MOVS     R0,R5
   \   00000048   0x.... 0x....      BL       CPU_SR_Restore
   2199                     *p_err = OS_ERR_OS_NOT_RUNNING;
   \   0000004C   0xF645 0x6089      MOVW     R0,#+24201
   \   00000050   0x8020             STRH     R0,[R4, #+0]
   2200                      return;
   \   00000052   0xE036             B.N      ??OSTaskSuspend_1
   2201                  }
   2202                  p_tcb = OSTCBCurPtr;
   \                     ??OSTaskSuspend_4: (+1)
   \   00000054   0x....             LDR.N    R0,??DataTable22
   \   00000056   0x6806             LDR      R6,[R0, #+0]
   2203              }
   2204          
   2205              if (p_tcb == OSTCBCurPtr) {
   \                     ??OSTaskSuspend_3: (+1)
   \   00000058   0x....             LDR.N    R0,??DataTable22
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0x4286             CMP      R6,R0
   \   0000005E   0xD10C             BNE.N    ??OSTaskSuspend_5
   2206                  if (OSSchedLockNestingCtr > 0u) {                       /* Can't suspend when the scheduler is locked           */
   \   00000060   0x....             LDR.N    R0,??DataTable22_1
   \   00000062   0x7800             LDRB     R0,[R0, #+0]
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD008             BEQ.N    ??OSTaskSuspend_5
   2207                      CPU_CRITICAL_EXIT();
   \   00000068   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000006C   0x0028             MOVS     R0,R5
   \   0000006E   0x.... 0x....      BL       CPU_SR_Restore
   2208                     *p_err = OS_ERR_SCHED_LOCKED;
   \   00000072   0xF646 0x5063      MOVW     R0,#+28003
   \   00000076   0x8020             STRH     R0,[R4, #+0]
   2209                      return;
   \   00000078   0xE023             B.N      ??OSTaskSuspend_1
   2210                  }
   2211              }
   2212          
   2213             *p_err = OS_ERR_NONE;
   \                     ??OSTaskSuspend_5: (+1)
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x8020             STRH     R0,[R4, #+0]
   2214              switch (p_tcb->TaskState) {
   \   0000007E   0xF896 0x003E      LDRB     R0,[R6, #+62]
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD009             BEQ.N    ??OSTaskSuspend_6
   \   00000086   0x1E40             SUBS     R0,R0,#+1
   \   00000088   0xD01C             BEQ.N    ??OSTaskSuspend_7
   \   0000008A   0x1E40             SUBS     R0,R0,#+1
   \   0000008C   0xD026             BEQ.N    ??OSTaskSuspend_8
   \   0000008E   0x1E40             SUBS     R0,R0,#+1
   \   00000090   0xD030             BEQ.N    ??OSTaskSuspend_9
   \   00000092   0x1E40             SUBS     R0,R0,#+1
   \   00000094   0x2803             CMP      R0,#+3
   \   00000096   0xD939             BLS.N    ??OSTaskSuspend_10
   \   00000098   0xE050             B.N      ??OSTaskSuspend_11
   2215                  case OS_TASK_STATE_RDY:
   2216                       p_tcb->TaskState  =  OS_TASK_STATE_SUSPENDED;
   \                     ??OSTaskSuspend_6: (+1)
   \   0000009A   0x2004             MOVS     R0,#+4
   \   0000009C   0xF886 0x003E      STRB     R0,[R6, #+62]
   2217                       p_tcb->SuspendCtr = 1u;
   \   000000A0   0x2001             MOVS     R0,#+1
   \   000000A2   0xF886 0x0086      STRB     R0,[R6, #+134]
   2218                       OS_RdyListRemove(p_tcb);
   \   000000A6   0x0030             MOVS     R0,R6
   \   000000A8   0x.... 0x....      BL       OS_RdyListRemove
   2219                       CPU_CRITICAL_EXIT();
   \   000000AC   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000B0   0x0028             MOVS     R0,R5
   \   000000B2   0x.... 0x....      BL       CPU_SR_Restore
   2220                       break;
   2221          
   2222                  case OS_TASK_STATE_DLY:
   2223                       p_tcb->TaskState  = OS_TASK_STATE_DLY_SUSPENDED;
   2224                       p_tcb->SuspendCtr = 1u;
   2225                       CPU_CRITICAL_EXIT();
   2226                       break;
   2227          
   2228                  case OS_TASK_STATE_PEND:
   2229                       p_tcb->TaskState  = OS_TASK_STATE_PEND_SUSPENDED;
   2230                       p_tcb->SuspendCtr = 1u;
   2231                       CPU_CRITICAL_EXIT();
   2232                       break;
   2233          
   2234                  case OS_TASK_STATE_PEND_TIMEOUT:
   2235                       p_tcb->TaskState  = OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED;
   2236                       p_tcb->SuspendCtr = 1u;
   2237                       CPU_CRITICAL_EXIT();
   2238                       break;
   2239          
   2240                  case OS_TASK_STATE_SUSPENDED:
   2241                  case OS_TASK_STATE_DLY_SUSPENDED:
   2242                  case OS_TASK_STATE_PEND_SUSPENDED:
   2243                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
   2244                      if (p_tcb->SuspendCtr == (OS_NESTING_CTR)-1) {
   2245                           CPU_CRITICAL_EXIT();
   2246                          *p_err = OS_ERR_TASK_SUSPEND_CTR_OVF;
   2247                           return;
   2248                       }
   2249                       p_tcb->SuspendCtr++;
   2250                       CPU_CRITICAL_EXIT();
   2251                       break;
   2252          
   2253                  default:
   2254                       CPU_CRITICAL_EXIT();
   2255                      *p_err = OS_ERR_STATE_INVALID;
   2256                       return;
   2257              }
   2258          
   2259              if (OSRunning == OS_STATE_OS_RUNNING) {                     /* Only schedule when the kernel is running             */
   \                     ??OSTaskSuspend_12: (+1)
   \   000000B6   0x....             LDR.N    R0,??DataTable22_6
   \   000000B8   0x7800             LDRB     R0,[R0, #+0]
   \   000000BA   0x2801             CMP      R0,#+1
   \   000000BC   0xD101             BNE.N    ??OSTaskSuspend_13
   2260                  OSSched();
   \   000000BE   0x.... 0x....      BL       OSSched
   2261              }
   2262          }
   \                     ??OSTaskSuspend_13: (+1)
   \                     ??OSTaskSuspend_1: (+1)
   \   000000C2   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??OSTaskSuspend_7: (+1)
   \   000000C4   0x2005             MOVS     R0,#+5
   \   000000C6   0xF886 0x003E      STRB     R0,[R6, #+62]
   \   000000CA   0x2001             MOVS     R0,#+1
   \   000000CC   0xF886 0x0086      STRB     R0,[R6, #+134]
   \   000000D0   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000D4   0x0028             MOVS     R0,R5
   \   000000D6   0x.... 0x....      BL       CPU_SR_Restore
   \   000000DA   0xE7EC             B.N      ??OSTaskSuspend_12
   \                     ??OSTaskSuspend_8: (+1)
   \   000000DC   0x2006             MOVS     R0,#+6
   \   000000DE   0xF886 0x003E      STRB     R0,[R6, #+62]
   \   000000E2   0x2001             MOVS     R0,#+1
   \   000000E4   0xF886 0x0086      STRB     R0,[R6, #+134]
   \   000000E8   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000EC   0x0028             MOVS     R0,R5
   \   000000EE   0x.... 0x....      BL       CPU_SR_Restore
   \   000000F2   0xE7E0             B.N      ??OSTaskSuspend_12
   \                     ??OSTaskSuspend_9: (+1)
   \   000000F4   0x2007             MOVS     R0,#+7
   \   000000F6   0xF886 0x003E      STRB     R0,[R6, #+62]
   \   000000FA   0x2001             MOVS     R0,#+1
   \   000000FC   0xF886 0x0086      STRB     R0,[R6, #+134]
   \   00000100   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000104   0x0028             MOVS     R0,R5
   \   00000106   0x.... 0x....      BL       CPU_SR_Restore
   \   0000010A   0xE7D4             B.N      ??OSTaskSuspend_12
   \                     ??OSTaskSuspend_10: (+1)
   \   0000010C   0xF896 0x0086      LDRB     R0,[R6, #+134]
   \   00000110   0x28FF             CMP      R0,#+255
   \   00000112   0xD108             BNE.N    ??OSTaskSuspend_14
   \   00000114   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000118   0x0028             MOVS     R0,R5
   \   0000011A   0x.... 0x....      BL       CPU_SR_Restore
   \   0000011E   0xF247 0x1060      MOVW     R0,#+29024
   \   00000122   0x8020             STRH     R0,[R4, #+0]
   \   00000124   0xE7CD             B.N      ??OSTaskSuspend_1
   \                     ??OSTaskSuspend_14: (+1)
   \   00000126   0xF896 0x0086      LDRB     R0,[R6, #+134]
   \   0000012A   0x1C40             ADDS     R0,R0,#+1
   \   0000012C   0xF886 0x0086      STRB     R0,[R6, #+134]
   \   00000130   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000134   0x0028             MOVS     R0,R5
   \   00000136   0x.... 0x....      BL       CPU_SR_Restore
   \   0000013A   0xE7BC             B.N      ??OSTaskSuspend_12
   \                     ??OSTaskSuspend_11: (+1)
   \   0000013C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000140   0x0028             MOVS     R0,R5
   \   00000142   0x.... 0x....      BL       CPU_SR_Restore
   \   00000146   0xF646 0x602D      MOVW     R0,#+28205
   \   0000014A   0x8020             STRH     R0,[R4, #+0]
   \   0000014C   0xE7B9             B.N      ??OSTaskSuspend_1
   2263          #endif
   2264          
   2265          
   2266          /*
   2267          ************************************************************************************************************************
   2268          *                                                CHANGE A TASK'S TIME SLICE
   2269          *
   2270          * Description: This function is called to change the value of the task's specific time slice.
   2271          *
   2272          * Arguments  : p_tcb        is the pointer to the TCB of the task to change. If you specify an NULL pointer, the current
   2273          *                           task is assumed.
   2274          *
   2275          *              time_quanta  is the number of ticks before the CPU is taken away when round-robin scheduling is enabled.
   2276          *
   2277          *              p_err        is a pointer to an error code returned by this function:
   2278          *
   2279          *                               OS_ERR_NONE       Upon success
   2280          *                               OS_ERR_SET_ISR    If you called this function from an ISR
   2281          *
   2282          * Returns    : none
   2283          *
   2284          * Note(s)    : none
   2285          ************************************************************************************************************************
   2286          */
   2287          
   2288          #if (OS_CFG_SCHED_ROUND_ROBIN_EN == DEF_ENABLED)
   2289          void  OSTaskTimeQuantaSet (OS_TCB   *p_tcb,
   2290                                     OS_TICK   time_quanta,
   2291                                     OS_ERR   *p_err)
   2292          {
   2293              CPU_SR_ALLOC();
   2294          
   2295          
   2296          
   2297          #ifdef OS_SAFETY_CRITICAL
   2298              if (p_err == DEF_NULL) {
   2299                  OS_SAFETY_CRITICAL_EXCEPTION();
   2300                  return;
   2301              }
   2302          #endif
   2303          
   2304          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
   2305              if (OSIntNestingCtr > 0u) {                                 /* Can't call this function from an ISR                 */
   2306                 *p_err = OS_ERR_SET_ISR;
   2307                  return;
   2308              }
   2309          #endif
   2310          
   2311              CPU_CRITICAL_ENTER();
   2312              if (p_tcb == DEF_NULL) {
   2313                  p_tcb = OSTCBCurPtr;
   2314              }
   2315          
   2316              if (time_quanta == 0u) {
   2317                  p_tcb->TimeQuanta    = OSSchedRoundRobinDfltTimeQuanta;
   2318              } else {
   2319                  p_tcb->TimeQuanta    = time_quanta;
   2320              }
   2321              if (p_tcb->TimeQuanta > p_tcb->TimeQuantaCtr) {
   2322                  p_tcb->TimeQuantaCtr = p_tcb->TimeQuanta;
   2323              }
   2324              CPU_CRITICAL_EXIT();
   2325             *p_err = OS_ERR_NONE;
   2326          }
   2327          #endif
   2328          
   2329          
   2330          /*
   2331          ************************************************************************************************************************
   2332          *                                            ADD/REMOVE TASK TO/FROM DEBUG LIST
   2333          *
   2334          * Description: These functions are called by uC/OS-III to add or remove an OS_TCB from the debug list.
   2335          *
   2336          * Arguments  : p_tcb     is a pointer to the OS_TCB to add/remove
   2337          *
   2338          * Returns    : none
   2339          *
   2340          * Note(s)    : These functions are INTERNAL to uC/OS-III and your application should not call it.
   2341          ************************************************************************************************************************
   2342          */
   2343          
   2344          #if (OS_CFG_DBG_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   2345          void  OS_TaskDbgListAdd (OS_TCB  *p_tcb)
   2346          {
   2347              p_tcb->DbgPrevPtr                = DEF_NULL;
   \                     OS_TaskDbgListAdd: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xF8C0 0x1094      STR      R1,[R0, #+148]
   2348              if (OSTaskDbgListPtr == DEF_NULL) {
   \   00000006   0x....             LDR.N    R1,??DataTable22_7
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD103             BNE.N    ??OS_TaskDbgListAdd_0
   2349                  p_tcb->DbgNextPtr            = DEF_NULL;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0xF8C0 0x1098      STR      R1,[R0, #+152]
   \   00000014   0xE007             B.N      ??OS_TaskDbgListAdd_1
   2350              } else {
   2351                  p_tcb->DbgNextPtr            =  OSTaskDbgListPtr;
   \                     ??OS_TaskDbgListAdd_0: (+1)
   \   00000016   0x....             LDR.N    R1,??DataTable22_7
   \   00000018   0x6809             LDR      R1,[R1, #+0]
   \   0000001A   0xF8C0 0x1098      STR      R1,[R0, #+152]
   2352                  OSTaskDbgListPtr->DbgPrevPtr =  p_tcb;
   \   0000001E   0x....             LDR.N    R1,??DataTable22_7
   \   00000020   0x6809             LDR      R1,[R1, #+0]
   \   00000022   0xF8C1 0x0094      STR      R0,[R1, #+148]
   2353              }
   2354              OSTaskDbgListPtr                 =  p_tcb;
   \                     ??OS_TaskDbgListAdd_1: (+1)
   \   00000026   0x....             LDR.N    R1,??DataTable22_7
   \   00000028   0x6008             STR      R0,[R1, #+0]
   2355          }
   \   0000002A   0x4770             BX       LR               ;; return
   2356          
   2357          
   2358          

   \                                 In section .text, align 2, keep-with-next
   2359          void  OS_TaskDbgListRemove (OS_TCB  *p_tcb)
   2360          {
   2361              OS_TCB  *p_tcb_next;
   2362              OS_TCB  *p_tcb_prev;
   2363          
   2364          
   2365              p_tcb_prev = p_tcb->DbgPrevPtr;
   \                     OS_TaskDbgListRemove: (+1)
   \   00000000   0xF8D0 0x2094      LDR      R2,[R0, #+148]
   2366              p_tcb_next = p_tcb->DbgNextPtr;
   \   00000004   0xF8D0 0x1098      LDR      R1,[R0, #+152]
   2367          
   2368              if (p_tcb_prev == DEF_NULL) {
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xD10A             BNE.N    ??OS_TaskDbgListRemove_0
   2369                  OSTaskDbgListPtr = p_tcb_next;
   \   0000000C   0x....             LDR.N    R2,??DataTable22_7
   \   0000000E   0x6011             STR      R1,[R2, #+0]
   2370                  if (p_tcb_next != DEF_NULL) {
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD002             BEQ.N    ??OS_TaskDbgListRemove_1
   2371                      p_tcb_next->DbgPrevPtr = DEF_NULL;
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0xF8C1 0x2094      STR      R2,[R1, #+148]
   2372                  }
   2373                  p_tcb->DbgNextPtr = DEF_NULL;
   \                     ??OS_TaskDbgListRemove_1: (+1)
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0xF8C0 0x1098      STR      R1,[R0, #+152]
   \   00000020   0xE012             B.N      ??OS_TaskDbgListRemove_2
   2374          
   2375              } else if (p_tcb_next == DEF_NULL) {
   \                     ??OS_TaskDbgListRemove_0: (+1)
   \   00000022   0x2900             CMP      R1,#+0
   \   00000024   0xD106             BNE.N    ??OS_TaskDbgListRemove_3
   2376                  p_tcb_prev->DbgNextPtr = DEF_NULL;
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0xF8C2 0x1098      STR      R1,[R2, #+152]
   2377                  p_tcb->DbgPrevPtr      = DEF_NULL;
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0xF8C0 0x1094      STR      R1,[R0, #+148]
   \   00000032   0xE009             B.N      ??OS_TaskDbgListRemove_2
   2378          
   2379              } else {
   2380                  p_tcb_prev->DbgNextPtr =  p_tcb_next;
   \                     ??OS_TaskDbgListRemove_3: (+1)
   \   00000034   0xF8C2 0x1098      STR      R1,[R2, #+152]
   2381                  p_tcb_next->DbgPrevPtr =  p_tcb_prev;
   \   00000038   0xF8C1 0x2094      STR      R2,[R1, #+148]
   2382                  p_tcb->DbgNextPtr      = DEF_NULL;
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0xF8C0 0x1098      STR      R1,[R0, #+152]
   2383                  p_tcb->DbgPrevPtr      = DEF_NULL;
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0xF8C0 0x1094      STR      R1,[R0, #+148]
   2384              }
   2385          }
   \                     ??OS_TaskDbgListRemove_2: (+1)
   \   00000048   0x4770             BX       LR               ;; return
   2386          #endif
   2387          
   2388          
   2389          /*
   2390          ************************************************************************************************************************
   2391          *                                             TASK MANAGER INITIALIZATION
   2392          *
   2393          * Description: This function is called by OSInit() to initialize the task management.
   2394          *
   2395          
   2396          * Argument(s): p_err        is a pointer to a variable that will contain an error code returned by this function.
   2397          *
   2398          *                                OS_ERR_NONE     the call was successful
   2399          *
   2400          * Returns    : none
   2401          *
   2402          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   2403          ************************************************************************************************************************
   2404          */
   2405          

   \                                 In section .text, align 2, keep-with-next
   2406          void  OS_TaskInit (OS_ERR  *p_err)
   2407          {
   2408          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   2409              OSTaskDbgListPtr = DEF_NULL;
   \                     OS_TaskInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x....             LDR.N    R2,??DataTable22_7
   \   00000004   0x6011             STR      R1,[R2, #+0]
   2410          #endif
   2411          
   2412              OSTaskQty        = 0u;                                      /* Clear the number of tasks                            */
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x....             LDR.N    R2,??DataTable22_8
   \   0000000A   0x8011             STRH     R1,[R2, #+0]
   2413          
   2414          #if ((OS_CFG_TASK_PROFILE_EN == DEF_ENABLED) || (OS_CFG_DBG_EN == DEF_ENABLED))
   2415              OSTaskCtxSwCtr   = 0u;                                      /* Clear the context switch counter                     */
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x....             LDR.N    R2,??DataTable22_9
   \   00000010   0x6011             STR      R1,[R2, #+0]
   2416          #endif
   2417          
   2418             *p_err            = OS_ERR_NONE;
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x8001             STRH     R1,[R0, #+0]
   2419          }
   \   00000016   0x4770             BX       LR               ;; return
   2420          
   2421          
   2422          /*
   2423          ************************************************************************************************************************
   2424          *                                               INITIALIZE TCB FIELDS
   2425          *
   2426          * Description: This function is called to initialize a TCB to default values
   2427          *
   2428          * Arguments  : p_tcb    is a pointer to the TCB to initialize
   2429          *
   2430          * Returns    : none
   2431          *
   2432          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   2433          ************************************************************************************************************************
   2434          */
   2435          

   \                                 In section .text, align 2, keep-with-next
   2436          void  OS_TaskInitTCB (OS_TCB  *p_tcb)
   2437          {
   \                     OS_TaskInitTCB: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2438          #if (OS_CFG_TASK_REG_TBL_SIZE > 0u)
   2439              OS_REG_ID   reg_id;
   2440          #endif
   2441          #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
   2442              OS_TLS_ID   id;
   2443          #endif
   2444          
   2445          
   2446              p_tcb->StkPtr             = DEF_NULL;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x6020             STR      R0,[R4, #+0]
   2447          #if ((OS_CFG_DBG_EN == DEF_ENABLED) || (OS_CFG_STAT_TASK_STK_CHK_EN == DEF_ENABLED))
   2448              p_tcb->StkLimitPtr        = DEF_NULL;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x60E0             STR      R0,[R4, #+12]
   2449          #endif
   2450          
   2451              p_tcb->ExtPtr             = DEF_NULL;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x6060             STR      R0,[R4, #+4]
   2452          
   2453              p_tcb->NextPtr            = DEF_NULL;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x6120             STR      R0,[R4, #+16]
   2454              p_tcb->PrevPtr            = DEF_NULL;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x6160             STR      R0,[R4, #+20]
   2455          
   2456          #if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
   2457              p_tcb->TickNextPtr        = DEF_NULL;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x61A0             STR      R0,[R4, #+24]
   2458              p_tcb->TickPrevPtr        = DEF_NULL;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x61E0             STR      R0,[R4, #+28]
   2459              p_tcb->TickListPtr        = DEF_NULL;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x6220             STR      R0,[R4, #+32]
   2460          #endif
   2461          
   2462          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   2463              p_tcb->NamePtr            = (CPU_CHAR *)((void *)"?Task");
   \   00000024   0x....             LDR.N    R0,??DataTable22_10
   \   00000026   0x60A0             STR      R0,[R4, #+8]
   2464          #endif
   2465          
   2466          #if ((OS_CFG_DBG_EN == DEF_ENABLED) || (OS_CFG_STAT_TASK_STK_CHK_EN == DEF_ENABLED))
   2467              p_tcb->StkBasePtr         = DEF_NULL;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x6260             STR      R0,[R4, #+36]
   2468          #endif
   2469          
   2470          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   2471              p_tcb->TaskEntryAddr      = 0u;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x62A0             STR      R0,[R4, #+40]
   2472              p_tcb->TaskEntryArg       = DEF_NULL;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x62E0             STR      R0,[R4, #+44]
   2473          #endif
   2474          
   2475          #if (OS_CFG_TS_EN == DEF_ENABLED)
   2476              p_tcb->TS                 = 0u;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x6520             STR      R0,[R4, #+80]
   2477          #endif
   2478          
   2479          #if (OS_MSG_EN == DEF_ENABLED)
   2480              p_tcb->MsgPtr             = DEF_NULL;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x6620             STR      R0,[R4, #+96]
   2481              p_tcb->MsgSize            = 0u;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xF8A4 0x0064      STRH     R0,[R4, #+100]
   2482          #endif
   2483          
   2484          #if (OS_CFG_TASK_Q_EN == DEF_ENABLED)
   2485              OS_MsgQInit(&p_tcb->MsgQ,
   2486                           0u);
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0xF114 0x0068      ADDS     R0,R4,#+104
   \   00000048   0x.... 0x....      BL       OS_MsgQInit
   2487          #if (OS_CFG_TASK_PROFILE_EN == DEF_ENABLED)
   2488              p_tcb->MsgQPendTime       = 0u;
   2489              p_tcb->MsgQPendTimeMax    = 0u;
   2490          #endif
   2491          #endif
   2492          
   2493          #if (OS_CFG_FLAG_EN == DEF_ENABLED)
   2494              p_tcb->FlagsPend          = 0u;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x67E0             STR      R0,[R4, #+124]
   2495              p_tcb->FlagsOpt           = 0u;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xF8A4 0x0084      STRH     R0,[R4, #+132]
   2496              p_tcb->FlagsRdy           = 0u;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xF8C4 0x0080      STR      R0,[R4, #+128]
   2497          #endif
   2498          
   2499          #if (OS_CFG_MON_EN == DEF_ENABLED)
   2500               p_tcb->MonData.p_eval_data = DEF_NULL;
   2501               p_tcb->MonData.p_on_eval   = DEF_NULL;
   2502          #endif
   2503          
   2504          #if (OS_CFG_TASK_REG_TBL_SIZE > 0u)
   2505              for (reg_id = 0u; reg_id < OS_CFG_TASK_REG_TBL_SIZE; reg_id++) {
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0xE005             B.N      ??OS_TaskInitTCB_0
   2506                  p_tcb->RegTbl[reg_id] = 0u;
   \                     ??OS_TaskInitTCB_1: (+1)
   \   00000060   0x2100             MOVS     R1,#+0
   \   00000062   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000064   0xEB14 0x0280      ADDS     R2,R4,R0, LSL #+2
   \   00000068   0x6791             STR      R1,[R2, #+120]
   2507              }
   \   0000006A   0x1C40             ADDS     R0,R0,#+1
   \                     ??OS_TaskInitTCB_0: (+1)
   \   0000006C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD0F6             BEQ.N    ??OS_TaskInitTCB_1
   2508          #endif
   2509          
   2510          #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
   2511              for (id = 0u; id < OS_CFG_TLS_TBL_SIZE; id++) {
   2512                  p_tcb->TLS_Tbl[id]    = 0u;
   2513              }
   2514          #endif
   2515          
   2516              p_tcb->SemCtr             = 0u;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x6560             STR      R0,[R4, #+84]
   2517          #if (OS_CFG_TASK_PROFILE_EN == DEF_ENABLED)
   2518              p_tcb->SemPendTime        = 0u;
   2519              p_tcb->SemPendTimeMax     = 0u;
   2520          #endif
   2521          
   2522          #if ((OS_CFG_DBG_EN == DEF_ENABLED) || (OS_CFG_STAT_TASK_STK_CHK_EN == DEF_ENABLED))
   2523              p_tcb->StkSize            = 0u;
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0x64A0             STR      R0,[R4, #+72]
   2524          #endif
   2525          
   2526          
   2527          #if (OS_CFG_TASK_SUSPEND_EN == DEF_ENABLED)
   2528              p_tcb->SuspendCtr         = 0u;
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0xF884 0x0086      STRB     R0,[R4, #+134]
   2529          #endif
   2530          
   2531          #if (OS_CFG_STAT_TASK_STK_CHK_EN == DEF_ENABLED)
   2532              p_tcb->StkFree            = 0u;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xF8C4 0x008C      STR      R0,[R4, #+140]
   2533              p_tcb->StkUsed            = 0u;
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0xF8C4 0x0088      STR      R0,[R4, #+136]
   2534          #endif
   2535          
   2536              p_tcb->Opt                = 0u;
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0xF8A4 0x004C      STRH     R0,[R4, #+76]
   2537          
   2538          #if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
   2539              p_tcb->TickRemain         = 0u;
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x65A0             STR      R0,[R4, #+88]
   2540              p_tcb->TickCtrPrev        = 0u;
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0x65E0             STR      R0,[R4, #+92]
   2541          #endif
   2542          
   2543          #if (OS_CFG_SCHED_ROUND_ROBIN_EN == DEF_ENABLED)
   2544              p_tcb->TimeQuanta         = 0u;
   2545              p_tcb->TimeQuantaCtr      = 0u;
   2546          #endif
   2547          
   2548          #if (OS_CFG_TASK_PROFILE_EN == DEF_ENABLED)
   2549              p_tcb->CPUUsage           = 0u;
   2550              p_tcb->CPUUsageMax        = 0u;
   2551              p_tcb->CtxSwCtr           = 0u;
   2552              p_tcb->CyclesDelta        = 0u;
   2553          #if (OS_CFG_TS_EN == DEF_ENABLED)
   2554              p_tcb->CyclesStart        = OS_TS_GET();                    /* Read the current timestamp and save                    */
   2555          #else
   2556              p_tcb->CyclesStart        = 0u;
   2557          #endif
   2558              p_tcb->CyclesTotal        = 0u;
   2559          #endif
   2560          
   2561          #ifdef CPU_CFG_INT_DIS_MEAS_EN
   2562              p_tcb->IntDisTimeMax      = 0u;
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0xF8C4 0x0090      STR      R0,[R4, #+144]
   2563          #endif
   2564          #if (OS_CFG_SCHED_LOCK_TIME_MEAS_EN == DEF_ENABLED)
   2565              p_tcb->SchedLockTimeMax   = 0u;
   2566          #endif
   2567          
   2568              p_tcb->PendNextPtr        = DEF_NULL;
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0x6320             STR      R0,[R4, #+48]
   2569              p_tcb->PendPrevPtr        = DEF_NULL;
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0x6360             STR      R0,[R4, #+52]
   2570              p_tcb->PendObjPtr         = DEF_NULL;
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0x63A0             STR      R0,[R4, #+56]
   2571              p_tcb->PendOn             = OS_TASK_PEND_ON_NOTHING;
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0xF884 0x003C      STRB     R0,[R4, #+60]
   2572              p_tcb->PendStatus         = OS_STATUS_PEND_OK;
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0xF884 0x003D      STRB     R0,[R4, #+61]
   2573              p_tcb->TaskState          = OS_TASK_STATE_RDY;
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0xF884 0x003E      STRB     R0,[R4, #+62]
   2574          
   2575              p_tcb->Prio               = OS_PRIO_INIT;
   \   000000BE   0x2040             MOVS     R0,#+64
   \   000000C0   0xF884 0x003F      STRB     R0,[R4, #+63]
   2576          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
   2577              p_tcb->BasePrio           = OS_PRIO_INIT;
   \   000000C4   0x2040             MOVS     R0,#+64
   \   000000C6   0xF884 0x0040      STRB     R0,[R4, #+64]
   2578              p_tcb->MutexGrpHeadPtr    = DEF_NULL;
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0x6460             STR      R0,[R4, #+68]
   2579          #endif
   2580          
   2581          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   2582              p_tcb->DbgPrevPtr         = DEF_NULL;
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0xF8C4 0x0094      STR      R0,[R4, #+148]
   2583              p_tcb->DbgNextPtr         = DEF_NULL;
   \   000000D4   0x2000             MOVS     R0,#+0
   \   000000D6   0xF8C4 0x0098      STR      R0,[R4, #+152]
   2584              p_tcb->DbgNamePtr         = (CPU_CHAR *)((void *)" ");
   \   000000DA   0x....             ADR.N    R0,??DataTable22_2  ;; " "
   \   000000DC   0xF8C4 0x009C      STR      R0,[R4, #+156]
   2585          #endif
   2586          }
   \   000000E0   0xBD10             POP      {R4,PC}          ;; return
   2587          
   2588          
   2589          /*
   2590          ************************************************************************************************************************
   2591          *                                              CATCH ACCIDENTAL TASK RETURN
   2592          *
   2593          * Description: This function is called if a task accidentally returns without deleting itself.  In other words, a task
   2594          *              should either be an infinite loop or delete itself if it's done.
   2595          *
   2596          * Arguments  : none
   2597          *
   2598          * Returns    : none
   2599          *
   2600          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   2601          ************************************************************************************************************************
   2602          */
   2603          

   \                                 In section .text, align 2, keep-with-next
   2604          void  OS_TaskReturn (void)
   2605          {
   \                     OS_TaskReturn: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2606              OS_ERR  err;
   2607          
   2608          
   2609          
   2610              OSTaskReturnHook(OSTCBCurPtr);                              /* Call hook to let user decide on what to do           */
   \   00000002   0x....             LDR.N    R0,??DataTable22
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x.... 0x....      BL       OSTaskReturnHook
   2611          #if (OS_CFG_TASK_DEL_EN == DEF_ENABLED)
   2612              OSTaskDel( DEF_NULL,                                        /* Delete task if it accidentally returns!              */
   2613                        &err);
   \   0000000A   0x4669             MOV      R1,SP
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x.... 0x....      BL       OSTaskDel
   2614          #else
   2615              for (;;) {
   2616                  OSTimeDly(OSCfg_TickRate_Hz,
   2617                            OS_OPT_TIME_DLY,
   2618                            &err);
   2619                  (void)err;
   2620              }
   2621          #endif
   2622          }
   \   00000012   0xBD01             POP      {R0,PC}          ;; return
   2623          
   2624          
   2625          /*
   2626          ************************************************************************************************************************
   2627          *                                          CHECK THE STACK REDZONE OF A TASK
   2628          *
   2629          * Description: Verify a task's stack redzone.
   2630          *
   2631          * Arguments  : p_tcb        is a pointer to the base of the stack.
   2632          *
   2633          *              stk_size     is the size of the stack.
   2634          *
   2635          * Returns    : none
   2636          *
   2637          * Caller(s)  : OSTaskStkRedzoneChk() and OSIntExit().
   2638          *
   2639          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application should not call it.
   2640          ************************************************************************************************************************
   2641          */
   2642          
   2643          #if (OS_CFG_TASK_STK_REDZONE_EN == DEF_ENABLED)
   2644          CPU_BOOLEAN   OS_TaskStkRedzoneChk (CPU_STK       *p_base,
   2645                                              CPU_STK_SIZE   stk_size)
   2646          {
   2647              CPU_INT32U  i;
   2648          
   2649          
   2650          #if (CPU_CFG_STK_GROWTH == CPU_STK_GROWTH_HI_TO_LO)
   2651             (void)stk_size;                                              /* Prevent compiler warning for not using 'stk_size'    */
   2652          
   2653              for (i = 0u; i < OS_CFG_TASK_STK_REDZONE_DEPTH; i++) {
   2654                  if (*p_base != (CPU_DATA)OS_STACK_CHECK_VAL) {
   2655                      return (DEF_FAIL);
   2656                  }
   2657                  p_base++;
   2658              }
   2659          #else
   2660              p_base = p_base + stk_size - 1u;
   2661              for (i = 0u; i < OS_CFG_TASK_STK_REDZONE_DEPTH; i++) {
   2662                  if (*p_base != (CPU_DATA)OS_STACK_CHECK_VAL) {
   2663                      return (DEF_FAIL);
   2664                  }
   2665                  p_base--;
   2666              }
   2667          #endif
   2668          
   2669              return (DEF_OK);
   2670          }
   2671          #endif
   2672          
   2673          
   2674          /*
   2675          ************************************************************************************************************************
   2676          *                                          INITIALIZE A REDZONE ENABLED STACK
   2677          *
   2678          * Description: This functions is used to initialize a stack with Redzone checking.
   2679          *
   2680          * Arguments  : p_tcb        is a pointer to the base of the stack.
   2681          *
   2682          *              stk_size     is the size of the stack.
   2683          *
   2684          * Returns    : If the stack is corrupted (DEF_FAIL) or not (DEF_OK).
   2685          *
   2686          * Caller(s)  : OSTaskCreate() and OSInit().
   2687          *
   2688          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application should not call it.
   2689          ************************************************************************************************************************
   2690          */
   2691          
   2692          #if (OS_CFG_TASK_STK_REDZONE_EN == DEF_ENABLED)
   2693          void  OS_TaskStkRedzoneInit (CPU_STK       *p_base,
   2694                                       CPU_STK_SIZE   stk_size)
   2695          {
   2696              CPU_STK_SIZE   i;
   2697          
   2698          
   2699          #if (CPU_CFG_STK_GROWTH == CPU_STK_GROWTH_HI_TO_LO)
   2700             (void)stk_size;                                              /* Prevent compiler warning for not using 'stk_size'    */
   2701          
   2702              for (i = 0u; i < OS_CFG_TASK_STK_REDZONE_DEPTH; i++) {
   2703                  *(p_base + i) = (CPU_DATA)OS_STACK_CHECK_VAL;
   2704              }
   2705          #else
   2706              for (i = 0u; i < OS_CFG_TASK_STK_REDZONE_DEPTH; i++) {
   2707                  *(p_base + stk_size - 1u - i) = (CPU_DATA)OS_STACK_CHECK_VAL;
   2708              }
   2709          #endif
   2710          }
   2711          #endif
   2712          
   2713          
   2714          /*
   2715          ************************************************************************************************************************
   2716          *                                               CHANGE PRIORITY OF A TASK
   2717          *
   2718          * Description: This function is called by the kernel to perform the actual operation of changing a task's priority.
   2719          *              Priority inheritance is updated if necessary.
   2720          *
   2721          *
   2722          *
   2723          * Argument(s): p_tcb        is a pointer to the tcb of the task to change the priority.
   2724          *
   2725          *              prio_new     is the new priority to give to the task.
   2726          *
   2727          *
   2728          * Returns    : none.
   2729          *
   2730          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   2731          ************************************************************************************************************************
   2732          */
   2733          

   \                                 In section .text, align 2, keep-with-next
   2734          void  OS_TaskChangePrio(OS_TCB  *p_tcb,
   2735                                  OS_PRIO  prio_new)
   2736          {
   \                     OS_TaskChangePrio: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0006             MOVS     R6,R0
   \   00000004   0x000C             MOVS     R4,R1
   2737              OS_TCB  *p_tcb_owner;
   2738          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
   2739              OS_PRIO  prio_cur;
   2740          #endif
   2741          
   2742          
   2743              do {
   2744                  p_tcb_owner = DEF_NULL;
   \                     ??OS_TaskChangePrio_0: (+1)
   \   00000006   0x2500             MOVS     R5,#+0
   2745          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
   2746                  prio_cur    = p_tcb->Prio;
   \   00000008   0xF896 0x703F      LDRB     R7,[R6, #+63]
   2747          #endif
   2748                  switch (p_tcb->TaskState) {
   \   0000000C   0xF896 0x003E      LDRB     R0,[R6, #+62]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD00B             BEQ.N    ??OS_TaskChangePrio_1
   \   00000014   0x2802             CMP      R0,#+2
   \   00000016   0xD024             BEQ.N    ??OS_TaskChangePrio_2
   \   00000018   0xD320             BCC.N    ??OS_TaskChangePrio_3
   \   0000001A   0x2804             CMP      R0,#+4
   \   0000001C   0xD01E             BEQ.N    ??OS_TaskChangePrio_3
   \   0000001E   0xD320             BCC.N    ??OS_TaskChangePrio_2
   \   00000020   0x2806             CMP      R0,#+6
   \   00000022   0xD01E             BEQ.N    ??OS_TaskChangePrio_2
   \   00000024   0xD31A             BCC.N    ??OS_TaskChangePrio_3
   \   00000026   0x2807             CMP      R0,#+7
   \   00000028   0xD01B             BEQ.N    ??OS_TaskChangePrio_2
   \   0000002A   0xE053             B.N      ??OS_TaskChangePrio_4
   2749                      case OS_TASK_STATE_RDY:
   2750                           OS_RdyListRemove(p_tcb);                       /* Remove from current priority                         */
   \                     ??OS_TaskChangePrio_1: (+1)
   \   0000002C   0x0030             MOVS     R0,R6
   \   0000002E   0x.... 0x....      BL       OS_RdyListRemove
   2751                           p_tcb->Prio = prio_new;                        /* Set new task priority                                */
   \   00000032   0xF886 0x403F      STRB     R4,[R6, #+63]
   2752                           OS_PrioInsert(p_tcb->Prio);
   \   00000036   0xF896 0x003F      LDRB     R0,[R6, #+63]
   \   0000003A   0x.... 0x....      BL       OS_PrioInsert
   2753                           if (p_tcb == OSTCBCurPtr) {
   \   0000003E   0x....             LDR.N    R0,??DataTable22
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x4286             CMP      R6,R0
   \   00000044   0xD103             BNE.N    ??OS_TaskChangePrio_5
   2754                               OS_RdyListInsertHead(p_tcb);
   \   00000046   0x0030             MOVS     R0,R6
   \   00000048   0x.... 0x....      BL       OS_RdyListInsertHead
   \   0000004C   0xE002             B.N      ??OS_TaskChangePrio_6
   2755                           } else {
   2756                               OS_RdyListInsertTail(p_tcb);
   \                     ??OS_TaskChangePrio_5: (+1)
   \   0000004E   0x0030             MOVS     R0,R6
   \   00000050   0x.... 0x....      BL       OS_RdyListInsertTail
   2757                           }
   2758                           break;
   2759          
   2760                      case OS_TASK_STATE_DLY:                             /* Nothing to do except change the priority in the OS_TCB*/
   2761                      case OS_TASK_STATE_SUSPENDED:
   2762                      case OS_TASK_STATE_DLY_SUSPENDED:
   2763                           p_tcb->Prio = prio_new;                        /* Set new task priority                                */
   2764                           break;
   2765          
   2766                      case OS_TASK_STATE_PEND:
   2767                      case OS_TASK_STATE_PEND_TIMEOUT:
   2768                      case OS_TASK_STATE_PEND_SUSPENDED:
   2769                      case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
   2770                           p_tcb->Prio = prio_new;                        /* Set new task priority                                */
   2771                           switch (p_tcb->PendOn) {                       /* What to do depends on what we are pending on         */
   2772                               case OS_TASK_PEND_ON_FLAG:
   2773                               case OS_TASK_PEND_ON_Q:
   2774                               case OS_TASK_PEND_ON_SEM:
   2775                                    OS_PendListChangePrio(p_tcb);
   2776                                    break;
   2777          
   2778                               case OS_TASK_PEND_ON_MUTEX:
   2779          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
   2780                                    OS_PendListChangePrio(p_tcb);
   2781                                    p_tcb_owner = ((OS_MUTEX *)p_tcb->PendObjPtr)->OwnerTCBPtr;
   2782                                    if (prio_cur > prio_new) {            /* Are we increasing the priority?                      */
   2783                                        if (p_tcb_owner->Prio <= prio_new) { /* Yes, do we need to give this prio to the owner?   */
   2784                                            p_tcb_owner = DEF_NULL;
   2785                                        } else {
   2786                                           OS_TRACE_MUTEX_TASK_PRIO_INHERIT(p_tcb_owner, prio_new);
   2787                                        }
   2788                                    } else {
   2789                                        if (p_tcb_owner->Prio == prio_cur) { /* No, is it required to check for a lower prio?     */
   2790                                            prio_new = OS_MutexGrpPrioFindHighest(p_tcb_owner);
   2791                                            prio_new = (prio_new > p_tcb_owner->BasePrio) ? p_tcb_owner->BasePrio : prio_new;     /*lint !e9044 */
   2792                                            if (prio_new == p_tcb_owner->Prio) {
   2793                                                p_tcb_owner = DEF_NULL;
   2794                                            } else {
   2795                                               OS_TRACE_MUTEX_TASK_PRIO_DISINHERIT(p_tcb_owner, prio_new);
   2796                                            }
   2797                                        }
   2798                                    }
   2799          #endif
   2800                                    break;
   2801          
   2802                               case OS_TASK_PEND_ON_TASK_Q:
   2803                               case OS_TASK_PEND_ON_TASK_SEM:
   2804                               default:
   2805                                    break;
   2806                           }
   2807                           break;
   2808          
   2809                      default:
   2810                           return;
   2811                  }
   2812                  p_tcb = p_tcb_owner;
   \                     ??OS_TaskChangePrio_6: (+1)
   \                     ??OS_TaskChangePrio_7: (+1)
   \   00000054   0x002E             MOVS     R6,R5
   2813              } while (p_tcb != DEF_NULL);
   \   00000056   0x2E00             CMP      R6,#+0
   \   00000058   0xD1D5             BNE.N    ??OS_TaskChangePrio_0
   2814          }
   \                     ??OS_TaskChangePrio_8: (+1)
   \   0000005A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   \                     ??OS_TaskChangePrio_3: (+1)
   \   0000005C   0xF886 0x403F      STRB     R4,[R6, #+63]
   \   00000060   0xE7F8             B.N      ??OS_TaskChangePrio_7
   \                     ??OS_TaskChangePrio_2: (+1)
   \   00000062   0xF886 0x403F      STRB     R4,[R6, #+63]
   \   00000066   0xF896 0x003C      LDRB     R0,[R6, #+60]
   \   0000006A   0x2801             CMP      R0,#+1
   \   0000006C   0xD005             BEQ.N    ??OS_TaskChangePrio_9
   \   0000006E   0x2804             CMP      R0,#+4
   \   00000070   0xD007             BEQ.N    ??OS_TaskChangePrio_10
   \   00000072   0x2805             CMP      R0,#+5
   \   00000074   0xD001             BEQ.N    ??OS_TaskChangePrio_9
   \   00000076   0x2806             CMP      R0,#+6
   \   00000078   0xD12B             BNE.N    ??OS_TaskChangePrio_11
   \                     ??OS_TaskChangePrio_9: (+1)
   \   0000007A   0x0030             MOVS     R0,R6
   \   0000007C   0x.... 0x....      BL       OS_PendListChangePrio
   \   00000080   0xE027             B.N      ??OS_TaskChangePrio_12
   \                     ??OS_TaskChangePrio_10: (+1)
   \   00000082   0x0030             MOVS     R0,R6
   \   00000084   0x.... 0x....      BL       OS_PendListChangePrio
   \   00000088   0x6BB0             LDR      R0,[R6, #+56]
   \   0000008A   0x6A45             LDR      R5,[R0, #+36]
   \   0000008C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000008E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000090   0x42BC             CMP      R4,R7
   \   00000092   0xD206             BCS.N    ??OS_TaskChangePrio_13
   \   00000094   0xF895 0x003F      LDRB     R0,[R5, #+63]
   \   00000098   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000009A   0x4284             CMP      R4,R0
   \   0000009C   0xD318             BCC.N    ??OS_TaskChangePrio_14
   \   0000009E   0x2500             MOVS     R5,#+0
   \   000000A0   0xE016             B.N      ??OS_TaskChangePrio_14
   \                     ??OS_TaskChangePrio_13: (+1)
   \   000000A2   0xF895 0x003F      LDRB     R0,[R5, #+63]
   \   000000A6   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000A8   0x42B8             CMP      R0,R7
   \   000000AA   0xD111             BNE.N    ??OS_TaskChangePrio_14
   \   000000AC   0x0028             MOVS     R0,R5
   \   000000AE   0x.... 0x....      BL       OS_MutexGrpPrioFindHighest
   \   000000B2   0x0004             MOVS     R4,R0
   \   000000B4   0xF895 0x0040      LDRB     R0,[R5, #+64]
   \   000000B8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000BA   0x42A0             CMP      R0,R4
   \   000000BC   0xD202             BCS.N    ??OS_TaskChangePrio_15
   \   000000BE   0xF895 0x4040      LDRB     R4,[R5, #+64]
   \   000000C2   0xE7FF             B.N      ??OS_TaskChangePrio_16
   \                     ??OS_TaskChangePrio_15: (+1)
   \                     ??OS_TaskChangePrio_16: (+1)
   \   000000C4   0xF895 0x003F      LDRB     R0,[R5, #+63]
   \   000000C8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000CA   0x4284             CMP      R4,R0
   \   000000CC   0xD100             BNE.N    ??OS_TaskChangePrio_14
   \   000000CE   0x2500             MOVS     R5,#+0
   \                     ??OS_TaskChangePrio_14: (+1)
   \   000000D0   0xE7FF             B.N      ??OS_TaskChangePrio_12
   \                     ??OS_TaskChangePrio_11: (+1)
   \                     ??OS_TaskChangePrio_12: (+1)
   \   000000D2   0xE7BF             B.N      ??OS_TaskChangePrio_7
   \                     ??OS_TaskChangePrio_4: (+1)
   \   000000D4   0xE7C1             B.N      ??OS_TaskChangePrio_8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x........         DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x........         DC32     OSRunning

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x........         DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x........         DC32     OSCfg_StkSizeMin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x........         DC32     OSIdleTaskTCB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   0x........         DC32     OSTaskQty

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \   00000000   0x........         DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_1:
   \   00000000   0x........         DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_2:
   \   00000000   0x20 0x00          DC8      " ",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_3:
   \   00000000   0x........         DC32     OSTaskRegNextAvailID

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_4:
   \   00000000   0x........         DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_5:
   \   00000000   0x........         DC32     OSIdleTaskTCB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_6:
   \   00000000   0x........         DC32     OSRunning

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_7:
   \   00000000   0x........         DC32     OSTaskDbgListPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_8:
   \   00000000   0x........         DC32     OSTaskQty

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_9:
   \   00000000   0x........         DC32     OSTaskCtxSwCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_10:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x3F 0x54          DC8 "?Task"
   \              0x61 0x73    
   \              0x6B 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 2
   \   00000000   0x20 0x00          DC8 " "

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   OSTaskChangePrio
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OSSched
        24   -> OS_MutexGrpPrioFindHighest
        24   -> OS_TaskChangePrio
      56   OSTaskCreate
        56   -> CPU_IntDisMeasStart
        56   -> CPU_IntDisMeasStop
        56   -> CPU_SR_Restore
        56   -> CPU_SR_Save
        56   -> OSSched
        56   -> OSTaskCreateHook
        56   -> OSTaskStkInit
        56   -> OS_MsgQInit
        56   -> OS_PrioInsert
        56   -> OS_RdyListInsertTail
        56   -> OS_TaskDbgListAdd
        56   -> OS_TaskInitTCB
      24   OSTaskDel
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OSSched
        24   -> OSTaskDelHook
        24   -> OS_MsgQFreeAll
        24   -> OS_MutexGrpPostAll
        24   -> OS_MutexGrpPrioFindHighest
        24   -> OS_PendListRemove
        24   -> OS_RdyListRemove
        24   -> OS_TaskChangePrio
        24   -> OS_TaskDbgListRemove
        24   -> OS_TaskInitTCB
        24   -> OS_TickListRemove
      16   OSTaskQFlush
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> OS_MsgQFreeAll
      32   OSTaskQPend
        32   -> CPU_IntDisMeasStart
        32   -> CPU_IntDisMeasStop
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> OSSched
        32   -> OS_MsgQGet
        32   -> OS_Pend
      24   OSTaskQPendAbort
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> CPU_TS_TmrRd
        24   -> OSSched
        24   -> OS_PendAbort
      40   OSTaskQPost
        40   -> CPU_IntDisMeasStart
        40   -> CPU_IntDisMeasStop
        40   -> CPU_SR_Restore
        40   -> CPU_SR_Save
        40   -> CPU_TS_TmrRd
        40   -> OSSched
        40   -> OS_MsgQPut
        40   -> OS_Post
      24   OSTaskRegGet
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
      16   OSTaskRegGetID
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
      24   OSTaskRegSet
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
      16   OSTaskResume
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> OSSched
        16   -> OS_RdyListInsert
      24   OSTaskSemPend
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OSSched
        24   -> OS_Pend
      24   OSTaskSemPendAbort
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> CPU_TS_TmrRd
        24   -> OSSched
        24   -> OS_PendAbort
      32   OSTaskSemPost
        32   -> CPU_IntDisMeasStart
        32   -> CPU_IntDisMeasStop
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> CPU_TS_TmrRd
        32   -> OSSched
        32   -> OS_Post
      24   OSTaskSemSet
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
      24   OSTaskStkChk
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
      16   OSTaskSuspend
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> OSSched
        16   -> OS_RdyListRemove
      24   OS_TaskChangePrio
        24   -> OS_MutexGrpPrioFindHighest
        24   -> OS_PendListChangePrio
        24   -> OS_PrioInsert
        24   -> OS_RdyListInsertHead
        24   -> OS_RdyListInsertTail
        24   -> OS_RdyListRemove
       0   OS_TaskDbgListAdd
       0   OS_TaskDbgListRemove
       0   OS_TaskInit
       8   OS_TaskInitTCB
         8   -> OS_MsgQInit
       8   OS_TaskReturn
         8   -> OSTaskDel
         8   -> OSTaskReturnHook


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_10
       4  ??DataTable22_2
       4  ??DataTable22_3
       4  ??DataTable22_4
       4  ??DataTable22_5
       4  ??DataTable22_6
       4  ??DataTable22_7
       4  ??DataTable22_8
       4  ??DataTable22_9
       8  ?_0
       2  ?_1
     186  OSTaskChangePrio
     424  OSTaskCreate
     390  OSTaskDel
      98  OSTaskQFlush
     374  OSTaskQPend
     168  OSTaskQPendAbort
     266  OSTaskQPost
      72  OSTaskRegGet
      86  OSTaskRegGetID
      76  OSTaskRegSet
     310  OSTaskResume
     356  OSTaskSemPend
     186  OSTaskSemPendAbort
     272  OSTaskSemPost
     114  OSTaskSemSet
     186  OSTaskStkChk
     334  OSTaskSuspend
     214  OS_TaskChangePrio
      44  OS_TaskDbgListAdd
      74  OS_TaskDbgListRemove
      24  OS_TaskInit
     226  OS_TaskInitTCB
      20  OS_TaskReturn

 
    10 bytes in section .rodata
 4 568 bytes in section .text
 
 4 568 bytes of CODE  memory
    10 bytes of CONST memory

Errors: none
Warnings: none
