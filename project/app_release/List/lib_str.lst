###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       11/Jul/2018  11:13:08
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC210\NC210-200处理板\source\Software\uC-LIB\lib_str.c
#    Command line =  
#        F:\iar\NC210\NC210-200处理板\source\Software\uC-LIB\lib_str.c -D
#        USE_STDPERIPH_DRIVER -D APP_RELEASE -lCN
#        F:\iar\NC210\NC210-200处理板\project\app_release\List -o
#        F:\iar\NC210\NC210-200处理板\project\app_release\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC210\NC210-200处理板\project\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\config\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\task\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\user\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\OS\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\Ports\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\driver\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-LIB\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Source\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\ST\STM32\inc\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Ports\STM32\STM32F103\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Source\
#        -Ol --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC210\NC210-200处理板\project\app_release\List\lib_str.lst
#    Object file  =  
#        F:\iar\NC210\NC210-200处理板\project\app_release\Obj\lib_str.o
#
###############################################################################

F:\iar\NC210\NC210-200处理板\source\Software\uC-LIB\lib_str.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/LIB
      4          *                                        CUSTOM LIBRARY MODULES
      5          *
      6          *                         (c) Copyright 2004-2015; Micrium, Inc.; Weston, FL
      7          *
      8          *                  All rights reserved.  Protected by international copyright laws.
      9          *
     10          *                  uC/LIB is provided in source form to registered licensees ONLY.  It is
     11          *                  illegal to distribute this source code to any third party unless you receive
     12          *                  written permission by an authorized Micrium representative.  Knowledge of
     13          *                  the source code may NOT be used to develop a similar product.
     14          *
     15          *                  Please help us continue to provide the Embedded community with the finest
     16          *                  software available.  Your honesty is greatly appreciated.
     17          *
     18          *                  You can find our product's user manual, API reference, release notes and
     19          *                  more information at: https://doc.micrium.com
     20          *
     21          *                  You can contact us at: http://www.micrium.com
     22          *********************************************************************************************************
     23          */
     24          
     25          /*
     26          *********************************************************************************************************
     27          *
     28          *                                       ASCII STRING MANAGEMENT
     29          *
     30          * Filename      : lib_str.c
     31          * Version       : V1.38.02
     32          * Programmer(s) : ITJ
     33          *                 BAN
     34          *                 JDH
     35          *********************************************************************************************************
     36          * Note(s)       : (1) NO compiler-supplied standard library functions are used in library or product software.
     37          *
     38          *                     (a) ALL standard library functions are implemented in the custom library modules :
     39          *
     40          *                         (1) \<Custom Library Directory>\lib_*.*
     41          *
     42          *                         (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
     43          *
     44          *                               where
     45          *                                       <Custom Library Directory>      directory path for custom library software
     46          *                                       <cpu>                           directory name for specific processor (CPU)
     47          *                                       <compiler>                      directory name for specific compiler
     48          *
     49          *                     (b) Product-specific library functions are implemented in individual products.
     50          *
     51          *********************************************************************************************************
     52          * Notice(s)     : (1) The Institute of Electrical and Electronics Engineers and The Open Group, have given
     53          *                     us permission to reprint portions of their documentation.  Portions of this text are
     54          *                     reprinted and reproduced in electronic form from the IEEE Std 1003.1, 2004 Edition,
     55          *                     Standard for Information Technology -- Portable Operating System Interface (POSIX),
     56          *                     The Open Group Base Specifications Issue 6, Copyright (C) 2001-2004 by the Institute
     57          *                     of Electrical and Electronics Engineers, Inc and The Open Group.  In the event of any
     58          *                     discrepancy between these versions and the original IEEE and The Open Group Standard,
     59          *                     the original IEEE and The Open Group Standard is the referee document.  The original
     60          *                     Standard can be obtained online at http://www.opengroup.org/unix/online.html.
     61          *********************************************************************************************************
     62          */
     63          
     64          
     65          /*
     66          *********************************************************************************************************
     67          *                                            INCLUDE FILES
     68          *********************************************************************************************************
     69          */
     70          
     71          #define    MICRIUM_SOURCE
     72          #define    LIB_STR_MODULE
     73          #include  <lib_str.h>
     74          
     75          
     76          /*
     77          *********************************************************************************************************
     78          *                                            LOCAL DEFINES
     79          *********************************************************************************************************
     80          */
     81          
     82          
     83          /*
     84          *********************************************************************************************************
     85          *                                           LOCAL CONSTANTS
     86          *********************************************************************************************************
     87          */
     88          
     89          
     90          /*
     91          *********************************************************************************************************
     92          *                                          LOCAL DATA TYPES
     93          *********************************************************************************************************
     94          */
     95          
     96          
     97          /*
     98          *********************************************************************************************************
     99          *                                            LOCAL TABLES
    100          *********************************************************************************************************
    101          */
    102          

   \                                 In section .rodata, align 4
    103          static  const  CPU_INT32U  Str_MultOvfThTbl_Int32U[] = {
   \                     Str_MultOvfThTbl_Int32U:
   \   00000000   0xFFFFFFFF         DC32 4294967295, 4294967295, 2147483647, 1431655765, 1073741823
   \              0xFFFFFFFF   
   \              0x7FFFFFFF   
   \              0x55555555   
   \              0x3FFFFFFF   
   \   00000014   0x33333333         DC32 858993459, 715827882, 613566756, 536870911, 477218588, 429496729
   \              0x2AAAAAAA   
   \              0x24924924   
   \              0x1FFFFFFF   
   \              0x1C71C71C   
   \              0x19999999   
   \   0000002C   0x1745D174         DC32 390451572, 357913941, 330382099, 306783378, 286331153, 268435455
   \              0x15555555   
   \              0x13B13B13   
   \              0x12492492   
   \              0x11111111   
   \              0x0FFFFFFF   
   \   00000044   0x0F0F0F0F         DC32 252645135, 238609294, 226050910, 214748364, 204522252, 195225786
   \              0x0E38E38E   
   \              0x0D79435E   
   \              0x0CCCCCCC   
   \              0x0C30C30C   
   \              0x0BA2E8BA   
   \   0000005C   0x0B21642C         DC32 186737708, 178956970, 171798691, 165191049, 159072862, 153391689
   \              0x0AAAAAAA   
   \              0x0A3D70A3   
   \              0x09D89D89   
   \              0x097B425E   
   \              0x09249249   
   \   00000074   0x08D3DCB0         DC32 148102320, 143165576, 138547332, 134217727, 130150524, 126322567
   \              0x08888888   
   \              0x08421084   
   \              0x07FFFFFF   
   \              0x07C1F07C   
   \              0x07878787   
   \   0000008C   0x07507507         DC32 122713351, 119304647
   \              0x071C71C7   
    104             (CPU_INT32U) DEF_INT_32U_MAX_VAL,                /*                Invalid base  0.  */
    105             (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  1u),         /*                Invalid base  1.  */
    106             (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  2u),         /* 32-bit mult ovf th for base  2.  */
    107             (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  3u),         /* 32-bit mult ovf th for base  3.  */
    108             (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  4u),         /* 32-bit mult ovf th for base  4.  */
    109             (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  5u),         /* 32-bit mult ovf th for base  5.  */
    110             (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  6u),         /* 32-bit mult ovf th for base  6.  */
    111             (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  7u),         /* 32-bit mult ovf th for base  7.  */
    112             (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  8u),         /* 32-bit mult ovf th for base  8.  */
    113             (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  9u),         /* 32-bit mult ovf th for base  9.  */
    114             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 10u),         /* 32-bit mult ovf th for base 10.  */
    115             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 11u),         /* 32-bit mult ovf th for base 11.  */
    116             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 12u),         /* 32-bit mult ovf th for base 12.  */
    117             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 13u),         /* 32-bit mult ovf th for base 13.  */
    118             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 14u),         /* 32-bit mult ovf th for base 14.  */
    119             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 15u),         /* 32-bit mult ovf th for base 15.  */
    120             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 16u),         /* 32-bit mult ovf th for base 16.  */
    121             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 17u),         /* 32-bit mult ovf th for base 17.  */
    122             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 18u),         /* 32-bit mult ovf th for base 18.  */
    123             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 19u),         /* 32-bit mult ovf th for base 19.  */
    124             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 20u),         /* 32-bit mult ovf th for base 20.  */
    125             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 21u),         /* 32-bit mult ovf th for base 21.  */
    126             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 22u),         /* 32-bit mult ovf th for base 22.  */
    127             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 23u),         /* 32-bit mult ovf th for base 23.  */
    128             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 24u),         /* 32-bit mult ovf th for base 24.  */
    129             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 25u),         /* 32-bit mult ovf th for base 25.  */
    130             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 26u),         /* 32-bit mult ovf th for base 26.  */
    131             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 27u),         /* 32-bit mult ovf th for base 27.  */
    132             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 28u),         /* 32-bit mult ovf th for base 28.  */
    133             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 29u),         /* 32-bit mult ovf th for base 29.  */
    134             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 30u),         /* 32-bit mult ovf th for base 30.  */
    135             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 31u),         /* 32-bit mult ovf th for base 31.  */
    136             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 32u),         /* 32-bit mult ovf th for base 32.  */
    137             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 33u),         /* 32-bit mult ovf th for base 33.  */
    138             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 34u),         /* 32-bit mult ovf th for base 34.  */
    139             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 35u),         /* 32-bit mult ovf th for base 35.  */
    140             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 36u)          /* 32-bit mult ovf th for base 36.  */
    141          };
    142          
    143          
    144          /*
    145          *********************************************************************************************************
    146          *                                       LOCAL GLOBAL VARIABLES
    147          *********************************************************************************************************
    148          */
    149          
    150          
    151          /*
    152          *********************************************************************************************************
    153          *                                      LOCAL FUNCTION PROTOTYPES
    154          *********************************************************************************************************
    155          */
    156          
    157          static  CPU_CHAR    *Str_FmtNbr_Int32  (       CPU_INT32U     nbr,
    158                                                         CPU_INT08U     nbr_dig,
    159                                                         CPU_INT08U     nbr_base,
    160                                                         CPU_BOOLEAN    nbr_neg,
    161                                                         CPU_CHAR       lead_char,
    162                                                         CPU_BOOLEAN    lower_case,
    163                                                         CPU_BOOLEAN    nul,
    164                                                         CPU_CHAR      *pstr);
    165          
    166          static  CPU_INT32U   Str_ParseNbr_Int32(const  CPU_CHAR      *pstr,
    167                                                         CPU_CHAR     **pstr_next,
    168                                                         CPU_INT08U     nbr_base,
    169                                                         CPU_BOOLEAN    nbr_signed,
    170                                                         CPU_BOOLEAN   *pnbr_neg);
    171          
    172          
    173          /*
    174          *********************************************************************************************************
    175          *                                     LOCAL CONFIGURATION ERRORS
    176          *********************************************************************************************************
    177          */
    178          
    179          
    180          /*
    181          *********************************************************************************************************
    182          *                                              Str_Len()
    183          *
    184          * Description : Calculate length of a string.
    185          *
    186          * Argument(s) : pstr        Pointer to string (see Note #1).
    187          *
    188          * Return(s)   : Length of string; number of characters in string before terminating NULL character
    189          *                   (see Note #2b1).
    190          *
    191          * Caller(s)   : Application.
    192          *
    193          * Note(s)     : (1) String buffer NOT modified.
    194          *
    195          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strlen() : DESCRIPTION' states that :
    196          *
    197          *                       (1) "The strlen() function shall compute the number of bytes in the string to
    198          *                            which 's' ('pstr') points," ...
    199          *                       (2) "not including the terminating null byte."
    200          *
    201          *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strlen() : RETURN VALUE' states that :
    202          *
    203          *                       (1) "The strlen() function shall return the length of 's' ('pstr');" ...
    204          *                       (2) "no return value shall be reserved to indicate an error."
    205          *
    206          *               (3) String length calculation terminates when :
    207          *
    208          *                   (a) String pointer points to NULL.
    209          *                       (1) String buffer overlaps with NULL address.
    210          *                       (2) String length calculated for string up to but NOT beyond or including
    211          *                           the NULL address.
    212          *
    213          *                   (b) Terminating NULL character found.
    214          *                       (1) String length calculated for string up to but NOT           including
    215          *                           the NULL character (see Note #2a2).
    216          *********************************************************************************************************
    217          */
    218          

   \                                 In section .text, align 2, keep-with-next
    219          CPU_SIZE_T  Str_Len (const  CPU_CHAR  *pstr)
    220          {
   \                     Str_Len: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    221              CPU_SIZE_T  len;
    222          
    223          
    224              len = Str_Len_N(pstr,
    225                              DEF_INT_CPU_U_MAX_VAL);
   \   00000002   0xF05F 0x31FF      MOVS     R1,#-1
   \   00000006   0x.... 0x....      BL       Str_Len_N
    226          
    227              return (len);
   \   0000000A   0xBD02             POP      {R1,PC}          ;; return
    228          }
    229          
    230          
    231          /*
    232          *********************************************************************************************************
    233          *                                             Str_Len_N()
    234          *
    235          * Description : Calculate length of a string, up to a maximum number of characters.
    236          *
    237          * Argument(s) : pstr        Pointer to string (see Note #1).
    238          *
    239          *               len_max     Maximum number of characters to search (see Note #3c).
    240          *
    241          * Return(s)   : Length of string; number of characters in string before terminating NULL character,
    242          *                   if terminating NULL character     found (see Note #2b1).
    243          *
    244          *               Requested maximum number of characters to search,
    245          *                   if terminating NULL character NOT found (see Note #3c).
    246          *
    247          * Caller(s)   : Application.
    248          *
    249          * Note(s)     : (1) String buffer NOT modified.
    250          *
    251          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strlen() : DESCRIPTION' states that :
    252          *
    253          *                       (1) "The strlen() function shall compute the number of bytes in the string to
    254          *                            which 's' ('pstr') points," ...
    255          *                       (2) "not including the terminating null byte."
    256          *
    257          *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strlen() : RETURN VALUE' states that :
    258          *
    259          *                       (1) "The strlen() function shall return the length of 's' ('pstr');" ...
    260          *                       (2) "no return value shall be reserved to indicate an error."
    261          *
    262          *               (3) String length calculation terminates when :
    263          *
    264          *                   (a) String pointer points to NULL.
    265          *                       (1) String buffer overlaps with NULL address.
    266          *                       (2) String length calculated for string up to but NOT beyond or including
    267          *                           the NULL address.
    268          *
    269          *                   (b) Terminating NULL character found.
    270          *                       (1) String length calculated for string up to but NOT           including
    271          *                           the NULL character (see Note #2a2).
    272          *
    273          *                   (c) 'len_max' number of characters searched.
    274          *                       (1) 'len_max' number of characters does NOT include the terminating NULL character.
    275          *********************************************************************************************************
    276          */
    277          

   \                                 In section .text, align 2, keep-with-next
    278          CPU_SIZE_T  Str_Len_N (const  CPU_CHAR    *pstr,
    279                                        CPU_SIZE_T   len_max)
    280          {
    281              const  CPU_CHAR    *pstr_len;
    282                     CPU_SIZE_T   len;
    283          
    284          
    285              pstr_len = pstr;
    286              len      = 0u;
   \                     Str_Len_N: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   \   00000002   0xE001             B.N      ??Str_Len_N_0
    287              while (( pstr_len != (const CPU_CHAR *)  0 ) &&             /* Calc str len until NULL ptr (see Note #3a) ...       */
    288                     (*pstr_len != (      CPU_CHAR  )'\0') &&             /* ... or NULL char found      (see Note #3b) ...       */
    289                     ( len      <  (      CPU_SIZE_T)len_max)) {          /* ... or max nbr chars srch'd (see Note #3c).          */
    290                  pstr_len++;
   \                     ??Str_Len_N_1: (+1)
   \   00000004   0x1C40             ADDS     R0,R0,#+1
    291                  len++;
   \   00000006   0x1C52             ADDS     R2,R2,#+1
    292              }
   \                     ??Str_Len_N_0: (+1)
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD004             BEQ.N    ??Str_Len_N_2
   \   0000000C   0x7803             LDRB     R3,[R0, #+0]
   \   0000000E   0x2B00             CMP      R3,#+0
   \   00000010   0xD001             BEQ.N    ??Str_Len_N_2
   \   00000012   0x428A             CMP      R2,R1
   \   00000014   0xD3F6             BCC.N    ??Str_Len_N_1
    293          
    294              return (len);                                               /* Rtn str len (see Note #3b1).                         */
   \                     ??Str_Len_N_2: (+1)
   \   00000016   0x0010             MOVS     R0,R2
   \   00000018   0x4770             BX       LR               ;; return
    295          }
    296          
    297          
    298          /*
    299          *********************************************************************************************************
    300          *                                             Str_Copy()
    301          *
    302          * Description : Copy source string to destination string buffer.
    303          *
    304          * Argument(s) : pstr_dest   Pointer to destination string buffer to receive source string copy   (see Note #1a).
    305          *
    306          *               pstr_src    Pointer to source      string to copy into destination string buffer (see Note #1b).
    307          *
    308          * Return(s)   : Pointer to destination string, if NO error(s) [see Note #2b1].
    309          *
    310          *               Pointer to NULL,               otherwise      (see Note #2b2A).
    311          *
    312          * Caller(s)   : Application.
    313          *
    314          * Note(s)     : (1) (a) Destination buffer size NOT validated; buffer overruns MUST be prevented by caller.
    315          *
    316          *                       (1) Destination buffer size MUST be large enough to accommodate the entire source
    317          *                           string size including the terminating NULL character.
    318          *
    319          *                   (b) Source buffer NOT modified.
    320          *
    321          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strcpy() : DESCRIPTION' states that :
    322          *
    323          *                       (1) "The strcpy() function shall copy the string pointed to by 's2' ('pstr_src')
    324          *                            ... into the array pointed to by 's1' ('pstr_dest')" ...
    325          *                       (2) "(including the terminating null byte)."
    326          *
    327          *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strcpy() : RETURN VALUE' states that :
    328          *
    329          *                       (1) "The strcpy() function shall return 's1' ('pstr_dest');" ...
    330          *                       (2) "no return value is reserved to indicate an error."
    331          *                           (A) #### This requirement is intentionally NOT implemented in order to return
    332          *                               NULL for any error(s).
    333          *
    334          *                   (c) IEEE Std 1003.1, 2004 Edition, Section 'strcpy() : DESCRIPTION' states that "if
    335          *                       copying takes place between objects that overlap, the behavior is undefined".
    336          *
    337          *               (3) String copy terminates when :
    338          *
    339          *                   (a) Destination/Source string pointer(s) are passed NULL pointers.
    340          *                       (1) No string copy performed; NULL pointer returned.
    341          *
    342          *                   (b) Destination/Source string pointer(s) point to NULL.
    343          *                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
    344          *
    345          *                   (c) Source string's terminating NULL character found.
    346          *                       (1) Entire source string copied into destination string buffer (see Note #2a).
    347          *********************************************************************************************************
    348          */
    349          

   \                                 In section .text, align 2, keep-with-next
    350          CPU_CHAR  *Str_Copy (       CPU_CHAR  *pstr_dest,
    351                               const  CPU_CHAR  *pstr_src)
    352          {
   \                     Str_Copy: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    353              CPU_CHAR  *pstr_rtn;
    354          
    355          
    356              pstr_rtn = Str_Copy_N(pstr_dest,
    357                                    pstr_src,
    358                                    DEF_INT_CPU_U_MAX_VAL);
   \   00000002   0xF05F 0x32FF      MOVS     R2,#-1
   \   00000006   0x.... 0x....      BL       Str_Copy_N
    359          
    360              return (pstr_rtn);
   \   0000000A   0xBD02             POP      {R1,PC}          ;; return
    361          }
    362          
    363          
    364          /*
    365          *********************************************************************************************************
    366          *                                            Str_Copy_N()
    367          *
    368          * Description : Copy source string to destination string buffer, up to a maximum number of characters.
    369          *
    370          * Argument(s) : pstr_dest   Pointer to destination string buffer to receive source string copy   (see Note #1a).
    371          *
    372          *               pstr_src    Pointer to source      string to copy into destination string buffer (see Note #1b).
    373          *
    374          *               len_max     Maximum number of characters  to copy (see Notes #2a2 & #3d).
    375          *
    376          * Return(s)   : Pointer to destination string, if NO error(s) [see Note #2b1].
    377          *
    378          *               Pointer to NULL,               otherwise      (see Note #2b2A).
    379          *
    380          * Caller(s)   : Application.
    381          *
    382          * Note(s)     : (1) (a) Destination buffer size NOT validated; buffer overruns MUST be prevented by caller.
    383          *
    384          *                       (1) Destination buffer size MUST be large enough to accommodate the entire source
    385          *                           string size including the terminating NULL character.
    386          *
    387          *                   (b) Source string buffer NOT modified.
    388          *
    389          *               (2) (a) (1) IEEE Std 1003.1, 2004 Edition, Section 'strncpy() : DESCRIPTION' states that :
    390          *
    391          *                           (A) "The strncpy() function shall copy ... the array pointed to by 's2'
    392          *                               ('pstr_src') to the array pointed to by 's1' ('pstr_dest')"; ...
    393          *                           (B)  but "not more than 'n' ('len_max') bytes"                   ...
    394          *                           (C)  &   "(bytes that follow a null byte are not copied)".
    395          *
    396          *                       (2) (A) IEEE Std 1003.1, 2004 Edition, Section 'strncpy() : DESCRIPTION' adds that
    397          *                              "if the array pointed to by 's2' ('pstr_src') is a string that is shorter
    398          *                               than 'n' ('len_max') bytes, null bytes shall be appended to the copy in
    399          *                               the array pointed to by 's1' ('pstr_dest'), until 'n' ('len_max') bytes
    400          *                               in all are written."
    401          *
    402          *                               (1) #### Since Str_Copy() limits the maximum number of characters to copy
    403          *                                   via Str_Copy_N() by the CPU's maximum number of addressable characters,
    404          *                                   this requirement is intentionally NOT implemented to avoid appending
    405          *                                   a potentially large number of unnecessary terminating NULL characters.
    406          *
    407          *                           (B) IEEE Std 1003.1, 2004 Edition, Section 'strncpy() : APPLICATION USAGE' also
    408          *                               states that "if there is no null byte in the first 'n' ('len_max') bytes of
    409          *                               the array pointed to by 's2' ('pstr_src'), the result is not null-terminated".
    410          *
    411          *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strncpy() : RETURN VALUE' states that :
    412          *
    413          *                       (1) "The strncpy() function shall return 's1' ('pstr_dest');" ...
    414          *                       (2) "no return value is reserved to indicate an error."
    415          *                           (A) #### This requirement is intentionally ignored in order to return NULL
    416          *                               for any error(s).
    417          *
    418          *                   (c) IEEE Std 1003.1, 2004 Edition, Section 'strncpy() : DESCRIPTION' states that "if
    419          *                       copying takes place between objects that overlap, the behavior is undefined".
    420          *
    421          *               (3) String copy terminates when :
    422          *
    423          *                   (a) Destination/Source string pointer(s) are passed NULL pointers.
    424          *                       (1) No string copy performed; NULL pointer returned.
    425          *
    426          *                   (b) Destination/Source string pointer(s) point to NULL.
    427          *                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
    428          *
    429          *                   (c) Source string's terminating NULL character found.
    430          *                       (1) Entire source string copied into destination string buffer (see Note #2a1A).
    431          *
    432          *                   (d) 'len_max' number of characters copied.
    433          *                       (1) 'len_max' number of characters MAY include the terminating NULL character
    434          *                           (see Note #2a1C).
    435          *                       (2) Null copies allowed (i.e. zero-length copies).
    436          *                           (A) No string copy performed; destination string returned  (see Note #2b1).
    437          *********************************************************************************************************
    438          */
    439          

   \                                 In section .text, align 2, keep-with-next
    440          CPU_CHAR  *Str_Copy_N (       CPU_CHAR    *pstr_dest,
    441                                 const  CPU_CHAR    *pstr_src,
    442                                        CPU_SIZE_T   len_max)
    443          {
   \                     Str_Copy_N: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    444                     CPU_CHAR    *pstr_copy_dest;
    445              const  CPU_CHAR    *pstr_copy_src;
    446                     CPU_SIZE_T   len_copy;
    447          
    448                                                                          /* Rtn NULL if str ptr(s) NULL (see Note #3a1).         */
    449              if (pstr_dest == (CPU_CHAR *)0) {
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD101             BNE.N    ??Str_Copy_N_0
    450                  return ((CPU_CHAR *)0);
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xE01E             B.N      ??Str_Copy_N_1
    451              }
    452              if (pstr_src  == (const CPU_CHAR *)0) {
   \                     ??Str_Copy_N_0: (+1)
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD101             BNE.N    ??Str_Copy_N_2
    453                  return ((CPU_CHAR *)0);
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xE01A             B.N      ??Str_Copy_N_1
    454              }
    455          
    456          
    457              pstr_copy_dest = pstr_dest;
   \                     ??Str_Copy_N_2: (+1)
   \   00000012   0x0003             MOVS     R3,R0
    458              pstr_copy_src  = pstr_src;
    459              len_copy       = 0u;
   \   00000014   0x2400             MOVS     R4,#+0
   \   00000016   0xE004             B.N      ??Str_Copy_N_3
    460          
    461              while (( pstr_copy_dest != (      CPU_CHAR *)  0 ) &&       /* Copy str until NULL ptr(s)  [see Note #3b]  ...      */
    462                     ( pstr_copy_src  != (const CPU_CHAR *)  0 ) &&
    463                     (*pstr_copy_src  != (      CPU_CHAR  )'\0') &&       /* ... or NULL char found      (see Note #3c); ...      */
    464                     ( len_copy       <  (      CPU_SIZE_T)len_max)) {    /* ... or max nbr chars copied (see Note #3d).          */
    465                 *pstr_copy_dest = *pstr_copy_src;
   \                     ??Str_Copy_N_4: (+1)
   \   00000018   0x780D             LDRB     R5,[R1, #+0]
   \   0000001A   0x701D             STRB     R5,[R3, #+0]
    466                  pstr_copy_dest++;
   \   0000001C   0x1C5B             ADDS     R3,R3,#+1
    467                  pstr_copy_src++;
   \   0000001E   0x1C49             ADDS     R1,R1,#+1
    468                  len_copy++;
   \   00000020   0x1C64             ADDS     R4,R4,#+1
    469              }
   \                     ??Str_Copy_N_3: (+1)
   \   00000022   0x2B00             CMP      R3,#+0
   \   00000024   0xD006             BEQ.N    ??Str_Copy_N_5
   \   00000026   0x2900             CMP      R1,#+0
   \   00000028   0xD004             BEQ.N    ??Str_Copy_N_5
   \   0000002A   0x780D             LDRB     R5,[R1, #+0]
   \   0000002C   0x2D00             CMP      R5,#+0
   \   0000002E   0xD001             BEQ.N    ??Str_Copy_N_5
   \   00000030   0x4294             CMP      R4,R2
   \   00000032   0xD3F1             BCC.N    ??Str_Copy_N_4
    470          
    471                                                                          /* Rtn NULL if NULL ptr(s) found  (see Note #3b1).      */
    472              if ((pstr_copy_dest == (      CPU_CHAR *)0) ||
    473                  (pstr_copy_src  == (const CPU_CHAR *)0)) {
   \                     ??Str_Copy_N_5: (+1)
   \   00000034   0x2B00             CMP      R3,#+0
   \   00000036   0xD001             BEQ.N    ??Str_Copy_N_6
   \   00000038   0x2900             CMP      R1,#+0
   \   0000003A   0xD101             BNE.N    ??Str_Copy_N_7
    474                   return ((CPU_CHAR *)0);
   \                     ??Str_Copy_N_6: (+1)
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xE003             B.N      ??Str_Copy_N_1
    475              }
    476          
    477              if (len_copy < len_max) {                                   /* If  copy str len < max buf len (see Note #2a2A), ... */
   \                     ??Str_Copy_N_7: (+1)
   \   00000040   0x4294             CMP      R4,R2
   \   00000042   0xD201             BCS.N    ??Str_Copy_N_8
    478                 *pstr_copy_dest = (CPU_CHAR)'\0';                        /* ... copy NULL char  (see Note #3c1).                 */
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0x7019             STRB     R1,[R3, #+0]
    479              }
    480          
    481          
    482              return (pstr_dest);                                         /* Rtn ptr to dest str (see Note #2b1).                 */
   \                     ??Str_Copy_N_8: (+1)
   \                     ??Str_Copy_N_1: (+1)
   \   00000048   0xBC30             POP      {R4,R5}
   \   0000004A   0x4770             BX       LR               ;; return
    483          }
    484          
    485          
    486          /*
    487          *********************************************************************************************************
    488          *                                              Str_Cat()
    489          *
    490          * Description : Append concatenation string to destination string.
    491          *
    492          * Argument(s) : pstr_dest   Pointer to destination   string to append concatenation  string (see Note #1a).
    493          *
    494          *               pstr_cat    Pointer to concatenation string to append to destination string (see Note #1b).
    495          *
    496          * Return(s)   : Pointer to destination string, if NO error(s) [see Note #2b1].
    497          *
    498          *               Pointer to NULL,               otherwise      (see Note #2b2A).
    499          *
    500          * Caller(s)   : Application.
    501          *
    502          * Note(s)     : (1) (a) Destination buffer size NOT validated; buffer overruns MUST be prevented by caller.
    503          *
    504          *                       (1) Destination buffer size MUST be large enough to accommodate the entire
    505          *                           concatenated string size including the terminating NULL character.
    506          *
    507          *                   (b) Concatenation string buffer NOT modified.
    508          *
    509          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strcat() : DESCRIPTION' states that :
    510          *
    511          *                       (1) "The strcat() function shall append a copy of the string pointed to by 's2'
    512          *                           ('pstr_cat') ... to the end of the string pointed to by 's1' ('pstr_dest')."
    513          *
    514          *                       (2) (A) "The initial byte of 's2' ('pstr_cat') overwrites the null byte at the
    515          *                                end of 's1' ('pstr_dest')."
    516          *                           (B)  A "terminating null byte" is appended at the end of the concatenated
    517          *                                destination strings.
    518          *
    519          *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strcat() : RETURN VALUE' states that :
    520          *
    521          *                       (1) "The strcat() function shall return 's1' ('pstr_dest');" ...
    522          *                       (2) "no return value shall be reserved to indicate an error."
    523          *                           (A) #### This requirement is intentionally NOT implemented in order to return
    524          *                               NULL for any error(s).
    525          *
    526          *                   (c) IEEE Std 1003.1, 2004 Edition, Section 'strcat() : DESCRIPTION' states that "if
    527          *                       copying takes place between objects that overlap, the behavior is undefined."
    528          *
    529          *               (3) String concatenation terminates when :
    530          *
    531          *                   (a) Destination/Concatenation string pointer(s) are passed NULL pointers.
    532          *                       (1) No string concatenation performed; NULL pointer returned.
    533          *
    534          *                   (b) Destination/Concatenation string pointer(s) point to NULL.
    535          *                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
    536          *
    537          *                   (c) Concatenation string's terminating NULL character found.
    538          *                       (1) Entire concatenation string appended to destination string (see Note #2a1).
    539          *********************************************************************************************************
    540          */
    541          

   \                                 In section .text, align 2, keep-with-next
    542          CPU_CHAR  *Str_Cat (       CPU_CHAR  *pstr_dest,
    543                              const  CPU_CHAR  *pstr_cat)
    544          {
   \                     Str_Cat: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    545              CPU_CHAR  *pstr_rtn;
    546          
    547          
    548              pstr_rtn = Str_Cat_N(pstr_dest,
    549                                   pstr_cat,
    550                                   DEF_INT_CPU_U_MAX_VAL);
   \   00000002   0xF05F 0x32FF      MOVS     R2,#-1
   \   00000006   0x.... 0x....      BL       Str_Cat_N
    551          
    552              return (pstr_rtn);
   \   0000000A   0xBD02             POP      {R1,PC}          ;; return
    553          }
    554          
    555          
    556          /*
    557          *********************************************************************************************************
    558          *                                             Str_Cat_N()
    559          *
    560          * Description : Append concatenation string to destination string, up to a maximum number of characters.
    561          *
    562          * Argument(s) : pstr_dest   Pointer to destination   string to append concatenation  string (see Note #1a).
    563          *
    564          *               pstr_cat    Pointer to concatenation string to append to destination string (see Note #1b).
    565          *
    566          *               len_max     Maximum number of characters to concatenate (see Notes #2a1B & #3d).
    567          *
    568          * Return(s)   : Pointer to destination string, if NO error(s) [see Note #2b1].
    569          *
    570          *               Pointer to NULL,               otherwise      (see Note #2b2A).
    571          *
    572          * Caller(s)   : Application.
    573          *
    574          * Note(s)     : (1) (a) Destination buffer size NOT validated; buffer overruns MUST be prevented by caller.
    575          *
    576          *                       (1) Destination buffer size MUST be large enough to accommodate the entire
    577          *                           concatenated string size including the terminating NULL character.
    578          *
    579          *                   (b) Concatenation string buffer NOT modified.
    580          *
    581          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strncat() : DESCRIPTION' states that :
    582          *
    583          *                       (1) (A) "The strncat() function shall append ... the array pointed to by 's2'
    584          *                               ('pstr_cat') to the end of the string pointed to by 's1' ('pstr_dest')" ...
    585          *                           (B)  but "not more than 'n' ('len_max') bytes".
    586          *
    587          *                       (2) (A) "The initial byte of 's2' ('pstr_cat') overwrites the null byte at the
    588          *                                end of 's1' ('pstr_dest')."
    589          *                           (B) "(a null byte and bytes that follow it are not appended)."
    590          *                           (C) "A terminating null byte is always appended to the result."
    591          *
    592          *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strncat() : RETURN VALUE' states that :
    593          *
    594          *                       (1) "The strncat() function shall return 's1' ('pstr_dest');" ...
    595          *                       (2) "no return value shall be reserved to indicate an error."
    596          *                           (A) #### This requirement is intentionally NOT implemented in order to return
    597          *                               NULL for any error(s).
    598          *
    599          *                   (c) IEEE Std 1003.1, 2004 Edition, Section 'strncat() : DESCRIPTION' states that "if
    600          *                       copying takes place between objects that overlap, the behavior is undefined."
    601          *
    602          *               (3) String concatenation terminates when :
    603          *
    604          *                   (a) Destination/Concatenation string pointer(s) are passed NULL pointers.
    605          *                       (1) No string concatenation performed; NULL pointer returned.
    606          *
    607          *                   (b) Destination/Concatenation string pointer(s) point to NULL.
    608          *                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
    609          *
    610          *                   (c) Concatenation string's terminating NULL character found.
    611          *                       (1) Entire concatenation string appended to destination string (see Note #2a1A).
    612          *
    613          *                   (d) 'len_max' number of characters concatenated.
    614          *
    615          *                       (1) 'len_max' number of characters does NOT include the terminating NULL character
    616          *                           (see Note #2a2).
    617          *
    618          *                       (2) Null concatenations allowed (i.e. zero-length concatenations).
    619          *                           (A) No string concatenation performed; destination string returned
    620          *                               (see Note #2b1).
    621          *********************************************************************************************************
    622          */
    623          

   \                                 In section .text, align 2, keep-with-next
    624          CPU_CHAR  *Str_Cat_N (       CPU_CHAR    *pstr_dest,
    625                                const  CPU_CHAR    *pstr_cat,
    626                                       CPU_SIZE_T   len_max)
    627          {
   \                     Str_Cat_N: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    628                     CPU_CHAR    *pstr_cat_dest;
    629              const  CPU_CHAR    *pstr_cat_src;
    630                     CPU_SIZE_T   len_cat;
    631          
    632                                                                          /* Rtn NULL if str ptr(s) NULL (see Note #3a1).         */
    633              if (pstr_dest == (CPU_CHAR *)0) {
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD101             BNE.N    ??Str_Cat_N_0
    634                  return ((CPU_CHAR *)0);
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xE029             B.N      ??Str_Cat_N_1
    635              }
    636              if (pstr_cat  == (const CPU_CHAR *)0) {
   \                     ??Str_Cat_N_0: (+1)
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD101             BNE.N    ??Str_Cat_N_2
    637                  return ((CPU_CHAR *)0);
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xE025             B.N      ??Str_Cat_N_1
    638              }
    639          
    640              if (len_max < 1) {                                          /* Rtn dest str if cat len = 0 (see Note #3d2A).        */
   \                     ??Str_Cat_N_2: (+1)
   \   00000012   0x2A00             CMP      R2,#+0
   \   00000014   0xD023             BEQ.N    ??Str_Cat_N_1
    641                  return ((CPU_CHAR *)pstr_dest);
    642              }
    643          
    644          
    645              pstr_cat_dest = pstr_dest;
   \                     ??Str_Cat_N_3: (+1)
   \   00000016   0x0003             MOVS     R3,R0
   \   00000018   0xE000             B.N      ??Str_Cat_N_4
    646              while (( pstr_cat_dest != (CPU_CHAR *)  0 ) &&              /* Adv to end of cur dest str until NULL ptr ...        */
    647                     (*pstr_cat_dest != (CPU_CHAR  )'\0')) {              /* ... or NULL char found..                             */
    648                  pstr_cat_dest++;
   \                     ??Str_Cat_N_5: (+1)
   \   0000001A   0x1C5B             ADDS     R3,R3,#+1
    649              }
   \                     ??Str_Cat_N_4: (+1)
   \   0000001C   0x2B00             CMP      R3,#+0
   \   0000001E   0xD002             BEQ.N    ??Str_Cat_N_6
   \   00000020   0x781C             LDRB     R4,[R3, #+0]
   \   00000022   0x2C00             CMP      R4,#+0
   \   00000024   0xD1F9             BNE.N    ??Str_Cat_N_5
    650          
    651              if (pstr_cat_dest == (CPU_CHAR *)0) {                       /* Rtn NULL if NULL ptr found (see Note #3b1).          */
   \                     ??Str_Cat_N_6: (+1)
   \   00000026   0x2B00             CMP      R3,#+0
   \   00000028   0xD101             BNE.N    ??Str_Cat_N_7
    652                  return ((CPU_CHAR *)0);
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xE017             B.N      ??Str_Cat_N_1
    653              }
    654          
    655              pstr_cat_src = pstr_cat;
    656              len_cat      = 0u;
   \                     ??Str_Cat_N_7: (+1)
   \   0000002E   0x2400             MOVS     R4,#+0
   \   00000030   0xE004             B.N      ??Str_Cat_N_8
    657          
    658              while (( pstr_cat_dest != (      CPU_CHAR *)  0 ) &&        /* Cat str until NULL ptr(s)  [see Note #3b]  ...       */
    659                     ( pstr_cat_src  != (const CPU_CHAR *)  0 ) &&
    660                     (*pstr_cat_src  != (      CPU_CHAR  )'\0') &&        /* ... or NULL char found     (see Note #3c); ...       */
    661                     ( len_cat       <  (      CPU_SIZE_T)len_max)) {     /* ... or max nbr chars cat'd (see Note #3d).           */
    662                 *pstr_cat_dest = *pstr_cat_src;
   \                     ??Str_Cat_N_9: (+1)
   \   00000032   0x780D             LDRB     R5,[R1, #+0]
   \   00000034   0x701D             STRB     R5,[R3, #+0]
    663                  pstr_cat_dest++;
   \   00000036   0x1C5B             ADDS     R3,R3,#+1
    664                  pstr_cat_src++;
   \   00000038   0x1C49             ADDS     R1,R1,#+1
    665                  len_cat++;
   \   0000003A   0x1C64             ADDS     R4,R4,#+1
    666              }
   \                     ??Str_Cat_N_8: (+1)
   \   0000003C   0x2B00             CMP      R3,#+0
   \   0000003E   0xD006             BEQ.N    ??Str_Cat_N_10
   \   00000040   0x2900             CMP      R1,#+0
   \   00000042   0xD004             BEQ.N    ??Str_Cat_N_10
   \   00000044   0x780D             LDRB     R5,[R1, #+0]
   \   00000046   0x2D00             CMP      R5,#+0
   \   00000048   0xD001             BEQ.N    ??Str_Cat_N_10
   \   0000004A   0x4294             CMP      R4,R2
   \   0000004C   0xD3F1             BCC.N    ??Str_Cat_N_9
    667          
    668                                                                          /* Rtn NULL if NULL ptr(s) found (see Note #3b1).       */
    669              if ((pstr_cat_dest == (      CPU_CHAR *)0) ||
    670                  (pstr_cat_src  == (const CPU_CHAR *)0)) {
   \                     ??Str_Cat_N_10: (+1)
   \   0000004E   0x2B00             CMP      R3,#+0
   \   00000050   0xD001             BEQ.N    ??Str_Cat_N_11
   \   00000052   0x2900             CMP      R1,#+0
   \   00000054   0xD101             BNE.N    ??Str_Cat_N_12
    671                   return ((CPU_CHAR *)0);
   \                     ??Str_Cat_N_11: (+1)
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xE001             B.N      ??Str_Cat_N_1
    672              }
    673          
    674             *pstr_cat_dest = (CPU_CHAR)'\0';                             /* Append NULL char    (see Note #2a2C).                */
   \                     ??Str_Cat_N_12: (+1)
   \   0000005A   0x2100             MOVS     R1,#+0
   \   0000005C   0x7019             STRB     R1,[R3, #+0]
    675          
    676          
    677              return (pstr_dest);                                         /* Rtn ptr to dest str (see Note #2b1).                 */
   \                     ??Str_Cat_N_1: (+1)
   \   0000005E   0xBC30             POP      {R4,R5}
   \   00000060   0x4770             BX       LR               ;; return
    678          }
    679          
    680          
    681          /*
    682          *********************************************************************************************************
    683          *                                              Str_Cmp()
    684          *
    685          * Description : Determine if two strings are identical.
    686          *
    687          * Argument(s) : p1_str      Pointer to first  string (see Note #1).
    688          *
    689          *               p2_str      Pointer to second string (see Note #1).
    690          *
    691          * Return(s)   : 0,              if strings are identical             (see Notes #3a1A, #3a2A, & #3b).
    692          *
    693          *               Negative value, if 'p1_str' is less    than 'p2_str' (see Notes #3a1B1, #3a2B1, & #3c).
    694          *
    695          *               Positive value, if 'p1_str' is greater than 'p2_str' (see Notes #3a1B2, #3a2B2, & #3c).
    696          *
    697          *               See also Note #2b.
    698          *
    699          * Caller(s)   : Application.
    700          *
    701          * Note(s)     : (1) String buffers NOT modified.
    702          *
    703          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : DESCRIPTION' states that "the
    704          *                       strcmp() function shall compare the string pointed to by 's1' ('p1_str') to the
    705          *                       string pointed to by 's2' ('p2_str)".
    706          *
    707          *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : RETURN VALUE' states that
    708          *                          "upon successful completion, strcmp() shall return an integer greater than,
    709          *                           equal to, or less than 0".
    710          *
    711          *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : DESCRIPTION' adds that "the
    712          *                           sign of a non-zero return value shall be determined by the sign of the difference
    713          *                           between the values of the first pair of bytes ... that differ in the strings
    714          *                           being compared".
    715          *
    716          *               (3) String comparison terminates when :
    717          *
    718          *                   (a) (1) (A) BOTH string pointer(s) are passed NULL pointers.
    719          *                               (1) NULL strings identical; 0 returned.
    720          *
    721          *                           (B) (1) 'p1_str' passed a NULL pointer.
    722          *                                   (a) Return negative value of character pointed to by 'p2_str'.
    723          *
    724          *                               (2) 'p2_str' passed a NULL pointer.
    725          *                                   (a) Return positive value of character pointed to by 'p1_str'.
    726          *
    727          *                       (2) (A) BOTH strings point to NULL.
    728          *                               (1) Strings overlap with NULL address.
    729          *                               (2) Strings identical up to but NOT beyond or including the NULL address;
    730          *                                   0 returned.
    731          *
    732          *                           (B) (1) 'p1_str_cmp_next' points to NULL.
    733          *                                   (a) 'p1_str' overlaps with NULL address.
    734          *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
    735          *                                   (c) Return negative value of character pointed to by 'p2_str_cmp_next'.
    736          *
    737          *                               (2) 'p2_str_cmp_next' points to NULL.
    738          *                                   (a) 'p2_str' overlaps with NULL address.
    739          *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
    740          *                                   (c) Return positive value of character pointed to by 'p1_str_cmp_next'.
    741          *
    742          *                   (b) Terminating NULL character found in both strings.
    743          *                       (1) Strings identical; 0 returned.
    744          *                       (2) Only one NULL character test required in conditional since previous condition
    745          *                           tested character equality.
    746          *
    747          *                   (c) Non-matching characters found.
    748          *                       (1) Return signed-integer difference of the character pointed to by 'p2_str'
    749          *                           from the character pointed to by 'p1_str'.
    750          *
    751          *               (4) Since 16-bit signed arithmetic is performed to calculate a non-identical comparison
    752          *                   return value, 'CPU_CHAR' native data type size MUST be 8-bit.
    753          *********************************************************************************************************
    754          */
    755          

   \                                 In section .text, align 2, keep-with-next
    756          CPU_INT16S  Str_Cmp (const  CPU_CHAR  *p1_str,
    757                               const  CPU_CHAR  *p2_str)
    758          {
   \                     Str_Cmp: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    759              CPU_INT16S  cmp_val;
    760          
    761          
    762              cmp_val = Str_Cmp_N(p1_str,
    763                                  p2_str,
    764                                  DEF_INT_CPU_U_MAX_VAL);
   \   00000002   0xF05F 0x32FF      MOVS     R2,#-1
   \   00000006   0x.... 0x....      BL       Str_Cmp_N
    765          
    766              return (cmp_val);
   \   0000000A   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   0000000C   0xBD02             POP      {R1,PC}          ;; return
    767          }
    768          
    769          
    770          /*
    771          *********************************************************************************************************
    772          *                                             Str_Cmp_N()
    773          *
    774          * Description : Determine if two strings are identical for up to a maximum number of characters.
    775          *
    776          * Argument(s) : p1_str      Pointer to first  string (see Note #1).
    777          *
    778          *               p2_str      Pointer to second string (see Note #1).
    779          *
    780          *               len_max     Maximum number of characters to compare  (see Note  #3d).
    781          *
    782          * Return(s)   : 0,              if strings are identical             (see Notes #3a1A, #3a2A, #3b, & #3d).
    783          *
    784          *               Negative value, if 'p1_str' is less    than 'p2_str' (see Notes #3a1B1, #3a2B1, & #3c).
    785          *
    786          *               Positive value, if 'p1_str' is greater than 'p2_str' (see Notes #3a1B2, #3a2B2, & #3c).
    787          *
    788          *               See also Note #2b.
    789          *
    790          * Caller(s)   : Application.
    791          *
    792          * Note(s)     : (1) String buffers NOT modified.
    793          *
    794          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strncmp() : DESCRIPTION' states that :
    795          *
    796          *                       (1) "The strncmp() function shall compare ... the array pointed to by 's1' ('p1_str')
    797          *                            to the array pointed to by 's2' ('p2_str)" ...
    798          *                       (2)  but "not more than 'n' ('len_max') bytes" of either array.
    799          *
    800          *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strncmp() : RETURN VALUE' states that
    801          *                          "upon successful completion, strncmp() shall return an integer greater than,
    802          *                           equal to, or less than 0".
    803          *
    804          *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strncmp() : DESCRIPTION' adds that
    805          *                          "the sign of a non-zero return value is determined by the sign of the difference
    806          *                           between the values of the first pair of bytes ... that differ in the strings
    807          *                           being compared".
    808          *
    809          *               (3) String comparison terminates when :
    810          *
    811          *                   (a) (1) (A) BOTH string pointer(s) are passed NULL pointers.
    812          *                               (1) NULL strings identical; 0 returned.
    813          *
    814          *                           (B) (1) 'p1_str' passed a NULL pointer.
    815          *                                   (a) Return negative value of character pointed to by 'p2_str'.
    816          *
    817          *                               (2) 'p2_str' passed a NULL pointer.
    818          *                                   (a) Return positive value of character pointed to by 'p1_str'.
    819          *
    820          *                       (2) (A) BOTH strings point to NULL.
    821          *                               (1) Strings overlap with NULL address.
    822          *                               (2) Strings identical up to but NOT beyond or including the NULL address;
    823          *                                   0 returned.
    824          *
    825          *                           (B) (1) 'p1_str_cmp_next' points to NULL.
    826          *                                   (a) 'p1_str' overlaps with NULL address.
    827          *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
    828          *                                   (c) Return negative value of character pointed to by 'p2_str_cmp_next'.
    829          *
    830          *                               (2) 'p2_str_cmp_next' points to NULL.
    831          *                                   (a) 'p2_str' overlaps with NULL address.
    832          *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
    833          *                                   (c) Return positive value of character pointed to by 'p1_str_cmp_next'.
    834          *
    835          *                   (b) Terminating NULL character found in both strings.
    836          *                       (1) Strings identical; 0 returned.
    837          *                       (2) Only one NULL character test required in conditional since previous condition
    838          *                           tested character equality.
    839          *
    840          *                   (c) Non-matching characters found.
    841          *                       (1) Return signed-integer difference of the character pointed to by 'p2_str'
    842          *                           from the character pointed to by 'p1_str'.
    843          *
    844          *                   (d) (1) 'len_max' passed a zero length.
    845          *                           (A) Zero-length strings identical; 0 returned.
    846          *
    847          *                       (2) First 'len_max' number of characters identical.
    848          *                           (A) Strings identical; 0 returned.
    849          *
    850          *                       See also Note #2a2.
    851          *
    852          *               (4) Since 16-bit signed arithmetic is performed to calculate a non-identical comparison
    853          *                   return value, 'CPU_CHAR' native data type size MUST be 8-bit.
    854          *********************************************************************************************************
    855          */
    856          

   \                                 In section .text, align 2, keep-with-next
    857          CPU_INT16S  Str_Cmp_N (const  CPU_CHAR    *p1_str,
    858                                 const  CPU_CHAR    *p2_str,
    859                                        CPU_SIZE_T   len_max)
    860          {
   \                     Str_Cmp_N: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    861              const  CPU_CHAR    *p1_str_cmp;
    862              const  CPU_CHAR    *p2_str_cmp;
    863              const  CPU_CHAR    *p1_str_cmp_next;
    864              const  CPU_CHAR    *p2_str_cmp_next;
    865                     CPU_INT16S   cmp_val;
    866                     CPU_SIZE_T   cmp_len;
    867          
    868          
    869              if (len_max < 1) {                                          /* If cmp len = 0,        rtn 0       (see Note #3d1A). */
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD101             BNE.N    ??Str_Cmp_N_0
    870                  return (0);
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xE042             B.N      ??Str_Cmp_N_1
    871              }
    872          
    873              if (p1_str == (const CPU_CHAR *)0) {
   \                     ??Str_Cmp_N_0: (+1)
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD107             BNE.N    ??Str_Cmp_N_2
    874                  if (p2_str == (const CPU_CHAR *)0) {
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD101             BNE.N    ??Str_Cmp_N_3
    875                      return (0);                                         /* If BOTH str ptrs NULL, rtn 0       (see Note #3a1A). */
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xE03C             B.N      ??Str_Cmp_N_1
    876                  }
    877                  cmp_val = (CPU_INT16S)((CPU_INT16S)0 - (CPU_INT16S)(*p2_str));
   \                     ??Str_Cmp_N_3: (+1)
   \   00000016   0x7808             LDRB     R0,[R1, #+0]
   \   00000018   0x4240             RSBS     R0,R0,#+0
    878                  return (cmp_val);                                       /* If p1_str NULL, rtn neg p2_str val (see Note #3a1B1).*/
   \   0000001A   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   0000001C   0xE038             B.N      ??Str_Cmp_N_1
    879              }
    880              if (p2_str == (const CPU_CHAR *)0) {
   \                     ??Str_Cmp_N_2: (+1)
   \   0000001E   0x2900             CMP      R1,#+0
   \   00000020   0xD102             BNE.N    ??Str_Cmp_N_4
    881                  cmp_val = (CPU_INT16S)(*p1_str);
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
    882                  return (cmp_val);                                       /* If p2_str NULL, rtn pos p1_str val (see Note #3a1B2).*/
   \   00000024   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000026   0xE033             B.N      ??Str_Cmp_N_1
    883              }
    884          
    885          
    886              p1_str_cmp      = p1_str;
    887              p2_str_cmp      = p2_str;
    888              p1_str_cmp_next = p1_str_cmp;
   \                     ??Str_Cmp_N_4: (+1)
   \   00000028   0x0003             MOVS     R3,R0
    889              p2_str_cmp_next = p2_str_cmp;
   \   0000002A   0x000C             MOVS     R4,R1
    890              p1_str_cmp_next++;
   \   0000002C   0x1C5B             ADDS     R3,R3,#+1
    891              p2_str_cmp_next++;
   \   0000002E   0x1C64             ADDS     R4,R4,#+1
    892              cmp_len         = 0u;
   \   00000030   0x2500             MOVS     R5,#+0
   \   00000032   0xE004             B.N      ??Str_Cmp_N_5
    893          
    894              while ((*p1_str_cmp      == *p2_str_cmp)            &&      /* Cmp strs until non-matching chars (see Note #3c) ... */
    895                     (*p1_str_cmp      != (      CPU_CHAR  )'\0') &&      /* ... or NULL chars                 (see Note #3b) ... */
    896                     ( p1_str_cmp_next != (const CPU_CHAR *)  0 ) &&      /* ... or NULL ptr(s) found          (see Note #3a2).   */
    897                     ( p2_str_cmp_next != (const CPU_CHAR *)  0 ) &&
    898                     ( cmp_len         <  (      CPU_SIZE_T)len_max)) {   /* ... or max nbr chars cmp'd        (see Note #3d2).   */
    899                  p1_str_cmp++;
   \                     ??Str_Cmp_N_6: (+1)
   \   00000034   0x1C40             ADDS     R0,R0,#+1
    900                  p2_str_cmp++;
   \   00000036   0x1C49             ADDS     R1,R1,#+1
    901                  p1_str_cmp_next++;
   \   00000038   0x1C5B             ADDS     R3,R3,#+1
    902                  p2_str_cmp_next++;
   \   0000003A   0x1C64             ADDS     R4,R4,#+1
    903                  cmp_len++;
   \   0000003C   0x1C6D             ADDS     R5,R5,#+1
    904              }
   \                     ??Str_Cmp_N_5: (+1)
   \   0000003E   0x7806             LDRB     R6,[R0, #+0]
   \   00000040   0x780F             LDRB     R7,[R1, #+0]
   \   00000042   0x42BE             CMP      R6,R7
   \   00000044   0xD108             BNE.N    ??Str_Cmp_N_7
   \   00000046   0x7806             LDRB     R6,[R0, #+0]
   \   00000048   0x2E00             CMP      R6,#+0
   \   0000004A   0xD005             BEQ.N    ??Str_Cmp_N_7
   \   0000004C   0x2B00             CMP      R3,#+0
   \   0000004E   0xD003             BEQ.N    ??Str_Cmp_N_7
   \   00000050   0x2C00             CMP      R4,#+0
   \   00000052   0xD001             BEQ.N    ??Str_Cmp_N_7
   \   00000054   0x4295             CMP      R5,R2
   \   00000056   0xD3ED             BCC.N    ??Str_Cmp_N_6
    905          
    906          
    907              if (cmp_len == len_max) {                                   /* If strs     identical for max len nbr of chars, ...  */
   \                     ??Str_Cmp_N_7: (+1)
   \   00000058   0x4295             CMP      R5,R2
   \   0000005A   0xD101             BNE.N    ??Str_Cmp_N_8
    908                  return (0);                                             /* ... rtn 0                 (see Note #3d2A).          */
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0xE017             B.N      ??Str_Cmp_N_1
    909              }
    910          
    911              if (*p1_str_cmp != *p2_str_cmp) {                           /* If strs NOT identical, ...                           */
   \                     ??Str_Cmp_N_8: (+1)
   \   00000060   0x7802             LDRB     R2,[R0, #+0]
   \   00000062   0x780D             LDRB     R5,[R1, #+0]
   \   00000064   0x42AA             CMP      R2,R5
   \   00000066   0xD003             BEQ.N    ??Str_Cmp_N_9
    912                                                                          /* ... calc & rtn char diff  (see Note #3c1).           */
    913                   cmp_val = (CPU_INT16S)((CPU_INT16S)(*p1_str_cmp) - (CPU_INT16S)(*p2_str_cmp));
   \   00000068   0x7800             LDRB     R0,[R0, #+0]
   \   0000006A   0x7809             LDRB     R1,[R1, #+0]
   \   0000006C   0x1A40             SUBS     R0,R0,R1
   \   0000006E   0xE00E             B.N      ??Str_Cmp_N_10
    914          
    915              } else if (*p1_str_cmp  == (CPU_CHAR)'\0') {                /* If NULL char(s) found, ...                           */
   \                     ??Str_Cmp_N_9: (+1)
   \   00000070   0x7800             LDRB     R0,[R0, #+0]
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD101             BNE.N    ??Str_Cmp_N_11
    916                   cmp_val = (CPU_INT16S)0;                               /* ... strs identical; rtn 0 (see Note #3b).            */
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xE009             B.N      ??Str_Cmp_N_10
    917          
    918              } else {
    919                  if (p1_str_cmp_next == (const CPU_CHAR *)0) {
   \                     ??Str_Cmp_N_11: (+1)
   \   0000007A   0x2B00             CMP      R3,#+0
   \   0000007C   0xD106             BNE.N    ??Str_Cmp_N_12
    920                      if (p2_str_cmp_next == (const CPU_CHAR *)0) {       /* If BOTH next str ptrs NULL, ...                      */
   \   0000007E   0x2C00             CMP      R4,#+0
   \   00000080   0xD101             BNE.N    ??Str_Cmp_N_13
    921                          cmp_val = (CPU_INT16S)0;                        /* ... rtn 0                       (see Note #3a2A).    */
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0xE003             B.N      ??Str_Cmp_N_10
    922                      } else {                                            /* If p1_str_cmp_next NULL, ...                         */
    923                                                                          /* ... rtn neg p2_str_cmp_next val (see Note #3a2B1).   */
    924                          cmp_val = (CPU_INT16S)((CPU_INT16S)0 - (CPU_INT16S)(*p2_str_cmp_next));
   \                     ??Str_Cmp_N_13: (+1)
   \   00000086   0x7820             LDRB     R0,[R4, #+0]
   \   00000088   0x4240             RSBS     R0,R0,#+0
   \   0000008A   0xE000             B.N      ??Str_Cmp_N_10
    925                      }
    926                  } else {                                                /* If p2_str_cmp_next NULL, ...                         */
    927                      cmp_val = (CPU_INT16S)(*p1_str_cmp_next);           /* ... rtn pos p1_str_cmp_next val (see Note #3a2B2).   */
   \                     ??Str_Cmp_N_12: (+1)
   \   0000008C   0x7818             LDRB     R0,[R3, #+0]
    928                  }
    929              }
    930          
    931          
    932              return (cmp_val);
   \                     ??Str_Cmp_N_10: (+1)
   \   0000008E   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \                     ??Str_Cmp_N_1: (+1)
   \   00000090   0xBCF0             POP      {R4-R7}
   \   00000092   0x4770             BX       LR               ;; return
    933          }
    934          
    935          
    936          /*
    937          *********************************************************************************************************
    938          *                                         Str_CmpIgnoreCase()
    939          *
    940          * Description : Determine if two strings are identical, ignoring case.
    941          *
    942          * Argument(s) : p1_str      Pointer to first  string (see Note #1).
    943          *
    944          *               p2_str      Pointer to second string (see Note #1).
    945          *
    946          * Return(s)   : 0,              if strings are identical             (see Notes #3a1A, #3a2A, & #3b).
    947          *
    948          *               Negative value, if 'p1_str' is less    than 'p2_str' (see Notes #3a1B1, #3a2B1, & #3c).
    949          *
    950          *               Positive value, if 'p1_str' is greater than 'p2_str' (see Notes #3a1B2, #3a2B2, & #3c).
    951          *
    952          *               See also Note #2b.
    953          *
    954          * Caller(s)   : Application.
    955          *
    956          * Note(s)     : (1) String buffers NOT modified.
    957          *
    958          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strcasecmp() : DESCRIPTION' states that :
    959          *
    960          *                       (1) (A) "The strcasecmp() function shall compare ... the string pointed to by 's1'
    961          *                                ('p1_str') to the string pointed to by 's2' ('p2_str')" ...
    962          *                           (B) "ignoring differences in case".
    963          *
    964          *                       (2) "strcasecmp() ... shall behave as if the strings had been converted to lowercase
    965          *                            and then a byte comparison performed."
    966          *
    967          *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strcasecmp() : RETURN VALUE' states that
    968          *                          "upon successful completion, strcasecmp() shall return an integer greater than,
    969          *                           equal to, or less than 0".
    970          *
    971          *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : DESCRIPTION' adds that "the
    972          *                           sign of a non-zero return value shall be determined by the sign of the difference
    973          *                           between the values of the first pair of bytes ... that differ in the strings
    974          *                           being compared".
    975          *
    976          *               (3) String comparison terminates when :
    977          *
    978          *                   (a) (1) (A) BOTH string pointer(s) are passed NULL pointers.
    979          *                               (1) NULL strings identical; 0 returned.
    980          *
    981          *                           (B) (1) 'p1_str' passed a NULL pointer.
    982          *                                   (a) Return negative value of character pointed to by 'p2_str', converted
    983          *                                       to lower case (see Note #2a2).
    984          *
    985          *                               (2) 'p2_str' passed a NULL pointer.
    986          *                                   (a) Return positive value of character pointed to by 'p1_str', converted
    987          *                                       to lower case (see Note #2a2).
    988          *
    989          *                       (2) (A) BOTH strings point to NULL.
    990          *                               (1) Strings overlap with NULL address.
    991          *                               (2) Strings identical up to but NOT beyond or including the NULL address;
    992          *                                   0 returned.
    993          *
    994          *                           (B) (1) 'p1_str_cmp_next' points to NULL.
    995          *                                   (a) 'p1_str' overlaps with NULL address.
    996          *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
    997          *                                   (c) Return negative value of character pointed to by 'p2_str_cmp_next',
    998          *                                       converted to lower case (see Note #2a2).
    999          *
   1000          *                               (2) 'p2_str_cmp_next' points to NULL.
   1001          *                                   (a) 'p2_str' overlaps with NULL address.
   1002          *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
   1003          *                                   (c) Return positive value of character pointed to by 'p1_str_cmp_next',
   1004          *                                       converted to lower case (see Note #2a2).
   1005          *
   1006          *                   (b) Terminating NULL character found in both strings.
   1007          *                       (1) Strings identical; 0 returned.
   1008          *                       (2) Only one NULL character test required in conditional since previous condition
   1009          *                           tested character equality.
   1010          *
   1011          *                   (c) Non-matching characters found.
   1012          *                       (1) Return signed-integer difference of the character pointed to by 'p2_str',
   1013          *                           converted to lower case, from the character pointed to by 'p1_str', converted
   1014          *                           to lower case.
   1015          *
   1016          *               (4) Since 16-bit signed arithmetic is performed to calculate a non-identical comparison
   1017          *                   return value, 'CPU_CHAR' native data type size MUST be 8-bit.
   1018          *********************************************************************************************************
   1019          */
   1020          

   \                                 In section .text, align 2, keep-with-next
   1021          CPU_INT16S  Str_CmpIgnoreCase (const  CPU_CHAR  *p1_str,
   1022                                         const  CPU_CHAR  *p2_str)
   1023          {
   \                     Str_CmpIgnoreCase: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1024              CPU_INT16S  cmp_val;
   1025          
   1026          
   1027              cmp_val = Str_CmpIgnoreCase_N(p1_str,
   1028                                            p2_str,
   1029                                            DEF_INT_CPU_U_MAX_VAL);
   \   00000002   0xF05F 0x32FF      MOVS     R2,#-1
   \   00000006   0x.... 0x....      BL       Str_CmpIgnoreCase_N
   1030          
   1031              return (cmp_val);
   \   0000000A   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   0000000C   0xBD02             POP      {R1,PC}          ;; return
   1032          }
   1033          
   1034          
   1035          /*
   1036          *********************************************************************************************************
   1037          *                                        Str_CmpIgnoreCase_N()
   1038          *
   1039          * Description : Determine if two strings are identical for up to a maximum number of characters,
   1040          *                   ignoring case.
   1041          *
   1042          * Argument(s) : p1_str      Pointer to first  string (see Note #1).
   1043          *
   1044          *               p2_str      Pointer to second string (see Note #1).
   1045          *
   1046          *               len_max     Maximum number of characters to compare  (see Note  #3d).
   1047          *
   1048          * Return(s)   : 0,              if strings are identical             (see Notes #3a1A, #3a2A, #3b, & #3d).
   1049          *
   1050          *               Negative value, if 'p1_str' is less    than 'p2_str' (see Notes #3a1B1, #3a2B1, & #3c).
   1051          *
   1052          *               Positive value, if 'p1_str' is greater than 'p2_str' (see Notes #3a1B2, #3a2B2, & #3c).
   1053          *
   1054          *               See also Note #2b.
   1055          *
   1056          * Caller(s)   : Application.
   1057          *
   1058          * Note(s)     : (1) String buffers NOT modified.
   1059          *
   1060          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strncasecmp() : DESCRIPTION' states that :
   1061          *
   1062          *                       (1) (A) "The strncasecmp() function shall compare ... the string pointed to by 's1'
   1063          *                                ('p1_str') to the string pointed to by 's2' ('p2_str')" ...
   1064          *                           (B) "ignoring differences in case"                           ...
   1065          *                           (C)  but "not more than 'n' ('len_max') bytes" of either string.
   1066          *
   1067          *                       (2) "strncasecmp() shall behave as if the strings had been converted to lowercase
   1068          *                            and then a byte comparison performed."
   1069          *
   1070          *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strncasecmp() : RETURN VALUE' states that
   1071          *                          "upon successful completion, strncasecmp() shall return an integer greater than,
   1072          *                           equal to, or less than 0".
   1073          *
   1074          *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : DESCRIPTION' adds that "the
   1075          *                           sign of a non-zero return value shall be determined by the sign of the difference
   1076          *                           between the values of the first pair of bytes ... that differ in the strings
   1077          *                           being compared".
   1078          *
   1079          *               (3) String comparison terminates when :
   1080          *
   1081          *                   (a) (1) (A) BOTH string pointer(s) are passed NULL pointers.
   1082          *                               (1) NULL strings identical; 0 returned.
   1083          *
   1084          *                           (B) (1) 'p1_str' passed a NULL pointer.
   1085          *                                   (a) Return negative value of character pointed to by 'p2_str', converted
   1086          *                                       to lower case (see Note #2a2).
   1087          *
   1088          *                               (2) 'p2_str' passed a NULL pointer.
   1089          *                                   (a) Return positive value of character pointed to by 'p1_str', converted
   1090          *                                       to lower case (see Note #2a2).
   1091          *
   1092          *                       (2) (A) BOTH strings point to NULL.
   1093          *                               (1) Strings overlap with NULL address.
   1094          *                               (2) Strings identical up to but NOT beyond or including the NULL address;
   1095          *                                   0 returned.
   1096          *
   1097          *                           (B) (1) 'p1_str_cmp_next' points to NULL.
   1098          *                                   (a) 'p1_str' overlaps with NULL address.
   1099          *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
   1100          *                                   (c) Return negative value of character pointed to by 'p2_str_cmp_next',
   1101          *                                       converted to lower case (see Note #2a2).
   1102          *
   1103          *                               (2) 'p2_str_cmp_next' points to NULL.
   1104          *                                   (a) 'p2_str' overlaps with NULL address.
   1105          *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
   1106          *                                   (c) Return positive value of character pointed to by 'p1_str_cmp_next',
   1107          *                                       converted to lower case (see Note #2a2).
   1108          *
   1109          *                   (b) Terminating NULL character found in both strings.
   1110          *                       (1) Strings identical; 0 returned.
   1111          *                       (2) Only one NULL character test required in conditional since previous condition
   1112          *                           tested character equality.
   1113          *
   1114          *                   (c) Non-matching characters found.
   1115          *                       (1) Return signed-integer difference of the character pointed to by 'p2_str',
   1116          *                           converted to lower case, from the character pointed to by 'p1_str', converted
   1117          *                           to lower case.
   1118          *
   1119          *                   (d) (1) 'len_max' passed a zero length.
   1120          *                           (A) Zero-length strings identical; 0 returned.
   1121          *
   1122          *                       (2) First 'len_max' number of characters identical.
   1123          *                           (A) Strings identical; 0 returned.
   1124          *
   1125          *                       See also Note #2a1C.
   1126          *
   1127          *               (4) Since 16-bit signed arithmetic is performed to calculate a non-identical comparison
   1128          *                   return value, 'CPU_CHAR' native data type size MUST be 8-bit.
   1129          *********************************************************************************************************
   1130          */
   1131          

   \                                 In section .text, align 2, keep-with-next
   1132          CPU_INT16S  Str_CmpIgnoreCase_N (const  CPU_CHAR    *p1_str,
   1133                                           const  CPU_CHAR    *p2_str,
   1134                                                  CPU_SIZE_T   len_max)
   1135          {
   \                     Str_CmpIgnoreCase_N: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   1136              const  CPU_CHAR    *p1_str_cmp;
   1137              const  CPU_CHAR    *p2_str_cmp;
   1138              const  CPU_CHAR    *p1_str_cmp_next;
   1139              const  CPU_CHAR    *p2_str_cmp_next;
   1140                     CPU_CHAR     char_1;
   1141                     CPU_CHAR     char_2;
   1142                     CPU_INT16S   cmp_val;
   1143                     CPU_SIZE_T   cmp_len;
   1144          
   1145          
   1146              if (len_max < 1) {                                          /* If cmp len = 0,        rtn 0       (see Note #3d1A). */
   \   0000000A   0x2E00             CMP      R6,#+0
   \   0000000C   0xD101             BNE.N    ??Str_CmpIgnoreCase_N_0
   1147                  return (0);
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xE074             B.N      ??Str_CmpIgnoreCase_N_1
   1148              }
   1149          
   1150              if (p1_str == (const CPU_CHAR *)0) {
   \                     ??Str_CmpIgnoreCase_N_0: (+1)
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xD10C             BNE.N    ??Str_CmpIgnoreCase_N_2
   1151                  if (p2_str == (const CPU_CHAR *)0) {
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD101             BNE.N    ??Str_CmpIgnoreCase_N_3
   1152                      return (0);                                         /* If BOTH str ptrs NULL, rtn 0       (see Note #3a1A). */
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE06E             B.N      ??Str_CmpIgnoreCase_N_1
   1153                  }
   1154                  char_2  =  ASCII_ToLower(*p2_str);
   \                     ??Str_CmpIgnoreCase_N_3: (+1)
   \   0000001E   0x7828             LDRB     R0,[R5, #+0]
   \   00000020   0x.... 0x....      BL       ASCII_ToLower
   1155                  cmp_val = (CPU_INT16S)((CPU_INT16S)0 - (CPU_INT16S)char_2);
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0xF1D0 0x0900      RSBS     R9,R0,#+0
   1156                  return (cmp_val);                                       /* If p1_str NULL, rtn neg p2_str val (see Note #3a1B1).*/
   \   0000002A   0x4648             MOV      R0,R9
   \   0000002C   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   0000002E   0xE065             B.N      ??Str_CmpIgnoreCase_N_1
   1157              }
   1158              if (p2_str == (const CPU_CHAR *)0) {
   \                     ??Str_CmpIgnoreCase_N_2: (+1)
   \   00000030   0x2D00             CMP      R5,#+0
   \   00000032   0xD108             BNE.N    ??Str_CmpIgnoreCase_N_4
   1159                  char_1  =  ASCII_ToLower(*p1_str);
   \   00000034   0x7820             LDRB     R0,[R4, #+0]
   \   00000036   0x.... 0x....      BL       ASCII_ToLower
   \   0000003A   0x4681             MOV      R9,R0
   1160                  cmp_val = (CPU_INT16S)char_1;
   \   0000003C   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   1161                  return (cmp_val);                                       /* If p2_str NULL, rtn pos p1_str val (see Note #3a1B2).*/
   \   00000040   0x4648             MOV      R0,R9
   \   00000042   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000044   0xE05A             B.N      ??Str_CmpIgnoreCase_N_1
   1162              }
   1163          
   1164          
   1165              p1_str_cmp      = p1_str;
   1166              p2_str_cmp      = p2_str;
   1167              p1_str_cmp_next = p1_str_cmp;
   \                     ??Str_CmpIgnoreCase_N_4: (+1)
   \   00000046   0x0027             MOVS     R7,R4
   1168              p2_str_cmp_next = p2_str_cmp;
   \   00000048   0x46A8             MOV      R8,R5
   1169              p1_str_cmp_next++;
   \   0000004A   0x1C7F             ADDS     R7,R7,#+1
   1170              p2_str_cmp_next++;
   \   0000004C   0xF118 0x0801      ADDS     R8,R8,#+1
   1171              char_1          = ASCII_ToLower(*p1_str_cmp);
   \   00000050   0x7820             LDRB     R0,[R4, #+0]
   \   00000052   0x.... 0x....      BL       ASCII_ToLower
   \   00000056   0x4681             MOV      R9,R0
   1172              char_2          = ASCII_ToLower(*p2_str_cmp);
   \   00000058   0x7828             LDRB     R0,[R5, #+0]
   \   0000005A   0x.... 0x....      BL       ASCII_ToLower
   1173              cmp_len         = 0u;
   \   0000005E   0xF05F 0x0A00      MOVS     R10,#+0
   \   00000062   0xE00D             B.N      ??Str_CmpIgnoreCase_N_5
   1174          
   1175              while (( char_1          ==  char_2)                &&      /* Cmp strs until non-matching chars (see Note #3c) ... */
   1176                     (*p1_str_cmp      != (      CPU_CHAR  )'\0') &&      /* ... or NULL chars                 (see Note #3b) ... */
   1177                     ( p1_str_cmp_next != (const CPU_CHAR *)  0 ) &&      /* ... or NULL ptr(s) found          (see Note #3a2).   */
   1178                     ( p2_str_cmp_next != (const CPU_CHAR *)  0 ) &&
   1179                     ( cmp_len         <  (      CPU_SIZE_T)len_max)) {   /* ... or max nbr chars cmp'd        (see Note #3d2).   */
   1180                  p1_str_cmp++;
   \                     ??Str_CmpIgnoreCase_N_6: (+1)
   \   00000064   0x1C64             ADDS     R4,R4,#+1
   1181                  p2_str_cmp++;
   \   00000066   0x1C6D             ADDS     R5,R5,#+1
   1182                  p1_str_cmp_next++;
   \   00000068   0x1C7F             ADDS     R7,R7,#+1
   1183                  p2_str_cmp_next++;
   \   0000006A   0xF118 0x0801      ADDS     R8,R8,#+1
   1184                  cmp_len++;
   \   0000006E   0xF11A 0x0A01      ADDS     R10,R10,#+1
   1185                  char_1 = ASCII_ToLower(*p1_str_cmp);
   \   00000072   0x7820             LDRB     R0,[R4, #+0]
   \   00000074   0x.... 0x....      BL       ASCII_ToLower
   \   00000078   0x4681             MOV      R9,R0
   1186                  char_2 = ASCII_ToLower(*p2_str_cmp);
   \   0000007A   0x7828             LDRB     R0,[R5, #+0]
   \   0000007C   0x.... 0x....      BL       ASCII_ToLower
   1187              }
   \                     ??Str_CmpIgnoreCase_N_5: (+1)
   \   00000080   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000084   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000086   0x4581             CMP      R9,R0
   \   00000088   0xD109             BNE.N    ??Str_CmpIgnoreCase_N_7
   \   0000008A   0x7821             LDRB     R1,[R4, #+0]
   \   0000008C   0x2900             CMP      R1,#+0
   \   0000008E   0xD006             BEQ.N    ??Str_CmpIgnoreCase_N_7
   \   00000090   0x2F00             CMP      R7,#+0
   \   00000092   0xD004             BEQ.N    ??Str_CmpIgnoreCase_N_7
   \   00000094   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000098   0xD001             BEQ.N    ??Str_CmpIgnoreCase_N_7
   \   0000009A   0x45B2             CMP      R10,R6
   \   0000009C   0xD3E2             BCC.N    ??Str_CmpIgnoreCase_N_6
   1188          
   1189          
   1190              if (cmp_len == len_max) {                                   /* If strs     identical for max len nbr of chars, ...  */
   \                     ??Str_CmpIgnoreCase_N_7: (+1)
   \   0000009E   0x45B2             CMP      R10,R6
   \   000000A0   0xD101             BNE.N    ??Str_CmpIgnoreCase_N_8
   1191                  return (0);                                             /* ... rtn 0                 (see Note #3d2A).          */
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0xE02A             B.N      ??Str_CmpIgnoreCase_N_1
   1192              }
   1193          
   1194              if (char_1 != char_2) {                                     /* If strs NOT identical, ...                           */
   \                     ??Str_CmpIgnoreCase_N_8: (+1)
   \   000000A6   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000AA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AC   0x4581             CMP      R9,R0
   \   000000AE   0xD005             BEQ.N    ??Str_CmpIgnoreCase_N_9
   1195                                                                          /* ... calc & rtn char diff  (see Note #3c1).           */
   1196                   cmp_val = (CPU_INT16S)((CPU_INT16S)char_1 - (CPU_INT16S)char_2);
   \   000000B0   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000B4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B6   0xEBB9 0x0900      SUBS     R9,R9,R0
   \   000000BA   0xE01D             B.N      ??Str_CmpIgnoreCase_N_10
   1197          
   1198              } else if (char_1 == (CPU_CHAR)'\0') {                      /* If NULL char(s) found, ...                           */
   \                     ??Str_CmpIgnoreCase_N_9: (+1)
   \   000000BC   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000C0   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000C4   0xD102             BNE.N    ??Str_CmpIgnoreCase_N_11
   1199                   cmp_val = (CPU_INT16S)0;                               /* ... strs identical; rtn 0 (see Note #3b).            */
   \   000000C6   0xF05F 0x0900      MOVS     R9,#+0
   \   000000CA   0xE015             B.N      ??Str_CmpIgnoreCase_N_10
   1200          
   1201              } else {
   1202                  if (p1_str_cmp_next == (const CPU_CHAR *)0) {
   \                     ??Str_CmpIgnoreCase_N_11: (+1)
   \   000000CC   0x2F00             CMP      R7,#+0
   \   000000CE   0xD10D             BNE.N    ??Str_CmpIgnoreCase_N_12
   1203                      if (p2_str_cmp_next == (const CPU_CHAR *)0) {       /* If BOTH next str ptrs NULL, ...                      */
   \   000000D0   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000D4   0xD102             BNE.N    ??Str_CmpIgnoreCase_N_13
   1204                          cmp_val = (CPU_INT16S)0;                        /* ... rtn 0                       (see Note #3a2A).    */
   \   000000D6   0xF05F 0x0900      MOVS     R9,#+0
   \   000000DA   0xE00D             B.N      ??Str_CmpIgnoreCase_N_10
   1205                      } else {                                            /* If p1_str_cmp_next NULL, ...                         */
   1206                          char_2  =  ASCII_ToLower(*p2_str_cmp_next);
   \                     ??Str_CmpIgnoreCase_N_13: (+1)
   \   000000DC   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   000000E0   0x.... 0x....      BL       ASCII_ToLower
   1207                                                                          /* ... rtn neg p2_str_cmp_next val (see Note #3a2B1).   */
   1208                          cmp_val = (CPU_INT16S)((CPU_INT16S)0 - (CPU_INT16S)char_2);
   \   000000E4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E6   0xF1D0 0x0900      RSBS     R9,R0,#+0
   \   000000EA   0xE005             B.N      ??Str_CmpIgnoreCase_N_10
   1209                      }
   1210                  } else {                                                /* If p2_str_cmp_next NULL, ...                         */
   1211                      char_1  =  ASCII_ToLower(*p1_str_cmp_next);
   \                     ??Str_CmpIgnoreCase_N_12: (+1)
   \   000000EC   0x7838             LDRB     R0,[R7, #+0]
   \   000000EE   0x.... 0x....      BL       ASCII_ToLower
   \   000000F2   0x4681             MOV      R9,R0
   1212                      cmp_val = (CPU_INT16S)char_1;                       /* ... rtn pos p1_str_cmp_next val (see Note #3a2B2).   */
   \   000000F4   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   1213                  }
   1214              }
   1215          
   1216          
   1217              return (cmp_val);
   \                     ??Str_CmpIgnoreCase_N_10: (+1)
   \   000000F8   0x4648             MOV      R0,R9
   \   000000FA   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \                     ??Str_CmpIgnoreCase_N_1: (+1)
   \   000000FC   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   1218          }
   1219          
   1220          
   1221          /*
   1222          *********************************************************************************************************
   1223          *                                             Str_Char()
   1224          *
   1225          * Description : Search string for first occurrence of specific character.
   1226          *
   1227          * Argument(s) : pstr            Pointer to string (see Note #1).
   1228          *
   1229          *               srch_char       Search character.
   1230          *
   1231          * Return(s)   : Pointer to first occurrence of search character in string, if any    (see Note #2b1).
   1232          *
   1233          *               Pointer to NULL,                                           otherwise (see Note #2b2).
   1234          *
   1235          * Caller(s)   : Application.
   1236          *
   1237          * Note(s)     : (1) String buffer NOT modified.
   1238          *
   1239          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strchr() : DESCRIPTION' states that :
   1240          *
   1241          *                       (1) "The strchr() function shall locate the first occurrence of 'c' ('srch_char')
   1242          *                            ... in the string pointed to by 's' ('pstr')."
   1243          *                       (2) "The terminating null byte is considered to be part of the string."
   1244          *
   1245          *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strchr() : RETURN VALUE' states that
   1246          *                       "upon completion, strchr() shall return" :
   1247          *
   1248          *                       (1) "a pointer to the byte," ...
   1249          *                       (2) "or a null pointer if the byte was not found."
   1250          *                           (A) #### Although NO strchr() specification states to return NULL for
   1251          *                               any other reason(s), NULL is also returned for any error(s).
   1252          *
   1253          *               (3) String search terminates when :
   1254          *
   1255          *                   (a) String pointer passed a NULL pointer.
   1256          *                       (1) No string search performed; NULL pointer returned.
   1257          *
   1258          *                   (b) String pointer points to NULL.
   1259          *                       (1) String overlaps with NULL address; NULL pointer returned.
   1260          *
   1261          *                   (c) String's terminating NULL character found.
   1262          *                       (1) Search character NOT found in search string; NULL pointer returned
   1263          *                           (see Note #2b2).
   1264          *                       (2) Applicable even if search character is the terminating NULL character
   1265          *                           (see Note #2a2).
   1266          *
   1267          *                   (d) Search character found.
   1268          *                       (1) Return pointer to first occurrence of search character in search string
   1269          *                           (see Note #2a1).
   1270          *********************************************************************************************************
   1271          */
   1272          

   \                                 In section .text, align 2, keep-with-next
   1273          CPU_CHAR  *Str_Char (const  CPU_CHAR  *pstr,
   1274                                      CPU_CHAR   srch_char)
   1275          {
   \                     Str_Char: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1276              CPU_CHAR  *pstr_rtn;
   1277          
   1278          
   1279              pstr_rtn = Str_Char_N(pstr,
   1280                                    DEF_INT_CPU_U_MAX_VAL,
   1281                                    srch_char);
   \   00000002   0x000A             MOVS     R2,R1
   \   00000004   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000006   0xF05F 0x31FF      MOVS     R1,#-1
   \   0000000A   0x.... 0x....      BL       Str_Char_N
   1282          
   1283              return (pstr_rtn);
   \   0000000E   0xBD02             POP      {R1,PC}          ;; return
   1284          }
   1285          
   1286          
   1287          /*
   1288          *********************************************************************************************************
   1289          *                                            Str_Char_N()
   1290          *
   1291          * Description : Search string for first occurrence of specific character, up to a maximum number
   1292          *                   of characters.
   1293          *
   1294          * Argument(s) : pstr            Pointer to string (see Note #1).
   1295          *
   1296          *               len_max         Maximum number of characters to search (see Notes #2c & #3e).
   1297          *
   1298          *               srch_char       Search character.
   1299          *
   1300          * Return(s)   : Pointer to first occurrence of search character in string, if any    (see Note #2b1).
   1301          *
   1302          *               Pointer to NULL,                                           otherwise (see Note #2b2).
   1303          *
   1304          * Caller(s)   : Application.
   1305          *
   1306          * Note(s)     : (1) String buffer NOT modified.
   1307          *
   1308          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strchr() : DESCRIPTION' states that :
   1309          *
   1310          *                       (1) "The strchr() function shall locate the first occurrence of 'c' ('srch_char')
   1311          *                            ... in the string pointed to by 's' ('pstr')."
   1312          *                       (2) "The terminating null byte is considered to be part of the string."
   1313          *
   1314          *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strchr() : RETURN VALUE' states that
   1315          *                       "upon completion, strchr() shall return" :
   1316          *
   1317          *                       (1) "a pointer to the byte," ...
   1318          *                       (2) "or a null pointer if the byte was not found."
   1319          *                           (A) #### Although NO strchr() specification states to return NULL for
   1320          *                               any other reason(s), NULL is also returned for any error(s).
   1321          *
   1322          *                   (c) Ideally, the 'len_max' argument would be the last argument in this function's
   1323          *                       argument list for consistency with all other custom string library functions.
   1324          *                       However, the 'len_max' argument is sequentially ordered as the second argument
   1325          *                       to comply with most standard library's strnchr() argument list.
   1326          *
   1327          *               (3) String search terminates when :
   1328          *
   1329          *                   (a) String pointer passed a NULL pointer.
   1330          *                       (1) No string search performed; NULL pointer returned.
   1331          *
   1332          *                   (b) String pointer points to NULL.
   1333          *                       (1) String overlaps with NULL address; NULL pointer returned.
   1334          *
   1335          *                   (c) String's terminating NULL character found.
   1336          *                       (1) Search character NOT found in search string; NULL pointer returned
   1337          *                           (see Note #2b2).
   1338          *                       (2) Applicable even if search character is the terminating NULL character
   1339          *                           (see Note #2a2).
   1340          *
   1341          *                   (d) Search character found.
   1342          *                       (1) Return pointer to first occurrence of search character in search string
   1343          *                           (see Note #2a1).
   1344          *
   1345          *                   (e) 'len_max' number of characters searched.
   1346          *                       (1) Search character NOT found in search string within first 'len_max' number
   1347          *                           of characters; NULL pointer returned.
   1348          *                       (2) 'len_max' number of characters MAY include terminating NULL character
   1349          *                           (see Note #2a2).
   1350          *********************************************************************************************************
   1351          */
   1352          

   \                                 In section .text, align 2, keep-with-next
   1353          CPU_CHAR  *Str_Char_N (const  CPU_CHAR    *pstr,
   1354                                        CPU_SIZE_T   len_max,
   1355                                        CPU_CHAR     srch_char)
   1356          {
   \                     Str_Char_N: (+1)
   \   00000000   0xB410             PUSH     {R4}
   1357              const  CPU_CHAR    *pstr_char;
   1358                     CPU_SIZE_T   len_srch;
   1359          
   1360          
   1361              if (pstr == (const CPU_CHAR *)0) {                          /* Rtn NULL if srch str ptr NULL (see Note #3a1).       */
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD101             BNE.N    ??Str_Char_N_0
   1362                  return ((CPU_CHAR *)0);
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xE020             B.N      ??Str_Char_N_1
   1363              }
   1364          
   1365              if (len_max < 1) {                                          /* Rtn NULL if srch len = 0      (see Note #3e1).       */
   \                     ??Str_Char_N_0: (+1)
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD101             BNE.N    ??Str_Char_N_2
   1366                  return ((CPU_CHAR *)0);
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xE01C             B.N      ??Str_Char_N_1
   1367              }
   1368          
   1369          
   1370              pstr_char = pstr;
   1371              len_srch  = 0u;
   \                     ??Str_Char_N_2: (+1)
   \   00000012   0x2300             MOVS     R3,#+0
   \   00000014   0xE001             B.N      ??Str_Char_N_3
   1372          
   1373              while (( pstr_char != (const CPU_CHAR *)  0 )      &&       /* Srch str until NULL ptr     [see Note #3b]  ...      */
   1374                     (*pstr_char != (      CPU_CHAR  )'\0')      &&       /* ... or NULL char            (see Note #3c)  ...      */
   1375                     (*pstr_char != (      CPU_CHAR  )srch_char) &&       /* ... or srch char found      (see Note #3d); ...      */
   1376                     ( len_srch  <  (      CPU_SIZE_T)len_max)) {         /* ... or max nbr chars srch'd (see Note #3e).          */
   1377                  pstr_char++;
   \                     ??Str_Char_N_4: (+1)
   \   00000016   0x1C40             ADDS     R0,R0,#+1
   1378                  len_srch++;
   \   00000018   0x1C5B             ADDS     R3,R3,#+1
   1379              }
   \                     ??Str_Char_N_3: (+1)
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD008             BEQ.N    ??Str_Char_N_5
   \   0000001E   0x7804             LDRB     R4,[R0, #+0]
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD005             BEQ.N    ??Str_Char_N_5
   \   00000024   0x7804             LDRB     R4,[R0, #+0]
   \   00000026   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000028   0x4294             CMP      R4,R2
   \   0000002A   0xD001             BEQ.N    ??Str_Char_N_5
   \   0000002C   0x428B             CMP      R3,R1
   \   0000002E   0xD3F2             BCC.N    ??Str_Char_N_4
   1380          
   1381              if (pstr_char == (const CPU_CHAR *)0) {                     /* Rtn NULL if NULL ptr found      (see Note #3b1).     */
   \                     ??Str_Char_N_5: (+1)
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD101             BNE.N    ??Str_Char_N_6
   1382                  return ((CPU_CHAR *)0);
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xE009             B.N      ??Str_Char_N_1
   1383              }
   1384          
   1385              if (len_srch >= len_max) {                                  /* Rtn NULL if srch char NOT found ...                  */
   \                     ??Str_Char_N_6: (+1)
   \   00000038   0x428B             CMP      R3,R1
   \   0000003A   0xD301             BCC.N    ??Str_Char_N_7
   1386                  return ((CPU_CHAR *)0);                                 /* ... within max nbr of chars     (see Note #3e1).     */
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xE005             B.N      ??Str_Char_N_1
   1387              }
   1388          
   1389              if (*pstr_char != srch_char) {                              /* Rtn NULL if srch char NOT found (see Note #3c1).     */
   \                     ??Str_Char_N_7: (+1)
   \   00000040   0x7801             LDRB     R1,[R0, #+0]
   \   00000042   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000044   0x4291             CMP      R1,R2
   \   00000046   0xD001             BEQ.N    ??Str_Char_N_8
   1390                   return ((CPU_CHAR *)0);
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xE7FF             B.N      ??Str_Char_N_1
   1391              }
   1392          
   1393          
   1394              return ((CPU_CHAR *)pstr_char);                             /* Else rtn ptr to found srch char (see Note #3d1).     */
   \                     ??Str_Char_N_8: (+1)
   \                     ??Str_Char_N_1: (+1)
   \   0000004C   0xBC10             POP      {R4}
   \   0000004E   0x4770             BX       LR               ;; return
   1395          }
   1396          
   1397          
   1398          /*
   1399          *********************************************************************************************************
   1400          *                                           Str_Char_Last()
   1401          *
   1402          * Description : Search string for last occurrence of specific character.
   1403          *
   1404          * Argument(s) : pstr            Pointer to string (see Note #1).
   1405          *
   1406          *               srch_char       Search character.
   1407          *
   1408          * Return(s)   : Pointer to last occurrence of search character in string, if any    (see Note #2b1).
   1409          *
   1410          *               Pointer to NULL,                                          otherwise (see Note #2b2).
   1411          *
   1412          * Caller(s)   : Application.
   1413          *
   1414          * Note(s)     : (1) String buffer NOT modified.
   1415          *
   1416          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strrchr() : DESCRIPTION' states that :
   1417          *
   1418          *                       (1) "The strrchr() function shall locate the last occurrence of 'c' ('srch_char')
   1419          *                            ... in the string pointed to by 's' ('pstr')."
   1420          *                       (2) "The terminating null byte is considered to be part of the string."
   1421          *
   1422          *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strrchr() : RETURN VALUE' states that
   1423          *                       "upon successful completion, strrchr() shall return" :
   1424          *
   1425          *                       (1) "a pointer to the byte" ...
   1426          *                       (2) "or a null pointer if 'c' ('srch_char') does not occur in the string."
   1427          *                           (A) #### Although NO strrchr() specification states to return NULL for
   1428          *                               any other reason(s), NULL is also returned for any error(s).
   1429          *
   1430          *               (3) String search terminates when :
   1431          *
   1432          *                   (a) String pointer passed a NULL pointer.
   1433          *                       (1) No string search performed; NULL pointer returned.
   1434          *
   1435          *                   (b) String pointer points to NULL.
   1436          *                       (1) String overlaps with NULL address; NULL pointer returned.
   1437          *
   1438          *                   (c) String searched from end to beginning.
   1439          *                       (1) Search character NOT found in search string; NULL pointer returned.
   1440          *                       (2) Applicable even if search character is the terminating NULL character
   1441          *                           (see Note #2a2).
   1442          *
   1443          *                   (d) Search character found.
   1444          *                       (1) Return pointer to last occurrence of search character in search string
   1445          *                           (see Note #2a1).
   1446          *********************************************************************************************************
   1447          */
   1448          

   \                                 In section .text, align 2, keep-with-next
   1449          CPU_CHAR  *Str_Char_Last (const  CPU_CHAR  *pstr,
   1450                                           CPU_CHAR   srch_char)
   1451          {
   \                     Str_Char_Last: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1452              CPU_CHAR  *pstr_rtn;
   1453          
   1454          
   1455              pstr_rtn = Str_Char_Last_N(pstr,
   1456                                         DEF_INT_CPU_U_MAX_VAL,
   1457                                         srch_char);
   \   00000002   0x000A             MOVS     R2,R1
   \   00000004   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000006   0xF05F 0x31FF      MOVS     R1,#-1
   \   0000000A   0x.... 0x....      BL       Str_Char_Last_N
   1458          
   1459              return (pstr_rtn);
   \   0000000E   0xBD02             POP      {R1,PC}          ;; return
   1460          }
   1461          
   1462          
   1463          /*
   1464          *********************************************************************************************************
   1465          *                                          Str_Char_Last_N()
   1466          *
   1467          * Description : Search string for last occurrence of specific character, up to a maximum number
   1468          *                   of characters.
   1469          *
   1470          * Argument(s) : pstr            Pointer to string (see Note #1).
   1471          *
   1472          *               len_max         Maximum number of characters to search (see Notes #2c & #3e).
   1473          *
   1474          *               srch_char       Search character.
   1475          *
   1476          * Return(s)   : Pointer to last occurrence of search character in string, if any    (see Note #2b1).
   1477          *
   1478          *               Pointer to NULL,                                          otherwise (see Note #2b2).
   1479          *
   1480          * Caller(s)   : Application.
   1481          *
   1482          * Note(s)     : (1) String buffer NOT modified.
   1483          *
   1484          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strrchr() : DESCRIPTION' states that :
   1485          *
   1486          *                       (1) "The strrchr() function shall locate the last occurrence of 'c' ('srch_char')
   1487          *                            ... in the string pointed to by 's' ('pstr')."
   1488          *                       (2) "The terminating null byte is considered to be part of the string."
   1489          *
   1490          *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strrchr() : RETURN VALUE' states that
   1491          *                       "upon successful completion, strrchr() shall return" :
   1492          *
   1493          *                       (1) "a pointer to the byte" ...
   1494          *                       (2) "or a null pointer if 'c' ('srch_char') does not occur in the string."
   1495          *                           (A) #### Although NO strrchr() specification states to return NULL for
   1496          *                               any other reason(s), NULL is also returned for any error(s).
   1497          *
   1498          *                   (c) Ideally, the 'len_max' argument would be the last argument in this function's
   1499          *                       argument list for consistency with all other custom string library functions.
   1500          *                       However, the 'len_max' argument is sequentially ordered as the second argument
   1501          *                       to comply with most standard library's strnrchr() argument list.
   1502          *
   1503          *                       See also 'Str_Char_N()  Note #2c'.
   1504          *
   1505          *               (3) String search terminates when :
   1506          *
   1507          *                   (a) String pointer passed a NULL pointer.
   1508          *                       (1) No string search performed; NULL pointer returned.
   1509          *
   1510          *                   (b) String pointer points to NULL.
   1511          *                       (1) String overlaps with NULL address; NULL pointer returned.
   1512          *
   1513          *                   (c) String searched from end to beginning.
   1514          *                       (1) Search character NOT found in search string; NULL pointer returned
   1515          *                           (see Note #2b2).
   1516          *                       (2) Applicable even if search character is the terminating NULL character
   1517          *                           (see Note #2a2).
   1518          *
   1519          *                   (d) Search character found.
   1520          *                       (1) Return pointer to last occurrence of search character in search string
   1521          *                           (see Note #2a1).
   1522          *
   1523          *                   (e) 'len_max' number of characters searched.
   1524          *                       (1) Search character NOT found in search string within last 'len_max' number
   1525          *                           of characters; NULL pointer returned.
   1526          *                       (2) 'len_max' number of characters MAY include terminating NULL character
   1527          *                           (see Note #2a2).
   1528          *********************************************************************************************************
   1529          */
   1530          

   \                                 In section .text, align 2, keep-with-next
   1531          CPU_CHAR  *Str_Char_Last_N (const  CPU_CHAR    *pstr,
   1532                                             CPU_SIZE_T   len_max,
   1533                                             CPU_CHAR     srch_char)
   1534          {
   \                     Str_Char_Last_N: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0015             MOVS     R5,R2
   1535              const  CPU_CHAR    *pstr_char;
   1536                     CPU_SIZE_T   str_len_max;
   1537                     CPU_SIZE_T   str_len;
   1538          
   1539          
   1540              if (pstr == (const CPU_CHAR *)0) {                          /* Rtn NULL if srch str ptr NULL (see Note #3a1).       */
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD101             BNE.N    ??Str_Char_Last_N_0
   1541                  return ((CPU_CHAR *)0);
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xE01B             B.N      ??Str_Char_Last_N_1
   1542              }
   1543          
   1544              if (len_max < 1) {                                          /* Rtn NULL if srch len = 0      (see Note #3e1).       */
   \                     ??Str_Char_Last_N_0: (+1)
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD101             BNE.N    ??Str_Char_Last_N_2
   1545                  return ((CPU_CHAR *)0);
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xE017             B.N      ??Str_Char_Last_N_1
   1546              }
   1547          
   1548          
   1549              pstr_char    = pstr;
   \                     ??Str_Char_Last_N_2: (+1)
   \   00000016   0x0026             MOVS     R6,R4
   1550               str_len_max = len_max - sizeof("");                        /* Str len adj'd for NULL char len.                     */
   \   00000018   0x1E49             SUBS     R1,R1,#+1
   1551               str_len     = Str_Len_N(pstr_char, str_len_max);
   \   0000001A   0x0030             MOVS     R0,R6
   \   0000001C   0x.... 0x....      BL       Str_Len_N
   1552              pstr_char   += str_len;
   \   00000020   0x1986             ADDS     R6,R0,R6
   1553          
   1554              if (pstr_char == (const CPU_CHAR *)0) {                     /* Rtn NULL if NULL ptr found        (see Note #3b1).   */
   \   00000022   0x2E00             CMP      R6,#+0
   \   00000024   0xD102             BNE.N    ??Str_Char_Last_N_3
   1555                  return ((CPU_CHAR *)0);
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE00D             B.N      ??Str_Char_Last_N_1
   1556              }
   1557          
   1558              while (( pstr_char != pstr) &&                              /* Srch str from end until beginning (see Note #3c) ... */
   1559                     (*pstr_char != srch_char)) {                         /* ... until srch char found         (see Note #3d).    */
   1560                  pstr_char--;
   \                     ??Str_Char_Last_N_4: (+1)
   \   0000002A   0x1E76             SUBS     R6,R6,#+1
   1561              }
   \                     ??Str_Char_Last_N_3: (+1)
   \   0000002C   0x42A6             CMP      R6,R4
   \   0000002E   0xD003             BEQ.N    ??Str_Char_Last_N_5
   \   00000030   0x7830             LDRB     R0,[R6, #+0]
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x42A8             CMP      R0,R5
   \   00000036   0xD1F8             BNE.N    ??Str_Char_Last_N_4
   1562          
   1563          
   1564              if (*pstr_char != srch_char) {                              /* Rtn NULL if srch char NOT found   (see Note #3c1).   */
   \                     ??Str_Char_Last_N_5: (+1)
   \   00000038   0x7830             LDRB     R0,[R6, #+0]
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x42A8             CMP      R0,R5
   \   0000003E   0xD001             BEQ.N    ??Str_Char_Last_N_6
   1565                   return ((CPU_CHAR *)0);
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xE000             B.N      ??Str_Char_Last_N_1
   1566              }
   1567          
   1568          
   1569              return ((CPU_CHAR *)pstr_char);                             /* Else rtn ptr to found srch char   (see Note #3d1).   */
   \                     ??Str_Char_Last_N_6: (+1)
   \   00000044   0x0030             MOVS     R0,R6
   \                     ??Str_Char_Last_N_1: (+1)
   \   00000046   0xBD70             POP      {R4-R6,PC}       ;; return
   1570          }
   1571          
   1572          
   1573          /*
   1574          *********************************************************************************************************
   1575          *                                         Str_Char_Replace()
   1576          *
   1577          * Description : Search string for specific character and replace it by another specific character.
   1578          *
   1579          * Argument(s) : pstr            Pointer to string (see Note #1).
   1580          *
   1581          *               char_srch       Search character.
   1582          *
   1583          *               char_replace    Replace character.
   1584          *
   1585          * Return(s)   : Pointer to string, if NO error(s).
   1586          *
   1587          *               Pointer to NULL,   otherwise.
   1588          *
   1589          * Caller(s)   : Application.
   1590          *
   1591          * Note(s)     : (1) String buffer modified.
   1592          *
   1593          *               (2) String search terminates when :
   1594          *
   1595          *                   (a) String pointer passed a NULL pointer.
   1596          *                       (1) No string search performed; NULL pointer returned.
   1597          *
   1598          *                   (b) String pointer points to NULL.
   1599          *                       (1) String overlaps with NULL address; NULL pointer returned.
   1600          *
   1601          *                   (c) String's terminating NULL character found.
   1602          *                       (1) Search character NOT found in search string; NULL pointer returned
   1603          *                       (2) Applicable even if search character is the terminating NULL character
   1604          *
   1605          *                   (d) Search character found.
   1606          *                       (1) Replace character found by the specified character.
   1607          *********************************************************************************************************
   1608          */
   1609          

   \                                 In section .text, align 2, keep-with-next
   1610          CPU_CHAR  *Str_Char_Replace (CPU_CHAR  *pstr,
   1611                                       CPU_CHAR   char_srch,
   1612                                       CPU_CHAR   char_replace)
   1613          {
   \                     Str_Char_Replace: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1614              CPU_CHAR  *pstr_rtn;
   1615          
   1616          
   1617              pstr_rtn = Str_Char_Replace_N(pstr,
   1618                                            char_srch,
   1619                                            char_replace,
   1620                                            DEF_INT_CPU_U_MAX_VAL);
   \   00000002   0xF05F 0x33FF      MOVS     R3,#-1
   \   00000006   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x.... 0x....      BL       Str_Char_Replace_N
   1621          
   1622              return (pstr_rtn);
   \   0000000E   0xBD02             POP      {R1,PC}          ;; return
   1623          }
   1624          
   1625          
   1626          /*
   1627          *********************************************************************************************************
   1628          *                                        Str_Char_Replace_N()
   1629          *
   1630          * Description : Search string for specific character and replace it by another specific character, up to
   1631          *               a maximum number of characters.
   1632          *
   1633          * Argument(s) : pstr            Pointer to string (see Note #1).
   1634          *
   1635          *               char_srch       Search character.
   1636          *
   1637          *               char_replace    Replace character.
   1638          *
   1639          *               len_max         Maximum number of characters to search (see Notes #2c & #3e).
   1640          *
   1641          * Return(s)   : Pointer to string, if NO error(s).
   1642          *
   1643          *               Pointer to NULL,   otherwise.
   1644          *
   1645          * Caller(s)   : Application.
   1646          *
   1647          * Note(s)     : (1) String buffer modified.
   1648          *
   1649          *               (2) String search terminates when :
   1650          *
   1651          *                   (a) String pointer passed a NULL pointer.
   1652          *                       (1) No string search performed; NULL pointer returned.
   1653          *
   1654          *                   (b) String pointer points to NULL.
   1655          *                       (1) String overlaps with NULL address; NULL pointer returned.
   1656          *
   1657          *                   (c) String's terminating NULL character found.
   1658          *                       (1) Search character NOT found in search string; NULL pointer returned
   1659          *                       (2) Applicable even if search character is the terminating NULL character
   1660          *
   1661          *                   (d) Search character found.
   1662          *                       (1) Replace character found by the specified character.
   1663          *
   1664          *                   (e) 'len_max' number of characters searched.
   1665          *                       (1) Search character NOT found in search string within first 'len_max' number
   1666          *                           of characters; NULL pointer returned.
   1667          *                       (2) 'len_max' number of characters MAY include terminating NULL character
   1668          *                           (see Note #2a2).
   1669          *********************************************************************************************************
   1670          */
   1671          

   \                                 In section .text, align 2, keep-with-next
   1672          CPU_CHAR  *Str_Char_Replace_N (CPU_CHAR    *pstr,
   1673                                         CPU_CHAR     char_srch,
   1674                                         CPU_CHAR     char_replace,
   1675                                         CPU_SIZE_T   len_max)
   1676          {
   \                     Str_Char_Replace_N: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   1677              CPU_CHAR    *pstr_char;
   1678              CPU_SIZE_T   len;
   1679          
   1680          
   1681              if (pstr == (const CPU_CHAR *)0) {                          /* Rtn NULL if srch str ptr NULL (see Note #2a1).       */
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD101             BNE.N    ??Str_Char_Replace_N_0
   1682                  return ((CPU_CHAR *)0);
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xE013             B.N      ??Str_Char_Replace_N_1
   1683              }
   1684          
   1685              if (len_max < 1) {                                          /* Rtn NULL if srch len = 0      (see Note #2e1).       */
   \                     ??Str_Char_Replace_N_0: (+1)
   \   0000000A   0x2B00             CMP      R3,#+0
   \   0000000C   0xD101             BNE.N    ??Str_Char_Replace_N_2
   1686                  return ((CPU_CHAR *)0);
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xE00F             B.N      ??Str_Char_Replace_N_1
   1687              }
   1688          
   1689              pstr_char = pstr;
   \                     ??Str_Char_Replace_N_2: (+1)
   \   00000012   0x0004             MOVS     R4,R0
   1690              len       = len_max;
   \   00000014   0xE006             B.N      ??Str_Char_Replace_N_3
   1691          
   1692              while (( pstr_char != (const CPU_CHAR *)0) &&               /* Srch str until NULL ptr     [see Note #2b]  ...      */
   1693                     (*pstr_char !=  ASCII_CHAR_NULL   ) &&               /* ... or NULL char            (see Note #2c)  ...      */
   1694                     ( len        >                   0)) {               /* ... or max nbr chars srch'd (see Note #2e).          */
   1695          
   1696                  if (*pstr_char == char_srch) {
   \                     ??Str_Char_Replace_N_4: (+1)
   \   00000016   0x7825             LDRB     R5,[R4, #+0]
   \   00000018   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001A   0x428D             CMP      R5,R1
   \   0000001C   0xD100             BNE.N    ??Str_Char_Replace_N_5
   1697                      *pstr_char  = char_replace;                         /* Replace char if srch char is found.                  */
   \   0000001E   0x7022             STRB     R2,[R4, #+0]
   1698                  }
   1699          
   1700                  pstr_char++;
   \                     ??Str_Char_Replace_N_5: (+1)
   \   00000020   0x1C64             ADDS     R4,R4,#+1
   1701                  len--;
   \   00000022   0x1E5B             SUBS     R3,R3,#+1
   1702              }
   \                     ??Str_Char_Replace_N_3: (+1)
   \   00000024   0x2C00             CMP      R4,#+0
   \   00000026   0xD004             BEQ.N    ??Str_Char_Replace_N_6
   \   00000028   0x7825             LDRB     R5,[R4, #+0]
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD001             BEQ.N    ??Str_Char_Replace_N_6
   \   0000002E   0x2B00             CMP      R3,#+0
   \   00000030   0xD1F1             BNE.N    ??Str_Char_Replace_N_4
   1703          
   1704              return (pstr);
   \                     ??Str_Char_Replace_N_6: (+1)
   \                     ??Str_Char_Replace_N_1: (+1)
   \   00000032   0xBC30             POP      {R4,R5}
   \   00000034   0x4770             BX       LR               ;; return
   1705          }
   1706          
   1707          
   1708          /*
   1709          *********************************************************************************************************
   1710          *                                              Str_Str()
   1711          *
   1712          * Description : Search string for first occurence of a specific search string.
   1713          *
   1714          * Argument(s) : pstr            Pointer to        string (see Note #1).
   1715          *
   1716          *               pstr_srch       Pointer to search string (see Note #1).
   1717          *
   1718          * Return(s)   : Pointer to first occurrence of search string in string, if any                (see Note #2b1A).
   1719          *
   1720          *               Pointer to string,                                      if NULL search string (see Note #2b2).
   1721          *
   1722          *               Pointer to NULL,                                        otherwise             (see Note #2b1B).
   1723          *
   1724          * Caller(s)   : Application.
   1725          *
   1726          * Note(s)     : (1) String buffers NOT modified.
   1727          *
   1728          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strstr() : DESCRIPTION' states that :
   1729          *
   1730          *                       (1) "The strstr() function shall locate the first occurrence  in the string
   1731          *                            pointed to by 's1' ('pstr') of the sequence of bytes ... in the string
   1732          *                            pointed to by 's2' ('pstr_srch')" ...
   1733          *                       (2) "(excluding the terminating null byte)."
   1734          *
   1735          *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strstr() : RETURN VALUE' states that :
   1736          *
   1737          *                       (1) "Upon successful completion, strstr() shall return" :
   1738          *                           (A) "a pointer to the located string" ...
   1739          *                           (B) "or a null pointer if the string is not found."
   1740          *                               (1) #### Although NO strstr() specification states to return NULL for
   1741          *                                   any other reason(s), NULL is also returned for any error(s).
   1742          *
   1743          *                       (2) "If 's2' ('pstr_srch') points to a string with zero length, the function
   1744          *                            shall return 's1' ('pstr')."
   1745          *
   1746          *               (3) String search terminates when :
   1747          *
   1748          *                   (a) String pointer(s) are passed NULL pointers.
   1749          *                       (1) No string search performed; NULL pointer returned.
   1750          *
   1751          *                   (b) String pointer(s) point to NULL.
   1752          *                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
   1753          *
   1754          *                   (c) Search string length equal to zero.
   1755          *                       (1) No string search performed; string pointer returned (see Note #2b2).
   1756          *
   1757          *                   (d) Search string length greater than string length.
   1758          *                       (1) No string search performed; NULL   pointer returned (see Note #2b1B).
   1759          *
   1760          *                   (e) Entire string has been searched.
   1761          *                       (1) Search string not found; NULL pointer returned (see Note #2b1B).
   1762          *
   1763          *                   (f) Search string found.
   1764          *                       (1) Return pointer to first occurrence of search string in string (see Note #2b1A).
   1765          *********************************************************************************************************
   1766          */
   1767          

   \                                 In section .text, align 2, keep-with-next
   1768          CPU_CHAR  *Str_Str (const  CPU_CHAR  *pstr,
   1769                              const  CPU_CHAR  *pstr_srch)
   1770          {
   \                     Str_Str: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1771              CPU_CHAR  *pstr_rtn;
   1772          
   1773          
   1774              pstr_rtn = Str_Str_N(pstr,
   1775                                   pstr_srch,
   1776                                   DEF_INT_CPU_U_MAX_VAL);
   \   00000002   0xF05F 0x32FF      MOVS     R2,#-1
   \   00000006   0x.... 0x....      BL       Str_Str_N
   1777          
   1778              return (pstr_rtn);
   \   0000000A   0xBD02             POP      {R1,PC}          ;; return
   1779          }
   1780          
   1781          
   1782          /*
   1783          *********************************************************************************************************
   1784          *                                             Str_Str_N()
   1785          *
   1786          * Description : Search string for first occurence of a specific search string, up to a maximum number
   1787          *                   of characters.
   1788          *
   1789          * Argument(s) : pstr            Pointer to        string (see Note #1).
   1790          *
   1791          *               pstr_srch       Pointer to search string (see Note #1).
   1792          *
   1793          *               len_max         Maximum number of characters to search (see Note #3g).
   1794          *
   1795          * Return(s)   : Pointer to first occurrence of search string in string, if any                (see Note #2b1A).
   1796          *
   1797          *               Pointer to string,                                      if NULL search string (see Note #2b2).
   1798          *
   1799          *               Pointer to NULL,                                        otherwise             (see Note #2b1B).
   1800          *
   1801          * Caller(s)   : Application.
   1802          *
   1803          * Note(s)     : (1) String buffers NOT modified.
   1804          *
   1805          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strstr() : DESCRIPTION' states that :
   1806          *
   1807          *                       (1) "The strstr() function shall locate the first occurrence  in the string
   1808          *                            pointed to by 's1' ('pstr') of the sequence of bytes ... in the string
   1809          *                            pointed to by 's2' ('pstr_srch')" ...
   1810          *                       (2) "(excluding the terminating null byte)."
   1811          *
   1812          *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strstr() : RETURN VALUE' states that :
   1813          *
   1814          *                       (1) "Upon successful completion, strstr() shall return" :
   1815          *                           (A) "a pointer to the located string" ...
   1816          *                           (B) "or a null pointer if the string is not found."
   1817          *                               (1) #### Although NO strstr() specification states to return NULL for
   1818          *                                   any other reason(s), NULL is also returned for any error(s).
   1819          *
   1820          *                       (2) "If 's2' ('pstr_srch') points to a string with zero length, the function
   1821          *                            shall return 's1' ('pstr')."
   1822          *
   1823          *               (3) String search terminates when :
   1824          *
   1825          *                   (a) String pointer(s) are passed NULL pointers.
   1826          *                       (1) No string search performed; NULL pointer returned.
   1827          *
   1828          *                   (b) String pointer(s) point to NULL.
   1829          *                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
   1830          *
   1831          *                   (c) Search string length equal to zero.
   1832          *                       (1) No string search performed; string pointer returned (see Note #2b2).
   1833          *
   1834          *                   (d) Search string length greater than string length.
   1835          *                       (1) No string search performed; NULL   pointer returned (see Note #2b1B).
   1836          *
   1837          *                   (e) Entire string has been searched.
   1838          *                       (1) Search string not found; NULL pointer returned (see Note #2b1B).
   1839          *                       (2) Maximum size of the search is defined as the subtraction of the
   1840          *                           search string length from the string length.
   1841          *
   1842          *                   (f) Search string found.
   1843          *                       (1) Return pointer to first occurrence of search string in string (see Note #2b1A).
   1844          *                       (2) Search string found via Str_Cmp_N().
   1845          *
   1846          *                   (g) 'len_max' number of characters searched.
   1847          *                       (1) 'len_max' number of characters does NOT include terminating NULL character
   1848          *                           (see Note #2a2).
   1849          *********************************************************************************************************
   1850          */
   1851          

   \                                 In section .text, align 2, keep-with-next
   1852          CPU_CHAR  *Str_Str_N (const  CPU_CHAR    *pstr,
   1853                                const  CPU_CHAR    *pstr_srch,
   1854                                       CPU_SIZE_T   len_max)
   1855          {
   \                     Str_Str_N: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0011             MOVS     R1,R2
   1856                     CPU_SIZE_T    str_len;
   1857                     CPU_SIZE_T    str_len_srch;
   1858                     CPU_SIZE_T    len_max_srch;
   1859                     CPU_SIZE_T    srch_len;
   1860                     CPU_SIZE_T    srch_ix;
   1861                     CPU_BOOLEAN   srch_done;
   1862                     CPU_INT16S    srch_cmp;
   1863              const  CPU_CHAR     *pstr_str;
   1864              const  CPU_CHAR     *pstr_srch_ix;
   1865          
   1866                                                                          /* Rtn NULL if str ptr(s) NULL (see Note #3a).          */
   1867              if (pstr == (const CPU_CHAR *)0) {
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD101             BNE.N    ??Str_Str_N_0
   1868                  return ((CPU_CHAR *)0);
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xE046             B.N      ??Str_Str_N_1
   1869              }
   1870              if (pstr_srch == (const CPU_CHAR *)0) {
   \                     ??Str_Str_N_0: (+1)
   \   00000012   0x2D00             CMP      R5,#+0
   \   00000014   0xD101             BNE.N    ??Str_Str_N_2
   1871                  return ((CPU_CHAR *)0);
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE042             B.N      ??Str_Str_N_1
   1872              }
   1873          
   1874              if (len_max < 1) {                                          /* Rtn NULL if srch len = 0    (see Note #3g).          */
   \                     ??Str_Str_N_2: (+1)
   \   0000001A   0x2900             CMP      R1,#+0
   \   0000001C   0xD101             BNE.N    ??Str_Str_N_3
   1875                  return ((CPU_CHAR *)0);
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xE03E             B.N      ??Str_Str_N_1
   1876              }
   1877          
   1878                                                                          /* Lim max srch str len (to chk > str len).             */
   1879              len_max_srch = (len_max <       DEF_INT_CPU_U_MAX_VAL)
   1880                           ? (len_max + 1u) : DEF_INT_CPU_U_MAX_VAL;
   \                     ??Str_Str_N_3: (+1)
   \   00000022   0xF111 0x0F01      CMN      R1,#+1
   \   00000026   0xD001             BEQ.N    ??Str_Str_N_4
   \   00000028   0x1C4E             ADDS     R6,R1,#+1
   \   0000002A   0xE001             B.N      ??Str_Str_N_5
   \                     ??Str_Str_N_4: (+1)
   \   0000002C   0xF05F 0x36FF      MOVS     R6,#-1
   1881          
   1882              str_len      = Str_Len_N(pstr,      len_max);
   \                     ??Str_Str_N_5: (+1)
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       Str_Len_N
   \   00000036   0x0007             MOVS     R7,R0
   1883              str_len_srch = Str_Len_N(pstr_srch, len_max_srch);
   \   00000038   0x0031             MOVS     R1,R6
   \   0000003A   0x0028             MOVS     R0,R5
   \   0000003C   0x.... 0x....      BL       Str_Len_N
   \   00000040   0x0006             MOVS     R6,R0
   1884              if (str_len_srch < 1) {                                     /* Rtn ptr to str if srch str len = 0 (see Note #2b2).  */
   \   00000042   0x2E00             CMP      R6,#+0
   \   00000044   0xD101             BNE.N    ??Str_Str_N_6
   1885                  return ((CPU_CHAR *)pstr);
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0xE02A             B.N      ??Str_Str_N_1
   1886              }
   1887              if (str_len_srch > str_len) {                               /* Rtn NULL if srch str len > str len (see Note #3d).   */
   \                     ??Str_Str_N_6: (+1)
   \   0000004A   0x42B7             CMP      R7,R6
   \   0000004C   0xD201             BCS.N    ??Str_Str_N_7
   1888                  return ((CPU_CHAR *)0);
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xE026             B.N      ??Str_Str_N_1
   1889              }
   1890          
   1891                                                                          /* Rtn NULL if NULL ptr found         (see Note #3b1).  */
   1892              pstr_str = pstr      + str_len;
   \                     ??Str_Str_N_7: (+1)
   \   00000052   0x1938             ADDS     R0,R7,R4
   1893              if (pstr_str == (const CPU_CHAR *)0) {
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD101             BNE.N    ??Str_Str_N_8
   1894                  return ((CPU_CHAR *)0);
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xE021             B.N      ??Str_Str_N_1
   1895              }
   1896              pstr_str = pstr_srch + str_len_srch;
   \                     ??Str_Str_N_8: (+1)
   \   0000005C   0x1970             ADDS     R0,R6,R5
   1897              if (pstr_str == (const CPU_CHAR *)0) {
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD101             BNE.N    ??Str_Str_N_9
   1898                  return ((CPU_CHAR *)0);
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0xE01C             B.N      ??Str_Str_N_1
   1899              }
   1900          
   1901              srch_len  = str_len - str_len_srch;                         /* Calc srch len (see Note #3e2).                       */
   \                     ??Str_Str_N_9: (+1)
   \   00000066   0x1BBF             SUBS     R7,R7,R6
   1902              srch_ix   = 0u;
   \   00000068   0xF05F 0x0800      MOVS     R8,#+0
   1903          
   1904              do {
   1905                  pstr_srch_ix = (const CPU_CHAR *)(pstr + srch_ix);
   \                     ??Str_Str_N_10: (+1)
   \   0000006C   0xEB18 0x0904      ADDS     R9,R8,R4
   1906                  srch_cmp     =  Str_Cmp_N(pstr_srch_ix, pstr_srch, str_len_srch);
   \   00000070   0x0032             MOVS     R2,R6
   \   00000072   0x0029             MOVS     R1,R5
   \   00000074   0x4648             MOV      R0,R9
   \   00000076   0x.... 0x....      BL       Str_Cmp_N
   1907                  srch_done    = (srch_cmp == 0) ? DEF_YES : DEF_NO;
   \   0000007A   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD101             BNE.N    ??Str_Str_N_11
   \   00000080   0x2101             MOVS     R1,#+1
   \   00000082   0xE000             B.N      ??Str_Str_N_12
   \                     ??Str_Str_N_11: (+1)
   \   00000084   0x2100             MOVS     R1,#+0
   1908                  srch_ix++;
   \                     ??Str_Str_N_12: (+1)
   \   00000086   0xF118 0x0801      ADDS     R8,R8,#+1
   1909              } while ((srch_done == DEF_NO) && (srch_ix <= srch_len));
   \   0000008A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000008C   0x2900             CMP      R1,#+0
   \   0000008E   0xD101             BNE.N    ??Str_Str_N_13
   \   00000090   0x4547             CMP      R7,R8
   \   00000092   0xD2EB             BCS.N    ??Str_Str_N_10
   1910          
   1911          
   1912              if (srch_cmp != 0) {                                        /* Rtn NULL if srch str NOT found (see Note #3e2).      */
   \                     ??Str_Str_N_13: (+1)
   \   00000094   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD001             BEQ.N    ??Str_Str_N_14
   1913                  return ((CPU_CHAR *)0);
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0xE000             B.N      ??Str_Str_N_1
   1914              }
   1915          
   1916              return ((CPU_CHAR *)pstr_srch_ix);                          /* Else rtn ptr to found srch str (see Note #3f1).      */
   \                     ??Str_Str_N_14: (+1)
   \   0000009E   0x4648             MOV      R0,R9
   \                     ??Str_Str_N_1: (+1)
   \   000000A0   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1917          }
   1918          
   1919          
   1920          /*
   1921          *********************************************************************************************************
   1922          *                                         Str_FmtNbr_Int32U()
   1923          *
   1924          * Description : Format 32-bit unsigned integer into a multi-digit character string.
   1925          *
   1926          * Argument(s) : nbr             Number           to format.
   1927          *
   1928          *               nbr_dig         Number of digits to format (see Note #1).
   1929          *
   1930          *                               The following may be used to specify the number of digits to format :
   1931          *
   1932          *                                   DEF_INT_32U_NBR_DIG_MIN     Minimum number of 32-bit unsigned digits
   1933          *                                   DEF_INT_32U_NBR_DIG_MAX     Maximum number of 32-bit unsigned digits
   1934          *
   1935          *               nbr_base        Base   of number to format (see Note #2).
   1936          *
   1937          *                               The following may be used to specify the number base :
   1938          *
   1939          *                                   DEF_NBR_BASE_BIN            Base  2
   1940          *                                   DEF_NBR_BASE_OCT            Base  8
   1941          *                                   DEF_NBR_BASE_DEC            Base 10
   1942          *                                   DEF_NBR_BASE_HEX            Base 16
   1943          *
   1944          *               lead_char       Prepend leading character  (see Note #3) :
   1945          *
   1946          *                                   '\0'                    Do NOT prepend leading character to string.
   1947          *                                     Printable character          Prepend leading character to string.
   1948          *                                   Unprintable character   Format invalid string (see Note #6).
   1949          *
   1950          *               lower_case      Format alphabetic characters (if any) in lower case :
   1951          *
   1952          *                                   DEF_NO          Format alphabetic characters in upper case.
   1953          *                                   DEF_YES         Format alphabetic characters in lower case.
   1954          *
   1955          *               nul             Append terminating NULL-character (see Note #4) :
   1956          *
   1957          *                                   DEF_NO          Do NOT append terminating NULL-character to string.
   1958          *                                   DEF_YES                Append terminating NULL-character to string.
   1959          *
   1960          *               pstr            Pointer to character array to return formatted number string (see Note #5).
   1961          *
   1962          * Return(s)   : Pointer to formatted string, if NO error(s).
   1963          *
   1964          *               Pointer to NULL,             otherwise.
   1965          *
   1966          * Caller(s)   : Application.
   1967          *
   1968          * Note(s)     : (1) (a) If the number of digits to format ('nbr_dig') is zero; then NO formatting
   1969          *                       is performed except possible NULL-termination of the string (see Note #4).
   1970          *
   1971          *                           Example :
   1972          *
   1973          *                               nbr      = 23456
   1974          *                               nbr_dig  = 0
   1975          *                               nbr_base = 10
   1976          *
   1977          *                               pstr     = ""                   See Note #6a
   1978          *
   1979          *                   (b) If the number of digits to format ('nbr_dig') is less than the number of
   1980          *                       significant integer digits of the number to format ('nbr'); then an invalid
   1981          *                       string is formatted instead of truncating any significant integer digits.
   1982          *
   1983          *                           Example :
   1984          *
   1985          *                               nbr      = 23456
   1986          *                               nbr_dig  = 3
   1987          *                               nbr_base = 10
   1988          *
   1989          *                               pstr     = "???"                See Note #6b
   1990          *
   1991          *               (2) The number's base MUST be between 2 & 36, inclusive.
   1992          *
   1993          *               (3) Leading character option prepends leading characters prior to the first non-zero digit.
   1994          *
   1995          *                   (a) (1) Leading character MUST be a printable ASCII character.
   1996          *
   1997          *                       (2) (A) Leading character MUST NOT be a number base digit, ...
   1998          *                           (B) with the exception of '0'.
   1999          *
   2000          *                   (b) The number of leading characters is such that the total number of significant
   2001          *                       integer digits plus the number of leading characters is equal to the requested
   2002          *                       number of integer digits to format ('nbr_dig').
   2003          *
   2004          *                           Example :
   2005          *
   2006          *                               nbr       = 23456
   2007          *                               nbr_dig   = 7
   2008          *                               nbr_base  = 10
   2009          *                               lead_char = ' '
   2010          *
   2011          *                               pstr      = "  23456"
   2012          *
   2013          *                   (c) (1) If the value of the number to format is     zero  ...
   2014          *                       (2) ... & the number of digits to format is non-zero, ...
   2015          *                       (3) ... but NO leading character available;           ...
   2016          *                       (4) ... then one digit of '0' value is formatted.
   2017          *
   2018          *                           This is NOT a leading character; but a single integer digit of '0' value.
   2019          *
   2020          *               (4) (a) NULL-character terminate option DISABLED prevents overwriting previous character
   2021          *                       array formatting.
   2022          *
   2023          *                   (b) WARNING: Unless 'pstr' character array is pre-/post-terminated, NULL-character
   2024          *                       terminate option DISABLED will cause character string run-on.
   2025          *
   2026          *               (5) (a) Format buffer size NOT validated; buffer overruns MUST be prevented by caller.
   2027          *
   2028          *                   (b) To prevent character buffer overrun :
   2029          *
   2030          *                           Character array size MUST be  >=  ('nbr_dig'          +
   2031          *                                                               1 'NUL' terminator)  characters
   2032          *
   2033          *               (6) For any unsuccessful string format or error(s), an invalid string of question marks
   2034          *                   ('?') will be formatted, where the number of question marks is determined by the
   2035          *                   number of digits to format ('nbr_dig') :
   2036          *
   2037          *                      Invalid string's     {  (a)   0 (NULL string)  ,  if 'nbr_dig' = 0
   2038          *                          number of     =  {
   2039          *                       question marks      {  (b)  'nbr_dig'         ,  if 'nbr_dig' > 0
   2040          *
   2041          *********************************************************************************************************
   2042          */
   2043          

   \                                 In section .text, align 2, keep-with-next
   2044          CPU_CHAR  *Str_FmtNbr_Int32U (CPU_INT32U    nbr,
   2045                                        CPU_INT08U    nbr_dig,
   2046                                        CPU_INT08U    nbr_base,
   2047                                        CPU_CHAR      lead_char,
   2048                                        CPU_BOOLEAN   lower_case,
   2049                                        CPU_BOOLEAN   nul,
   2050                                        CPU_CHAR     *pstr)
   2051          {
   \                     Str_FmtNbr_Int32U: (+1)
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
   2052              CPU_CHAR  *pstr_fmt;
   2053          
   2054          
   2055              pstr_fmt = Str_FmtNbr_Int32(nbr,                            /* Fmt unsigned int into str.                           */
   2056                                          nbr_dig,
   2057                                          nbr_base,
   2058                                          DEF_NO,
   2059                                          lead_char,
   2060                                          lower_case,
   2061                                          nul,
   2062                                          pstr);
   \   00000002   0x9C08             LDR      R4,[SP, #+32]
   \   00000004   0x9403             STR      R4,[SP, #+12]
   \   00000006   0x9C07             LDR      R4,[SP, #+28]
   \   00000008   0x9402             STR      R4,[SP, #+8]
   \   0000000A   0x9C06             LDR      R4,[SP, #+24]
   \   0000000C   0x9401             STR      R4,[SP, #+4]
   \   0000000E   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000010   0x9300             STR      R3,[SP, #+0]
   \   00000012   0x2300             MOVS     R3,#+0
   \   00000014   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000016   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000018   0x.... 0x....      BL       Str_FmtNbr_Int32
   2063          
   2064              return (pstr_fmt);
   \   0000001C   0xB004             ADD      SP,SP,#+16
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
   2065          }
   2066          
   2067          
   2068          /*
   2069          *********************************************************************************************************
   2070          *                                         Str_FmtNbr_Int32S()
   2071          *
   2072          * Description : Format 32-bit signed integer into a multi-digit character string.
   2073          *
   2074          * Argument(s) : nbr             Number           to format.
   2075          *
   2076          *               nbr_dig         Number of digits to format (see Note #1).
   2077          *
   2078          *                               The following may be used to specify the number of digits to format :
   2079          *
   2080          *                                   DEF_INT_32S_NBR_DIG_MIN + 1     Minimum number of 32-bit signed digits
   2081          *                                   DEF_INT_32S_NBR_DIG_MAX + 1     Maximum number of 32-bit signed digits
   2082          *                                                                   (plus 1 digit for possible negative sign)
   2083          *
   2084          *               nbr_base        Base   of number to format (see Note #2).
   2085          *
   2086          *                               The following may be used to specify the number base :
   2087          *
   2088          *                                   DEF_NBR_BASE_BIN            Base  2
   2089          *                                   DEF_NBR_BASE_OCT            Base  8
   2090          *                                   DEF_NBR_BASE_DEC            Base 10
   2091          *                                   DEF_NBR_BASE_HEX            Base 16
   2092          *
   2093          *               lead_char       Prepend leading character  (see Note #3) :
   2094          *
   2095          *                                   '\0'                    Do NOT prepend leading character to string.
   2096          *                                     Printable character          Prepend leading character to string.
   2097          *                                   Unprintable character   Format invalid string (see Note #6).
   2098          *
   2099          *               lower_case      Format alphabetic characters (if any) in lower case :
   2100          *
   2101          *                                   DEF_NO          Format alphabetic characters in upper case.
   2102          *                                   DEF_YES         Format alphabetic characters in lower case.
   2103          *
   2104          *               nul             Append terminating NULL-character (see Note #4) :
   2105          *
   2106          *                                   DEF_NO          Do NOT append terminating NULL-character to string.
   2107          *                                   DEF_YES                Append terminating NULL-character to string.
   2108          *
   2109          *               pstr            Pointer to character array to return formatted number string (see Note #5).
   2110          *
   2111          * Return(s)   : Pointer to formatted string, if NO error(s).
   2112          *
   2113          *               Pointer to NULL,             otherwise.
   2114          *
   2115          * Caller(s)   : Application.
   2116          *
   2117          * Note(s)     : (1) (a) If the number of digits to format ('nbr_dig') is zero; then NO formatting
   2118          *                       is performed except possible NULL-termination of the string (see Note #4).
   2119          *
   2120          *                           Example :
   2121          *
   2122          *                               nbr      = -23456
   2123          *                               nbr_dig  =  0
   2124          *                               nbr_base = 10
   2125          *
   2126          *                               pstr     = ""                   See Note #6a
   2127          *
   2128          *                   (b) If the number of digits to format ('nbr_dig') is less than the number of
   2129          *                       significant integer digits of the number to format ('nbr'); then an invalid
   2130          *                       string is formatted instead of truncating any significant integer digits.
   2131          *
   2132          *                           Example :
   2133          *
   2134          *                               nbr      = 23456
   2135          *                               nbr_dig  = 3
   2136          *                               nbr_base = 10
   2137          *
   2138          *                               pstr     = "???"                See Note #6b
   2139          *
   2140          *                   (c) If the number to format ('nbr') is negative but the number of digits to format
   2141          *                       ('nbr_dig') is equal to the number of significant integer digits of the number
   2142          *                       to format ('nbr'); then an invalid string is formatted instead of truncating
   2143          *                       the negative sign.
   2144          *
   2145          *                           Example :
   2146          *
   2147          *                               nbr      = -23456
   2148          *                               nbr_dig  =  5
   2149          *                               nbr_base = 10
   2150          *
   2151          *                               pstr     = "?????"              See Note #6b
   2152          *
   2153          *               (2) The number's base MUST be between 2 & 36, inclusive.
   2154          *
   2155          *               (3) Leading character option prepends leading characters prior to the first non-zero digit.
   2156          *
   2157          *                   (a) (1) Leading character MUST be a printable ASCII character.
   2158          *
   2159          *                       (2) (A) Leading character MUST NOT be a number base digit, ...
   2160          *                           (B) with the exception of '0'.
   2161          *
   2162          *                   (b) (1) The number of leading characters is such that the total number of significant
   2163          *                           integer digits plus the number of leading characters plus possible negative
   2164          *                           sign character is equal to the requested number of integer digits to format
   2165          *                           ('nbr_dig').
   2166          *
   2167          *                               Examples :
   2168          *
   2169          *                                   nbr       = 23456
   2170          *                                   nbr_dig   = 7
   2171          *                                   nbr_base  = 10
   2172          *                                   lead_char = ' '
   2173          *
   2174          *                                   pstr      = "  23456"
   2175          *
   2176          *
   2177          *                                   nbr       = -23456
   2178          *                                   nbr_dig   =  7
   2179          *                                   nbr_base  = 10
   2180          *                                   lead_char = ' '
   2181          *
   2182          *                                   pstr      = " -23456"
   2183          *
   2184          *                       (2) (A) If the number to format ('nbr') is negative AND the leading character
   2185          *                               ('lead_char') is     a '0' digit; then the negative sign character
   2186          *                               prefixes all leading characters prior to the formatted number.
   2187          *
   2188          *                                   Examples :
   2189          *
   2190          *                                       nbr        = -23456
   2191          *                                       nbr_dig    =  8
   2192          *                                       nbr_base   = 10
   2193          *                                       lead_char  = '0'
   2194          *
   2195          *                                       pstr       = "-0023456"
   2196          *
   2197          *
   2198          *                                       nbr        = -43981
   2199          *                                       nbr_dig    =  8
   2200          *                                       nbr_base   = 16
   2201          *                                       lead_char  = '0'
   2202          *                                       lower_case = DEF_NO
   2203          *
   2204          *                                       pstr       = "-000ABCD"
   2205          *
   2206          *                           (B) If the number to format ('nbr') is negative AND the leading character
   2207          *                               ('lead_char') is NOT a '0' digit; then the negative sign character
   2208          *                               immediately prefixes the most significant digit of the formatted number.
   2209          *
   2210          *                                   Examples :
   2211          *
   2212          *                                       nbr        = -23456
   2213          *                                       nbr_dig    =  8
   2214          *                                       nbr_base   = 10
   2215          *                                       lead_char  = '#'
   2216          *
   2217          *                                       pstr       = "##-23456"
   2218          *
   2219          *
   2220          *                                       nbr        = -43981
   2221          *                                       nbr_dig    =  8
   2222          *                                       nbr_base   = 16
   2223          *                                       lead_char  = '#'
   2224          *                                       lower_case = DEF_YES
   2225          *
   2226          *                                       pstr       = "###-abcd"
   2227          *
   2228          *                   (c) (1) If the value of the number to format is     zero  ...
   2229          *                       (2) ... & the number of digits to format is non-zero, ...
   2230          *                       (3) ... but NO leading character available;           ...
   2231          *                       (4) ... then one digit of '0' value is formatted.
   2232          *
   2233          *                           This is NOT a leading character; but a single integer digit of '0' value.
   2234          *
   2235          *               (4) (a) NULL-character terminate option DISABLED prevents overwriting previous character
   2236          *                       array formatting.
   2237          *
   2238          *                   (b) WARNING: Unless 'pstr' character array is pre-/post-terminated, NULL-character
   2239          *                       terminate option DISABLED will cause character string run-on.
   2240          *
   2241          *               (5) (a) Format buffer size NOT validated; buffer overruns MUST be prevented by caller.
   2242          *
   2243          *                   (b) To prevent character buffer overrun :
   2244          *
   2245          *                           Character array size MUST be  >=  ('nbr_dig'          +
   2246          *                                                               1 negative sign   +
   2247          *                                                               1 'NUL' terminator)  characters
   2248          *
   2249          *               (6) For any unsuccessful string format or error(s), an invalid string of question marks
   2250          *                   ('?') will be formatted, where the number of question marks is determined by the
   2251          *                   number of digits to format ('nbr_dig') :
   2252          *
   2253          *                      Invalid string's     {  (a)   0 (NULL string)  ,  if 'nbr_dig' = 0
   2254          *                          number of     =  {
   2255          *                       question marks      {  (b)  'nbr_dig'         ,  if 'nbr_dig' > 0
   2256          *
   2257          *********************************************************************************************************
   2258          */
   2259          

   \                                 In section .text, align 2, keep-with-next
   2260          CPU_CHAR  *Str_FmtNbr_Int32S (CPU_INT32S    nbr,
   2261                                        CPU_INT08U    nbr_dig,
   2262                                        CPU_INT08U    nbr_base,
   2263                                        CPU_CHAR      lead_char,
   2264                                        CPU_BOOLEAN   lower_case,
   2265                                        CPU_BOOLEAN   nul,
   2266                                        CPU_CHAR     *pstr)
   2267          {
   \                     Str_FmtNbr_Int32S: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   2268              CPU_CHAR     *pstr_fmt;
   2269              CPU_INT32S    nbr_fmt;
   2270              CPU_BOOLEAN   nbr_neg;
   2271          
   2272          
   2273              if (nbr < 0) {                                              /* If nbr neg, ...                                      */
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD502             BPL.N    ??Str_FmtNbr_Int32S_0
   2274                  nbr_fmt = -nbr;                                         /* ... negate nbr.                                      */
   \   00000008   0x4240             RSBS     R0,R0,#+0
   2275                  nbr_neg =  DEF_YES;
   \   0000000A   0x2501             MOVS     R5,#+1
   \   0000000C   0xE000             B.N      ??Str_FmtNbr_Int32S_1
   2276              } else {
   2277                  nbr_fmt =  nbr;
   2278                  nbr_neg =  DEF_NO;
   \                     ??Str_FmtNbr_Int32S_0: (+1)
   \   0000000E   0x2500             MOVS     R5,#+0
   2279              }
   2280          
   2281              pstr_fmt = Str_FmtNbr_Int32((CPU_INT32U)nbr_fmt,            /* Fmt signed int into str.                             */
   2282                                                      nbr_dig,
   2283                                                      nbr_base,
   2284                                                      nbr_neg,
   2285                                                      lead_char,
   2286                                                      lower_case,
   2287                                                      nul,
   2288                                                      pstr);
   \                     ??Str_FmtNbr_Int32S_1: (+1)
   \   00000010   0x9C0A             LDR      R4,[SP, #+40]
   \   00000012   0x9403             STR      R4,[SP, #+12]
   \   00000014   0x9C09             LDR      R4,[SP, #+36]
   \   00000016   0x9402             STR      R4,[SP, #+8]
   \   00000018   0x9C08             LDR      R4,[SP, #+32]
   \   0000001A   0x9401             STR      R4,[SP, #+4]
   \   0000001C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000001E   0x9300             STR      R3,[SP, #+0]
   \   00000020   0x002B             MOVS     R3,R5
   \   00000022   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000024   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000026   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000028   0x.... 0x....      BL       Str_FmtNbr_Int32
   2289          
   2290              return (pstr_fmt);
   \   0000002C   0xB005             ADD      SP,SP,#+20
   \   0000002E   0xBD30             POP      {R4,R5,PC}       ;; return
   2291          }
   2292          
   2293          
   2294          /*
   2295          *********************************************************************************************************
   2296          *                                           Str_FmtNbr_32()
   2297          *
   2298          * Description : Format number into a multi-digit character string.
   2299          *
   2300          * Argument(s) : nbr             Number                         to format (see Note #1).
   2301          *
   2302          *               nbr_dig         Number of decimal       digits to format (see Note #2).
   2303          *
   2304          *               nbr_dp          Number of decimal point digits to format.
   2305          *
   2306          *               lead_char       Prepend leading character (see Note #3) :
   2307          *
   2308          *                                   '\0'                    Do NOT prepend leading character to string.
   2309          *                                     Printable character          Prepend leading character to string.
   2310          *                                   Unprintable character   Format invalid string (see Note #6d).
   2311          *
   2312          *               nul             Append terminating NULL-character (see Note #4) :
   2313          *
   2314          *                                   DEF_NO          Do NOT append terminating NULL-character to string.
   2315          *                                   DEF_YES                Append terminating NULL-character to string.
   2316          *
   2317          *               pstr            Pointer to character array to return formatted number string (see Note #5).
   2318          *
   2319          * Return(s)   : Pointer to formatted string, if NO error(s) [see Note #6c].
   2320          *
   2321          *               Pointer to NULL,             otherwise.
   2322          *
   2323          * Caller(s)   : Application.
   2324          *
   2325          * Note(s)     : (1) (a) The maximum accuracy for 32-bit floating-point numbers :
   2326          *
   2327          *
   2328          *                                 Maximum Accuracy            log [Internal-Base ^ (Number-Internal-Base-Digits)]
   2329          *                           32-bit Floating-point Number  =  -----------------------------------------------------
   2330          *                                                                             log [External-Base]
   2331          *
   2332          *                                                             log [2 ^ 24]
   2333          *                                                         =  --------------
   2334          *                                                               log [10]
   2335          *
   2336          *                                                         <  7.225  Base-10 Digits
   2337          *
   2338          *                               where
   2339          *                                       Internal-Base                   Internal number base of floating-
   2340          *                                                                           point numbers (i.e.  2)
   2341          *                                       External-Base                   External number base of floating-
   2342          *                                                                           point numbers (i.e. 10)
   2343          *                                       Number-Internal-Base-Digits     Number of internal number base
   2344          *                                                                           significant digits (i.e. 24)
   2345          *
   2346          *                   (b) Some CPUs' &/or compilers' floating-point implementations MAY further reduce the
   2347          *                       maximum accuracy.
   2348          *
   2349          *               (2) (a) If the total number of digits to format ('nbr_dig + nbr_dp') is zero; then NO
   2350          *                       formatting is performed except possible NULL-termination of the string (see Note #4).
   2351          *
   2352          *                           Example :
   2353          *
   2354          *                               nbr     = -23456.789
   2355          *                               nbr_dig =  0
   2356          *                               nbr_dp  =  0
   2357          *
   2358          *                               pstr    = ""                        See Note #7a
   2359          *
   2360          *                   (b) (1) If the number of digits to format ('nbr_dig') is less than the number of
   2361          *                           significant integer digits of the number to format ('nbr'); then an invalid
   2362          *                           string is formatted instead of truncating any significant integer digits.
   2363          *
   2364          *                               Example :
   2365          *
   2366          *                                   nbr     = 23456.789
   2367          *                                   nbr_dig = 3
   2368          *                                   nbr_dp  = 2
   2369          *
   2370          *                                   pstr    = "??????"              See Note #7d
   2371          *
   2372          *                       (2) If the number to format ('nbr') is negative but the number of digits to format
   2373          *                           ('nbr_dig') is equal to the number of significant integer digits of the number
   2374          *                           to format ('nbr'); then an invalid string is formatted instead of truncating
   2375          *                           the negative sign.
   2376          *
   2377          *                               Example :
   2378          *
   2379          *                                   nbr     = -23456.789
   2380          *                                   nbr_dig =  5
   2381          *                                   nbr_dp  =  2
   2382          *
   2383          *                                   pstr    = "????????"            See Note #7d
   2384          *
   2385          *                       (3) If the number to format ('nbr') is negative but the number of significant
   2386          *                           integer digits is zero, & the number of digits to format ('nbr_dig') is one
   2387          *                           but the number of decimal point digits to format ('nbr_dp') is zero; then
   2388          *                           an invalid string is formatted instead of truncating the negative sign.
   2389          *
   2390          *                               Example :
   2391          *
   2392          *                                   nbr     = -0.7895
   2393          *                                   nbr_dig =  1
   2394          *                                   nbr_dp  =  0
   2395          *
   2396          *                                   pstr    = "?"                   See Note #7d
   2397          *
   2398          *                       (4) (A) If the number to format ('nbr') is negative but the number of significant
   2399          *                               integer digits is zero, & the number of digits to format ('nbr_dig') is
   2400          *                               zero but the number of decimal point digits to format ('nbr_dp') is non-
   2401          *                               zero; then the negative sign immediately prefixes the decimal point --
   2402          *                               with NO decimal digits formatted, NOT even a single decimal digit of '0'.
   2403          *
   2404          *                                   Example :
   2405          *
   2406          *                                       nbr     = -0.7895
   2407          *                                       nbr_dig =  0
   2408          *                                       nbr_dp  =  2
   2409          *
   2410          *                                       pstr    = "-.78"
   2411          *
   2412          *                           (B) If the number to format ('nbr') is positive but the number of significant
   2413          *                               integer digits is zero, & the number of digits to format ('nbr_dig') is
   2414          *                               zero but the number of decimal point digits to format ('nbr_dp') is non-
   2415          *                               zero; then a single decimal digit of '0' prefixes the decimal point.
   2416          *
   2417          *                               This '0' digit is used whenever a negative sign is not formatted (see
   2418          *                               Note #2b4A) so that the formatted string's decimal point is not floating,
   2419          *                               but fixed in the string as the 2nd character.
   2420          *
   2421          *                                   Example :
   2422          *
   2423          *                                       nbr     =  0.7895
   2424          *                                       nbr_dig =  0
   2425          *                                       nbr_dp  =  2
   2426          *
   2427          *                                       pstr    = "0.78"
   2428          *
   2429          *                   (c) (1) If the total number of digits to format ('nbr_dig + nbr_dp') is greater than ... :
   2430          *
   2431          *                           (A) ... the maximum accuracy of the CPU's &/or compiler's 32-bit floating-point
   2432          *                               numbers, digits following all significantly-accurate digits of the number to
   2433          *                               format ('nbr') will be inaccurate; ...
   2434          *                           (B) ... the configured maximum accuracy ('LIB_STR_CFG_FP_MAX_NBR_DIG_SIG'), all
   2435          *                               digits or decimal places following all significantly-accurate digits of the
   2436          *                               number to format ('nbr') will be replaced & formatted with zeros ('0').
   2437          *
   2438          *                                   Example :
   2439          *
   2440          *                                       nbr                            = 123456789.012345
   2441          *                                       nbr_dig                        = 9
   2442          *                                       nbr_dp                         = 6
   2443          *                                       LIB_STR_CFG_FP_MAX_NBR_DIG_SIG = 7
   2444          *
   2445          *                                       pstr                           = "123456700.000000"
   2446          *
   2447          *                       (2) Therefore, one or more least-significant digit(s) of the number to format ('nbr')
   2448          *                           MAY be rounded & not necessarily truncated due to the inaccuracy of the CPU's
   2449          *                           &/or compiler's floating-point implementation.
   2450          *
   2451          *                       See also Note #1.
   2452          *
   2453          *               (3) Leading character option prepends leading characters prior to the first non-zero digit.
   2454          *
   2455          *                   (a) (1) Leading character MUST be a printable ASCII character.
   2456          *
   2457          *                       (2) (A) Leading character MUST NOT be a base-10 digit, ...
   2458          *                           (B) with the exception of '0'.
   2459          *
   2460          *                   (b) (1) The number of leading characters is such that the total number of significant
   2461          *                           integer digits plus the number of leading characters plus possible negative
   2462          *                           sign character is equal to the requested number of integer digits to format
   2463          *                           ('nbr_dig').
   2464          *
   2465          *                               Examples :
   2466          *
   2467          *                                   nbr       = 23456.789
   2468          *                                   nbr_dig   = 7
   2469          *                                   nbr_dp    = 2
   2470          *                                   lead_char = ' '
   2471          *
   2472          *                                   pstr      = "  23456.78"
   2473          *
   2474          *
   2475          *                                   nbr       = -23456.789
   2476          *                                   nbr_dig   =  7
   2477          *                                   nbr_dp    =  2
   2478          *                                   lead_char = ' '
   2479          *
   2480          *                                   pstr      = " -23456.78"
   2481          *
   2482          *                       (2) (A) If the number to format ('nbr') is negative AND the leading character
   2483          *                               ('lead_char') is     a '0' digit; then the negative sign character
   2484          *                               prefixes all leading characters prior to the formatted number.
   2485          *
   2486          *                                   Example :
   2487          *
   2488          *                                       nbr       = -23456.789
   2489          *                                       nbr_dig   =  8
   2490          *                                       nbr_dp    =  2
   2491          *                                       lead_char = '0'
   2492          *
   2493          *                                       pstr      = "-0023456.78"
   2494          *
   2495          *                           (B) If the number to format ('nbr') is negative AND the leading character
   2496          *                               ('lead_char') is NOT a '0' digit; then the negative sign character
   2497          *                               immediately prefixes the most significant digit of the formatted number.
   2498          *
   2499          *                                   Examples :
   2500          *
   2501          *                                       nbr       = -23456.789
   2502          *                                       nbr_dig   =  8
   2503          *                                       nbr_dp    =  2
   2504          *                                       lead_char = '#'
   2505          *
   2506          *                                       pstr      = "##-23456.78"
   2507          *
   2508          *                   (c) (1) If the integer value of the number to format is zero & ...
   2509          *                       (2) ... the number of digits to format is greater than one ...
   2510          *                       (3) ... OR  the number is NOT negative,                    ...
   2511          *                       (4) ... but NO leading character available;                ...
   2512          *                       (5) ... then one digit of '0' value is formatted.
   2513          *
   2514          *                           This is NOT a leading character; but a single integer digit of '0' value.
   2515          *
   2516          *                       See also Note #2b4B.
   2517          *
   2518          *               (4) (a) NULL-character terminate option DISABLED prevents overwriting previous character
   2519          *                       array formatting.
   2520          *
   2521          *                   (b) WARNING: Unless 'pstr' character array is pre-/post-terminated, NULL-character
   2522          *                       terminate option DISABLED will cause character string run-on.
   2523          *
   2524          *               (5) (a) Format buffer size NOT validated; buffer overruns MUST be prevented by caller.
   2525          *
   2526          *                   (b) To prevent character buffer overrun :
   2527          *
   2528          *                           Character array size MUST be  >=  ('nbr_dig'          +
   2529          *                                                              'nbr_dp'           +
   2530          *                                                               1 negative sign   +
   2531          *                                                               1 decimal point   +
   2532          *                                                               1 'NUL' terminator)  characters
   2533          *
   2534          *               (6) String format terminates when :
   2535          *
   2536          *                   (a) Format string pointer is passed a NULL pointer.
   2537          *                       (1) No      string formatted;                NULL pointer returned.
   2538          *
   2539          *                   (b) Total number of digits to format ('nbr_dig + nbr_dp') is zero.
   2540          *                       (1) NULL    string formatted (see Note #7a); NULL pointer returned.
   2541          *
   2542          *                   (c) Number of digits to format ('nbr_dig') is less than number of significant
   2543          *                           integer digits of the number to format ('nbr'), including possible
   2544          *                           negative sign.
   2545          *                       (1) Invalid string formatted (see Note #7);  NULL pointer returned.
   2546          *
   2547          *                   (d) Lead character is NOT a valid, printable character (see Note #3a).
   2548          *                       (1) Invalid string formatted (see Note #7);  NULL pointer returned.
   2549          *
   2550          *                   (e) Number successfully formatted into character string array.
   2551          *
   2552          *               (7) For any unsuccessful string format or error(s), an invalid string of question marks
   2553          *                   ('?') will be formatted, where the number of question marks is determined by the
   2554          *                   number of digits ('nbr_dig') & number of decimal point digits ('nbr_dp') to format :
   2555          *
   2556          *                                           {  (a)    0 (NULL string)          ,  if 'nbr_dig' = 0  AND
   2557          *                                           {                                        'nbr_dp'  = 0
   2558          *                                           {
   2559          *                                           {  (b)   'nbr_dig'                 ,  if 'nbr_dig' > 0  AND
   2560          *                                           {                                        'nbr_dp'  = 0
   2561          *                      Invalid string's     {
   2562          *                          number of     =  {  (c)  ['nbr_dp'               +  ,  if 'nbr_dig' = 0  AND
   2563          *                       question marks      {         1 (for decimal point) +        'nbr_dp'  > 0
   2564          *                                           {         1 (for negative sign) ]
   2565          *                                           {
   2566          *                                           {  (d)  ['nbr_dig'              +  ,  if 'nbr_dig' > 0  AND
   2567          *                                           {        'nbr_dp'               +        'nbr_dp'  > 0
   2568          *                                           {         1 (for decimal point) ]
   2569          *
   2570          *********************************************************************************************************
   2571          */
   2572          
   2573          #if (LIB_STR_CFG_FP_EN == DEF_ENABLED)
   2574          CPU_CHAR  *Str_FmtNbr_32 (CPU_FP32      nbr,
   2575                                    CPU_INT08U    nbr_dig,
   2576                                    CPU_INT08U    nbr_dp,
   2577                                    CPU_CHAR      lead_char,
   2578                                    CPU_BOOLEAN   nul,
   2579                                    CPU_CHAR     *pstr)
   2580          {
   2581              CPU_CHAR     *pstr_fmt;
   2582              CPU_DATA      i;
   2583              CPU_FP32      nbr_fmt;
   2584              CPU_FP32      nbr_log;
   2585              CPU_INT32U    nbr_shiftd;
   2586              CPU_INT16U    nbr_dig_max;
   2587              CPU_INT16U    nbr_dig_sig    = 0;
   2588              CPU_INT08U    nbr_neg_sign;
   2589              CPU_INT08U    dig_val;
   2590              CPU_FP32      dig_exp;
   2591              CPU_FP32      dp_exp;
   2592              CPU_BOOLEAN   lead_char_dig;
   2593              CPU_BOOLEAN   lead_char_fmtd = DEF_NO;
   2594              CPU_BOOLEAN   lead_char_0;
   2595              CPU_BOOLEAN   fmt_invalid;
   2596              CPU_BOOLEAN   print_char;
   2597              CPU_BOOLEAN   nbr_neg;
   2598              CPU_BOOLEAN   nbr_neg_fmtd   = DEF_NO;
   2599          
   2600          
   2601                                                                          /* ---------------- VALIDATE FMT ARGS ----------------- */
   2602              if (pstr == (CPU_CHAR *)0) {                                /* Rtn NULL if str ptr NULL (see Note #6a).             */
   2603                  return ((CPU_CHAR *)0);
   2604              }
   2605          
   2606              dig_exp     =  1.0f;
   2607              fmt_invalid =  DEF_NO;
   2608              lead_char_0 = (lead_char == '0') ? DEF_YES : DEF_NO;        /* Chk if lead char a '0' dig (see Note #3b2).          */
   2609              nbr_fmt     =  0.0f;
   2610              nbr_neg     =  DEF_NO;
   2611          
   2612              if ((nbr_dig < 1) && (nbr_dp < 1)) {                        /* If nbr digs/dps = 0, ...                             */
   2613                  fmt_invalid = DEF_YES;                                  /* ... fmt invalid str (see Note #6b).                  */
   2614              }
   2615          
   2616              if (lead_char != (CPU_CHAR)'\0') {
   2617                  print_char =  ASCII_IsPrint(lead_char);
   2618                  if (print_char != DEF_YES) {                            /* If lead char non-printable  (see Note #3a1), ...     */
   2619                      fmt_invalid = DEF_YES;                              /* ... fmt invalid str         (see Note #6d).          */
   2620          
   2621                  } else if (lead_char != '0') {                          /* Chk lead char for non-0 dig.                         */
   2622                      lead_char_dig = ASCII_IsDig(lead_char);
   2623                      if (lead_char_dig == DEF_YES) {                     /* If  lead char     non-0 dig (see Note #3a2A), ...    */
   2624                          fmt_invalid = DEF_YES;                          /* ... fmt invalid str         (see Note #6d).          */
   2625                      }
   2626                  }
   2627              }
   2628          
   2629          
   2630                                                                          /* ----------------- PREPARE NBR FMT ------------------ */
   2631              pstr_fmt = pstr;
   2632          
   2633              if (fmt_invalid == DEF_NO) {
   2634                  if (nbr < 0.0f) {                                       /* If nbr neg, ...                                      */
   2635                      nbr_fmt      = -nbr;                                /* ... negate nbr.                                      */
   2636                      nbr_neg_sign =  1u;
   2637                      nbr_neg      =  DEF_YES;
   2638                  } else {
   2639                      nbr_fmt      =  nbr;
   2640                      nbr_neg_sign =  0u;
   2641                      nbr_neg      =  DEF_NO;
   2642                  }
   2643          
   2644                  nbr_log     = nbr_fmt;
   2645                  nbr_dig_max = 0u;
   2646                  while (nbr_log >= 1.0f) {                               /* While base-10 digs avail, ...                        */
   2647                      nbr_dig_max++;                                      /* ... calc max nbr digs.                               */
   2648                      nbr_log /= 10.0f;
   2649                  }
   2650          
   2651                  if (((nbr_dig >= (nbr_dig_max + nbr_neg_sign)) ||       /* If req'd nbr digs >= (max nbr digs + neg sign)    .. */
   2652                       (nbr_dig_max < 1))                        &&       /* .. or NO nbr digs,                                .. */
   2653                      ((nbr_dig     > 1) ||                               /* .. but NOT [(req'd nbr dig = 1) AND               .. */
   2654                       (nbr_dp      > 0) ||                               /* ..          (req'd nbr dp  = 0) AND               .. */
   2655                       (nbr_neg == DEF_NO))) {                            /* ..          (      nbr neg    )]   (see Note #2b3).  */
   2656                                                                          /* .. prepare nbr digs to fmt.                          */
   2657                      for (i = 1u; i < nbr_dig; i++) {
   2658                          dig_exp *= 10.0f;
   2659                      }
   2660          
   2661                      nbr_neg_fmtd   =  DEF_NO;
   2662                      nbr_dig_sig    =  0u;
   2663                      lead_char_fmtd =  DEF_NO;
   2664                  } else {                                                /* Else if nbr trunc'd, ...                             */
   2665                      fmt_invalid = DEF_YES;                              /* ... fmt invalid str (see Note #6c).                  */
   2666                  }
   2667              }
   2668          
   2669          
   2670                                                                          /* ------------------- FMT NBR STR -------------------- */
   2671              for (i = nbr_dig; i > 0; i--) {                             /* Fmt str for desired nbr digs :                       */
   2672                  if (fmt_invalid == DEF_NO) {
   2673                      if (nbr_dig_sig < LIB_STR_CFG_FP_MAX_NBR_DIG_SIG) { /* If nbr sig digs < max, fmt str digs;           ...   */
   2674                          nbr_shiftd = (CPU_INT32U)(nbr_fmt / dig_exp);
   2675                          if ((nbr_shiftd > 0) ||                         /* If shifted nbr > 0                          ...      */
   2676                              (i == 1u)) {                                /* ... OR on one's dig to fmt (see Note #3c1), ...      */
   2677                                                                          /* ... calc & fmt dig val;                     ...      */
   2678                              if ((nbr_neg      == DEF_YES) &&            /* If  nbr neg                     ...                  */
   2679                                  (nbr_neg_fmtd == DEF_NO )) {            /* ... but neg sign NOT yet fmt'd; ...                  */
   2680          
   2681                                  if (lead_char_fmtd == DEF_YES) {        /* ... & if lead char(s) fmt'd,    ...                  */
   2682                                      pstr_fmt--;                         /* ... replace last lead char w/   ...                  */
   2683                                  }
   2684                                 *pstr_fmt++   = '-';                     /* ... prepend neg sign (see Notes #2b & #3b).          */
   2685                                  nbr_neg_fmtd = DEF_YES;
   2686                              }
   2687          
   2688                              if (nbr_shiftd > 0) {                       /* If shifted nbr > 0,        ...                       */
   2689                                  dig_val    = (CPU_INT08U)(nbr_shiftd % 10u);
   2690                                 *pstr_fmt++ = (CPU_CHAR  )(dig_val    + '0');
   2691          
   2692                                  nbr_dig_sig++;                          /* ... inc nbr sig digs;      ...                       */
   2693          
   2694                              } else if ((nbr_dig > 1) ||                 /* ... else if req'd digs > 1 ...                       */
   2695                                         (nbr_neg == DEF_NO)) {           /* ... or non-neg nbr,        ...                       */
   2696                                 *pstr_fmt++ = '0';                       /* ... fmt one '0' char (see Note #3c5).                */
   2697                              }
   2698          
   2699                          } else if ((nbr_neg      == DEF_YES) &&         /* ... else if nbr neg                         ...      */
   2700                                     (lead_char_0  == DEF_YES) &&         /* ... & lead char a '0' dig                   ...      */
   2701                                     (nbr_neg_fmtd == DEF_NO )) {         /* ... but neg sign NOT yet fmt'd,             ...      */
   2702          
   2703                             *pstr_fmt++   = '-';                         /* ... prepend neg sign (see Note #3b);        ...      */
   2704                              nbr_neg_fmtd = DEF_YES;
   2705          
   2706                          } else if (lead_char != (CPU_CHAR)'\0') {       /* ... else if avail,                          ...      */
   2707                             *pstr_fmt++     = lead_char;                 /* ... fmt lead char.                                   */
   2708                              lead_char_fmtd = DEF_YES;
   2709                          }
   2710          
   2711                          dig_exp /= 10.0f;                               /* Shift to next least-sig dig.                         */
   2712          
   2713                      } else {                                            /* ... else append non-sig 0's (see Note #2c2).         */
   2714                         *pstr_fmt++ = '0';
   2715                      }
   2716          
   2717                  } else {                                                /* Else fmt '?' for invalid str (see Note #7).          */
   2718                     *pstr_fmt++ = '?';
   2719                  }
   2720              }
   2721          
   2722          
   2723              if (nbr_dp > 0) {                                           /* Fmt str for desired nbr dp :                         */
   2724                  if (nbr_dig < 1) {                                      /* If NO digs fmt'd;                             ...    */
   2725                      if (fmt_invalid == DEF_NO) {                        /* ... nbr fmt valid,                            ...    */
   2726                          if ((nbr_neg      == DEF_YES) &&                /* ... nbr neg                                   ...    */
   2727                              (nbr_neg_fmtd == DEF_NO )) {                /* ... but neg sign NOT yet fmt'd,               ...    */
   2728                              *pstr_fmt++ = '-';                          /* ... prepend neg sign (see Notes #2b & #3b);   ...    */
   2729                          } else {                                        /* ... else prepend 1 dig of '0' (see Note #3c5) ...    */
   2730                              *pstr_fmt++ = '0';
   2731                          }
   2732                      } else {                                            /* ... else fmt '?' for invalid str (see Note #7).      */
   2733                          *pstr_fmt++ = '?';
   2734                      }
   2735                  }
   2736          
   2737                  if (fmt_invalid == DEF_NO) {                            /* If nbr fmt valid, ...                                */
   2738                     *pstr_fmt++ = '.';                                   /* ... append dp prior to dp conversion.                */
   2739                  } else {                                                /* Else fmt '?' for invalid str (see Note #7).          */
   2740                     *pstr_fmt++ = '?';
   2741                  }
   2742          
   2743                  dp_exp = 10.0f;
   2744                  for (i = 0u; i < nbr_dp; i++) {
   2745                      if (fmt_invalid == DEF_NO) {
   2746                                                                          /* If nbr sig digs < max, fmt str dps;    ...           */
   2747                          if (nbr_dig_sig <  LIB_STR_CFG_FP_MAX_NBR_DIG_SIG) {
   2748                              nbr_shiftd  = (CPU_INT32U)(nbr_fmt * dp_exp);
   2749                              dig_val     = (CPU_INT08U)(nbr_shiftd % 10u);
   2750                             *pstr_fmt++  = (CPU_CHAR  )(dig_val    + '0');
   2751                              dp_exp     *=  10.0f;                       /* Shift to next least-sig dp.                          */
   2752          
   2753                              if ((nbr_shiftd  > 0) ||                    /* If shifted nbr > 0                  ...              */
   2754                                  (nbr_dig_sig > 0)) {                    /* ... OR  > 0 sig digs already fmt'd, ...              */
   2755                                   nbr_dig_sig++;                         /* ... inc nbr sig digs.                                */
   2756                              }
   2757          
   2758                          } else {                                        /* ... else append non-sig 0's (see Note #2c2).         */
   2759                             *pstr_fmt++ = '0';
   2760                          }
   2761          
   2762                      } else {                                            /* Else fmt '?' for invalid str (see Note #7).          */
   2763                         *pstr_fmt++ = '?';
   2764                      }
   2765                  }
   2766              }
   2767          
   2768          
   2769              if (nul != DEF_NO) {                                        /* If NOT DISABLED, append NULL char (see Note #4).     */
   2770                 *pstr_fmt = (CPU_CHAR)'\0';
   2771              }
   2772          
   2773          
   2774              if (fmt_invalid != DEF_NO) {                                /* Rtn NULL for invalid str fmt (see Notes #6a - #6d).  */
   2775                  return ((CPU_CHAR *)0);
   2776              }
   2777          
   2778          
   2779              return (pstr);                                              /* Rtn ptr to fmt'd str (see Note #6e).                 */
   2780          }
   2781          #endif
   2782          
   2783          
   2784          /*
   2785          *********************************************************************************************************
   2786          *                                        Str_ParseNbr_Int32U()
   2787          *
   2788          * Description : Parse 32-bit unsigned integer from string.
   2789          *
   2790          * Argument(s) : pstr        Pointer to string (see Notes #1 & #2a).
   2791          *
   2792          *               pstr_next   Optional pointer to a variable to ... :
   2793          *
   2794          *                               (a) Return a pointer to first character following the integer string,
   2795          *                                       if NO error(s) [see Note #2a2B2];
   2796          *                               (b) Return a pointer to 'pstr',
   2797          *                                       otherwise      (see Note #2a2A2).
   2798          *
   2799          *               nbr_base    Base of number to parse (see Notes #2a1B1 & #2a2B1).
   2800          *
   2801          * Return(s)   : Parsed integer,      if integer parsed with NO overflow   (see Note #2a3A).
   2802          *
   2803          *               DEF_INT_32U_MAX_VAL, if integer parsed but     overflowed (see Note #2a3A1).
   2804          *
   2805          *               0,                   otherwise                            (see Note #2a3B).
   2806          *
   2807          * Caller(s)   : Application.
   2808          *
   2809          * Note(s)     : (1) String buffer NOT modified.
   2810          *
   2811          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : DESCRIPTION' states that "these
   2812          *                       functions shall convert the initial portion of the string pointed to by 'str' ('pstr')
   2813          *                       to a type unsigned long ... representation" :
   2814          *
   2815          *                       (1) "First, they decompose the input string into three parts" :
   2816          *
   2817          *                           (A) "An initial, possibly empty, sequence of white-space characters [as specified
   2818          *                                by isspace()]."
   2819          *
   2820          *                               (1) "The subject sequence is defined as the longest initial subsequence of the
   2821          *                                    input string, starting with the first non-white-space character that is of
   2822          *                                    the expected form.  The subject sequence shall contain no characters if the
   2823          *                                    input string is empty or consists entirely of white-space characters."
   2824          *
   2825          *                           (B) (1) "A subject sequence interpreted as an integer represented in some radix
   2826          *                                    determined by the value of 'base' ('nbr_base')" :
   2827          *
   2828          *                                   (a) "If the value of 'base' ('nbr_base') is 0, the expected form of the
   2829          *                                        subject sequence is that of a decimal constant, octal constant, or
   2830          *                                        hexadecimal constant" :
   2831          *
   2832          *                                       (1) "A decimal constant begins with a non-zero digit, and consists of a
   2833          *                                            sequence of decimal digits."
   2834          *
   2835          *                                       (2) "An octal constant consists of the prefix '0' optionally followed by
   2836          *                                            a sequence of the digits '0' to '7' only."
   2837          *
   2838          *                                       (3) "A hexadecimal constant consists of the prefix '0x' or '0X' followed
   2839          *                                            by a sequence of the decimal digits and letters 'a' (or 'A') to 'f'
   2840          *                                            (or 'F') with values 10 to 15 respectively."
   2841          *
   2842          *                                   (b) "If the value of 'base' ('nbr_base') is between 2 and 36, the expected form
   2843          *                                        of the subject sequence is a sequence of letters and digits representing
   2844          *                                        an integer with the radix specified by 'base' ('nbr_base')" :
   2845          *
   2846          *                                       (1) (A) "The letters from 'a' (or 'A') to 'z' (or 'Z') inclusive are
   2847          *                                                ascribed the values 10 to 35"; ...
   2848          *                                           (B) "only letters whose ascribed values are less than that of base
   2849          *                                                are permitted."
   2850          *
   2851          *                                       (2) (A) "If the value of 'base' ('nbr_base') is 16, the characters '0x' or
   2852          *                                                '0X' may optionally precede the sequence of letters and digits."
   2853          *
   2854          *                                           (B) Although NO specification states that "if the value of 'base'
   2855          *                                               ('nbr_base') is" 8, the '0' character "may optionally precede
   2856          *                                               the sequence of letters and digits"; it seems reasonable to
   2857          *                                               allow the '0' character to be optionally parsed.
   2858          *
   2859          *                               (2) "A subject sequence .... may be preceded by a '+' or '-' sign."
   2860          *
   2861          *                                   (a) However, it does NOT seem reasonable to parse & convert a negative number
   2862          *                                       integer string into an unsigned integer.
   2863          *
   2864          *                           (C) (1) (a) "A final string of one or more unrecognized characters,"  ...
   2865          *                                   (b) "including the terminating null byte of the input string" ...
   2866          *                               (2) "other than a sign or a permissible letter or digit."
   2867          *
   2868          *                       (2) Second, "they shall attempt to convert the subject sequence to an unsigned integer" :
   2869          *
   2870          *                           (A) "If the subject sequence is empty or does not have the expected form" :
   2871          *
   2872          *                               (1) "no conversion [is] performed"; ...
   2873          *                               (2) "the value of 'str' ('pstr') [is] stored in the object pointed to by 'endptr'
   2874          *                                    ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null pointer."
   2875          *
   2876          *                           (B) "If the subject sequence has the expected form" :
   2877          *
   2878          *                               (1) (a) "and the value of 'base' ('nbr_base') is 0, the sequence of characters
   2879          *                                        starting with the first digit shall be interpreted as an integer constant."
   2880          *
   2881          *                                   (b) "and the value of 'base' ('nbr_base') is between 2 and 36, it shall be
   2882          *                                        used as the base for conversion, ascribing to each letter its value as
   2883          *                                        given above" (see Note #2a1B1b1A).
   2884          *
   2885          *                               (2) "A pointer to the final string shall be stored in the object pointed to by
   2886          *                                   'endptr' ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null
   2887          *                                   pointer."
   2888          *
   2889          *                       (3) Lastly, IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : RETURN VALUE' states that :
   2890          *
   2891          *                           (A) "Upon successful completion, these functions shall return the converted value."
   2892          *                               (1) "If the correct value is outside the range of representable values, {ULONG_MAX}
   2893          *                                    ... shall be returned."
   2894          *
   2895          *                           (B) "If no conversion could be performed, 0 shall be returned."
   2896          *
   2897          *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
   2898          *                           shall fail if" :
   2899          *
   2900          *                           (A) "[EINVAL] - The value of 'base' ('nbr_base') is not supported."
   2901          *
   2902          *                           (B) "[ERANGE] - The value to be returned is not representable."
   2903          *
   2904          *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
   2905          *                           may fail if" :
   2906          *
   2907          *                           (A) "[EINVAL] - No conversion could be performed."
   2908          *
   2909          *               (3) Return integer value & next string pointer should be used to diagnose parse success or failure :
   2910          *
   2911          *                   (a) Valid parse string integer :
   2912          *
   2913          *                           pstr      = "     ABCDE xyz"
   2914          *                           nbr_base  = 16
   2915          *
   2916          *                           nbr       = 703710
   2917          *                           pstr_next = " xyz"
   2918          *
   2919          *
   2920          *                   (b) Invalid parse string integer :
   2921          *
   2922          *                           pstr      = "     ABCDE"
   2923          *                           nbr_base  = 10
   2924          *
   2925          *                           nbr       =  0
   2926          *                           pstr_next = pstr = "     ABCDE"
   2927          *
   2928          *
   2929          *                   (c) Valid hexadecimal parse string integer :
   2930          *
   2931          *                           pstr      = "     0xGABCDE"
   2932          *                           nbr_base  = 16
   2933          *
   2934          *                           nbr       =  0
   2935          *                           pstr_next = "xGABCDE"
   2936          *
   2937          *
   2938          *                   (d) Valid decimal parse string integer ('0x' prefix ignored
   2939          *                               following invalid hexadecimal characters) :
   2940          *
   2941          *                           pstr      = "     0xGABCDE"
   2942          *                           nbr_base  =  0
   2943          *
   2944          *                           nbr       =  0
   2945          *                           pstr_next = "xGABCDE"
   2946          *
   2947          *
   2948          *                   (e) Valid decimal parse string integer ('0'  prefix ignored
   2949          *                               following invalid octal       characters) :
   2950          *
   2951          *                           pstr      = "     0GABCDE"
   2952          *                           nbr_base  =  0
   2953          *
   2954          *                           nbr       =  0
   2955          *                           pstr_next = "GABCDE"
   2956          *
   2957          *
   2958          *                   (f) Parse string integer overflow :
   2959          *
   2960          *                           pstr      = "   12345678901234567890*123456"
   2961          *                           nbr_base  = 10
   2962          *
   2963          *                           nbr       = DEF_INT_32U_MAX_VAL
   2964          *                           pstr_next = "*123456"
   2965          *
   2966          *
   2967          *                   (g) Invalid negative unsigned parse string :
   2968          *
   2969          *                           pstr      = "  -12345678901234567890*123456"
   2970          *                           nbr_base  = 10
   2971          *
   2972          *                           nbr       = 0
   2973          *                           pstr_next = pstr = "  -12345678901234567890*123456"
   2974          *
   2975          *********************************************************************************************************
   2976          */
   2977          

   \                                 In section .text, align 2, keep-with-next
   2978          CPU_INT32U  Str_ParseNbr_Int32U (const  CPU_CHAR     *pstr,
   2979                                                  CPU_CHAR    **pstr_next,
   2980                                                  CPU_INT08U    nbr_base)
   2981          {
   \                     Str_ParseNbr_Int32U: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2982              CPU_INT32U  nbr;
   2983          
   2984          
   2985              nbr = Str_ParseNbr_Int32(               pstr,               /* Parse/convert str ...                                */
   2986                                                      pstr_next,
   2987                                                      nbr_base,
   2988                                                      DEF_NO,             /* ... as unsigned int (see Note #2a2).                 */
   2989                                       (CPU_BOOLEAN *)0);
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x9300             STR      R3,[SP, #+0]
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000A   0x.... 0x....      BL       Str_ParseNbr_Int32
   2990          
   2991              return (nbr);
   \   0000000E   0xBD02             POP      {R1,PC}          ;; return
   2992          }
   2993          
   2994          
   2995          /*
   2996          *********************************************************************************************************
   2997          *                                        Str_ParseNbr_Int32S()
   2998          *
   2999          * Description : Parse 32-bit signed integer from string.
   3000          *
   3001          * Argument(s) : pstr        Pointer to string (see Notes #1 & #2a).
   3002          *
   3003          *               pstr_next   Optional pointer to a variable to ... :
   3004          *
   3005          *                               (a) Return a pointer to first character following the integer string,
   3006          *                                       if NO error(s) [see Note #2a2B2];
   3007          *                               (b) Return a pointer to 'pstr',
   3008          *                                       otherwise      (see Note #2a2A2).
   3009          *
   3010          *               nbr_base    Base of number to parse (see Notes #2a1B1 & #2a2B1).
   3011          *
   3012          * Return(s)   : Parsed integer,      if integer parsed with NO over- or underflow (see Note #2a3A).
   3013          *
   3014          *               DEF_INT_32S_MIN_VAL, if integer parsed but negatively underflowed (see Note #2a3A1a).
   3015          *
   3016          *               DEF_INT_32U_MAX_VAL, if integer parsed but positively overflowed  (see Note #2a3A1b).
   3017          *
   3018          *               0,                   otherwise                                    (see Note #2a3B).
   3019          *
   3020          * Caller(s)   : Application.
   3021          *
   3022          * Note(s)     : (1) String buffer NOT modified.
   3023          *
   3024          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strtol() : DESCRIPTION' states that "these
   3025          *                       functions shall convert the initial portion of the string pointed to by 'str' ('pstr')
   3026          *                       to a type long ... representation" :
   3027          *
   3028          *                       (1) "First, they decompose the input string into three parts" :
   3029          *
   3030          *                           (A) "An initial, possibly empty, sequence of white-space characters [as specified
   3031          *                                by isspace()]."
   3032          *
   3033          *                               (1) "The subject sequence is defined as the longest initial subsequence of the
   3034          *                                    input string, starting with the first non-white-space character that is of
   3035          *                                    the expected form.  The subject sequence shall contain no characters if the
   3036          *                                    input string is empty or consists entirely of white-space characters."
   3037          *
   3038          *                           (B) (1) "A subject sequence interpreted as an integer represented in some radix
   3039          *                                    determined by the value of 'base' ('nbr_base')" :
   3040          *
   3041          *                                   (a) "If the value of 'base' ('nbr_base') is 0, the expected form of the
   3042          *                                        subject sequence is that of a decimal constant, octal constant, or
   3043          *                                        hexadecimal constant" :
   3044          *
   3045          *                                       (1) "A decimal constant begins with a non-zero digit, and consists of a
   3046          *                                            sequence of decimal digits."
   3047          *
   3048          *                                       (2) "An octal constant consists of the prefix '0' optionally followed by
   3049          *                                            a sequence of the digits '0' to '7' only."
   3050          *
   3051          *                                       (3) "A hexadecimal constant consists of the prefix '0x' or '0X' followed
   3052          *                                            by a sequence of the decimal digits and letters 'a' (or 'A') to 'f'
   3053          *                                            (or 'F') with values 10 to 15 respectively."
   3054          *
   3055          *                                   (b) "If the value of 'base' ('nbr_base') is between 2 and 36, the expected form
   3056          *                                        of the subject sequence is a sequence of letters and digits representing
   3057          *                                        an integer with the radix specified by 'base' ('nbr_base')" :
   3058          *
   3059          *                                       (1) (A) "The letters from 'a' (or 'A') to 'z' (or 'Z') inclusive are
   3060          *                                                ascribed the values 10 to 35"; ...
   3061          *                                           (B) "only letters whose ascribed values are less than that of base
   3062          *                                                are permitted."
   3063          *
   3064          *                                       (2) (A) "If the value of 'base' ('nbr_base') is 16, the characters '0x' or
   3065          *                                                '0X' may optionally precede the sequence of letters and digits."
   3066          *
   3067          *                                           (B) Although NO specification states that "if the value of 'base'
   3068          *                                               ('nbr_base') is" 8, the '0' character "may optionally precede
   3069          *                                               the sequence of letters and digits"; it seems reasonable to
   3070          *                                               allow the '0' character to be optionally parsed.
   3071          *
   3072          *                               (2) "A subject sequence .... may be preceded by a '+' or '-' sign."
   3073          *
   3074          *                                   (a) However, it does NOT seem reasonable to parse & convert a negative number
   3075          *                                       integer string into an unsigned integer.
   3076          *
   3077          *                           (C) (1) (a) "A final string of one or more unrecognized characters,"  ...
   3078          *                                   (b) "including the terminating null byte of the input string" ...
   3079          *                               (2) "other than a sign or a permissible letter or digit."
   3080          *
   3081          *                       (2) Second, "they shall attempt to convert the subject sequence to an integer" :
   3082          *
   3083          *                           (A) "If the subject sequence is empty or does not have the expected form" :
   3084          *
   3085          *                               (1) "no conversion is performed"; ...
   3086          *                               (2) "the value of 'str' ('pstr') is stored in the object pointed to by 'endptr'
   3087          *                                    ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null pointer."
   3088          *
   3089          *                           (B) "If the subject sequence has the expected form" :
   3090          *
   3091          *                               (1) (a) "and the value of 'base' ('nbr_base') is 0, the sequence of characters
   3092          *                                        starting with the first digit shall be interpreted as an integer constant."
   3093          *
   3094          *                                   (b) "and the value of 'base' ('nbr_base') is between 2 and 36, it shall be
   3095          *                                        used as the base for conversion, ascribing to each letter its value as
   3096          *                                        given above" (see Note #2a1B1b1A).
   3097          *
   3098          *                               (2) "A pointer to the final string shall be stored in the object pointed to by
   3099          *                                   'endptr' ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null
   3100          *                                   pointer."
   3101          *
   3102          *                       (3) Lastly, IEEE Std 1003.1, 2004 Edition, Section 'strtol() : RETURN VALUE' states that :
   3103          *
   3104          *                           (A) "Upon successful completion, these functions shall return the converted value."
   3105          *
   3106          *                               (1) "If the correct value is outside the range of representable values", either
   3107          *                                    of the following "shall be returned" :
   3108          *                                   (a) "{LONG_MIN}" or ...
   3109          *                                   (b) "{LONG_MAX}"
   3110          *
   3111          *                           (B) "If no conversion could be performed, 0 shall be returned."
   3112          *
   3113          *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
   3114          *                           shall fail if" :
   3115          *
   3116          *                           (A) "[EINVAL] - The value of 'base' ('nbr_base') is not supported."
   3117          *
   3118          *                           (B) "[ERANGE] - The value to be returned is not representable."
   3119          *
   3120          *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
   3121          *                           may fail if" :
   3122          *
   3123          *                           (A) "[EINVAL] - No conversion could be performed."
   3124          *
   3125          *               (3) Return integer value & next string pointer should be used to diagnose parse success or failure :
   3126          *
   3127          *                   (a) Valid parse string integer :
   3128          *
   3129          *                           pstr      = "     ABCDE xyz"
   3130          *                           nbr_base  = 16
   3131          *
   3132          *                           nbr       = 703710
   3133          *                           pstr_next = " xyz"
   3134          *
   3135          *
   3136          *                   (b) Invalid parse string integer :
   3137          *
   3138          *                           pstr      = "     ABCDE"
   3139          *                           nbr_base  = 10
   3140          *
   3141          *                           nbr       =  0
   3142          *                           pstr_next = pstr = "     ABCDE"
   3143          *
   3144          *
   3145          *                   (c) Valid hexadecimal parse string integer :
   3146          *
   3147          *                           pstr      = "     0xGABCDE"
   3148          *                           nbr_base  = 16
   3149          *
   3150          *                           nbr       =  0
   3151          *                           pstr_next = "xGABCDE"
   3152          *
   3153          *
   3154          *                   (d) Valid decimal parse string integer ('0x' prefix ignored
   3155          *                               following invalid hexadecimal characters) :
   3156          *
   3157          *                           pstr      = "     0xGABCDE"
   3158          *                           nbr_base  =  0
   3159          *
   3160          *                           nbr       =  0
   3161          *                           pstr_next = "xGABCDE"
   3162          *
   3163          *
   3164          *                   (e) Valid decimal parse string integer ('0'  prefix ignored
   3165          *                               following invalid octal       characters) :
   3166          *
   3167          *                           pstr      = "     0GABCDE"
   3168          *                           nbr_base  =  0
   3169          *
   3170          *                           nbr       =  0
   3171          *                           pstr_next = "GABCDE"
   3172          *
   3173          *
   3174          *                   (f) Parse string integer overflow :
   3175          *
   3176          *                           pstr      = "   12345678901234567890*123456"
   3177          *                           nbr_base  = 10
   3178          *
   3179          *                           nbr       = DEF_INT_32S_MAX_VAL
   3180          *                           pstr_next = "*123456"
   3181          *
   3182          *
   3183          *                   (g) Parse string integer underflow :
   3184          *
   3185          *                           pstr      = "  -12345678901234567890*123456"
   3186          *                           nbr_base  = 10
   3187          *
   3188          *                           nbr       = DEF_INT_32S_MIN_VAL
   3189          *                           pstr_next = "*123456"
   3190          *
   3191          *********************************************************************************************************
   3192          */
   3193          

   \                                 In section .text, align 2, keep-with-next
   3194          CPU_INT32S  Str_ParseNbr_Int32S (const  CPU_CHAR     *pstr,
   3195                                                  CPU_CHAR    **pstr_next,
   3196                                                  CPU_INT08U    nbr_base)
   3197          {
   \                     Str_ParseNbr_Int32S: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   3198              CPU_INT32S   nbr;
   3199              CPU_INT32U   nbr_abs;
   3200              CPU_BOOLEAN  nbr_neg;
   3201          
   3202          
   3203              nbr_abs = Str_ParseNbr_Int32(pstr,                          /* Parse/convert str ...                                */
   3204                                           pstr_next,
   3205                                           nbr_base,
   3206                                           DEF_YES,                       /* ... as signed int (see Note #2a2).                   */
   3207                                          &nbr_neg);
   \   00000004   0xAB01             ADD      R3,SP,#+4
   \   00000006   0x9300             STR      R3,[SP, #+0]
   \   00000008   0x2301             MOVS     R3,#+1
   \   0000000A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000C   0x.... 0x....      BL       Str_ParseNbr_Int32
   3208          
   3209              if (nbr_neg == DEF_NO) {                                    /* Chk for neg nbr & ovf/undf (see Note #2a3A1).        */
   \   00000010   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   00000014   0x2900             CMP      R1,#+0
   \   00000016   0xD106             BNE.N    ??Str_ParseNbr_Int32S_0
   3210                  nbr = (nbr_abs > (CPU_INT32U) DEF_INT_32S_MAX_VAL)          ?  (CPU_INT32S)DEF_INT_32S_MAX_VAL
   3211                                                                              :  (CPU_INT32S)nbr_abs;
   \   00000018   0xF1B0 0x4F00      CMP      R0,#-2147483648
   \   0000001C   0xD302             BCC.N    ??Str_ParseNbr_Int32S_1
   \   0000001E   0xF07F 0x4000      MVNS     R0,#-2147483648
   \   00000022   0xE007             B.N      ??Str_ParseNbr_Int32S_2
   \                     ??Str_ParseNbr_Int32S_1: (+1)
   \   00000024   0xE006             B.N      ??Str_ParseNbr_Int32S_2
   3212              } else {
   3213                  nbr = (nbr_abs > (CPU_INT32U)-DEF_INT_32S_MIN_VAL_ONES_CPL) ?  (CPU_INT32S)DEF_INT_32S_MIN_VAL
   3214                                                                              : -(CPU_INT32S)nbr_abs;
   \                     ??Str_ParseNbr_Int32S_0: (+1)
   \   00000026   0xF1B0 0x4F00      CMP      R0,#-2147483648
   \   0000002A   0xD302             BCC.N    ??Str_ParseNbr_Int32S_3
   \   0000002C   0xF05F 0x4000      MOVS     R0,#-2147483648
   \   00000030   0xE000             B.N      ??Str_ParseNbr_Int32S_2
   \                     ??Str_ParseNbr_Int32S_3: (+1)
   \   00000032   0x4240             RSBS     R0,R0,#+0
   3215              }
   3216          
   3217              return (nbr);
   \                     ??Str_ParseNbr_Int32S_2: (+1)
   \   00000034   0xBD0E             POP      {R1-R3,PC}       ;; return
   3218          }
   3219          
   3220          
   3221          /*
   3222          *********************************************************************************************************
   3223          *********************************************************************************************************
   3224          *                                           LOCAL FUNCTIONS
   3225          *********************************************************************************************************
   3226          *********************************************************************************************************
   3227          */
   3228          
   3229          /*
   3230          *********************************************************************************************************
   3231          *                                         Str_FmtNbr_Int32()
   3232          *
   3233          * Description : Format 32-bit integer into a multi-digit character string.
   3234          *
   3235          * Argument(s) : nbr             Number           to format.
   3236          *
   3237          *               nbr_dig         Number of digits to format (see Note #1).
   3238          *
   3239          *               nbr_base        Base   of number to format (see Note #2).
   3240          *
   3241          *               nbr_neg         Indicates whether number to format is negative :
   3242          *               -------
   3243          *                                   DEF_NO          Number is non-negative.
   3244          *                                   DEF_YES         Number is     negative.
   3245          *
   3246          *                               Argument validated in Str_FmtNbr_Int32U(),
   3247          *                                                     Str_FmtNbr_Int32S().
   3248          *
   3249          *               lead_char       Prepend leading character  (see Note #3) :
   3250          *
   3251          *                                   '\0'                    Do NOT prepend leading character to string.
   3252          *                                     Printable character          Prepend leading character to string.
   3253          *                                   Unprintable character   Format invalid string (see Note #6e).
   3254          *
   3255          *               lower_case      Format alphabetic characters (if any) in lower case :
   3256          *
   3257          *                                   DEF_NO          Format alphabetic characters in upper case.
   3258          *                                   DEF_YES         Format alphabetic characters in lower case.
   3259          *
   3260          *               nul             Append terminating NULL-character (see Note #4) :
   3261          *
   3262          *                                   DEF_NO          Do NOT append terminating NULL-character to string.
   3263          *                                   DEF_YES                Append terminating NULL-character to string.
   3264          *
   3265          *               pstr            Pointer to character array to return formatted number string (see Note #5).
   3266          *
   3267          * Return(s)   : Pointer to formatted string, if NO error(s) [see Note #6f].
   3268          *
   3269          *               Pointer to NULL,             otherwise.
   3270          *
   3271          * Caller(s)   : Str_FmtNbr_Int32U(),
   3272          *               Str_FmtNbr_Int32S().
   3273          *
   3274          * Note(s)     : (1) (a) The maximum number of digits to format for 32-bit integer numbers :
   3275          *
   3276          *
   3277          *                               Maximum Number of             [  log (Number)      ]
   3278          *                             32-bit Integer Digits  =  floor [ -------------- + 1 ]
   3279          *                                   to Format                 [   log (Base)       ]
   3280          *
   3281          *                               where
   3282          *                                       Number                  Number to format
   3283          *                                       Base            Base of number to format
   3284          *
   3285          *                   (b) (1) If the number of digits to format ('nbr_dig') is zero; then NO formatting
   3286          *                           is performed except possible NULL-termination of the string (see Note #4).
   3287          *
   3288          *                               Example :
   3289          *
   3290          *                                   nbr      = -23456
   3291          *                                   nbr_dig  =  0
   3292          *                                   nbr_base = 10
   3293          *
   3294          *                                   pstr     = ""                   See Note #7a
   3295          *
   3296          *                       (2) If the number of digits to format ('nbr_dig') is less than the number of
   3297          *                           significant integer digits of the number to format ('nbr'); then an invalid
   3298          *                           string is formatted instead of truncating any significant integer digits.
   3299          *
   3300          *                               Example :
   3301          *
   3302          *                                   nbr      = 23456
   3303          *                                   nbr_dig  = 3
   3304          *                                   nbr_base = 10
   3305          *
   3306          *                                   pstr     = "???"                See Note #7b
   3307          *
   3308          *                       (3) If the number to format ('nbr') is negative but the number of digits to format
   3309          *                           ('nbr_dig') is equal to the number of significant integer digits of the number
   3310          *                           to format ('nbr'); then an invalid string is formatted instead of truncating
   3311          *                           the negative sign.
   3312          *
   3313          *                               Example :
   3314          *
   3315          *                                   nbr      = -23456
   3316          *                                   nbr_dig  =  5
   3317          *                                   nbr_base = 10
   3318          *
   3319          *                                   pstr     = "?????"              See Note #7b
   3320          *
   3321          *               (2) The number's base MUST be between 2 & 36, inclusive.
   3322          *
   3323          *               (3) Leading character option prepends leading characters prior to the first non-zero digit.
   3324          *
   3325          *                   (a) (1) Leading character MUST be a printable ASCII character.
   3326          *
   3327          *                       (2) (A) Leading character MUST NOT be a number base digit, ...
   3328          *                           (B) with the exception of '0'.
   3329          *
   3330          *                   (b) (1) The number of leading characters is such that the total number of significant
   3331          *                           integer digits plus the number of leading characters plus possible negative
   3332          *                           sign character is equal to the requested number of integer digits to format
   3333          *                           ('nbr_dig').
   3334          *
   3335          *                               Examples :
   3336          *
   3337          *                                   nbr       = 23456
   3338          *                                   nbr_dig   = 7
   3339          *                                   nbr_base  = 10
   3340          *                                   lead_char = ' '
   3341          *
   3342          *                                   pstr      = "  23456"
   3343          *
   3344          *
   3345          *                                   nbr       = -23456
   3346          *                                   nbr_dig   = 7
   3347          *                                   nbr_base  = 10
   3348          *                                   lead_char = ' '
   3349          *
   3350          *                                   pstr      = " -23456"
   3351          *
   3352          *                       (2) (A) If the number to format ('nbr') is negative AND the leading character
   3353          *                               ('lead_char') is     a '0' digit; then the negative sign character
   3354          *                               prefixes all leading characters prior to the formatted number.
   3355          *
   3356          *                                   Examples :
   3357          *
   3358          *                                       nbr        = -23456
   3359          *                                       nbr_dig    =  8
   3360          *                                       nbr_base   = 10
   3361          *                                       lead_char  = '0'
   3362          *
   3363          *                                       pstr       = "-0023456"
   3364          *
   3365          *
   3366          *                                       nbr        = -43981
   3367          *                                       nbr_dig    =  8
   3368          *                                       nbr_base   = 16
   3369          *                                       lead_char  = '0'
   3370          *                                       lower_case = DEF_NO
   3371          *
   3372          *                                       pstr       = "-000ABCD"
   3373          *
   3374          *                           (B) If the number to format ('nbr') is negative AND the leading character
   3375          *                               ('lead_char') is NOT a '0' digit; then the negative sign character
   3376          *                               immediately prefixes the most significant digit of the formatted number.
   3377          *
   3378          *                                   Examples :
   3379          *
   3380          *                                       nbr        = -23456
   3381          *                                       nbr_dig    =  8
   3382          *                                       nbr_base   = 10
   3383          *                                       lead_char  = '#'
   3384          *
   3385          *                                       pstr       = "##-23456"
   3386          *
   3387          *
   3388          *                                       nbr        = -43981
   3389          *                                       nbr_dig    =  8
   3390          *                                       nbr_base   = 16
   3391          *                                       lead_char  = '#'
   3392          *                                       lower_case = DEF_YES
   3393          *
   3394          *                                       pstr       = "###-abcd"
   3395          *
   3396          *                   (c) (1) If the value of the number to format is     zero  ...
   3397          *                       (2) ... & the number of digits to format is non-zero, ...
   3398          *                       (3) ... but NO leading character available;           ...
   3399          *                       (4) ... then one digit of '0' value is formatted.
   3400          *
   3401          *                           This is NOT a leading character; but a single integer digit of '0' value.
   3402          *
   3403          *               (4) (a) NULL-character terminate option DISABLED prevents overwriting previous character
   3404          *                       array formatting.
   3405          *
   3406          *                   (b) WARNING: Unless 'pstr' character array is pre-/post-terminated, NULL-character
   3407          *                       terminate option DISABLED will cause character string run-on.
   3408          *
   3409          *               (5) (a) Format buffer size NOT validated; buffer overruns MUST be prevented by caller.
   3410          *
   3411          *                   (b) To prevent character buffer overrun :
   3412          *
   3413          *                           Character array size MUST be  >=  ('nbr_dig'          +
   3414          *                                                               1 negative sign   +
   3415          *                                                               1 'NUL' terminator)  characters
   3416          *
   3417          *               (6) String format terminates when :
   3418          *
   3419          *                   (a) Format string pointer is passed a NULL pointer.
   3420          *                       (1) No      string formatted;                NULL pointer returned.
   3421          *
   3422          *                   (b) Number of digits to format ('nbr_dig') is zero.
   3423          *                       (1) NULL    string formatted (see Note #7a); NULL pointer returned.
   3424          *
   3425          *                   (c) Number of digits to format ('nbr_dig') is less than number of significant
   3426          *                           integer digits of the number to format ('nbr'), including possible
   3427          *                           negative sign.
   3428          *                       (1) Invalid string formatted (see Note #7);  NULL pointer returned.
   3429          *
   3430          *                   (d) Base is passed an invalid base (see Note #2).
   3431          *                       (1) Invalid string format performed; NULL pointer returned.
   3432          *
   3433          *                   (e) Lead character is NOT a valid, printable character (see Note #3a).
   3434          *                       (1) Invalid string formatted (see Note #7);  NULL pointer returned.
   3435          *
   3436          *                   (f) Number successfully formatted into character string array.
   3437          *
   3438          *               (7) For any unsuccessful string format or error(s), an invalid string of question marks
   3439          *                   ('?') will be formatted, where the number of question marks is determined by the
   3440          *                   number of digits to format ('nbr_dig') :
   3441          *
   3442          *                      Invalid string's     {  (a)   0 (NULL string)  ,  if 'nbr_dig' = 0
   3443          *                          number of     =  {
   3444          *                       question marks      {  (b)  'nbr_dig'         ,  if 'nbr_dig' > 0
   3445          *
   3446          *********************************************************************************************************
   3447          */
   3448          

   \                                 In section .text, align 2, keep-with-next
   3449          static  CPU_CHAR  *Str_FmtNbr_Int32 (CPU_INT32U    nbr,
   3450                                               CPU_INT08U    nbr_dig,
   3451                                               CPU_INT08U    nbr_base,
   3452                                               CPU_BOOLEAN   nbr_neg,
   3453                                               CPU_CHAR      lead_char,
   3454                                               CPU_BOOLEAN   lower_case,
   3455                                               CPU_BOOLEAN   nul,
   3456                                               CPU_CHAR     *pstr)
   3457          {
   \                     Str_FmtNbr_Int32: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4683             MOV      R11,R0
   \   00000006   0x468A             MOV      R10,R1
   \   00000008   0x0014             MOVS     R4,R2
   3458              CPU_CHAR     *pstr_fmt;
   3459              CPU_DATA      i;
   3460              CPU_INT32U    nbr_fmt            = 0;
   \   0000000A   0x2600             MOVS     R6,#+0
   3461              CPU_INT32U    nbr_log;
   3462              CPU_INT08U    nbr_dig_max;
   3463              CPU_INT08U    nbr_dig_min;
   3464              CPU_INT08U    nbr_dig_fmtd       = 0;
   \   0000000C   0x2700             MOVS     R7,#+0
   3465              CPU_INT08U    nbr_neg_sign;
   3466              CPU_INT08U    nbr_lead_char;
   3467              CPU_INT08U    dig_val;
   3468              CPU_INT08U    lead_char_delta_0;
   3469              CPU_INT08U    lead_char_delta_a;
   3470              CPU_BOOLEAN   lead_char_dig;
   3471              CPU_BOOLEAN   lead_char_0;
   3472              CPU_BOOLEAN   fmt_valid          = DEF_YES;
   \   0000000E   0xF05F 0x0801      MOVS     R8,#+1
   3473              CPU_BOOLEAN   print_char;
   3474              CPU_BOOLEAN   nbr_neg_fmtd       = DEF_NO;
   \   00000012   0xF05F 0x0900      MOVS     R9,#+0
   3475          
   3476          
   3477                                                                          /* ---------------- VALIDATE FMT ARGS ----------------- */
   3478              if (pstr == (CPU_CHAR *)0) {                                /* Rtn NULL if str ptr NULL (see Note #6a).             */
   \   00000016   0x980D             LDR      R0,[SP, #+52]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD101             BNE.N    ??Str_FmtNbr_Int32_0
   3479                  return ((CPU_CHAR *)0);
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE0E4             B.N      ??Str_FmtNbr_Int32_1
   3480              }
   3481          
   3482              if (nbr_dig < 1) {                                          /* If nbr digs = 0, ...                                 */
   \                     ??Str_FmtNbr_Int32_0: (+1)
   \   00000020   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000024   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000028   0xD101             BNE.N    ??Str_FmtNbr_Int32_2
   3483                  fmt_valid = DEF_NO;                                     /* ... fmt valid str (see Note #6b).                    */
   \   0000002A   0xF05F 0x0800      MOVS     R8,#+0
   3484              }
   3485                                                                          /* If invalid base, ...                                 */
   3486              if ((nbr_base <  2u) ||
   3487                  (nbr_base > 36u)) {
   \                     ??Str_FmtNbr_Int32_2: (+1)
   \   0000002E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000030   0x1EA0             SUBS     R0,R4,#+2
   \   00000032   0x2823             CMP      R0,#+35
   \   00000034   0xD301             BCC.N    ??Str_FmtNbr_Int32_3
   3488                  fmt_valid = DEF_NO;                                     /* ... fmt valid str (see Note #6d).                  */
   \   00000036   0xF05F 0x0800      MOVS     R8,#+0
   \                     ??Str_FmtNbr_Int32_3: (+1)
   \   0000003A   0x9D0A             LDR      R5,[SP, #+40]
   3489              }
   3490          
   3491              if (lead_char != (CPU_CHAR)'\0') {
   \   0000003C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003E   0x2D00             CMP      R5,#+0
   \   00000040   0xD032             BEQ.N    ??Str_FmtNbr_Int32_4
   3492                  print_char =  ASCII_IsPrint(lead_char);
   \   00000042   0x0028             MOVS     R0,R5
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   0x.... 0x....      BL       ASCII_IsPrint
   3493                  if (print_char != DEF_YES) {                            /* If lead char non-printable (see Note #3a1), ...      */
   \   0000004A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004C   0x2801             CMP      R0,#+1
   \   0000004E   0xD002             BEQ.N    ??Str_FmtNbr_Int32_5
   3494                      fmt_valid = DEF_NO;                                 /* ... fmt valid str          (see Note #6e).           */
   \   00000050   0xF05F 0x0800      MOVS     R8,#+0
   \   00000054   0xE028             B.N      ??Str_FmtNbr_Int32_4
   3495          
   3496                  } else if (lead_char != '0') {                          /* Chk lead char for non-0 nbr base dig.                */
   \                     ??Str_FmtNbr_Int32_5: (+1)
   \   00000056   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000058   0x2D30             CMP      R5,#+48
   \   0000005A   0xD025             BEQ.N    ??Str_FmtNbr_Int32_4
   3497                      lead_char_delta_0 = (CPU_INT08U)(lead_char - '0');
   \   0000005C   0xF1B5 0x0030      SUBS     R0,R5,#+48
   3498                      if (lower_case != DEF_YES) {
   \   00000060   0xF89D 0x102C      LDRB     R1,[SP, #+44]
   \   00000064   0x2901             CMP      R1,#+1
   \   00000066   0xD002             BEQ.N    ??Str_FmtNbr_Int32_6
   3499                          lead_char_delta_a = (CPU_INT08U)(lead_char - 'A');
   \   00000068   0xF1B5 0x0141      SUBS     R1,R5,#+65
   \   0000006C   0xE001             B.N      ??Str_FmtNbr_Int32_7
   3500                      } else {
   3501                          lead_char_delta_a = (CPU_INT08U)(lead_char - 'a');
   \                     ??Str_FmtNbr_Int32_6: (+1)
   \   0000006E   0xF1B5 0x0161      SUBS     R1,R5,#+97
   3502                      }
   3503          
   3504                      lead_char_dig = (((nbr_base <= 10u) &&  (lead_char_delta_0 <  nbr_base))      ||
   3505                                       ((nbr_base >  10u) && ((lead_char_delta_0 <             10u) ||
   3506                                                              (lead_char_delta_a < (nbr_base - 10u))))) ? DEF_YES : DEF_NO;
   \                     ??Str_FmtNbr_Int32_7: (+1)
   \   00000072   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000074   0x2C0B             CMP      R4,#+11
   \   00000076   0xD203             BCS.N    ??Str_FmtNbr_Int32_8
   \   00000078   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000007C   0x42A0             CMP      R0,R4
   \   0000007E   0xD30B             BCC.N    ??Str_FmtNbr_Int32_9
   \                     ??Str_FmtNbr_Int32_8: (+1)
   \   00000080   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000082   0x2C0B             CMP      R4,#+11
   \   00000084   0xD30A             BCC.N    ??Str_FmtNbr_Int32_10
   \   00000086   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000088   0x280A             CMP      R0,#+10
   \   0000008A   0xD305             BCC.N    ??Str_FmtNbr_Int32_9
   \   0000008C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000008E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000090   0xF1B4 0x000A      SUBS     R0,R4,#+10
   \   00000094   0x4281             CMP      R1,R0
   \   00000096   0xD201             BCS.N    ??Str_FmtNbr_Int32_10
   \                     ??Str_FmtNbr_Int32_9: (+1)
   \   00000098   0x2001             MOVS     R0,#+1
   \   0000009A   0xE000             B.N      ??Str_FmtNbr_Int32_11
   \                     ??Str_FmtNbr_Int32_10: (+1)
   \   0000009C   0x2000             MOVS     R0,#+0
   3507          
   3508                      if (lead_char_dig == DEF_YES) {                     /* If lead char non-0 nbr base dig (see Note #3a2A), ...*/
   \                     ??Str_FmtNbr_Int32_11: (+1)
   \   0000009E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A0   0x2801             CMP      R0,#+1
   \   000000A2   0xD101             BNE.N    ??Str_FmtNbr_Int32_4
   3509                          fmt_valid = DEF_NO;                             /* ... fmt valid str               (see Note #6e).      */
   \   000000A4   0xF05F 0x0800      MOVS     R8,#+0
   3510                      }
   3511                  }
   3512              }
   3513          
   3514          
   3515                                                                          /* ----------------- PREPARE NBR FMT ------------------ */
   3516              pstr_fmt    = pstr;
   \                     ??Str_FmtNbr_Int32_4: (+1)
   \   000000A8   0x990D             LDR      R1,[SP, #+52]
   3517              lead_char_0 = DEF_NO;
   \   000000AA   0x2200             MOVS     R2,#+0
   3518          
   3519              if (fmt_valid == DEF_YES) {
   \   000000AC   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000B0   0xF1B8 0x0F01      CMP      R8,#+1
   \   000000B4   0xD136             BNE.N    ??Str_FmtNbr_Int32_12
   3520                  nbr_fmt     = nbr;
   \   000000B6   0x465E             MOV      R6,R11
   3521                  nbr_log     = nbr;
   3522                  nbr_dig_max = 1u;
   \   000000B8   0x2001             MOVS     R0,#+1
   \   000000BA   0xE003             B.N      ??Str_FmtNbr_Int32_13
   3523                  while (nbr_log >= nbr_base) {                           /* While nbr base digs avail, ...                       */
   3524                      nbr_dig_max++;                                      /* ... calc max nbr digs.                               */
   \                     ??Str_FmtNbr_Int32_14: (+1)
   \   000000BC   0x1C40             ADDS     R0,R0,#+1
   3525                      nbr_log /= nbr_base;
   \   000000BE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000C0   0xFBBB 0xFBF4      UDIV     R11,R11,R4
   3526                  }
   \                     ??Str_FmtNbr_Int32_13: (+1)
   \   000000C4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000C6   0x45A3             CMP      R11,R4
   \   000000C8   0xD2F8             BCS.N    ??Str_FmtNbr_Int32_14
   3527          
   3528                  nbr_neg_sign = (nbr_neg == DEF_YES) ? 1u : 0u;
   \   000000CA   0xF89D 0x3000      LDRB     R3,[SP, #+0]
   \   000000CE   0x2B01             CMP      R3,#+1
   \   000000D0   0xD101             BNE.N    ??Str_FmtNbr_Int32_15
   \   000000D2   0x2301             MOVS     R3,#+1
   \   000000D4   0xE000             B.N      ??Str_FmtNbr_Int32_16
   \                     ??Str_FmtNbr_Int32_15: (+1)
   \   000000D6   0x2300             MOVS     R3,#+0
   3529                  if (nbr_dig >= (nbr_dig_max + nbr_neg_sign)) {          /* If req'd nbr digs >= (max nbr digs + neg sign), ...  */
   \                     ??Str_FmtNbr_Int32_16: (+1)
   \   000000D8   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000DC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000DE   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000000E0   0xEB13 0x0C00      ADDS     R12,R3,R0
   \   000000E4   0x45E2             CMP      R10,R12
   \   000000E6   0xDB1B             BLT.N    ??Str_FmtNbr_Int32_17
   3530                      nbr_neg_fmtd = DEF_NO;
   \   000000E8   0xF05F 0x0900      MOVS     R9,#+0
   3531                      nbr_dig_min  = DEF_MIN(nbr_dig_max, nbr_dig);
   \   000000EC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000EE   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000F2   0x4550             CMP      R0,R10
   \   000000F4   0xD300             BCC.N    ??Str_FmtNbr_Int32_18
   \                     ??Str_FmtNbr_Int32_19: (+1)
   \   000000F6   0x4650             MOV      R0,R10
   3532                                                                          /* ... calc nbr digs to fmt & nbr lead chars.           */
   3533                      if (lead_char != (CPU_CHAR)'\0') {
   \                     ??Str_FmtNbr_Int32_18: (+1)
   \   000000F8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000FA   0x2D00             CMP      R5,#+0
   \   000000FC   0xD004             BEQ.N    ??Str_FmtNbr_Int32_20
   3534                          nbr_dig_fmtd  = nbr_dig;
   \   000000FE   0x4657             MOV      R7,R10
   3535                          nbr_lead_char = nbr_dig     -
   3536                                         (nbr_dig_min + nbr_neg_sign);
   \   00000100   0xEBBA 0x0000      SUBS     R0,R10,R0
   \   00000104   0x1AC0             SUBS     R0,R0,R3
   \   00000106   0xE001             B.N      ??Str_FmtNbr_Int32_21
   3537                      } else {
   3538                          nbr_dig_fmtd  = nbr_dig_min + nbr_neg_sign;
   \                     ??Str_FmtNbr_Int32_20: (+1)
   \   00000108   0x181F             ADDS     R7,R3,R0
   3539                          nbr_lead_char = 0u;
   \   0000010A   0x2000             MOVS     R0,#+0
   3540                      }
   3541          
   3542                      if (nbr_lead_char > 0) {                            /* If lead chars to fmt, ...                            */
   \                     ??Str_FmtNbr_Int32_21: (+1)
   \   0000010C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000010E   0x2800             CMP      R0,#+0
   \   00000110   0xD008             BEQ.N    ??Str_FmtNbr_Int32_12
   3543                          lead_char_0 = (lead_char == '0')                /* ... chk if lead char a '0' dig (see Note #3a2B).     */
   3544                                      ?  DEF_YES : DEF_NO;
   \   00000112   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000114   0x2D30             CMP      R5,#+48
   \   00000116   0xD101             BNE.N    ??Str_FmtNbr_Int32_22
   \   00000118   0x2201             MOVS     R2,#+1
   \   0000011A   0xE003             B.N      ??Str_FmtNbr_Int32_12
   \                     ??Str_FmtNbr_Int32_22: (+1)
   \   0000011C   0x2200             MOVS     R2,#+0
   \   0000011E   0xE001             B.N      ??Str_FmtNbr_Int32_12
   3545                      }
   3546          
   3547                  } else {                                                /* Else if nbr trunc'd, ...                             */
   3548                      fmt_valid = DEF_NO;                                 /* ... fmt valid str (see Note #6c).                    */
   \                     ??Str_FmtNbr_Int32_17: (+1)
   \   00000120   0xF05F 0x0800      MOVS     R8,#+0
   3549                  }
   3550              }
   3551          
   3552              if (fmt_valid == DEF_NO) {
   \                     ??Str_FmtNbr_Int32_12: (+1)
   \   00000124   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000128   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000012C   0xD100             BNE.N    ??Str_FmtNbr_Int32_23
   3553                  nbr_dig_fmtd = nbr_dig;
   \   0000012E   0x4657             MOV      R7,R10
   3554              }
   3555          
   3556          
   3557                                                                          /* ------------------- FMT NBR STR -------------------- */
   3558              pstr_fmt += nbr_dig_fmtd;                                   /* Start fmt @ least-sig dig.                           */
   \                     ??Str_FmtNbr_Int32_23: (+1)
   \   00000130   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000132   0x1879             ADDS     R1,R7,R1
   3559          
   3560              if (nul != DEF_NO) {                                        /* If NOT DISABLED, append NULL char (see Note #4).     */
   \   00000134   0x980C             LDR      R0,[SP, #+48]
   \   00000136   0x2800             CMP      R0,#+0
   \   00000138   0xD001             BEQ.N    ??Str_FmtNbr_Int32_24
   3561                 *pstr_fmt = (CPU_CHAR)'\0';
   \   0000013A   0x2000             MOVS     R0,#+0
   \   0000013C   0x7008             STRB     R0,[R1, #+0]
   3562              }
   3563              pstr_fmt--;
   \                     ??Str_FmtNbr_Int32_24: (+1)
   \   0000013E   0x1E49             SUBS     R1,R1,#+1
   3564          
   3565          
   3566              for (i = 0u; i < nbr_dig_fmtd; i++) {                       /* Fmt str for desired nbr digs :                       */
   \   00000140   0x2000             MOVS     R0,#+0
   \   00000142   0xE003             B.N      ??Str_FmtNbr_Int32_25
   3567                  if (fmt_valid == DEF_YES) {
   3568                      if ((nbr_fmt > 0) ||                                /* If fmt nbr > 0                               ...     */
   3569                          (i == 0u)) {                                    /* ... OR on one's  dig to fmt (see Note #3c1), ...     */
   3570                                                                          /* ... calc & fmt dig val;                      ...     */
   3571                          dig_val = (CPU_INT08U)(nbr_fmt % nbr_base);
   3572                          if (dig_val < 10u) {
   3573                             *pstr_fmt-- = (CPU_CHAR)(dig_val + '0');
   3574                          } else {
   3575                              if (lower_case !=  DEF_YES) {
   3576                                 *pstr_fmt--  = (CPU_CHAR)((dig_val - 10u) + 'A');
   3577                              } else {
   3578                                 *pstr_fmt--  = (CPU_CHAR)((dig_val - 10u) + 'a');
   3579                              }
   3580                          }
   3581          
   3582                          nbr_fmt /= nbr_base;                            /* Shift to next more-sig dig.                          */
   3583          
   3584                      } else if ((nbr_neg      == DEF_YES)  &&            /* ... else if nbr neg             AND          ...     */
   3585                               (((lead_char_0  == DEF_NO )  &&            /* ... lead char NOT a '0' dig                  ...     */
   3586                                 (nbr_neg_fmtd == DEF_NO )) ||            /* ... but neg sign NOT yet fmt'd  OR           ...     */
   3587                                ((lead_char_0  != DEF_NO )  &&            /* ... lead char is  a '0' dig                  ...     */
   3588                                 (i == (nbr_dig_fmtd - 1u))))) {          /* ... & on most-sig dig to fmt,                ...     */
   3589          
   3590                         *pstr_fmt--   = '-';                             /* ... prepend neg sign (see Note #3b);         ...     */
   3591                          nbr_neg_fmtd = DEF_YES;
   3592          
   3593                      } else if (lead_char != (CPU_CHAR)'\0') {           /* ... else if avail,                           ...     */
   3594                         *pstr_fmt-- = lead_char;                         /* ... fmt lead char.                                   */
   3595                      }
   3596          
   3597                  } else {                                                /* Else fmt '?' for invalid str (see Note #7).          */
   3598                     *pstr_fmt-- = '?';
   \                     ??Str_FmtNbr_Int32_26: (+1)
   \   00000144   0x233F             MOVS     R3,#+63
   \   00000146   0x700B             STRB     R3,[R1, #+0]
   \   00000148   0x1E49             SUBS     R1,R1,#+1
   3599                  }
   \                     ??Str_FmtNbr_Int32_27: (+1)
   \   0000014A   0x1C40             ADDS     R0,R0,#+1
   \                     ??Str_FmtNbr_Int32_25: (+1)
   \   0000014C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000014E   0x42B8             CMP      R0,R7
   \   00000150   0xD243             BCS.N    ??Str_FmtNbr_Int32_28
   \   00000152   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000156   0xF1B8 0x0F01      CMP      R8,#+1
   \   0000015A   0xD1F3             BNE.N    ??Str_FmtNbr_Int32_26
   \   0000015C   0x2E00             CMP      R6,#+0
   \   0000015E   0xD101             BNE.N    ??Str_FmtNbr_Int32_29
   \   00000160   0x2800             CMP      R0,#+0
   \   00000162   0xD11B             BNE.N    ??Str_FmtNbr_Int32_30
   \                     ??Str_FmtNbr_Int32_29: (+1)
   \   00000164   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000166   0xFBB6 0xF3F4      UDIV     R3,R6,R4
   \   0000016A   0xFB04 0x6313      MLS      R3,R4,R3,R6
   \   0000016E   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000170   0x2B0A             CMP      R3,#+10
   \   00000172   0xD203             BCS.N    ??Str_FmtNbr_Int32_31
   \   00000174   0x3330             ADDS     R3,R3,#+48
   \   00000176   0x700B             STRB     R3,[R1, #+0]
   \   00000178   0x1E49             SUBS     R1,R1,#+1
   \   0000017A   0xE00B             B.N      ??Str_FmtNbr_Int32_32
   \                     ??Str_FmtNbr_Int32_31: (+1)
   \   0000017C   0xF89D 0xC02C      LDRB     R12,[SP, #+44]
   \   00000180   0xF1BC 0x0F01      CMP      R12,#+1
   \   00000184   0xD003             BEQ.N    ??Str_FmtNbr_Int32_33
   \   00000186   0x3337             ADDS     R3,R3,#+55
   \   00000188   0x700B             STRB     R3,[R1, #+0]
   \   0000018A   0x1E49             SUBS     R1,R1,#+1
   \   0000018C   0xE002             B.N      ??Str_FmtNbr_Int32_32
   \                     ??Str_FmtNbr_Int32_33: (+1)
   \   0000018E   0x3357             ADDS     R3,R3,#+87
   \   00000190   0x700B             STRB     R3,[R1, #+0]
   \   00000192   0x1E49             SUBS     R1,R1,#+1
   \                     ??Str_FmtNbr_Int32_32: (+1)
   \   00000194   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000196   0xFBB6 0xF6F4      UDIV     R6,R6,R4
   \   0000019A   0xE7D6             B.N      ??Str_FmtNbr_Int32_27
   \                     ??Str_FmtNbr_Int32_30: (+1)
   \   0000019C   0xF89D 0x3000      LDRB     R3,[SP, #+0]
   \   000001A0   0x2B01             CMP      R3,#+1
   \   000001A2   0xD114             BNE.N    ??Str_FmtNbr_Int32_34
   \   000001A4   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000001A6   0x2A00             CMP      R2,#+0
   \   000001A8   0xD104             BNE.N    ??Str_FmtNbr_Int32_35
   \   000001AA   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000001AE   0xF1B9 0x0F00      CMP      R9,#+0
   \   000001B2   0xD006             BEQ.N    ??Str_FmtNbr_Int32_36
   \                     ??Str_FmtNbr_Int32_35: (+1)
   \   000001B4   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000001B6   0x2A00             CMP      R2,#+0
   \   000001B8   0xD009             BEQ.N    ??Str_FmtNbr_Int32_34
   \   000001BA   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000001BC   0x1E7B             SUBS     R3,R7,#+1
   \   000001BE   0x4298             CMP      R0,R3
   \   000001C0   0xD105             BNE.N    ??Str_FmtNbr_Int32_34
   \                     ??Str_FmtNbr_Int32_36: (+1)
   \   000001C2   0x232D             MOVS     R3,#+45
   \   000001C4   0x700B             STRB     R3,[R1, #+0]
   \   000001C6   0x1E49             SUBS     R1,R1,#+1
   \   000001C8   0xF05F 0x0901      MOVS     R9,#+1
   \   000001CC   0xE7BD             B.N      ??Str_FmtNbr_Int32_27
   \                     ??Str_FmtNbr_Int32_34: (+1)
   \   000001CE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001D0   0x2D00             CMP      R5,#+0
   \   000001D2   0xD0BA             BEQ.N    ??Str_FmtNbr_Int32_27
   \   000001D4   0x700D             STRB     R5,[R1, #+0]
   \   000001D6   0x1E49             SUBS     R1,R1,#+1
   \   000001D8   0xE7B7             B.N      ??Str_FmtNbr_Int32_27
   3600              }
   3601          
   3602          
   3603              if (fmt_valid == DEF_NO) {                                /* Rtn NULL for invalid str fmt (see Notes #6a - #6e).  */
   \                     ??Str_FmtNbr_Int32_28: (+1)
   \   000001DA   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001DE   0xF1B8 0x0F00      CMP      R8,#+0
   \   000001E2   0xD101             BNE.N    ??Str_FmtNbr_Int32_37
   3604                  return ((CPU_CHAR *)0);
   \   000001E4   0x2000             MOVS     R0,#+0
   \   000001E6   0xE000             B.N      ??Str_FmtNbr_Int32_1
   3605              }
   3606          
   3607          
   3608              return (pstr);                                              /* Rtn ptr to fmt'd str (see Note #6f).                 */
   \                     ??Str_FmtNbr_Int32_37: (+1)
   \   000001E8   0x980D             LDR      R0,[SP, #+52]
   \                     ??Str_FmtNbr_Int32_1: (+1)
   \   000001EA   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   3609          }
   3610          
   3611          
   3612          /*
   3613          *********************************************************************************************************
   3614          *                                        Str_ParseNbr_Int32()
   3615          *
   3616          * Description : Parse 32-bit integer from string.
   3617          *
   3618          * Argument(s) : pstr            Pointer to string (see Notes #1 & #2a).
   3619          *
   3620          *               pstr_next       Optional pointer to a variable to ... :
   3621          *
   3622          *                                   (a) Return a pointer to first character following the integer string,
   3623          *                                           if NO error(s) [see Note #2a2B2];
   3624          *                                   (b) Return a pointer to 'pstr',
   3625          *                                           otherwise      (see Note #2a2A2).
   3626          *
   3627          *               nbr_base        Base of number to parse (see Notes #2a1B1 & #2a2B1).
   3628          *
   3629          *               nbr_signed      Indicates whether number to parse is signed :
   3630          *
   3631          *                                   DEF_NO                  Number is unsigned.
   3632          *                                   DEF_YES                 Number is   signed.
   3633          *
   3634          *               pnbr_neg        Pointer to a variable to return if the parsed (signed) number is negative :
   3635          *
   3636          *                                   DEF_NO                  Number is non-negative.
   3637          *                                   DEF_YES                 Number is     negative.
   3638          *
   3639          * Return(s)   : Parsed integer,      if integer parsed with NO overflow   (see Note #2a3A).
   3640          *
   3641          *               DEF_INT_32U_MAX_VAL, if integer parsed but     overflowed (see Note #2a3A1).
   3642          *
   3643          *               0,                   otherwise                            (see Note #2a3B).
   3644          *
   3645          * Caller(s)   : Str_ParseNbr_Int32U(),
   3646          *               Str_ParseNbr_Int32S().
   3647          *
   3648          * Note(s)     : (1) String buffer NOT modified.
   3649          *
   3650          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strtol() : DESCRIPTION' states that "these
   3651          *                       functions shall convert the initial portion of the string pointed to by 'str' ('pstr')
   3652          *                       to a type long ... representation" :
   3653          *
   3654          *                       (1) "First, they decompose the input string into three parts" :
   3655          *
   3656          *                           (A) "An initial, possibly empty, sequence of white-space characters [as specified
   3657          *                                by isspace()]."
   3658          *
   3659          *                               (1) "The subject sequence is defined as the longest initial subsequence of the
   3660          *                                    input string, starting with the first non-white-space character that is of
   3661          *                                    the expected form.  The subject sequence shall contain no characters if the
   3662          *                                    input string is empty or consists entirely of white-space characters."
   3663          *
   3664          *                           (B) (1) "A subject sequence interpreted as an integer represented in some radix
   3665          *                                    determined by the value of 'base' ('nbr_base')" :
   3666          *
   3667          *                                   (a) "If the value of 'base' ('nbr_base') is 0, the expected form of the
   3668          *                                        subject sequence is that of a decimal constant, octal constant, or
   3669          *                                        hexadecimal constant" :
   3670          *
   3671          *                                       (1) "A decimal constant begins with a non-zero digit, and consists of a
   3672          *                                            sequence of decimal digits."
   3673          *
   3674          *                                       (2) "An octal constant consists of the prefix '0' optionally followed by
   3675          *                                            a sequence of the digits '0' to '7' only."
   3676          *
   3677          *                                       (3) "A hexadecimal constant consists of the prefix '0x' or '0X' followed
   3678          *                                            by a sequence of the decimal digits and letters 'a' (or 'A') to 'f'
   3679          *                                            (or 'F') with values 10 to 15 respectively."
   3680          *
   3681          *                                   (b) "If the value of 'base' ('nbr_base') is between 2 and 36, the expected form
   3682          *                                        of the subject sequence is a sequence of letters and digits representing
   3683          *                                        an integer with the radix specified by 'base' ('nbr_base')" :
   3684          *
   3685          *                                       (1) (A) "The letters from 'a' (or 'A') to 'z' (or 'Z') inclusive are
   3686          *                                                ascribed the values 10 to 35"; ...
   3687          *                                           (B) "only letters whose ascribed values are less than that of base
   3688          *                                                are permitted."
   3689          *
   3690          *                                       (2) (A) "If the value of 'base' ('nbr_base') is 16, the characters '0x' or
   3691          *                                               '0X' may optionally precede the sequence of letters and digits."
   3692          *
   3693          *                                           (B) Although NO specification states that "if the value of 'base'
   3694          *                                               ('nbr_base') is" 8, the '0' character "may optionally precede
   3695          *                                               the sequence of letters and digits"; it seems reasonable to
   3696          *                                               allow the '0' character to be optionally parsed.
   3697          *
   3698          *                               (2) "A subject sequence .... may be preceded by a '+' or '-' sign."
   3699          *
   3700          *                                   (a) It does NOT seem reasonable to parse & convert a negative number
   3701          *                                       integer string into an unsigned integer.  However, a negative sign
   3702          *                                       for an unsigned integer will automatically be parsed as an invalid
   3703          *                                       character (see Note #2aC1).
   3704          *
   3705          *                           (C) (1) (a) "A final string of one or more unrecognized characters,"  ...
   3706          *                                   (b) "including the terminating null byte of the input string" ...
   3707          *                               (2) "other than a sign or a permissible letter or digit."
   3708          *
   3709          *                       (2) Second, "they shall attempt to convert the subject sequence to an integer" :
   3710          *
   3711          *                           (A) "If the subject sequence is empty or does not have the expected form" :
   3712          *
   3713          *                               (1) "no conversion is performed"; ...
   3714          *                               (2) "the value of 'str' ('pstr') is stored in the object pointed to by 'endptr'
   3715          *                                    ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null pointer."
   3716          *
   3717          *                           (B) "If the subject sequence has the expected form" :
   3718          *
   3719          *                               (1) (a) "and the value of 'base' ('nbr_base') is 0, the sequence of characters
   3720          *                                        starting with the first digit shall be interpreted as an integer constant."
   3721          *
   3722          *                                   (b) "and the value of 'base' ('nbr_base') is between 2 and 36, it shall be
   3723          *                                        used as the base for conversion, ascribing to each letter its value as
   3724          *                                        given above" (see Note #2a1B1b1A).
   3725          *
   3726          *                               (2) "A pointer to the final string shall be stored in the object pointed to by
   3727          *                                   'endptr' ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null
   3728          *                                   pointer."
   3729          *
   3730          *                       (3) Lastly, IEEE Std 1003.1, 2004 Edition, Section 'strtol() : RETURN VALUE' states that :
   3731          *
   3732          *                           (A) "Upon successful completion, these functions shall return the converted value."
   3733          *                               (1) "If the correct value is outside the range of representable values, {LONG_MIN}
   3734          *                                    [or] {LONG_MAX} ... shall be returned."
   3735          *
   3736          *                           (B) "If no conversion could be performed, 0 shall be returned."
   3737          *
   3738          *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
   3739          *                           shall fail if" :
   3740          *
   3741          *                           (A) "[EINVAL] - The value of 'base' ('nbr_base') is not supported."
   3742          *
   3743          *                           (B) "[ERANGE] - The value to be returned is not representable."
   3744          *
   3745          *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
   3746          *                           may fail if" :
   3747          *
   3748          *                           (A) "[EINVAL] - No conversion could be performed."
   3749          *
   3750          *               (3) Return integer value & next string pointer should be used to diagnose parse success or failure :
   3751          *
   3752          *                   (a) Valid parse string integer :
   3753          *
   3754          *                           pstr      = "     ABCDE xyz"
   3755          *                           nbr_base  = 16
   3756          *
   3757          *                           nbr       = 703710
   3758          *                           pstr_next = " xyz"
   3759          *
   3760          *
   3761          *                   (b) Invalid parse string integer :
   3762          *
   3763          *                           pstr      = "     ABCDE"
   3764          *                           nbr_base  = 10
   3765          *
   3766          *                           nbr       =  0
   3767          *                           pstr_next = pstr = "     ABCDE"
   3768          *
   3769          *
   3770          *                   (c) Valid hexadecimal parse string integer :
   3771          *
   3772          *                           pstr      = "     0xGABCDE"
   3773          *                           nbr_base  = 16
   3774          *
   3775          *                           nbr       =  0
   3776          *                           pstr_next = "xGABCDE"
   3777          *
   3778          *
   3779          *                   (d) Valid decimal parse string integer ('0x' prefix ignored
   3780          *                               following invalid hexadecimal characters) :
   3781          *
   3782          *                           pstr      = "     0xGABCDE"
   3783          *                           nbr_base  =  0
   3784          *
   3785          *                           nbr       =  0
   3786          *                           pstr_next = "xGABCDE"
   3787          *
   3788          *
   3789          *                   (e) Valid decimal parse string integer ('0'  prefix ignored
   3790          *                               following invalid octal       characters) :
   3791          *
   3792          *                           pstr      = "     0GABCDE"
   3793          *                           nbr_base  =  0
   3794          *
   3795          *                           nbr       =  0
   3796          *                           pstr_next = "GABCDE"
   3797          *
   3798          *
   3799          *                   (f) Parse string integer overflow :
   3800          *
   3801          *                           pstr      = "   12345678901234567890*123456"
   3802          *                           nbr_base  = 10
   3803          *
   3804          *                           nbr       = DEF_INT_32U_MAX_VAL
   3805          *                           pstr_next = "*123456"
   3806          *
   3807          *
   3808          *                   (g) Parse string integer underflow :
   3809          *
   3810          *                           pstr      = "  -12345678901234567890*123456"
   3811          *                           nbr_base  = 10
   3812          *
   3813          *                           nbr       = DEF_INT_32S_MIN_VAL
   3814          *                           pstr_next = "*123456"
   3815          *
   3816          *
   3817          *               (4) String parse terminates when :
   3818          *
   3819          *                   (a) Base passed an invalid base (see Note #2a1B1b).
   3820          *                       (1) No conversion performed; 0 returned.
   3821          *
   3822          *                   (b) (1) Parse string passed a NULL pointer OR empty integer sequence (see Note #2a2A).
   3823          *                           (A) No conversion performed; 0 returned.
   3824          *
   3825          *                       (2) Invalid parse string character found (see Note #2a1C).
   3826          *                           (A) Parsed integer returned.
   3827          *                           (B) 'pstr_next' points to invalid character.
   3828          *
   3829          *                       (3) Entire  parse string converted (see Note #2a2B).
   3830          *                           (A) Parsed integer returned.
   3831          *                           (B) 'pstr_next' points to terminating NULL character.
   3832          *
   3833          *               (5) Pointers to variables that return values MUST be initialized PRIOR to all other
   3834          *                   validation or function handling in case of any error(s).
   3835          *********************************************************************************************************
   3836          */
   3837          

   \                                 In section .text, align 2, keep-with-next
   3838          static  CPU_INT32U  Str_ParseNbr_Int32 (const  CPU_CHAR      *pstr,
   3839                                                         CPU_CHAR     **pstr_next,
   3840                                                         CPU_INT08U     nbr_base,
   3841                                                         CPU_BOOLEAN    nbr_signed,
   3842                                                         CPU_BOOLEAN   *pnbr_neg)
   3843          {
   \                     Str_ParseNbr_Int32: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   3844              const  CPU_CHAR     *pstr_parse;
   3845              const  CPU_CHAR     *pstr_parse_nbr;
   3846                     CPU_CHAR     *pstr_parse_unused;
   3847                     CPU_CHAR      parse_char;
   3848                     CPU_INT08U    parse_dig;
   3849                     CPU_INT32U    nbr;
   3850                     CPU_BOOLEAN   nbr_neg_unused;
   3851                     CPU_BOOLEAN   nbr_dig;
   3852                     CPU_BOOLEAN   nbr_alpha;
   3853                     CPU_BOOLEAN   nbr_hex;
   3854                     CPU_BOOLEAN   nbr_hex_lower;
   3855                     CPU_BOOLEAN   whitespace;
   3856                     CPU_BOOLEAN   neg;
   3857                     CPU_BOOLEAN   ovf;
   3858                     CPU_BOOLEAN   done;
   3859          
   3860                                                                          /* --------------- VALIDATE PARSE ARGS ---------------- */
   3861              if (pstr_next == (CPU_CHAR **) 0) {                         /* If NOT avail, ...                                    */
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD101             BNE.N    ??Str_ParseNbr_Int32_0
   3862                  pstr_next  = (CPU_CHAR **)&pstr_parse_unused;           /* ... re-cfg NULL rtn ptr to unused local var.         */
   \   00000010   0xAC01             ADD      R4,SP,#+4
   3863                 (void)&pstr_parse_unused;                                /* Prevent possible 'variable unused' warning.          */
   \   00000012   0xA801             ADD      R0,SP,#+4
   3864              }
   3865             *pstr_next = (CPU_CHAR *)pstr;                               /* Init rtn str for err (see Note #5).                  */
   \                     ??Str_ParseNbr_Int32_0: (+1)
   \   00000014   0x9804             LDR      R0,[SP, #+16]
   \   00000016   0x6020             STR      R0,[R4, #+0]
   3866          
   3867              if (pnbr_neg == (CPU_BOOLEAN *) 0) {                        /* If NOT avail, ...                                    */
   \   00000018   0x980E             LDR      R0,[SP, #+56]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD102             BNE.N    ??Str_ParseNbr_Int32_1
   3868                  pnbr_neg  = (CPU_BOOLEAN *)&nbr_neg_unused;             /* ... re-cfg NULL rtn ptr to unused local var.         */
   \   0000001E   0x4668             MOV      R0,SP
   \   00000020   0x900E             STR      R0,[SP, #+56]
   3869                 (void)&nbr_neg_unused;                                   /* Prevent possible 'variable unused' warning.          */
   \   00000022   0x4668             MOV      R0,SP
   3870              }
   3871             *pnbr_neg = DEF_NO;                                          /* Init nbr neg for err (see Note #5).                  */
   \                     ??Str_ParseNbr_Int32_1: (+1)
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x990E             LDR      R1,[SP, #+56]
   \   00000028   0x7008             STRB     R0,[R1, #+0]
   3872          
   3873          
   3874              if (pstr == (CPU_CHAR *)0) {                                /* Rtn zero if str ptr NULL (see Note #4b1).            */
   \   0000002A   0x9804             LDR      R0,[SP, #+16]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD101             BNE.N    ??Str_ParseNbr_Int32_2
   3875                  return (0u);
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xE0C2             B.N      ??Str_ParseNbr_Int32_3
   3876              }
   3877                                                                          /* Rtn zero if invalid base (see Note #4a).             */
   3878              if ((nbr_base == 1u) ||
   3879                  (nbr_base > 36u)) {
   \                     ??Str_ParseNbr_Int32_2: (+1)
   \   00000034   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000036   0x2E01             CMP      R6,#+1
   \   00000038   0xD002             BEQ.N    ??Str_ParseNbr_Int32_4
   \   0000003A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000003C   0x2E25             CMP      R6,#+37
   \   0000003E   0xD301             BCC.N    ??Str_ParseNbr_Int32_5
   3880                  return (0u);
   \                     ??Str_ParseNbr_Int32_4: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xE0BA             B.N      ??Str_ParseNbr_Int32_3
   3881              }
   3882          
   3883          
   3884                                                                          /* ------------- IGNORE PRECEDING CHAR(S) ------------- */
   3885              pstr_parse = pstr;                                          /* Save ptr to init'l str for err (see Note #2a2A2).    */
   \                     ??Str_ParseNbr_Int32_5: (+1)
   \   00000044   0x9D04             LDR      R5,[SP, #+16]
   3886          
   3887              whitespace = ASCII_IsSpace(*pstr_parse);
   \   00000046   0x7828             LDRB     R0,[R5, #+0]
   \   00000048   0x.... 0x....      BL       ASCII_IsSpace
   \   0000004C   0xE003             B.N      ??Str_ParseNbr_Int32_6
   3888              while (whitespace == DEF_YES) {                             /* Ignore initial white-space char(s) [see Note #2a1A]. */
   3889                  pstr_parse++;
   \                     ??Str_ParseNbr_Int32_7: (+1)
   \   0000004E   0x1C6D             ADDS     R5,R5,#+1
   3890                  whitespace = ASCII_IsSpace(*pstr_parse);
   \   00000050   0x7828             LDRB     R0,[R5, #+0]
   \   00000052   0x.... 0x....      BL       ASCII_IsSpace
   3891              }
   \                     ??Str_ParseNbr_Int32_6: (+1)
   \   00000056   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000058   0x2801             CMP      R0,#+1
   \   0000005A   0xD0F8             BEQ.N    ??Str_ParseNbr_Int32_7
   3892          
   3893              switch (*pstr_parse) {
   \   0000005C   0x7828             LDRB     R0,[R5, #+0]
   \   0000005E   0x282B             CMP      R0,#+43
   \   00000060   0xD002             BEQ.N    ??Str_ParseNbr_Int32_8
   \   00000062   0x282D             CMP      R0,#+45
   \   00000064   0xD003             BEQ.N    ??Str_ParseNbr_Int32_9
   \   00000066   0xE008             B.N      ??Str_ParseNbr_Int32_10
   3894                  case '+':                                               /* Ignore   pos sign (see Note #2a1B2).                 */
   3895                       pstr_parse++;
   \                     ??Str_ParseNbr_Int32_8: (+1)
   \   00000068   0x1C6D             ADDS     R5,R5,#+1
   3896                       neg = DEF_NO;
   \   0000006A   0x2700             MOVS     R7,#+0
   3897                       break;
   \   0000006C   0xE006             B.N      ??Str_ParseNbr_Int32_11
   3898          
   3899          
   3900                  case '-':                                               /* Validate neg sign (see Note #2a1B2a).                */
   3901                       if (nbr_signed == DEF_YES) {
   \                     ??Str_ParseNbr_Int32_9: (+1)
   \   0000006E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000070   0x2F01             CMP      R7,#+1
   \   00000072   0xD100             BNE.N    ??Str_ParseNbr_Int32_12
   3902                           pstr_parse++;
   \   00000074   0x1C6D             ADDS     R5,R5,#+1
   3903                       }
   3904                       neg = DEF_YES;
   \                     ??Str_ParseNbr_Int32_12: (+1)
   \   00000076   0x2701             MOVS     R7,#+1
   3905                       break;
   \   00000078   0xE000             B.N      ??Str_ParseNbr_Int32_11
   3906          
   3907          
   3908                  default:
   3909                       neg = DEF_NO;
   \                     ??Str_ParseNbr_Int32_10: (+1)
   \   0000007A   0x2700             MOVS     R7,#+0
   3910                       break;
   3911              }
   3912          
   3913          
   3914                                                                          /* --------- IGNORE NBR BASE PRECEDING CHAR(S) -------- */
   3915              pstr_parse_nbr = pstr_parse;                                /* Save ptr to str's nbr (see Note #2a1A1).             */
   \                     ??Str_ParseNbr_Int32_11: (+1)
   \   0000007C   0x9502             STR      R5,[SP, #+8]
   3916          
   3917              switch (nbr_base) {
   \   0000007E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000080   0x0030             MOVS     R0,R6
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD004             BEQ.N    ??Str_ParseNbr_Int32_13
   \   00000086   0x2808             CMP      R0,#+8
   \   00000088   0xD01B             BEQ.N    ??Str_ParseNbr_Int32_14
   \   0000008A   0x2810             CMP      R0,#+16
   \   0000008C   0xD01E             BEQ.N    ??Str_ParseNbr_Int32_15
   \   0000008E   0xE032             B.N      ??Str_ParseNbr_Int32_16
   3918                  case  0u:                                               /* Determine unspecified nbr base (see Notes #2a1B1a).  */
   3919                       if (*pstr_parse == '0') {                          /* If avail, ...                                        */
   \                     ??Str_ParseNbr_Int32_13: (+1)
   \   00000090   0x7828             LDRB     R0,[R5, #+0]
   \   00000092   0x2830             CMP      R0,#+48
   \   00000094   0xD113             BNE.N    ??Str_ParseNbr_Int32_17
   3920                            pstr_parse++;                                 /* ... adv past '0'  prefix (see Note #2a1B1b2).        */
   \   00000096   0x1C6D             ADDS     R5,R5,#+1
   3921                            switch (*pstr_parse) {
   \   00000098   0x7828             LDRB     R0,[R5, #+0]
   \   0000009A   0x2858             CMP      R0,#+88
   \   0000009C   0xD001             BEQ.N    ??Str_ParseNbr_Int32_18
   \   0000009E   0x2878             CMP      R0,#+120
   \   000000A0   0xD10B             BNE.N    ??Str_ParseNbr_Int32_19
   3922                                case 'x':                                 /* For '0x' prefix, ...                                 */
   3923                                case 'X':
   3924                                     nbr_base   = 16u;                    /* ... set nbr base = 16    (see Note #2a1B1a3).        */
   \                     ??Str_ParseNbr_Int32_18: (+1)
   \   000000A2   0x2610             MOVS     R6,#+16
   3925                                     parse_char = (CPU_CHAR)(*(pstr_parse + 1));
   \   000000A4   0xF895 0xB001      LDRB     R11,[R5, #+1]
   3926                                     nbr_hex    =  ASCII_IsDigHex(parse_char);
   \   000000A8   0x4658             MOV      R0,R11
   \   000000AA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AC   0x.... 0x....      BL       ASCII_IsDigHex
   3927                                     if (nbr_hex == DEF_YES) {            /* If next char is valid hex dig, ...                   */
   \   000000B0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B2   0x2801             CMP      R0,#+1
   \   000000B4   0xD100             BNE.N    ??Str_ParseNbr_Int32_20
   3928                                         pstr_parse++;                    /* ... adv past '0x' prefix (see Note #2a1B1b2A).       */
   \   000000B6   0x1C6D             ADDS     R5,R5,#+1
   3929                                     }
   3930                                     break;
   \                     ??Str_ParseNbr_Int32_20: (+1)
   \   000000B8   0xE002             B.N      ??Str_ParseNbr_Int32_21
   3931          
   3932          
   3933                                default:                                  /* For '0'  prefix, ...                                 */
   3934                                     nbr_base =  8u;                      /* ... set nbr base =  8    (see Note #2a1B1a2).        */
   \                     ??Str_ParseNbr_Int32_19: (+1)
   \   000000BA   0x2608             MOVS     R6,#+8
   3935                                     break;
   \   000000BC   0xE000             B.N      ??Str_ParseNbr_Int32_21
   3936                            }
   3937          
   3938                       } else {                                           /* For non-'0' prefix, ...                              */
   3939                           nbr_base = 10u;                                /* ... set nbr base = 10    (see Note #2a1B1a1).        */
   \                     ??Str_ParseNbr_Int32_17: (+1)
   \   000000BE   0x260A             MOVS     R6,#+10
   3940                       }
   3941                       break;
   \                     ??Str_ParseNbr_Int32_21: (+1)
   \   000000C0   0xE019             B.N      ??Str_ParseNbr_Int32_22
   3942          
   3943          
   3944                  case  8u:                                               /* See Note #2a1B1a2.                                   */
   3945                       if (*pstr_parse == '0') {                          /* If avail, ...                                        */
   \                     ??Str_ParseNbr_Int32_14: (+1)
   \   000000C2   0x7828             LDRB     R0,[R5, #+0]
   \   000000C4   0x2830             CMP      R0,#+48
   \   000000C6   0xD100             BNE.N    ??Str_ParseNbr_Int32_23
   3946                            pstr_parse++;                                 /* ... adv past '0'  prefix (see Note #2a1B1b2B).       */
   \   000000C8   0x1C6D             ADDS     R5,R5,#+1
   3947                       }
   3948                       break;
   \                     ??Str_ParseNbr_Int32_23: (+1)
   \   000000CA   0xE014             B.N      ??Str_ParseNbr_Int32_22
   3949          
   3950          
   3951                  case 16u:                                               /* See Note #2a1B1a3.                                   */
   3952                       if (*pstr_parse == '0') {                          /* If avail, ...                                        */
   \                     ??Str_ParseNbr_Int32_15: (+1)
   \   000000CC   0x7828             LDRB     R0,[R5, #+0]
   \   000000CE   0x2830             CMP      R0,#+48
   \   000000D0   0xD110             BNE.N    ??Str_ParseNbr_Int32_24
   3953                            pstr_parse++;                                 /* ... adv past '0'  prefix (see Note #2a1B1b2).        */
   \   000000D2   0x1C6D             ADDS     R5,R5,#+1
   3954                            switch (*pstr_parse) {
   \   000000D4   0x7828             LDRB     R0,[R5, #+0]
   \   000000D6   0x2858             CMP      R0,#+88
   \   000000D8   0xD001             BEQ.N    ??Str_ParseNbr_Int32_25
   \   000000DA   0x2878             CMP      R0,#+120
   \   000000DC   0xD10A             BNE.N    ??Str_ParseNbr_Int32_26
   3955                                case 'x':
   3956                                case 'X':
   3957                                     parse_char = (CPU_CHAR)(*(pstr_parse + 1));
   \                     ??Str_ParseNbr_Int32_25: (+1)
   \   000000DE   0xF895 0xB001      LDRB     R11,[R5, #+1]
   3958                                     nbr_hex    =  ASCII_IsDigHex(parse_char);
   \   000000E2   0x4658             MOV      R0,R11
   \   000000E4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E6   0x.... 0x....      BL       ASCII_IsDigHex
   3959                                     if (nbr_hex == DEF_YES) {            /* If next char is valid hex dig, ...                   */
   \   000000EA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000EC   0x2801             CMP      R0,#+1
   \   000000EE   0xD100             BNE.N    ??Str_ParseNbr_Int32_27
   3960                                         pstr_parse++;                    /* ... adv past '0x' prefix (see Note #2a1B1b2A).       */
   \   000000F0   0x1C6D             ADDS     R5,R5,#+1
   3961                                     }
   3962                                     break;
   \                     ??Str_ParseNbr_Int32_27: (+1)
   \   000000F2   0xE7FF             B.N      ??Str_ParseNbr_Int32_24
   3963          
   3964          
   3965                                default:
   3966                                     break;
   3967                            }
   3968                       }
   3969                       break;
   \                     ??Str_ParseNbr_Int32_26: (+1)
   \                     ??Str_ParseNbr_Int32_24: (+1)
   \   000000F4   0xE7FF             B.N      ??Str_ParseNbr_Int32_22
   3970          
   3971          
   3972                  default:                                                /* See Note #2a1B1b.                                    */
   3973                       break;
   3974              }
   3975          
   3976          
   3977                                                                          /* ------------------ PARSE INT STR ------------------- */
   3978              nbr  = 0u;
   \                     ??Str_ParseNbr_Int32_16: (+1)
   \                     ??Str_ParseNbr_Int32_22: (+1)
   \   000000F6   0xF05F 0x0800      MOVS     R8,#+0
   3979              ovf  = DEF_NO;
   \   000000FA   0xF05F 0x0900      MOVS     R9,#+0
   3980              done = DEF_NO;
   \   000000FE   0xF05F 0x0A00      MOVS     R10,#+0
   \   00000102   0xE001             B.N      ??Str_ParseNbr_Int32_28
   3981          
   3982              while (done == DEF_NO) {                                    /* Parse str for desired nbr base digs (see Note #2a2). */
   3983                  parse_char = (CPU_CHAR)*pstr_parse;
   3984                  nbr_alpha  =  ASCII_IsAlphaNum(parse_char);
   3985                  if (nbr_alpha == DEF_YES) {                             /* If valid alpha num nbr dig avail, ...                */
   3986                                                                          /* ... convert parse char into nbr dig.                 */
   3987                      nbr_dig = ASCII_IsDig(parse_char);
   3988                      if (nbr_dig == DEF_YES) {
   3989                          parse_dig = (CPU_INT08U)(parse_char - '0');
   3990                      } else {
   3991                          nbr_hex_lower = ASCII_IsLower(parse_char);
   3992                          if (nbr_hex_lower == DEF_YES) {
   3993                              parse_dig = ((CPU_INT08U)(parse_char - 'a') + 10u);
   3994                          } else {
   3995                              parse_dig = ((CPU_INT08U)(parse_char - 'A') + 10u);
   3996                          }
   3997                      }
   3998          
   3999                      if (parse_dig < nbr_base) {                         /* If parse char valid for nbr base ...                 */
   4000                          if (ovf == DEF_NO) {                            /* ... & nbr NOT yet ovf'd,         ...                 */
   4001                              if (nbr <= Str_MultOvfThTbl_Int32U[nbr_base]) {
   4002                                                                          /* ... merge parse char dig into nbr.                   */
   4003                                  nbr *= nbr_base;
   4004                                  nbr += parse_dig;
   4005                                  if (nbr < parse_dig) {
   4006                                      ovf = DEF_YES;
   4007                                  }
   4008                              } else {
   4009                                  ovf = DEF_YES;
   4010                              }
   4011                          }
   4012                          pstr_parse++;
   4013          
   4014                      } else {                                            /* Invalid         char parsed (see Note #2a1C1a).      */
   4015                          done = DEF_YES;
   4016                      }
   4017          
   4018                  } else {                                                /* Invalid OR NULL char parsed (see Note #2a1C1).       */
   4019                      done = DEF_YES;
   \                     ??Str_ParseNbr_Int32_29: (+1)
   \   00000104   0xF05F 0x0A01      MOVS     R10,#+1
   4020                  }
   \                     ??Str_ParseNbr_Int32_28: (+1)
   \   00000108   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000010C   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000110   0xD142             BNE.N    ??Str_ParseNbr_Int32_30
   \   00000112   0xF895 0xB000      LDRB     R11,[R5, #+0]
   \   00000116   0x4658             MOV      R0,R11
   \   00000118   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000011A   0x.... 0x....      BL       ASCII_IsAlphaNum
   \   0000011E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000120   0x2801             CMP      R0,#+1
   \   00000122   0xD1EF             BNE.N    ??Str_ParseNbr_Int32_29
   \   00000124   0x4658             MOV      R0,R11
   \   00000126   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000128   0x.... 0x....      BL       ASCII_IsDig
   \   0000012C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000012E   0x2801             CMP      R0,#+1
   \   00000130   0xD102             BNE.N    ??Str_ParseNbr_Int32_31
   \   00000132   0xF1BB 0x0030      SUBS     R0,R11,#+48
   \   00000136   0xE00D             B.N      ??Str_ParseNbr_Int32_32
   \                     ??Str_ParseNbr_Int32_31: (+1)
   \   00000138   0x4658             MOV      R0,R11
   \   0000013A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000013C   0x.... 0x....      BL       ASCII_IsLower
   \   00000140   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000142   0x2801             CMP      R0,#+1
   \   00000144   0xD103             BNE.N    ??Str_ParseNbr_Int32_33
   \   00000146   0xF1BB 0x0061      SUBS     R0,R11,#+97
   \   0000014A   0x300A             ADDS     R0,R0,#+10
   \   0000014C   0xE002             B.N      ??Str_ParseNbr_Int32_32
   \                     ??Str_ParseNbr_Int32_33: (+1)
   \   0000014E   0xF1BB 0x0041      SUBS     R0,R11,#+65
   \   00000152   0x300A             ADDS     R0,R0,#+10
   \                     ??Str_ParseNbr_Int32_32: (+1)
   \   00000154   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000156   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000158   0x42B0             CMP      R0,R6
   \   0000015A   0xD21A             BCS.N    ??Str_ParseNbr_Int32_34
   \   0000015C   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000160   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000164   0xD113             BNE.N    ??Str_ParseNbr_Int32_35
   \   00000166   0x....             LDR.N    R1,??DataTable0
   \   00000168   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000016A   0xF851 0x1026      LDR      R1,[R1, R6, LSL #+2]
   \   0000016E   0x4541             CMP      R1,R8
   \   00000170   0xD30B             BCC.N    ??Str_ParseNbr_Int32_36
   \   00000172   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000174   0xFB06 0xF808      MUL      R8,R6,R8
   \   00000178   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000017A   0xEB10 0x0808      ADDS     R8,R0,R8
   \   0000017E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000180   0x4580             CMP      R8,R0
   \   00000182   0xD204             BCS.N    ??Str_ParseNbr_Int32_35
   \   00000184   0xF05F 0x0901      MOVS     R9,#+1
   \   00000188   0xE001             B.N      ??Str_ParseNbr_Int32_35
   \                     ??Str_ParseNbr_Int32_36: (+1)
   \   0000018A   0xF05F 0x0901      MOVS     R9,#+1
   \                     ??Str_ParseNbr_Int32_35: (+1)
   \   0000018E   0x1C6D             ADDS     R5,R5,#+1
   \   00000190   0xE7BA             B.N      ??Str_ParseNbr_Int32_28
   \                     ??Str_ParseNbr_Int32_34: (+1)
   \   00000192   0xF05F 0x0A01      MOVS     R10,#+1
   \   00000196   0xE7B7             B.N      ??Str_ParseNbr_Int32_28
   4021              }
   4022          
   4023              if (ovf == DEF_YES) {                                       /* If nbr ovf'd, ...                                    */
   \                     ??Str_ParseNbr_Int32_30: (+1)
   \   00000198   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000019C   0xF1B9 0x0F01      CMP      R9,#+1
   \   000001A0   0xD101             BNE.N    ??Str_ParseNbr_Int32_37
   4024                  nbr  = DEF_INT_32U_MAX_VAL;                             /* ... rtn max int val (see Note #2a3A1).               */
   \   000001A2   0xF05F 0x38FF      MOVS     R8,#-1
   4025              }
   4026          
   4027          
   4028              if (pstr_parse !=             pstr_parse_nbr) {             /* If final parse str != init'l parse nbr str,       .. */
   \                     ??Str_ParseNbr_Int32_37: (+1)
   \   000001A6   0x9802             LDR      R0,[SP, #+8]
   \   000001A8   0x4285             CMP      R5,R0
   \   000001AA   0xD001             BEQ.N    ??Str_ParseNbr_Int32_38
   4029                 *pstr_next   = (CPU_CHAR *)pstr_parse;                   /* .. rtn   parse str's next char (see Note #2a2B2); .. */
   \   000001AC   0x6025             STR      R5,[R4, #+0]
   \   000001AE   0xE001             B.N      ??Str_ParseNbr_Int32_39
   4030              } else {
   4031                 *pstr_next   = (CPU_CHAR *)pstr;                         /* .. else rtn initial parse str  (see Note #2a2A2).    */
   \                     ??Str_ParseNbr_Int32_38: (+1)
   \   000001B0   0x9804             LDR      R0,[SP, #+16]
   \   000001B2   0x6020             STR      R0,[R4, #+0]
   4032              }
   4033          
   4034             *pnbr_neg = neg;                                             /* Rtn neg nbr status.                                  */
   \                     ??Str_ParseNbr_Int32_39: (+1)
   \   000001B4   0x980E             LDR      R0,[SP, #+56]
   \   000001B6   0x7007             STRB     R7,[R0, #+0]
   4035          
   4036          
   4037              return (nbr);
   \   000001B8   0x4640             MOV      R0,R8
   \                     ??Str_ParseNbr_Int32_3: (+1)
   \   000001BA   0xB005             ADD      SP,SP,#+20
   \   000001BC   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   4038          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0x........         DC32     Str_MultOvfThTbl_Int32U
   4039          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   Str_Cat
         8   -> Str_Cat_N
       8   Str_Cat_N
       8   Str_Char
         8   -> Str_Char_N
       8   Str_Char_Last
         8   -> Str_Char_Last_N
      16   Str_Char_Last_N
        16   -> Str_Len_N
       4   Str_Char_N
       8   Str_Char_Replace
         8   -> Str_Char_Replace_N
       8   Str_Char_Replace_N
       8   Str_Cmp
         8   -> Str_Cmp_N
       8   Str_CmpIgnoreCase
         8   -> Str_CmpIgnoreCase_N
      32   Str_CmpIgnoreCase_N
        32   -> ASCII_ToLower
      16   Str_Cmp_N
       8   Str_Copy
         8   -> Str_Copy_N
       8   Str_Copy_N
      40   Str_FmtNbr_Int32
        40   -> ASCII_IsPrint
      32   Str_FmtNbr_Int32S
        32   -> Str_FmtNbr_Int32
      24   Str_FmtNbr_Int32U
        24   -> Str_FmtNbr_Int32
       8   Str_Len
         8   -> Str_Len_N
       0   Str_Len_N
      56   Str_ParseNbr_Int32
        56   -> ASCII_IsAlphaNum
        56   -> ASCII_IsDig
        56   -> ASCII_IsDigHex
        56   -> ASCII_IsLower
        56   -> ASCII_IsSpace
      16   Str_ParseNbr_Int32S
        16   -> Str_ParseNbr_Int32
       8   Str_ParseNbr_Int32U
         8   -> Str_ParseNbr_Int32
       8   Str_Str
         8   -> Str_Str_N
      32   Str_Str_N
        32   -> Str_Cmp_N
        32   -> Str_Len_N


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
      12  Str_Cat
      98  Str_Cat_N
      16  Str_Char
      16  Str_Char_Last
      72  Str_Char_Last_N
      80  Str_Char_N
      16  Str_Char_Replace
      54  Str_Char_Replace_N
      14  Str_Cmp
      14  Str_CmpIgnoreCase
     256  Str_CmpIgnoreCase_N
     148  Str_Cmp_N
      12  Str_Copy
      76  Str_Copy_N
     494  Str_FmtNbr_Int32
      48  Str_FmtNbr_Int32S
      32  Str_FmtNbr_Int32U
      12  Str_Len
      26  Str_Len_N
     148  Str_MultOvfThTbl_Int32U
     448  Str_ParseNbr_Int32
      54  Str_ParseNbr_Int32S
      16  Str_ParseNbr_Int32U
      12  Str_Str
     164  Str_Str_N

 
   148 bytes in section .rodata
 2 194 bytes in section .text
 
 2 194 bytes of CODE  memory
   148 bytes of CONST memory

Errors: none
Warnings: none
