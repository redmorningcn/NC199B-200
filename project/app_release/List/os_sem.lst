###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       11/Jul/2018  11:13:10
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC210\NC210-200处理板\source\Software\uCOS-III\Source\os_sem.c
#    Command line =  
#        F:\iar\NC210\NC210-200处理板\source\Software\uCOS-III\Source\os_sem.c
#        -D USE_STDPERIPH_DRIVER -D APP_RELEASE -lCN
#        F:\iar\NC210\NC210-200处理板\project\app_release\List -o
#        F:\iar\NC210\NC210-200处理板\project\app_release\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC210\NC210-200处理板\project\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\config\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\task\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\user\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\OS\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\Ports\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\driver\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-LIB\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Source\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\ST\STM32\inc\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Ports\STM32\STM32F103\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Source\
#        -Ol --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC210\NC210-200处理板\project\app_release\List\os_sem.lst
#    Object file  =  
#        F:\iar\NC210\NC210-200处理板\project\app_release\Obj\os_sem.o
#
###############################################################################

F:\iar\NC210\NC210-200处理板\source\Software\uCOS-III\Source\os_sem.c
      1          /*
      2          ************************************************************************************************************************
      3          *                                                      uC/OS-III
      4          *                                                 The Real-Time Kernel
      5          *
      6          *                                  (c) Copyright 2009-2016; Micrium, Inc.; Weston, FL
      7          *                           All rights reserved.  Protected by international copyright laws.
      8          *
      9          *                                                 SEMAPHORE MANAGEMENT
     10          *
     11          * File    : OS_SEM.C
     12          * By      : JJL
     13          * Version : V3.06.00
     14          *
     15          * LICENSING TERMS:
     16          * ---------------
     17          *           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or
     18          *           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
     19          *           product then, you need to contact Micrium to properly license uC/OS-III for its use in your
     20          *           application/product.   We provide ALL the source code for your convenience and to help you
     21          *           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use
     22          *           it commercially without paying a licensing fee.
     23          *
     24          *           Knowledge of the source code may NOT be used to develop a similar product.
     25          *
     26          *           Please help us continue to provide the embedded community with the finest software available.
     27          *           Your honesty is greatly appreciated.
     28          *
     29          *           You can find our product's user manual, API reference, release notes and
     30          *           more information at https://doc.micrium.com.
     31          *           You can contact us at www.micrium.com.
     32          ************************************************************************************************************************
     33          */
     34          
     35          #define  MICRIUM_SOURCE
     36          #include "os.h"
     37          
     38          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     39          const  CPU_CHAR  *os_sem__c = "$Id: $";
     40          #endif
     41          
     42          
     43          #if (OS_CFG_SEM_EN == DEF_ENABLED)
     44          /*
     45          ************************************************************************************************************************
     46          *                                                  CREATE A SEMAPHORE
     47          *
     48          * Description: This function creates a semaphore.
     49          *
     50          * Arguments  : p_sem         is a pointer to the semaphore to initialize.  Your application is responsible for
     51          *                            allocating storage for the semaphore.
     52          *
     53          *              p_name        is a pointer to the name you would like to give the semaphore.
     54          *
     55          *              cnt           is the initial value for the semaphore.
     56          *                            If used to share resources, you should initialize to the number of resources available.
     57          *                            If used to signal the occurrence of event(s) then you should initialize to 0.
     58          *
     59          *              p_err         is a pointer to a variable that will contain an error code returned by this function.
     60          *
     61          *                                OS_ERR_NONE                    If the call was successful
     62          *                                OS_ERR_CREATE_ISR              If you called this function from an ISR
     63          *                                OS_ERR_ILLEGAL_CREATE_RUN_TIME If you are trying to create the semaphore after you
     64          *                                                                 called OSSafetyCriticalStart()
     65          *                                OS_ERR_OBJ_PTR_NULL            If 'p_sem'  is a NULL pointer
     66          *
     67          * Returns    : none
     68          *
     69          * Note(s)    : none
     70          ************************************************************************************************************************
     71          */
     72          

   \                                 In section .text, align 2, keep-with-next
     73          void  OSSemCreate (OS_SEM      *p_sem,
     74                             CPU_CHAR    *p_name,
     75                             OS_SEM_CTR   cnt,
     76                             OS_ERR      *p_err)
     77          {
   \                     OSSemCreate: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x4690             MOV      R8,R2
   \   0000000A   0x001C             MOVS     R4,R3
     78              CPU_SR_ALLOC();
   \   0000000C   0x2700             MOVS     R7,#+0
     79          
     80          
     81          #ifdef OS_SAFETY_CRITICAL
     82              if (p_err == DEF_NULL) {
     83                  OS_SAFETY_CRITICAL_EXCEPTION();
     84                  return;
     85              }
     86          #endif
     87          
     88          #ifdef OS_SAFETY_CRITICAL_IEC61508
     89              if (OSSafetyCriticalStartFlag == DEF_TRUE) {
     90                 *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
     91                  return;
     92              }
     93          #endif
     94          
     95          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
     96              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to be called from an ISR                 */
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD003             BEQ.N    ??OSSemCreate_0
     97                 *p_err = OS_ERR_CREATE_ISR;
   \   00000018   0xF642 0x60E1      MOVW     R0,#+12001
   \   0000001C   0x8020             STRH     R0,[R4, #+0]
     98                  return;
   \   0000001E   0xE027             B.N      ??OSSemCreate_1
     99              }
    100          #endif
    101          
    102          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
    103              if (p_sem == DEF_NULL) {                                    /* Validate 'p_sem'                                     */
   \                     ??OSSemCreate_0: (+1)
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD103             BNE.N    ??OSSemCreate_2
    104                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000024   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000028   0x8020             STRH     R0,[R4, #+0]
    105                  return;
   \   0000002A   0xE021             B.N      ??OSSemCreate_1
    106              }
    107          #endif
    108          
    109              CPU_CRITICAL_ENTER();
   \                     ??OSSemCreate_2: (+1)
   \   0000002C   0x.... 0x....      BL       CPU_SR_Save
   \   00000030   0x0007             MOVS     R7,R0
   \   00000032   0x.... 0x....      BL       CPU_IntDisMeasStart
    110          #if (OS_OBJ_TYPE_REQ == DEF_ENABLED)
    111              p_sem->Type    = OS_OBJ_TYPE_SEM;                           /* Mark the data structure as a semaphore               */
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable8_2  ;; 0x414d4553
   \   0000003A   0x6028             STR      R0,[R5, #+0]
    112          #endif
    113              p_sem->Ctr     = cnt;                                       /* Set semaphore value                                  */
   \   0000003C   0xF8C5 0x8020      STR      R8,[R5, #+32]
    114          #if (OS_CFG_TS_EN == DEF_ENABLED)
    115              p_sem->TS      = 0u;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x6268             STR      R0,[R5, #+36]
    116          #endif
    117          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    118              p_sem->NamePtr = p_name;                                    /* Save the name of the semaphore                       */
   \   00000044   0x606E             STR      R6,[R5, #+4]
    119          #else
    120              (void)p_name;
    121          #endif
    122              OS_PendListInit(&p_sem->PendList);                          /* Initialize the waiting list                          */
   \   00000046   0xF115 0x0008      ADDS     R0,R5,#+8
   \   0000004A   0x.... 0x....      BL       OS_PendListInit
    123          
    124          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    125              OS_SemDbgListAdd(p_sem);
   \   0000004E   0x0028             MOVS     R0,R5
   \   00000050   0x.... 0x....      BL       OS_SemDbgListAdd
    126              OSSemQty++;
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable8_3
   \   00000058   0x8800             LDRH     R0,[R0, #+0]
   \   0000005A   0x1C40             ADDS     R0,R0,#+1
   \   0000005C   0x.... 0x....      LDR.W    R1,??DataTable8_3
   \   00000060   0x8008             STRH     R0,[R1, #+0]
    127          #endif
    128          
    129              OS_TRACE_SEM_CREATE(p_sem, p_name);
    130          
    131              CPU_CRITICAL_EXIT();
   \   00000062   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000066   0x0038             MOVS     R0,R7
   \   00000068   0x.... 0x....      BL       CPU_SR_Restore
    132             *p_err = OS_ERR_NONE;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x8020             STRH     R0,[R4, #+0]
    133          }
   \                     ??OSSemCreate_1: (+1)
   \   00000070   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    134          
    135          
    136          /*
    137          ************************************************************************************************************************
    138          *                                                  DELETE A SEMAPHORE
    139          *
    140          * Description: This function deletes a semaphore.
    141          *
    142          * Arguments  : p_sem         is a pointer to the semaphore to delete
    143          *
    144          *              opt           determines delete options as follows:
    145          *
    146          *                                OS_OPT_DEL_NO_PEND          Delete semaphore ONLY if no task pending
    147          *                                OS_OPT_DEL_ALWAYS           Deletes the semaphore even if tasks are waiting.
    148          *                                                            In this case, all the tasks pending will be readied.
    149          *
    150          *              p_err         is a pointer to a variable that will contain an error code returned by this function.
    151          *
    152          *                                OS_ERR_NONE                    The call was successful and the semaphore was deleted
    153          *                                OS_ERR_DEL_ISR                 If you attempted to delete the semaphore from an ISR
    154          *                                OS_ERR_ILLEGAL_DEL_RUN_TIME    If you are trying to delete the semaphore after you called
    155          *                                                                 OSStart()
    156          *                                OS_ERR_OBJ_PTR_NULL            If 'p_sem' is a NULL pointer
    157          *                                OS_ERR_OBJ_TYPE                If 'p_sem' is not pointing at a semaphore
    158          *                                OS_ERR_OPT_INVALID             An invalid option was specified
    159          *                                OS_ERR_OS_NOT_RUNNING          If uC/OS-III is not running yet
    160          *                                OS_ERR_TASK_WAITING            One or more tasks were waiting on the semaphore
    161          *
    162          * Returns    : == 0          if no tasks were waiting on the semaphore, or upon error.
    163          *              >  0          if one or more tasks waiting on the semaphore are now readied and informed.
    164          *
    165          * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of the semaphore
    166          *                 MUST check the return code of OSSemPend().
    167          *              2) Because ALL tasks pending on the semaphore will be readied, you MUST be careful in applications where
    168          *                 the semaphore is used for mutual exclusion because the resource(s) will no longer be guarded by the
    169          *                 semaphore.
    170          ************************************************************************************************************************
    171          */
    172          
    173          #if (OS_CFG_SEM_DEL_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    174          OS_OBJ_QTY  OSSemDel (OS_SEM  *p_sem,
    175                                OS_OPT   opt,
    176                                OS_ERR  *p_err)
    177          {
   \                     OSSemDel: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0015             MOVS     R5,R2
    178              OS_OBJ_QTY     nbr_tasks;
    179              OS_PEND_LIST  *p_pend_list;
    180              OS_TCB        *p_tcb;
    181              CPU_TS         ts;
    182              CPU_SR_ALLOC();
   \   0000000A   0x2700             MOVS     R7,#+0
    183          
    184          
    185          #ifdef OS_SAFETY_CRITICAL
    186              if (p_err == DEF_NULL) {
    187                  OS_SAFETY_CRITICAL_EXCEPTION();
    188                  return (0u);
    189              }
    190          #endif
    191          
    192              OS_TRACE_SEM_DEL_ENTER(p_sem, opt);
    193          
    194          #ifdef OS_SAFETY_CRITICAL_IEC61508
    195              if (OSSafetyCriticalStartFlag == DEF_TRUE) {
    196                  OS_TRACE_SEM_DEL_EXIT(OS_ERR_ILLEGAL_DEL_RUN_TIME);
    197                 *p_err = OS_ERR_ILLEGAL_DEL_RUN_TIME;
    198                  return (0u);
    199              }
    200          #endif
    201          
    202          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
    203              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to delete a semaphore from an ISR        */
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD004             BEQ.N    ??OSSemDel_0
    204                  OS_TRACE_SEM_DEL_EXIT(OS_ERR_DEL_ISR);
    205                 *p_err = OS_ERR_DEL_ISR;
   \   00000016   0xF243 0x20C9      MOVW     R0,#+13001
   \   0000001A   0x8028             STRH     R0,[R5, #+0]
    206                  return (0u);
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE072             B.N      ??OSSemDel_1
    207              }
    208          #endif
    209          
    210          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
    211              if (OSRunning != OS_STATE_OS_RUNNING) {
    212                  OS_TRACE_SEM_DEL_EXIT(OS_ERR_OS_NOT_RUNNING);
    213                 *p_err = OS_ERR_OS_NOT_RUNNING;
    214                  return (0u);
    215              }
    216          #endif
    217          
    218          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
    219              if (p_sem == DEF_NULL) {                                    /* Validate 'p_sem'                                     */
   \                     ??OSSemDel_0: (+1)
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD104             BNE.N    ??OSSemDel_2
    220                  OS_TRACE_SEM_DEL_EXIT(OS_ERR_OBJ_PTR_NULL);
    221                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000024   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000028   0x8028             STRH     R0,[R5, #+0]
    222                  return (0u);
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xE06B             B.N      ??OSSemDel_1
    223              }
    224          #endif
    225          
    226          #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
    227              if (p_sem->Type != OS_OBJ_TYPE_SEM) {                       /* Make sure semaphore was created                      */
   \                     ??OSSemDel_2: (+1)
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable8_2  ;; 0x414d4553
   \   00000034   0x4288             CMP      R0,R1
   \   00000036   0xD004             BEQ.N    ??OSSemDel_3
    228                  OS_TRACE_SEM_DEL_EXIT(OS_ERR_OBJ_TYPE);
    229                 *p_err = OS_ERR_OBJ_TYPE;
   \   00000038   0xF645 0x50C4      MOVW     R0,#+24004
   \   0000003C   0x8028             STRH     R0,[R5, #+0]
    230                  return (0u);
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xE061             B.N      ??OSSemDel_1
    231              }
    232          #endif
    233          
    234              CPU_CRITICAL_ENTER();
   \                     ??OSSemDel_3: (+1)
   \   00000042   0x.... 0x....      BL       CPU_SR_Save
   \   00000046   0x0007             MOVS     R7,R0
   \   00000048   0x.... 0x....      BL       CPU_IntDisMeasStart
    235              p_pend_list = &p_sem->PendList;
   \   0000004C   0xF114 0x0908      ADDS     R9,R4,#+8
    236              nbr_tasks   = 0u;
   \   00000050   0xF05F 0x0800      MOVS     R8,#+0
    237              switch (opt) {
   \   00000054   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000056   0x2E00             CMP      R6,#+0
   \   00000058   0xD002             BEQ.N    ??OSSemDel_4
   \   0000005A   0x2E01             CMP      R6,#+1
   \   0000005C   0xD022             BEQ.N    ??OSSemDel_5
   \   0000005E   0xE048             B.N      ??OSSemDel_6
    238                  case OS_OPT_DEL_NO_PEND:                                /* Delete semaphore only if no task waiting             */
    239                       if (p_pend_list->HeadPtr == DEF_NULL) {
   \                     ??OSSemDel_4: (+1)
   \   00000060   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD114             BNE.N    ??OSSemDel_7
    240          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    241                           OS_SemDbgListRemove(p_sem);
   \   00000068   0x0020             MOVS     R0,R4
   \   0000006A   0x.... 0x....      BL       OS_SemDbgListRemove
    242                           OSSemQty--;
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable8_3
   \   00000072   0x8800             LDRH     R0,[R0, #+0]
   \   00000074   0x1E40             SUBS     R0,R0,#+1
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable8_3
   \   0000007A   0x8008             STRH     R0,[R1, #+0]
    243          #endif
    244                           OS_TRACE_SEM_DEL(p_sem);
    245                           OS_SemClr(p_sem);
   \   0000007C   0x0020             MOVS     R0,R4
   \   0000007E   0x.... 0x....      BL       OS_SemClr
    246                           CPU_CRITICAL_EXIT();
   \   00000082   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000086   0x0038             MOVS     R0,R7
   \   00000088   0x.... 0x....      BL       CPU_SR_Restore
    247                          *p_err = OS_ERR_NONE;
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0x8028             STRH     R0,[R5, #+0]
   \   00000090   0xE007             B.N      ??OSSemDel_8
    248                       } else {
    249                           CPU_CRITICAL_EXIT();
   \                     ??OSSemDel_7: (+1)
   \   00000092   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000096   0x0038             MOVS     R0,R7
   \   00000098   0x.... 0x....      BL       CPU_SR_Restore
    250                          *p_err = OS_ERR_TASK_WAITING;
   \   0000009C   0xF247 0x105F      MOVW     R0,#+29023
   \   000000A0   0x8028             STRH     R0,[R5, #+0]
    251                       }
    252                       break;
   \                     ??OSSemDel_8: (+1)
   \   000000A2   0xE02E             B.N      ??OSSemDel_9
    253          
    254                  case OS_OPT_DEL_ALWAYS:                                 /* Always delete the semaphore                          */
    255          #if (OS_CFG_TS_EN == DEF_ENABLED)
    256                       ts = OS_TS_GET();                                  /* Get local time stamp so all tasks get the same time  */
   \                     ??OSSemDel_5: (+1)
   \   000000A4   0x.... 0x....      BL       CPU_TS_TmrRd
   \   000000A8   0x0006             MOVS     R6,R0
   \   000000AA   0xE007             B.N      ??OSSemDel_10
    257          #else
    258                       ts = 0u;
    259          #endif
    260                       while (p_pend_list->HeadPtr != DEF_NULL) {         /* Remove all tasks on the pend list                    */
    261                           p_tcb = p_pend_list->HeadPtr;
   \                     ??OSSemDel_11: (+1)
   \   000000AC   0xF8D9 0x0000      LDR      R0,[R9, #+0]
    262                           OS_PendAbort(p_tcb,
    263                                        ts,
    264                                        OS_STATUS_PEND_DEL);
   \   000000B0   0x2202             MOVS     R2,#+2
   \   000000B2   0x0031             MOVS     R1,R6
   \   000000B4   0x.... 0x....      BL       OS_PendAbort
    265                           nbr_tasks++;
   \   000000B8   0xF118 0x0801      ADDS     R8,R8,#+1
    266                       }
   \                     ??OSSemDel_10: (+1)
   \   000000BC   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   000000C0   0x2800             CMP      R0,#+0
   \   000000C2   0xD1F3             BNE.N    ??OSSemDel_11
    267          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    268                       OS_SemDbgListRemove(p_sem);
   \   000000C4   0x0020             MOVS     R0,R4
   \   000000C6   0x.... 0x....      BL       OS_SemDbgListRemove
    269                       OSSemQty--;
   \   000000CA   0x.... 0x....      LDR.W    R0,??DataTable8_3
   \   000000CE   0x8800             LDRH     R0,[R0, #+0]
   \   000000D0   0x1E40             SUBS     R0,R0,#+1
   \   000000D2   0x.... 0x....      LDR.W    R1,??DataTable8_3
   \   000000D6   0x8008             STRH     R0,[R1, #+0]
    270          #endif
    271                       OS_TRACE_SEM_DEL(p_sem);
    272                       OS_SemClr(p_sem);
   \   000000D8   0x0020             MOVS     R0,R4
   \   000000DA   0x.... 0x....      BL       OS_SemClr
    273                       CPU_CRITICAL_EXIT();
   \   000000DE   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000E2   0x0038             MOVS     R0,R7
   \   000000E4   0x.... 0x....      BL       CPU_SR_Restore
    274                       OSSched();                                         /* Find highest priority task ready to run              */
   \   000000E8   0x.... 0x....      BL       OSSched
    275                      *p_err = OS_ERR_NONE;
   \   000000EC   0x2000             MOVS     R0,#+0
   \   000000EE   0x8028             STRH     R0,[R5, #+0]
    276                       break;
   \   000000F0   0xE007             B.N      ??OSSemDel_9
    277          
    278                  default:
    279                       CPU_CRITICAL_EXIT();
   \                     ??OSSemDel_6: (+1)
   \   000000F2   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000F6   0x0038             MOVS     R0,R7
   \   000000F8   0x.... 0x....      BL       CPU_SR_Restore
    280                      *p_err = OS_ERR_OPT_INVALID;
   \   000000FC   0xF645 0x6025      MOVW     R0,#+24101
   \   00000100   0x8028             STRH     R0,[R5, #+0]
    281                       break;
    282              }
    283          
    284              OS_TRACE_SEM_DEL_EXIT(*p_err);
    285          
    286              return (nbr_tasks);
   \                     ??OSSemDel_9: (+1)
   \   00000102   0x4640             MOV      R0,R8
   \   00000104   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSSemDel_1: (+1)
   \   00000106   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    287          }
    288          #endif
    289          
    290          
    291          /*
    292          ************************************************************************************************************************
    293          *                                                  PEND ON SEMAPHORE
    294          *
    295          * Description: This function waits for a semaphore.
    296          *
    297          * Arguments  : p_sem         is a pointer to the semaphore
    298          *
    299          *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will wait for the
    300          *                            resource up to the amount of time (in 'ticks') specified by this argument.  If you specify
    301          *                            0, however, your task will wait forever at the specified semaphore or, until the resource
    302          *                            becomes available (or the event occurs).
    303          *
    304          *              opt           determines whether the user wants to block if the semaphore is available or not:
    305          *
    306          *                                OS_OPT_PEND_BLOCKING
    307          *                                OS_OPT_PEND_NON_BLOCKING
    308          *
    309          *              p_ts          is a pointer to a variable that will receive the timestamp of when the semaphore was posted
    310          *                            or pend aborted or the semaphore deleted.  If you pass a NULL pointer (i.e. (CPU_TS*)0)
    311          *                            then you will not get the timestamp.  In other words, passing a NULL pointer is valid
    312          *                            and indicates that you don't need the timestamp.
    313          *
    314          *              p_err         is a pointer to a variable that will contain an error code returned by this function.
    315          *
    316          *                                OS_ERR_NONE               The call was successful and your task owns the resource
    317          *                                                          or, the event you are waiting for occurred
    318          *                                OS_ERR_OBJ_DEL            If 'p_sem' was deleted
    319          *                                OS_ERR_OBJ_PTR_NULL       If 'p_sem' is a NULL pointer
    320          *                                OS_ERR_OBJ_TYPE           If 'p_sem' is not pointing at a semaphore
    321          *                                OS_ERR_OPT_INVALID        If you specified an invalid value for 'opt'
    322          *                                OS_ERR_OS_NOT_RUNNING     If uC/OS-III is not running yet
    323          *                                OS_ERR_PEND_ABORT         If the pend was aborted by another task
    324          *                                OS_ERR_PEND_ISR           If you called this function from an ISR and the result
    325          *                                                          would lead to a suspension
    326          *                                OS_ERR_PEND_WOULD_BLOCK   If you specified non-blocking but the semaphore was not
    327          *                                                          available
    328          *                                OS_ERR_SCHED_LOCKED       If you called this function when the scheduler is locked
    329          *                                OS_ERR_STATUS_INVALID     Pend status is invalid
    330          *                                OS_ERR_TIMEOUT            The semaphore was not received within the specified
    331          *                                                          timeout
    332          *
    333          *
    334          * Returns    : The current value of the semaphore counter or 0 if not available.
    335          *
    336          * Note(s)    : none
    337          ************************************************************************************************************************
    338          */
    339          

   \                                 In section .text, align 2, keep-with-next
    340          OS_SEM_CTR  OSSemPend (OS_SEM   *p_sem,
    341                                 OS_TICK   timeout,
    342                                 OS_OPT    opt,
    343                                 CPU_TS   *p_ts,
    344                                 OS_ERR   *p_err)
    345          {
   \                     OSSemPend: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x4690             MOV      R8,R2
   \   0000000A   0x001F             MOVS     R7,R3
    346              OS_SEM_CTR  ctr;
    347              CPU_SR_ALLOC();
   \   0000000C   0xF05F 0x0900      MOVS     R9,#+0
   \   00000010   0x9C08             LDR      R4,[SP, #+32]
    348          
    349          
    350          #if (OS_CFG_TS_EN == DEF_DISABLED)
    351              (void)p_ts;                                                /* Prevent compiler warning for not using 'ts'          */
    352          #endif
    353          
    354          #ifdef OS_SAFETY_CRITICAL
    355              if (p_err == DEF_NULL) {
    356                  OS_SAFETY_CRITICAL_EXCEPTION();
    357                  return (0u);
    358              }
    359          #endif
    360          
    361              OS_TRACE_SEM_PEND_ENTER(p_sem, timeout, opt, p_ts);
    362          
    363          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
    364              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD004             BEQ.N    ??OSSemPend_0
    365                  OS_TRACE_SEM_PEND_FAILED(p_sem);
    366                  OS_TRACE_SEM_PEND_EXIT(OS_ERR_PEND_ISR);
    367                 *p_err = OS_ERR_PEND_ISR;
   \   0000001C   0xF246 0x10AE      MOVW     R0,#+25006
   \   00000020   0x8020             STRH     R0,[R4, #+0]
    368                  return (0u);
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xE089             B.N      ??OSSemPend_1
    369              }
    370          #endif
    371          
    372          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
    373              if (OSRunning != OS_STATE_OS_RUNNING) {
    374                  OS_TRACE_SEM_PEND_EXIT(OS_ERR_OS_NOT_RUNNING);
    375                 *p_err = OS_ERR_OS_NOT_RUNNING;
    376                  return (0u);
    377              }
    378          #endif
    379          
    380          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
    381              if (p_sem == DEF_NULL) {                                    /* Validate 'p_sem'                                     */
   \                     ??OSSemPend_0: (+1)
   \   00000026   0x2D00             CMP      R5,#+0
   \   00000028   0xD104             BNE.N    ??OSSemPend_2
    382                  OS_TRACE_SEM_PEND_EXIT(OS_ERR_OBJ_PTR_NULL);
    383                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   0000002A   0xF645 0x50C3      MOVW     R0,#+24003
   \   0000002E   0x8020             STRH     R0,[R4, #+0]
    384                  return (0u);
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xE082             B.N      ??OSSemPend_1
    385              }
    386              switch (opt) {                                              /* Validate 'opt'                                       */
   \                     ??OSSemPend_2: (+1)
   \   00000034   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000038   0x4640             MOV      R0,R8
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD002             BEQ.N    ??OSSemPend_3
   \   0000003E   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000042   0xD11D             BNE.N    ??OSSemPend_4
    387                  case OS_OPT_PEND_BLOCKING:
    388                  case OS_OPT_PEND_NON_BLOCKING:
    389                       break;
    390          
    391                  default:
    392                       OS_TRACE_SEM_PEND_FAILED(p_sem);
    393                       OS_TRACE_SEM_PEND_EXIT(OS_ERR_OPT_INVALID);
    394                      *p_err = OS_ERR_OPT_INVALID;
    395                       return (0u);
    396              }
    397          #endif
    398          
    399          #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
    400              if (p_sem->Type != OS_OBJ_TYPE_SEM) {                       /* Make sure semaphore was created                      */
   \                     ??OSSemPend_3: (+1)
   \   00000044   0x6828             LDR      R0,[R5, #+0]
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable8_2  ;; 0x414d4553
   \   0000004A   0x4288             CMP      R0,R1
   \   0000004C   0xD11D             BNE.N    ??OSSemPend_5
    401                  OS_TRACE_SEM_PEND_FAILED(p_sem);
    402                  OS_TRACE_SEM_PEND_EXIT(OS_ERR_OBJ_TYPE);
    403                 *p_err = OS_ERR_OBJ_TYPE;
    404                  return (0u);
    405              }
    406          #endif
    407          
    408          
    409              CPU_CRITICAL_ENTER();
   \   0000004E   0x.... 0x....      BL       CPU_SR_Save
   \   00000052   0x4681             MOV      R9,R0
   \   00000054   0x.... 0x....      BL       CPU_IntDisMeasStart
    410              if (p_sem->Ctr > 0u) {                                      /* Resource available?                                  */
   \   00000058   0x6A28             LDR      R0,[R5, #+32]
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD01A             BEQ.N    ??OSSemPend_6
    411                  p_sem->Ctr--;                                           /* Yes, caller may proceed                              */
   \   0000005E   0x6A28             LDR      R0,[R5, #+32]
   \   00000060   0x1E40             SUBS     R0,R0,#+1
   \   00000062   0x6228             STR      R0,[R5, #+32]
    412          #if (OS_CFG_TS_EN == DEF_ENABLED)
    413                  if (p_ts != DEF_NULL) {
   \   00000064   0x2F00             CMP      R7,#+0
   \   00000066   0xD001             BEQ.N    ??OSSemPend_7
    414                     *p_ts = p_sem->TS;                                   /* get timestamp of last post                           */
   \   00000068   0x6A68             LDR      R0,[R5, #+36]
   \   0000006A   0x6038             STR      R0,[R7, #+0]
    415                  }
    416          #endif
    417                  ctr   = p_sem->Ctr;
   \                     ??OSSemPend_7: (+1)
   \   0000006C   0x6A2D             LDR      R5,[R5, #+32]
    418                  OS_TRACE_SEM_PEND(p_sem);
    419                  CPU_CRITICAL_EXIT();
   \   0000006E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000072   0x4648             MOV      R0,R9
   \   00000074   0x.... 0x....      BL       CPU_SR_Restore
    420                  OS_TRACE_SEM_PEND_EXIT(OS_ERR_NONE);
    421                 *p_err = OS_ERR_NONE;
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0x8020             STRH     R0,[R4, #+0]
    422                  return (ctr);
   \   0000007C   0x0028             MOVS     R0,R5
   \   0000007E   0xE05C             B.N      ??OSSemPend_1
    423              }
   \                     ??OSSemPend_4: (+1)
   \   00000080   0xF645 0x6025      MOVW     R0,#+24101
   \   00000084   0x8020             STRH     R0,[R4, #+0]
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0xE057             B.N      ??OSSemPend_1
   \                     ??OSSemPend_5: (+1)
   \   0000008A   0xF645 0x50C4      MOVW     R0,#+24004
   \   0000008E   0x8020             STRH     R0,[R4, #+0]
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0xE052             B.N      ??OSSemPend_1
    424          
    425              if ((opt & OS_OPT_PEND_NON_BLOCKING) != 0u) {               /* Caller wants to block if not available?              */
   \                     ??OSSemPend_6: (+1)
   \   00000094   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000098   0xEA5F 0x4008      LSLS     R0,R8,#+16
   \   0000009C   0xD50E             BPL.N    ??OSSemPend_8
    426          #if (OS_CFG_TS_EN == DEF_ENABLED)
    427                  if (p_ts != DEF_NULL) {
   \   0000009E   0x2F00             CMP      R7,#+0
   \   000000A0   0xD001             BEQ.N    ??OSSemPend_9
    428                     *p_ts = 0u;
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0x6038             STR      R0,[R7, #+0]
    429                  }
    430          #endif
    431                  ctr   = p_sem->Ctr;                                     /* No                                                   */
   \                     ??OSSemPend_9: (+1)
   \   000000A6   0x6A2D             LDR      R5,[R5, #+32]
    432                  CPU_CRITICAL_EXIT();
   \   000000A8   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000AC   0x4648             MOV      R0,R9
   \   000000AE   0x.... 0x....      BL       CPU_SR_Restore
    433                  OS_TRACE_SEM_PEND_FAILED(p_sem);
    434                  OS_TRACE_SEM_PEND_EXIT(OS_ERR_PEND_WOULD_BLOCK);
    435                 *p_err = OS_ERR_PEND_WOULD_BLOCK;
   \   000000B2   0xF246 0x10B0      MOVW     R0,#+25008
   \   000000B6   0x8020             STRH     R0,[R4, #+0]
    436                  return (ctr);
   \   000000B8   0x0028             MOVS     R0,R5
   \   000000BA   0xE03E             B.N      ??OSSemPend_1
    437              } else {                                                    /* Yes                                                  */
    438                  if (OSSchedLockNestingCtr > 0u) {                       /* Can't pend when the scheduler is locked              */
   \                     ??OSSemPend_8: (+1)
   \   000000BC   0x.... 0x....      LDR.W    R0,??DataTable8_4
   \   000000C0   0x7800             LDRB     R0,[R0, #+0]
   \   000000C2   0x2800             CMP      R0,#+0
   \   000000C4   0xD00D             BEQ.N    ??OSSemPend_10
    439          #if (OS_CFG_TS_EN == DEF_ENABLED)
    440                      if (p_ts != DEF_NULL) {
   \   000000C6   0x2F00             CMP      R7,#+0
   \   000000C8   0xD001             BEQ.N    ??OSSemPend_11
    441                         *p_ts = 0u;
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0x6038             STR      R0,[R7, #+0]
    442                      }
    443          #endif
    444                      CPU_CRITICAL_EXIT();
   \                     ??OSSemPend_11: (+1)
   \   000000CE   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000D2   0x4648             MOV      R0,R9
   \   000000D4   0x.... 0x....      BL       CPU_SR_Restore
    445                      OS_TRACE_SEM_PEND_FAILED(p_sem);
    446                      OS_TRACE_SEM_PEND_EXIT(OS_ERR_SCHED_LOCKED);
    447                     *p_err = OS_ERR_SCHED_LOCKED;
   \   000000D8   0xF646 0x5063      MOVW     R0,#+28003
   \   000000DC   0x8020             STRH     R0,[R4, #+0]
    448                      return (0u);
   \   000000DE   0x2000             MOVS     R0,#+0
   \   000000E0   0xE02B             B.N      ??OSSemPend_1
    449                  }
    450              }
    451          
    452              OS_Pend((OS_PEND_OBJ *)((void *)p_sem),                     /* Block task pending on Semaphore                      */
    453                      OS_TASK_PEND_ON_SEM,
    454                      timeout);
   \                     ??OSSemPend_10: (+1)
   \   000000E2   0x0032             MOVS     R2,R6
   \   000000E4   0x2106             MOVS     R1,#+6
   \   000000E6   0x0028             MOVS     R0,R5
   \   000000E8   0x.... 0x....      BL       OS_Pend
    455              CPU_CRITICAL_EXIT();
   \   000000EC   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000F0   0x4648             MOV      R0,R9
   \   000000F2   0x.... 0x....      BL       CPU_SR_Restore
    456              OS_TRACE_SEM_PEND_BLOCK(p_sem);
    457              OSSched();                                                  /* Find the next highest priority task ready to run     */
   \   000000F6   0x.... 0x....      BL       OSSched
    458          
    459              CPU_CRITICAL_ENTER();
   \   000000FA   0x.... 0x....      BL       CPU_SR_Save
   \   000000FE   0x4681             MOV      R9,R0
   \   00000100   0x.... 0x....      BL       CPU_IntDisMeasStart
    460              switch (OSTCBCurPtr->PendStatus) {
   \   00000104   0x....             LDR.N    R0,??DataTable8_5
   \   00000106   0x6800             LDR      R0,[R0, #+0]
   \   00000108   0xF890 0x003D      LDRB     R0,[R0, #+61]
   \   0000010C   0x2800             CMP      R0,#+0
   \   0000010E   0xD005             BEQ.N    ??OSSemPend_12
   \   00000110   0x2802             CMP      R0,#+2
   \   00000112   0xD026             BEQ.N    ??OSSemPend_13
   \   00000114   0xD313             BCC.N    ??OSSemPend_14
   \   00000116   0x2803             CMP      R0,#+3
   \   00000118   0xD01B             BEQ.N    ??OSSemPend_15
   \   0000011A   0xE02C             B.N      ??OSSemPend_16
    461                  case OS_STATUS_PEND_OK:                                 /* We got the semaphore                                 */
    462          #if (OS_CFG_TS_EN == DEF_ENABLED)
    463                       if (p_ts != DEF_NULL) {
   \                     ??OSSemPend_12: (+1)
   \   0000011C   0x2F00             CMP      R7,#+0
   \   0000011E   0xD003             BEQ.N    ??OSSemPend_17
    464                          *p_ts = OSTCBCurPtr->TS;
   \   00000120   0x....             LDR.N    R0,??DataTable8_5
   \   00000122   0x6800             LDR      R0,[R0, #+0]
   \   00000124   0x6D00             LDR      R0,[R0, #+80]
   \   00000126   0x6038             STR      R0,[R7, #+0]
    465                       }
    466          #endif
    467                       OS_TRACE_SEM_PEND(p_sem);
    468                      *p_err = OS_ERR_NONE;
   \                     ??OSSemPend_17: (+1)
   \   00000128   0x2000             MOVS     R0,#+0
   \   0000012A   0x8020             STRH     R0,[R4, #+0]
    469                       break;
    470          
    471                  case OS_STATUS_PEND_ABORT:                              /* Indicate that we aborted                             */
    472          #if (OS_CFG_TS_EN == DEF_ENABLED)
    473                       if (p_ts != DEF_NULL) {
    474                          *p_ts = OSTCBCurPtr->TS;
    475                       }
    476          #endif
    477                       OS_TRACE_SEM_PEND_FAILED(p_sem);
    478                      *p_err = OS_ERR_PEND_ABORT;
    479                       break;
    480          
    481                  case OS_STATUS_PEND_TIMEOUT:                            /* Indicate that we didn't get semaphore within timeout */
    482          #if (OS_CFG_TS_EN == DEF_ENABLED)
    483                       if (p_ts != DEF_NULL) {
    484                          *p_ts = 0u;
    485                       }
    486          #endif
    487                       OS_TRACE_SEM_PEND_FAILED(p_sem);
    488                      *p_err = OS_ERR_TIMEOUT;
    489                       break;
    490          
    491                  case OS_STATUS_PEND_DEL:                                /* Indicate that object pended on has been deleted      */
    492          #if (OS_CFG_TS_EN == DEF_ENABLED)
    493                       if (p_ts != DEF_NULL) {
    494                          *p_ts = OSTCBCurPtr->TS;
    495                       }
    496          #endif
    497                       OS_TRACE_SEM_PEND_FAILED(p_sem);
    498                      *p_err = OS_ERR_OBJ_DEL;
    499                       break;
    500          
    501                  default:
    502                       OS_TRACE_SEM_PEND_FAILED(p_sem);
    503                      *p_err = OS_ERR_STATUS_INVALID;
    504                       CPU_CRITICAL_EXIT();
    505                       OS_TRACE_SEM_PEND_EXIT(*p_err);
    506                       return (0u);
    507              }
    508              ctr = p_sem->Ctr;
   \                     ??OSSemPend_18: (+1)
   \   0000012C   0x6A2D             LDR      R5,[R5, #+32]
    509              CPU_CRITICAL_EXIT();
   \   0000012E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000132   0x4648             MOV      R0,R9
   \   00000134   0x.... 0x....      BL       CPU_SR_Restore
    510              OS_TRACE_SEM_PEND_EXIT(*p_err);
    511              return (ctr);
   \   00000138   0x0028             MOVS     R0,R5
   \                     ??OSSemPend_1: (+1)
   \   0000013A   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   \                     ??OSSemPend_14: (+1)
   \   0000013E   0x2F00             CMP      R7,#+0
   \   00000140   0xD003             BEQ.N    ??OSSemPend_19
   \   00000142   0x....             LDR.N    R0,??DataTable8_5
   \   00000144   0x6800             LDR      R0,[R0, #+0]
   \   00000146   0x6D00             LDR      R0,[R0, #+80]
   \   00000148   0x6038             STR      R0,[R7, #+0]
   \                     ??OSSemPend_19: (+1)
   \   0000014A   0xF246 0x10A9      MOVW     R0,#+25001
   \   0000014E   0x8020             STRH     R0,[R4, #+0]
   \   00000150   0xE7EC             B.N      ??OSSemPend_18
   \                     ??OSSemPend_15: (+1)
   \   00000152   0x2F00             CMP      R7,#+0
   \   00000154   0xD001             BEQ.N    ??OSSemPend_20
   \   00000156   0x2000             MOVS     R0,#+0
   \   00000158   0x6038             STR      R0,[R7, #+0]
   \                     ??OSSemPend_20: (+1)
   \   0000015A   0xF247 0x20D9      MOVW     R0,#+29401
   \   0000015E   0x8020             STRH     R0,[R4, #+0]
   \   00000160   0xE7E4             B.N      ??OSSemPend_18
   \                     ??OSSemPend_13: (+1)
   \   00000162   0x2F00             CMP      R7,#+0
   \   00000164   0xD003             BEQ.N    ??OSSemPend_21
   \   00000166   0x....             LDR.N    R0,??DataTable8_5
   \   00000168   0x6800             LDR      R0,[R0, #+0]
   \   0000016A   0x6D00             LDR      R0,[R0, #+80]
   \   0000016C   0x6038             STR      R0,[R7, #+0]
   \                     ??OSSemPend_21: (+1)
   \   0000016E   0xF645 0x50C2      MOVW     R0,#+24002
   \   00000172   0x8020             STRH     R0,[R4, #+0]
   \   00000174   0xE7DA             B.N      ??OSSemPend_18
   \                     ??OSSemPend_16: (+1)
   \   00000176   0xF646 0x602E      MOVW     R0,#+28206
   \   0000017A   0x8020             STRH     R0,[R4, #+0]
   \   0000017C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000180   0x4648             MOV      R0,R9
   \   00000182   0x.... 0x....      BL       CPU_SR_Restore
   \   00000186   0x2000             MOVS     R0,#+0
   \   00000188   0xE7D7             B.N      ??OSSemPend_1
    512          }
    513          
    514          
    515          /*
    516          ************************************************************************************************************************
    517          *                                             ABORT WAITING ON A SEMAPHORE
    518          *
    519          * Description: This function aborts & readies any tasks currently waiting on a semaphore.  This function should be used
    520          *              to fault-abort the wait on the semaphore, rather than to normally signal the semaphore via OSSemPost().
    521          *
    522          * Arguments  : p_sem     is a pointer to the semaphore
    523          *
    524          *              opt       determines the type of ABORT performed:
    525          *
    526          *                            OS_OPT_PEND_ABORT_1          ABORT wait for a single task (HPT) waiting on the semaphore
    527          *                            OS_OPT_PEND_ABORT_ALL        ABORT wait for ALL tasks that are  waiting on the semaphore
    528          *                            OS_OPT_POST_NO_SCHED         Do not call the scheduler
    529          *
    530          *              p_err     is a pointer to a variable that will contain an error code returned by this function.
    531          *
    532          *                            OS_ERR_NONE                  At least one task waiting on the semaphore was readied and
    533          *                                                         informed of the aborted wait; check return value for the
    534          *                                                         number of tasks whose wait on the semaphore was aborted.
    535          *                            OS_ERR_OBJ_PTR_NULL          If 'p_sem' is a NULL pointer.
    536          *                            OS_ERR_OBJ_TYPE              If 'p_sem' is not pointing at a semaphore
    537          *                            OS_ERR_OPT_INVALID           If you specified an invalid option
    538          *                            OS_ERR_OS_NOT_RUNNING        If uC/OS-III is not running yet
    539          *                            OS_ERR_PEND_ABORT_ISR        If you called this function from an ISR
    540          *                            OS_ERR_PEND_ABORT_NONE       No task were pending
    541          *
    542          * Returns    : == 0          if no tasks were waiting on the semaphore, or upon error.
    543          *              >  0          if one or more tasks waiting on the semaphore are now readied and informed.
    544          *
    545          * Note(s)    : none
    546          ************************************************************************************************************************
    547          */
    548          
    549          #if (OS_CFG_SEM_PEND_ABORT_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    550          OS_OBJ_QTY  OSSemPendAbort (OS_SEM  *p_sem,
    551                                      OS_OPT   opt,
    552                                      OS_ERR  *p_err)
    553          {
   \                     OSSemPendAbort: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0006             MOVS     R6,R0
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0x0015             MOVS     R5,R2
    554              OS_PEND_LIST  *p_pend_list;
    555              OS_TCB        *p_tcb;
    556              CPU_TS         ts;
    557              OS_OBJ_QTY     nbr_tasks;
    558              CPU_SR_ALLOC();
   \   0000000A   0x2700             MOVS     R7,#+0
    559          
    560          
    561          #ifdef OS_SAFETY_CRITICAL
    562              if (p_err == DEF_NULL) {
    563                  OS_SAFETY_CRITICAL_EXCEPTION();
    564                  return (0u);
    565              }
    566          #endif
    567          
    568          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
    569              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to Pend Abort from an ISR                */
   \   0000000C   0x....             LDR.N    R0,??DataTable8_1
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD004             BEQ.N    ??OSSemPendAbort_0
    570                 *p_err =  OS_ERR_PEND_ABORT_ISR;
   \   00000014   0xF246 0x10AA      MOVW     R0,#+25002
   \   00000018   0x8028             STRH     R0,[R5, #+0]
    571                  return (0u);
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE057             B.N      ??OSSemPendAbort_1
    572              }
    573          #endif
    574          
    575          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
    576              if (OSRunning != OS_STATE_OS_RUNNING) {
    577                 *p_err = OS_ERR_OS_NOT_RUNNING;
    578                  return (0u);
    579              }
    580          #endif
    581          
    582          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
    583              if (p_sem == DEF_NULL) {                                    /* Validate 'p_sem'                                     */
   \                     ??OSSemPendAbort_0: (+1)
   \   0000001E   0x2E00             CMP      R6,#+0
   \   00000020   0xD104             BNE.N    ??OSSemPendAbort_2
    584                 *p_err =  OS_ERR_OBJ_PTR_NULL;
   \   00000022   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000026   0x8028             STRH     R0,[R5, #+0]
    585                  return (0u);
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xE050             B.N      ??OSSemPendAbort_1
    586              }
    587              switch (opt) {                                              /* Validate 'opt'                                       */
   \                     ??OSSemPendAbort_2: (+1)
   \   0000002C   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD008             BEQ.N    ??OSSemPendAbort_3
   \   00000034   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000038   0xD005             BEQ.N    ??OSSemPendAbort_3
   \   0000003A   0xF5B0 0x4F00      CMP      R0,#+32768
   \   0000003E   0xD002             BEQ.N    ??OSSemPendAbort_3
   \   00000040   0xF5B0 0x4F01      CMP      R0,#+33024
   \   00000044   0xD118             BNE.N    ??OSSemPendAbort_4
    588                  case OS_OPT_PEND_ABORT_1:
    589                  case OS_OPT_PEND_ABORT_ALL:
    590                  case OS_OPT_PEND_ABORT_1   | OS_OPT_POST_NO_SCHED:
    591                  case OS_OPT_PEND_ABORT_ALL | OS_OPT_POST_NO_SCHED:
    592                       break;
    593          
    594                  default:
    595                      *p_err =  OS_ERR_OPT_INVALID;
    596                       return (0u);
    597              }
    598          #endif
    599          
    600          #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
    601              if (p_sem->Type != OS_OBJ_TYPE_SEM) {                       /* Make sure semaphore was created                      */
   \                     ??OSSemPendAbort_3: (+1)
   \   00000046   0x6830             LDR      R0,[R6, #+0]
   \   00000048   0x....             LDR.N    R1,??DataTable8_2  ;; 0x414d4553
   \   0000004A   0x4288             CMP      R0,R1
   \   0000004C   0xD119             BNE.N    ??OSSemPendAbort_5
    602                 *p_err =  OS_ERR_OBJ_TYPE;
    603                  return (0u);
    604              }
    605          #endif
    606          
    607              CPU_CRITICAL_ENTER();
   \   0000004E   0x.... 0x....      BL       CPU_SR_Save
   \   00000052   0x0007             MOVS     R7,R0
   \   00000054   0x.... 0x....      BL       CPU_IntDisMeasStart
    608              p_pend_list = &p_sem->PendList;
   \   00000058   0xF116 0x0808      ADDS     R8,R6,#+8
    609              if (p_pend_list->HeadPtr == DEF_NULL) {                     /* Any task waiting on semaphore?                       */
   \   0000005C   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD113             BNE.N    ??OSSemPendAbort_6
    610                  CPU_CRITICAL_EXIT();                                    /* No                                                   */
   \   00000064   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000068   0x0038             MOVS     R0,R7
   \   0000006A   0x.... 0x....      BL       CPU_SR_Restore
    611                 *p_err =  OS_ERR_PEND_ABORT_NONE;
   \   0000006E   0xF246 0x10AB      MOVW     R0,#+25003
   \   00000072   0x8028             STRH     R0,[R5, #+0]
    612                  return (0u);
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0xE02A             B.N      ??OSSemPendAbort_1
    613              }
   \                     ??OSSemPendAbort_4: (+1)
   \   00000078   0xF645 0x6025      MOVW     R0,#+24101
   \   0000007C   0x8028             STRH     R0,[R5, #+0]
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xE025             B.N      ??OSSemPendAbort_1
   \                     ??OSSemPendAbort_5: (+1)
   \   00000082   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000086   0x8028             STRH     R0,[R5, #+0]
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0xE020             B.N      ??OSSemPendAbort_1
    614          
    615              nbr_tasks = 0u;
   \                     ??OSSemPendAbort_6: (+1)
   \   0000008C   0x2600             MOVS     R6,#+0
    616          #if (OS_CFG_TS_EN == DEF_ENABLED)
    617              ts        = OS_TS_GET();                                    /* Get local time stamp so all tasks get the same time  */
   \   0000008E   0x.... 0x....      BL       CPU_TS_TmrRd
   \   00000092   0x4681             MOV      R9,R0
    618          #else
    619              ts        = 0u;
    620          #endif
    621              while (p_pend_list->HeadPtr != DEF_NULL) {
   \                     ??OSSemPendAbort_7: (+1)
   \   00000094   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000098   0x2800             CMP      R0,#+0
   \   0000009A   0xD00A             BEQ.N    ??OSSemPendAbort_8
    622                  p_tcb = p_pend_list->HeadPtr;
   \   0000009C   0xF8D8 0x0000      LDR      R0,[R8, #+0]
    623                  OS_PendAbort(p_tcb,
    624                               ts,
    625                               OS_STATUS_PEND_ABORT);
   \   000000A0   0x2201             MOVS     R2,#+1
   \   000000A2   0x4649             MOV      R1,R9
   \   000000A4   0x.... 0x....      BL       OS_PendAbort
    626                  nbr_tasks++;
   \   000000A8   0x1C76             ADDS     R6,R6,#+1
    627                  if (opt != OS_OPT_PEND_ABORT_ALL) {                     /* Pend abort all tasks waiting?                        */
   \   000000AA   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000AC   0xF5B4 0x7F80      CMP      R4,#+256
   \   000000B0   0xD0F0             BEQ.N    ??OSSemPendAbort_7
    628                      break;                                              /* No                                                   */
    629                  }
    630              }
    631              CPU_CRITICAL_EXIT();
   \                     ??OSSemPendAbort_8: (+1)
   \   000000B2   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000B6   0x0038             MOVS     R0,R7
   \   000000B8   0x.... 0x....      BL       CPU_SR_Restore
    632          
    633              if ((opt & OS_OPT_POST_NO_SCHED) == 0u) {
   \   000000BC   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000BE   0x0420             LSLS     R0,R4,#+16
   \   000000C0   0xD401             BMI.N    ??OSSemPendAbort_9
    634                  OSSched();                                              /* Run the scheduler                                    */
   \   000000C2   0x.... 0x....      BL       OSSched
    635              }
    636          
    637             *p_err = OS_ERR_NONE;
   \                     ??OSSemPendAbort_9: (+1)
   \   000000C6   0x2000             MOVS     R0,#+0
   \   000000C8   0x8028             STRH     R0,[R5, #+0]
    638              return (nbr_tasks);
   \   000000CA   0x0030             MOVS     R0,R6
   \   000000CC   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSSemPendAbort_1: (+1)
   \   000000CE   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    639          }
    640          #endif
    641          
    642          
    643          /*
    644          ************************************************************************************************************************
    645          *                                                 POST TO A SEMAPHORE
    646          *
    647          * Description: This function signals a semaphore.
    648          *
    649          * Arguments  : p_sem    is a pointer to the semaphore
    650          *
    651          *              opt      determines the type of POST performed:
    652          *
    653          *                           OS_OPT_POST_1            POST and ready only the highest priority task waiting on semaphore
    654          *                                                    (if tasks are waiting).
    655          *                           OS_OPT_POST_ALL          POST to ALL tasks that are waiting on the semaphore
    656          *
    657          *                           OS_OPT_POST_NO_SCHED     Do not call the scheduler
    658          *
    659          *                           Note(s): 1) OS_OPT_POST_NO_SCHED can be added with one of the other options.
    660          *
    661          *              p_err    is a pointer to a variable that will contain an error code returned by this function.
    662          *
    663          *                           OS_ERR_NONE              The call was successful and the semaphore was signaled
    664          *                           OS_ERR_OBJ_PTR_NULL      If 'p_sem' is a NULL pointer
    665          *                           OS_ERR_OBJ_TYPE          If 'p_sem' is not pointing at a semaphore
    666          *                           OS_ERR_OPT_INVALID       If you specified an invalid option
    667          *                           OS_ERR_OS_NOT_RUNNING    If uC/OS-III is not running yet
    668          *                           OS_ERR_SEM_OVF           If the post would cause the semaphore count to overflow
    669          *
    670          * Returns    : The current value of the semaphore counter or 0 upon error.
    671          *
    672          * Note(s)    : none
    673          ************************************************************************************************************************
    674          */
    675          

   \                                 In section .text, align 2, keep-with-next
    676          OS_SEM_CTR  OSSemPost (OS_SEM  *p_sem,
    677                                 OS_OPT   opt,
    678                                 OS_ERR  *p_err)
    679          {
   \                     OSSemPost: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0014             MOVS     R4,R2
    680              OS_SEM_CTR     ctr;
    681              OS_PEND_LIST  *p_pend_list;
    682              OS_TCB        *p_tcb;
    683              OS_TCB        *p_tcb_next;
    684              CPU_TS         ts;
    685              CPU_SR_ALLOC();
   \   0000000A   0xF05F 0x0800      MOVS     R8,#+0
    686          
    687          
    688          #ifdef OS_SAFETY_CRITICAL
    689              if (p_err == DEF_NULL) {
    690                  OS_SAFETY_CRITICAL_EXCEPTION();
    691                  return (0u);
    692              }
    693          #endif
    694          
    695              OS_TRACE_SEM_POST_ENTER(p_sem, opt);
    696          
    697          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
    698              if (OSRunning != OS_STATE_OS_RUNNING) {
    699                  OS_TRACE_SEM_POST_EXIT(OS_ERR_OS_NOT_RUNNING);
    700                 *p_err = OS_ERR_OS_NOT_RUNNING;
    701                  return (0u);
    702              }
    703          #endif
    704          
    705          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
    706              if (p_sem == DEF_NULL) {                                    /* Validate 'p_sem'                                     */
   \   0000000E   0x2D00             CMP      R5,#+0
   \   00000010   0xD104             BNE.N    ??OSSemPost_0
    707                  OS_TRACE_SEM_POST_FAILED(p_sem);
    708                  OS_TRACE_SEM_POST_EXIT(OS_ERR_OBJ_PTR_NULL);
    709                 *p_err  = OS_ERR_OBJ_PTR_NULL;
   \   00000012   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000016   0x8020             STRH     R0,[R4, #+0]
    710                  return (0u);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE060             B.N      ??OSSemPost_1
    711              }
    712              switch (opt) {                                              /* Validate 'opt'                                       */
   \                     ??OSSemPost_0: (+1)
   \   0000001C   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000001E   0x0030             MOVS     R0,R6
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD008             BEQ.N    ??OSSemPost_2
   \   00000024   0xF5B0 0x7F00      CMP      R0,#+512
   \   00000028   0xD005             BEQ.N    ??OSSemPost_2
   \   0000002A   0xF5B0 0x4F00      CMP      R0,#+32768
   \   0000002E   0xD002             BEQ.N    ??OSSemPost_2
   \   00000030   0xF5B0 0x4F02      CMP      R0,#+33280
   \   00000034   0xD11E             BNE.N    ??OSSemPost_3
    713                  case OS_OPT_POST_1:
    714                  case OS_OPT_POST_ALL:
    715                  case OS_OPT_POST_1   | OS_OPT_POST_NO_SCHED:
    716                  case OS_OPT_POST_ALL | OS_OPT_POST_NO_SCHED:
    717                       break;
    718          
    719                  default:
    720                       OS_TRACE_SEM_POST_FAILED(p_sem);
    721                       OS_TRACE_SEM_POST_EXIT(OS_ERR_OPT_INVALID);
    722                      *p_err =  OS_ERR_OPT_INVALID;
    723                       return (0u);
    724              }
    725          #endif
    726          
    727          #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
    728              if (p_sem->Type != OS_OBJ_TYPE_SEM) {                       /* Make sure semaphore was created                      */
   \                     ??OSSemPost_2: (+1)
   \   00000036   0x6828             LDR      R0,[R5, #+0]
   \   00000038   0x....             LDR.N    R1,??DataTable8_2  ;; 0x414d4553
   \   0000003A   0x4288             CMP      R0,R1
   \   0000003C   0xD11F             BNE.N    ??OSSemPost_4
    729                  OS_TRACE_SEM_POST_FAILED(p_sem);
    730                  OS_TRACE_SEM_POST_EXIT(OS_ERR_OBJ_TYPE);
    731                 *p_err = OS_ERR_OBJ_TYPE;
    732                  return (0u);
    733              }
    734          #endif
    735          #if (OS_CFG_TS_EN == DEF_ENABLED)
    736              ts = OS_TS_GET();                                           /* Get timestamp                                        */
   \   0000003E   0x.... 0x....      BL       CPU_TS_TmrRd
   \   00000042   0x0007             MOVS     R7,R0
    737          #else
    738              ts = 0u;
    739          #endif
    740          
    741              OS_TRACE_SEM_POST(p_sem);
    742              CPU_CRITICAL_ENTER();
   \   00000044   0x.... 0x....      BL       CPU_SR_Save
   \   00000048   0x4680             MOV      R8,R0
   \   0000004A   0x.... 0x....      BL       CPU_IntDisMeasStart
    743              p_pend_list = &p_sem->PendList;
   \   0000004E   0xF115 0x0008      ADDS     R0,R5,#+8
    744              if (p_pend_list->HeadPtr == DEF_NULL) {                     /* Any task waiting on semaphore?                       */
   \   00000052   0x6801             LDR      R1,[R0, #+0]
   \   00000054   0x2900             CMP      R1,#+0
   \   00000056   0xD125             BNE.N    ??OSSemPost_5
    745                  if (p_sem->Ctr == (OS_SEM_CTR)-1) {
   \   00000058   0x6A28             LDR      R0,[R5, #+32]
   \   0000005A   0xF110 0x0F01      CMN      R0,#+1
   \   0000005E   0xD113             BNE.N    ??OSSemPost_6
    746                     CPU_CRITICAL_EXIT();
   \   00000060   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000064   0x4640             MOV      R0,R8
   \   00000066   0x.... 0x....      BL       CPU_SR_Restore
    747                    *p_err = OS_ERR_SEM_OVF;
   \   0000006A   0xF646 0x50C5      MOVW     R0,#+28101
   \   0000006E   0x8020             STRH     R0,[R4, #+0]
    748                     OS_TRACE_SEM_POST_EXIT(*p_err);
    749                     return (0u);
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0xE034             B.N      ??OSSemPost_1
    750                  }
   \                     ??OSSemPost_3: (+1)
   \   00000074   0xF645 0x6025      MOVW     R0,#+24101
   \   00000078   0x8020             STRH     R0,[R4, #+0]
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0xE02F             B.N      ??OSSemPost_1
   \                     ??OSSemPost_4: (+1)
   \   0000007E   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000082   0x8020             STRH     R0,[R4, #+0]
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0xE02A             B.N      ??OSSemPost_1
    751                  p_sem->Ctr++;                                           /* No                                                   */
   \                     ??OSSemPost_6: (+1)
   \   00000088   0x6A28             LDR      R0,[R5, #+32]
   \   0000008A   0x1C40             ADDS     R0,R0,#+1
   \   0000008C   0x6228             STR      R0,[R5, #+32]
    752                  ctr       = p_sem->Ctr;
   \   0000008E   0x6A2E             LDR      R6,[R5, #+32]
    753          #if (OS_CFG_TS_EN == DEF_ENABLED)
    754                  p_sem->TS = ts;                                         /* Save timestamp in semaphore control block            */
   \   00000090   0x626F             STR      R7,[R5, #+36]
    755          #endif
    756                  CPU_CRITICAL_EXIT();
   \   00000092   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000096   0x4640             MOV      R0,R8
   \   00000098   0x.... 0x....      BL       CPU_SR_Restore
    757                 *p_err     = OS_ERR_NONE;
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0x8020             STRH     R0,[R4, #+0]
    758                  OS_TRACE_SEM_POST_EXIT(*p_err);
    759                  return (ctr);
   \   000000A0   0x0030             MOVS     R0,R6
   \   000000A2   0xE01C             B.N      ??OSSemPost_1
    760              }
    761          
    762              p_tcb = p_pend_list->HeadPtr;
   \                     ??OSSemPost_5: (+1)
   \   000000A4   0x6801             LDR      R1,[R0, #+0]
   \   000000A6   0xE000             B.N      ??OSSemPost_7
    763              while (p_tcb != DEF_NULL) {
    764                  p_tcb_next = p_tcb->PendNextPtr;
    765                  OS_Post((OS_PEND_OBJ *)((void *)p_sem),
    766                          p_tcb,
    767                          DEF_NULL,
    768                          0u,
    769                          ts);
    770                  if ((opt & OS_OPT_POST_ALL) == 0u) {                     /* Post to all tasks waiting?                           */
    771                      break;                                              /* No                                                   */
    772                  }
    773                  p_tcb = p_tcb_next;
   \                     ??OSSemPost_8: (+1)
   \   000000A8   0x4649             MOV      R1,R9
   \                     ??OSSemPost_7: (+1)
   \   000000AA   0x2900             CMP      R1,#+0
   \   000000AC   0xD00A             BEQ.N    ??OSSemPost_9
   \   000000AE   0xF8D1 0x9030      LDR      R9,[R1, #+48]
   \   000000B2   0x9700             STR      R7,[SP, #+0]
   \   000000B4   0x2300             MOVS     R3,#+0
   \   000000B6   0x2200             MOVS     R2,#+0
   \   000000B8   0x0028             MOVS     R0,R5
   \   000000BA   0x.... 0x....      BL       OS_Post
   \   000000BE   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000C0   0x05B0             LSLS     R0,R6,#+22
   \   000000C2   0xD4F1             BMI.N    ??OSSemPost_8
    774              }
    775              CPU_CRITICAL_EXIT();
   \                     ??OSSemPost_9: (+1)
   \   000000C4   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000C8   0x4640             MOV      R0,R8
   \   000000CA   0x.... 0x....      BL       CPU_SR_Restore
    776              if ((opt & OS_OPT_POST_NO_SCHED) == 0u) {
   \   000000CE   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000D0   0x0430             LSLS     R0,R6,#+16
   \   000000D2   0xD401             BMI.N    ??OSSemPost_10
    777                  OSSched();                                              /* Run the scheduler                                    */
   \   000000D4   0x.... 0x....      BL       OSSched
    778              }
    779             *p_err = OS_ERR_NONE;
   \                     ??OSSemPost_10: (+1)
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0x8020             STRH     R0,[R4, #+0]
    780          
    781              OS_TRACE_SEM_POST_EXIT(*p_err);
    782              return (0u);
   \   000000DC   0x2000             MOVS     R0,#+0
   \                     ??OSSemPost_1: (+1)
   \   000000DE   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    783          }
    784          
    785          
    786          /*
    787          ************************************************************************************************************************
    788          *                                                    SET SEMAPHORE
    789          *
    790          * Description: This function sets the semaphore count to the value specified as an argument.  Typically, this value
    791          *              would be 0 but of course, we can set the semaphore to any value.
    792          *
    793          *              You would typically use this function when a semaphore is used as a signaling mechanism
    794          *              and, you want to reset the count value.
    795          *
    796          * Arguments  : p_sem     is a pointer to the semaphore
    797          *
    798          *              cnt       is the new value for the semaphore count.  You would pass 0 to reset the semaphore count.
    799          *
    800          *              p_err     is a pointer to a variable that will contain an error code returned by this function.
    801          *
    802          *                            OS_ERR_NONE           The call was successful and the semaphore value was set
    803          *                            OS_ERR_OBJ_PTR_NULL   If 'p_sem' is a NULL pointer
    804          *                            OS_ERR_OBJ_TYPE       If 'p_sem' is not pointing to a semaphore
    805          *                            OS_ERR_SET_ISR        If called from an ISR
    806          *                            OS_ERR_TASK_WAITING   If tasks are waiting on the semaphore
    807          *
    808          * Returns    : None
    809          *
    810          * Note(s)    : none
    811          ************************************************************************************************************************
    812          */
    813          
    814          #if (OS_CFG_SEM_SET_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    815          void  OSSemSet (OS_SEM      *p_sem,
    816                          OS_SEM_CTR   cnt,
    817                          OS_ERR      *p_err)
    818          {
   \                     OSSemSet: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0014             MOVS     R4,R2
    819              OS_PEND_LIST  *p_pend_list;
    820              CPU_SR_ALLOC();
   \   00000008   0x2700             MOVS     R7,#+0
    821          
    822          
    823          #ifdef OS_SAFETY_CRITICAL
    824              if (p_err == DEF_NULL) {
    825                  OS_SAFETY_CRITICAL_EXCEPTION();
    826                  return;
    827              }
    828          #endif
    829          
    830          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
    831              if (OSIntNestingCtr > 0u) {                                 /* Can't call this function from an ISR                 */
   \   0000000A   0x....             LDR.N    R0,??DataTable8_1
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD003             BEQ.N    ??OSSemSet_0
    832                 *p_err = OS_ERR_SET_ISR;
   \   00000012   0xF646 0x50C6      MOVW     R0,#+28102
   \   00000016   0x8020             STRH     R0,[R4, #+0]
    833                  return;
   \   00000018   0xE028             B.N      ??OSSemSet_1
    834              }
    835          #endif
    836          
    837          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
    838              if (p_sem == DEF_NULL) {                                    /* Validate 'p_sem'                                     */
   \                     ??OSSemSet_0: (+1)
   \   0000001A   0x2D00             CMP      R5,#+0
   \   0000001C   0xD103             BNE.N    ??OSSemSet_2
    839                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   0000001E   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000022   0x8020             STRH     R0,[R4, #+0]
    840                  return;
   \   00000024   0xE022             B.N      ??OSSemSet_1
    841              }
    842          #endif
    843          
    844          #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
    845              if (p_sem->Type != OS_OBJ_TYPE_SEM) {                       /* Make sure semaphore was created                      */
   \                     ??OSSemSet_2: (+1)
   \   00000026   0x6828             LDR      R0,[R5, #+0]
   \   00000028   0x....             LDR.N    R1,??DataTable8_2  ;; 0x414d4553
   \   0000002A   0x4288             CMP      R0,R1
   \   0000002C   0xD003             BEQ.N    ??OSSemSet_3
    846                 *p_err = OS_ERR_OBJ_TYPE;
   \   0000002E   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000032   0x8020             STRH     R0,[R4, #+0]
    847                  return;
   \   00000034   0xE01A             B.N      ??OSSemSet_1
    848              }
    849          #endif
    850          
    851             *p_err = OS_ERR_NONE;
   \                     ??OSSemSet_3: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x8020             STRH     R0,[R4, #+0]
    852              CPU_CRITICAL_ENTER();
   \   0000003A   0x.... 0x....      BL       CPU_SR_Save
   \   0000003E   0x0007             MOVS     R7,R0
   \   00000040   0x.... 0x....      BL       CPU_IntDisMeasStart
    853              if (p_sem->Ctr > 0u) {                                      /* See if semaphore already has a count                 */
   \   00000044   0x6A28             LDR      R0,[R5, #+32]
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD001             BEQ.N    ??OSSemSet_4
    854                  p_sem->Ctr = cnt;                                       /* Yes, set it to the new value specified.              */
   \   0000004A   0x622E             STR      R6,[R5, #+32]
   \   0000004C   0xE009             B.N      ??OSSemSet_5
    855              } else {
    856                  p_pend_list = &p_sem->PendList;                         /* No                                                   */
   \                     ??OSSemSet_4: (+1)
   \   0000004E   0xF115 0x0008      ADDS     R0,R5,#+8
    857                  if (p_pend_list->HeadPtr == DEF_NULL) {                 /* See if task(s) waiting?                              */
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD101             BNE.N    ??OSSemSet_6
    858                      p_sem->Ctr = cnt;                                   /* No, OK to set the value                              */
   \   00000058   0x622E             STR      R6,[R5, #+32]
   \   0000005A   0xE002             B.N      ??OSSemSet_5
    859                  } else {
    860                     *p_err      = OS_ERR_TASK_WAITING;
   \                     ??OSSemSet_6: (+1)
   \   0000005C   0xF247 0x105F      MOVW     R0,#+29023
   \   00000060   0x8020             STRH     R0,[R4, #+0]
    861                  }
    862              }
    863              CPU_CRITICAL_EXIT();
   \                     ??OSSemSet_5: (+1)
   \   00000062   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000066   0x0038             MOVS     R0,R7
   \   00000068   0x.... 0x....      BL       CPU_SR_Restore
    864          }
   \                     ??OSSemSet_1: (+1)
   \   0000006C   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    865          #endif
    866          
    867          
    868          /*
    869          ************************************************************************************************************************
    870          *                                           CLEAR THE CONTENTS OF A SEMAPHORE
    871          *
    872          * Description: This function is called by OSSemDel() to clear the contents of a semaphore
    873          *
    874          
    875          * Argument(s): p_sem      is a pointer to the semaphore to clear
    876          *              -----
    877          *
    878          * Returns    : none
    879          *
    880          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    881          ************************************************************************************************************************
    882          */
    883          

   \                                 In section .text, align 2, keep-with-next
    884          void  OS_SemClr (OS_SEM  *p_sem)
    885          {
   \                     OS_SemClr: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    886          #if (OS_OBJ_TYPE_REQ == DEF_ENABLED)
    887              p_sem->Type    = OS_OBJ_TYPE_NONE;                          /* Mark the data structure as a NONE                    */
   \   00000002   0x....             LDR.N    R1,??DataTable8_6  ;; 0x454e4f4e
   \   00000004   0x6001             STR      R1,[R0, #+0]
    888          #endif
    889              p_sem->Ctr     = 0u;                                        /* Set semaphore value                                  */
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x6201             STR      R1,[R0, #+32]
    890          #if (OS_CFG_TS_EN == DEF_ENABLED)
    891              p_sem->TS      = 0u;                                        /* Clear the time stamp                                 */
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x6241             STR      R1,[R0, #+36]
    892          #endif
    893          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    894              p_sem->NamePtr = (CPU_CHAR *)((void *)"?SEM");
   \   0000000E   0x....             LDR.N    R1,??DataTable8_7
   \   00000010   0x6041             STR      R1,[R0, #+4]
    895          #endif
    896              OS_PendListInit(&p_sem->PendList);                          /* Initialize the waiting list                          */
   \   00000012   0x3008             ADDS     R0,R0,#+8
   \   00000014   0x.... 0x....      BL       OS_PendListInit
    897          }
   \   00000018   0xBD01             POP      {R0,PC}          ;; return
    898          
    899          
    900          /*
    901          ************************************************************************************************************************
    902          *                                        ADD/REMOVE SEMAPHORE TO/FROM DEBUG LIST
    903          *
    904          * Description: These functions are called by uC/OS-III to add or remove a semaphore to/from the debug list.
    905          *
    906          * Arguments  : p_sem     is a pointer to the semaphore to add/remove
    907          *
    908          * Returns    : none
    909          *
    910          * Note(s)    : These functions are INTERNAL to uC/OS-III and your application should not call it.
    911          ************************************************************************************************************************
    912          */
    913          
    914          #if (OS_CFG_DBG_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    915          void  OS_SemDbgListAdd (OS_SEM  *p_sem)
    916          {
    917              p_sem->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
   \                     OS_SemDbgListAdd: (+1)
   \   00000000   0x....             ADR.N    R1,??DataTable8  ;; " "
   \   00000002   0x61C1             STR      R1,[R0, #+28]
    918              p_sem->DbgPrevPtr               = DEF_NULL;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6141             STR      R1,[R0, #+20]
    919              if (OSSemDbgListPtr == DEF_NULL) {
   \   00000008   0x....             LDR.N    R1,??DataTable8_8
   \   0000000A   0x6809             LDR      R1,[R1, #+0]
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD102             BNE.N    ??OS_SemDbgListAdd_0
    920                  p_sem->DbgNextPtr           = DEF_NULL;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6181             STR      R1,[R0, #+24]
   \   00000014   0xE005             B.N      ??OS_SemDbgListAdd_1
    921              } else {
    922                  p_sem->DbgNextPtr           =  OSSemDbgListPtr;
   \                     ??OS_SemDbgListAdd_0: (+1)
   \   00000016   0x....             LDR.N    R1,??DataTable8_8
   \   00000018   0x6809             LDR      R1,[R1, #+0]
   \   0000001A   0x6181             STR      R1,[R0, #+24]
    923                  OSSemDbgListPtr->DbgPrevPtr =  p_sem;
   \   0000001C   0x....             LDR.N    R1,??DataTable8_8
   \   0000001E   0x6809             LDR      R1,[R1, #+0]
   \   00000020   0x6148             STR      R0,[R1, #+20]
    924              }
    925              OSSemDbgListPtr                 =  p_sem;
   \                     ??OS_SemDbgListAdd_1: (+1)
   \   00000022   0x....             LDR.N    R1,??DataTable8_8
   \   00000024   0x6008             STR      R0,[R1, #+0]
    926          }
   \   00000026   0x4770             BX       LR               ;; return
    927          
    928          

   \                                 In section .text, align 2, keep-with-next
    929          void  OS_SemDbgListRemove (OS_SEM  *p_sem)
    930          {
    931              OS_SEM  *p_sem_next;
    932              OS_SEM  *p_sem_prev;
    933          
    934          
    935              p_sem_prev = p_sem->DbgPrevPtr;
   \                     OS_SemDbgListRemove: (+1)
   \   00000000   0x6942             LDR      R2,[R0, #+20]
    936              p_sem_next = p_sem->DbgNextPtr;
   \   00000002   0x6981             LDR      R1,[R0, #+24]
    937          
    938              if (p_sem_prev == DEF_NULL) {
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD108             BNE.N    ??OS_SemDbgListRemove_0
    939                  OSSemDbgListPtr = p_sem_next;
   \   00000008   0x....             LDR.N    R2,??DataTable8_8
   \   0000000A   0x6011             STR      R1,[R2, #+0]
    940                  if (p_sem_next != DEF_NULL) {
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD001             BEQ.N    ??OS_SemDbgListRemove_1
    941                      p_sem_next->DbgPrevPtr = DEF_NULL;
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x614A             STR      R2,[R1, #+20]
    942                  }
    943                  p_sem->DbgNextPtr = DEF_NULL;
   \                     ??OS_SemDbgListRemove_1: (+1)
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x6181             STR      R1,[R0, #+24]
   \   00000018   0xE00C             B.N      ??OS_SemDbgListRemove_2
    944          
    945              } else if (p_sem_next == DEF_NULL) {
   \                     ??OS_SemDbgListRemove_0: (+1)
   \   0000001A   0x2900             CMP      R1,#+0
   \   0000001C   0xD104             BNE.N    ??OS_SemDbgListRemove_3
    946                  p_sem_prev->DbgNextPtr = DEF_NULL;
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x6191             STR      R1,[R2, #+24]
    947                  p_sem->DbgPrevPtr      = DEF_NULL;
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0x6141             STR      R1,[R0, #+20]
   \   00000026   0xE005             B.N      ??OS_SemDbgListRemove_2
    948          
    949              } else {
    950                  p_sem_prev->DbgNextPtr =  p_sem_next;
   \                     ??OS_SemDbgListRemove_3: (+1)
   \   00000028   0x6191             STR      R1,[R2, #+24]
    951                  p_sem_next->DbgPrevPtr =  p_sem_prev;
   \   0000002A   0x614A             STR      R2,[R1, #+20]
    952                  p_sem->DbgNextPtr      = DEF_NULL;
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x6181             STR      R1,[R0, #+24]
    953                  p_sem->DbgPrevPtr      = DEF_NULL;
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0x6141             STR      R1,[R0, #+20]
    954              }
    955          }
   \                     ??OS_SemDbgListRemove_2: (+1)
   \   00000034   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x20 0x00          DC8      " ",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x........         DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x414D4553         DC32     0x414d4553

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x........         DC32     OSSemQty

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x........         DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0x........         DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \   00000000   0x454E4F4E         DC32     0x454e4f4e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \   00000000   0x........         DC32     OSSemDbgListPtr

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x3F 0x53          DC8 "?SEM"
   \              0x45 0x4D    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 2
   \   00000000   0x20 0x00          DC8 " "
    956          #endif
    957          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   OSSemCreate
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OS_PendListInit
        24   -> OS_SemDbgListAdd
      32   OSSemDel
        32   -> CPU_IntDisMeasStart
        32   -> CPU_IntDisMeasStop
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> CPU_TS_TmrRd
        32   -> OSSched
        32   -> OS_PendAbort
        32   -> OS_SemClr
        32   -> OS_SemDbgListRemove
      32   OSSemPend
        32   -> CPU_IntDisMeasStart
        32   -> CPU_IntDisMeasStop
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> OSSched
        32   -> OS_Pend
      32   OSSemPendAbort
        32   -> CPU_IntDisMeasStart
        32   -> CPU_IntDisMeasStop
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> CPU_TS_TmrRd
        32   -> OSSched
        32   -> OS_PendAbort
      32   OSSemPost
        32   -> CPU_IntDisMeasStart
        32   -> CPU_IntDisMeasStop
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> CPU_TS_TmrRd
        32   -> OSSched
        32   -> OS_Post
      24   OSSemSet
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
       8   OS_SemClr
         8   -> OS_PendListInit
       0   OS_SemDbgListAdd
       0   OS_SemDbgListRemove


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       8  ?_0
       2  ?_1
     116  OSSemCreate
     266  OSSemDel
     394  OSSemPend
     210  OSSemPendAbort
     226  OSSemPost
     110  OSSemSet
      26  OS_SemClr
      40  OS_SemDbgListAdd
      54  OS_SemDbgListRemove

 
    10 bytes in section .rodata
 1 478 bytes in section .text
 
 1 478 bytes of CODE  memory
    10 bytes of CONST memory

Errors: none
Warnings: none
