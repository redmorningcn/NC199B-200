###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       11/Jul/2018  11:13:07
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC210\NC210-200处理板\source\Software\uC-CPU\cpu_core.c
#    Command line =  
#        F:\iar\NC210\NC210-200处理板\source\Software\uC-CPU\cpu_core.c -D
#        USE_STDPERIPH_DRIVER -D APP_RELEASE -lCN
#        F:\iar\NC210\NC210-200处理板\project\app_release\List -o
#        F:\iar\NC210\NC210-200处理板\project\app_release\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC210\NC210-200处理板\project\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\config\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\task\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\user\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\OS\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\Ports\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\driver\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-LIB\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Source\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\ST\STM32\inc\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Ports\STM32\STM32F103\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Source\
#        -Ol --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC210\NC210-200处理板\project\app_release\List\cpu_core.lst
#    Object file  =  
#        F:\iar\NC210\NC210-200处理板\project\app_release\Obj\cpu_core.o
#
###############################################################################

F:\iar\NC210\NC210-200处理板\source\Software\uC-CPU\cpu_core.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/CPU
      4          *                                    CPU CONFIGURATION & PORT LAYER
      5          *
      6          *                          (c) Copyright 2004-2016; Micrium, Inc.; Weston, FL
      7          *
      8          *               All rights reserved.  Protected by international copyright laws.
      9          *
     10          *               uC/CPU is provided in source form to registered licensees ONLY.  It is
     11          *               illegal to distribute this source code to any third party unless you receive
     12          *               written permission by an authorized Micrium representative.  Knowledge of
     13          *               the source code may NOT be used to develop a similar product.
     14          *
     15          *               Please help us continue to provide the Embedded community with the finest
     16          *               software available.  Your honesty is greatly appreciated.
     17          *
     18          *               You can find our product's user manual, API reference, release notes and
     19          *               more information at https://doc.micrium.com.
     20          *               You can contact us at www.micrium.com.
     21          *********************************************************************************************************
     22          */
     23          
     24          /*
     25          *********************************************************************************************************
     26          *
     27          *                                           CORE CPU MODULE
     28          *
     29          * Filename      : cpu_core.c
     30          * Version       : V1.31.00
     31          * Programmer(s) : SR
     32          *                 ITJ
     33          *********************************************************************************************************
     34          */
     35          
     36          
     37          /*
     38          *********************************************************************************************************
     39          *                                            INCLUDE FILES
     40          *********************************************************************************************************
     41          */
     42          
     43          #define    MICRIUM_SOURCE
     44          #define    CPU_CORE_MODULE
     45          #include  "cpu_core.h"

   \                                 In section .bss, align 4
   \   __absolute char CPU_Name[16]
   \                     CPU_Name:
   \   00000000                      DS8 16

   \                                 In section .bss, align 4
   \   __absolute CPU_INT32U CPU_TS_TmrFreq_Hz
   \                     CPU_TS_TmrFreq_Hz:
   \   00000000                      DS8 4

   \                                 In section .bss, align 2
   \   __absolute CPU_INT16U CPU_IntDisMeasCtr
   \                     CPU_IntDisMeasCtr:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
   \   __absolute CPU_INT16U CPU_IntDisNestCtr
   \                     CPU_IntDisNestCtr:
   \   00000000                      DS8 2

   \                                 In section .bss, align 4
   \   __absolute CPU_TS_TMR CPU_IntDisMeasStart_cnts
   \                     CPU_IntDisMeasStart_cnts:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute CPU_TS_TMR CPU_IntDisMeasStop_cnts
   \                     CPU_IntDisMeasStop_cnts:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute CPU_TS_TMR CPU_IntDisMeasOvrhd_cnts
   \                     CPU_IntDisMeasOvrhd_cnts:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute CPU_TS_TMR CPU_IntDisMeasMaxCur_cnts
   \                     CPU_IntDisMeasMaxCur_cnts:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute CPU_TS_TMR CPU_IntDisMeasMax_cnts
   \                     CPU_IntDisMeasMax_cnts:
   \   00000000                      DS8 4
     46          
     47          #if (CPU_CFG_CACHE_MGMT_EN == DEF_ENABLED)
     48          #include  "cpu_cache.h"
     49          #endif
     50          
     51          
     52          /*
     53          *********************************************************************************************************
     54          *                                            LOCAL DEFINES
     55          *********************************************************************************************************
     56          */
     57          
     58                                                                          /* Pop cnt algorithm csts.                              */
     59          #define CRC_UTIL_POPCNT_MASK01010101_32  0x55555555u
     60          #define CRC_UTIL_POPCNT_MASK00110011_32  0x33333333u
     61          #define CRC_UTIL_POPCNT_MASK00001111_32  0x0F0F0F0Fu
     62          #define CRC_UTIL_POPCNT_POWERSOF256_32   0x01010101u
     63          
     64          
     65          /*
     66          *********************************************************************************************************
     67          *                                           LOCAL CONSTANTS
     68          *********************************************************************************************************
     69          */
     70          
     71          
     72          /*
     73          *********************************************************************************************************
     74          *                                          LOCAL DATA TYPES
     75          *********************************************************************************************************
     76          */
     77          
     78          
     79          /*
     80          *********************************************************************************************************
     81          *                                            LOCAL TABLES
     82          *********************************************************************************************************
     83          */
     84          
     85          /*
     86          *********************************************************************************************************
     87          *                                  CPU COUNT LEAD ZEROs LOOKUP TABLE
     88          *
     89          * Note(s) : (1) Index into bit pattern table determines the number of leading zeros in an 8-bit value :
     90          *
     91          *                         b07  b06  b05  b04  b03  b02  b01  b00    # Leading Zeros
     92          *                         ---  ---  ---  ---  ---  ---  ---  ---    ---------------
     93          *                          1    x    x    x    x    x    x    x            0
     94          *                          0    1    x    x    x    x    x    x            1
     95          *                          0    0    1    x    x    x    x    x            2
     96          *                          0    0    0    1    x    x    x    x            3
     97          *                          0    0    0    0    1    x    x    x            4
     98          *                          0    0    0    0    0    1    x    x            5
     99          *                          0    0    0    0    0    0    1    x            6
    100          *                          0    0    0    0    0    0    0    1            7
    101          *                          0    0    0    0    0    0    0    0            8
    102          *********************************************************************************************************
    103          */
    104          
    105          #if (!(defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) || \
    106                (CPU_CFG_DATA_SIZE_MAX > CPU_CFG_DATA_SIZE))

   \                                 In section .rodata, align 4
    107          static  const  CPU_INT08U  CPU_CntLeadZerosTbl[256] = {                             /* Data vals :                      */
   \                     CPU_CntLeadZerosTbl:
   \   00000000   0x08 0x07          DC8 8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3
   \              0x06 0x06    
   \              0x05 0x05    
   \              0x05 0x05    
   \              0x04 0x04    
   \              0x04 0x04    
   \              0x04 0x04    
   \              0x04 0x04    
   \              0x03 0x03    
   \              0x03 0x03    
   \              0x03 0x03    
   \              0x03         
   \   00000017   0x03 0x03          DC8 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2
   \              0x03 0x03    
   \              0x03 0x03    
   \              0x03 0x03    
   \              0x03 0x02    
   \              0x02 0x02    
   \              0x02 0x02    
   \              0x02 0x02    
   \              0x02 0x02    
   \              0x02 0x02    
   \              0x02 0x02    
   \              0x02         
   \   0000002E   0x02 0x02          DC8 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1
   \              0x02 0x02    
   \              0x02 0x02    
   \              0x02 0x02    
   \              0x02 0x02    
   \              0x02 0x02    
   \              0x02 0x02    
   \              0x02 0x02    
   \              0x02 0x02    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01         
   \   00000045   0x01 0x01          DC8 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01         
   \   0000005C   0x01 0x01          DC8 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01         
   \   00000073   0x01 0x01          DC8 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   0000008A   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   000000A1   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   000000B8   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   000000CF   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   000000E6   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   000000FD   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    108          /*   0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F   */
    109              8u,  7u,  6u,  6u,  5u,  5u,  5u,  5u,  4u,  4u,  4u,  4u,  4u,  4u,  4u,  4u,  /*   0x00 to 0x0F                   */
    110              3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  /*   0x10 to 0x1F                   */
    111              2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  /*   0x20 to 0x2F                   */
    112              2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  /*   0x30 to 0x3F                   */
    113              1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  /*   0x40 to 0x4F                   */
    114              1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  /*   0x50 to 0x5F                   */
    115              1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  /*   0x60 to 0x6F                   */
    116              1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  /*   0x70 to 0x7F                   */
    117              0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  /*   0x80 to 0x8F                   */
    118              0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  /*   0x90 to 0x9F                   */
    119              0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  /*   0xA0 to 0xAF                   */
    120              0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  /*   0xB0 to 0xBF                   */
    121              0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  /*   0xC0 to 0xCF                   */
    122              0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  /*   0xD0 to 0xDF                   */
    123              0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  /*   0xE0 to 0xEF                   */
    124              0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u   /*   0xF0 to 0xFF                   */
    125          };
    126          #endif
    127          
    128          
    129          /*
    130          *********************************************************************************************************
    131          *                                       LOCAL GLOBAL VARIABLES
    132          *********************************************************************************************************
    133          */
    134          

   \                                 In section .rodata, align 4
    135          CPU_INT32U  const  CPU_EndiannessTest = 0x12345678LU;               /* Variable to test CPU endianness.                 */
   \                     CPU_EndiannessTest:
   \   00000000   0x12345678         DC32 305419896
    136          
    137          
    138          /*
    139          *********************************************************************************************************
    140          *                                      LOCAL FUNCTION PROTOTYPES
    141          *********************************************************************************************************
    142          */
    143          
    144          #if    (CPU_CFG_NAME_EN   == DEF_ENABLED)                           /* ---------------- CPU NAME FNCTS ---------------- */
    145          static  void        CPU_NameInit         (void);
    146          #endif
    147          
    148          
    149                                                                              /* ----------------- CPU TS FNCTS ----------------- */
    150          #if   ((CPU_CFG_TS_EN     == DEF_ENABLED) || \
    151                 (CPU_CFG_TS_TMR_EN == DEF_ENABLED))
    152          static  void        CPU_TS_Init          (void);
    153          #endif
    154          
    155          
    156          #ifdef  CPU_CFG_INT_DIS_MEAS_EN                                     /* ---------- CPU INT DIS TIME MEAS FNCTS --------- */
    157          static  void        CPU_IntDisMeasInit   (void);
    158          
    159          static  CPU_TS_TMR  CPU_IntDisMeasMaxCalc(CPU_TS_TMR  time_tot_cnts);
    160          #endif
    161          
    162          
    163          /*
    164          *********************************************************************************************************
    165          *                                     LOCAL CONFIGURATION ERRORS
    166          *********************************************************************************************************
    167          */
    168          
    169          
    170          /*
    171          *********************************************************************************************************
    172          *                                             CPU_Init()
    173          *
    174          * Description : (1) Initialize CPU module :
    175          *
    176          *                   (a) Initialize CPU timestamps
    177          *                   (b) Initialize CPU interrupts disabled time measurements
    178          *                   (c) Initialize CPU host name
    179          *
    180          *
    181          * Argument(s) : none.
    182          *
    183          * Return(s)   : none.
    184          *
    185          * Caller(s)   : Your Product's Application.
    186          *
    187          *               This function is a CPU initialization function & MAY be called by application/
    188          *               initialization function(s).
    189          *
    190          * Note(s)     : (2) CPU_Init() MUST be called ... :
    191          *
    192          *                   (a) ONLY ONCE from a product's application; ...
    193          *                   (b) BEFORE product's application calls any core CPU module function(s)
    194          *
    195          *               (3) The following initialization functions MUST be sequenced as follows :
    196          *
    197          *                   (a) CPU_TS_Init()           SHOULD precede ALL calls to other CPU timestamp functions
    198          *
    199          *                   (b) CPU_IntDisMeasInit()    SHOULD precede ALL calls to CPU_CRITICAL_ENTER()/CPU_CRITICAL_EXIT()
    200          *                                                   & other CPU interrupts disabled time measurement functions
    201          *********************************************************************************************************
    202          */
    203          

   \                                 In section .text, align 2, keep-with-next
    204          void  CPU_Init (void)
    205          {
   \                     CPU_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    206                                                                          /* --------------------- INIT TS ---------------------- */
    207          #if ((CPU_CFG_TS_EN     == DEF_ENABLED) || \
    208               (CPU_CFG_TS_TMR_EN == DEF_ENABLED))
    209              CPU_TS_Init();                                              /* See Note #3a.                                        */
   \   00000002   0x.... 0x....      BL       CPU_TS_Init
    210          #endif
    211                                                                          /* -------------- INIT INT DIS TIME MEAS -------------- */
    212          #ifdef  CPU_CFG_INT_DIS_MEAS_EN
    213              CPU_IntDisMeasInit();                                       /* See Note #3b.                                        */
   \   00000006   0x.... 0x....      BL       CPU_IntDisMeasInit
    214          #endif
    215          
    216                                                                          /* ------------------ INIT CPU NAME ------------------- */
    217          #if (CPU_CFG_NAME_EN == DEF_ENABLED)
    218               CPU_NameInit();
   \   0000000A   0x.... 0x....      BL       CPU_NameInit
    219          #endif
    220          
    221          #if (CPU_CFG_CACHE_MGMT_EN == DEF_ENABLED)
    222               CPU_Cache_Init();
    223          #endif
    224          }
   \   0000000E   0xBD01             POP      {R0,PC}          ;; return
    225          
    226          
    227          /*
    228          *********************************************************************************************************
    229          *                                         CPU_SW_Exception()
    230          *
    231          * Description : Trap unrecoverable software exception.
    232          *
    233          * Argument(s) : none.
    234          *
    235          * Return(s)   : none.
    236          *
    237          * Caller(s)   : various.
    238          *
    239          * Note(s)     : (1) CPU_SW_Exception() deadlocks the current code execution -- whether multi-tasked/
    240          *                   -processed/-threaded or single-threaded -- when the current code execution cannot
    241          *                   gracefully recover or report a fault or exception condition.
    242          *
    243          *                   See also 'cpu_core.h  CPU_SW_EXCEPTION()  Note #1'.
    244          *********************************************************************************************************
    245          */
    246          

   \                                 In section .text, align 2, keep-with-next
    247          void  CPU_SW_Exception (void)
    248          {
    249              while (DEF_ON) {
   \                     CPU_SW_Exception: (+1)
   \                     ??CPU_SW_Exception_0: (+1)
   \   00000000   0xE7FE             B.N      ??CPU_SW_Exception_0
    250                  ;
    251              }
    252          }
    253          
    254          
    255          /*
    256          *********************************************************************************************************
    257          *                                            CPU_NameClr()
    258          *
    259          * Description : Clear CPU Name.
    260          *
    261          * Argument(s) : none.
    262          *
    263          * Return(s)   : none.
    264          *
    265          * Caller(s)   : CPU_NameInit(),
    266          *               Application.
    267          *
    268          *               This function is a CPU module application programming interface (API) function & MAY be
    269          *               called by application function(s).
    270          *
    271          * Note(s)     : none.
    272          *********************************************************************************************************
    273          */
    274          
    275          #if (CPU_CFG_NAME_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    276          void  CPU_NameClr (void)
    277          {
   \                     CPU_NameClr: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    278              CPU_SR_ALLOC();
   \   00000002   0x2400             MOVS     R4,#+0
    279          
    280          
    281              CPU_CRITICAL_ENTER();
   \   00000004   0x.... 0x....      BL       CPU_SR_Save
   \   00000008   0x0004             MOVS     R4,R0
   \   0000000A   0x.... 0x....      BL       CPU_IntDisMeasStart
    282              Mem_Clr((void     *)&CPU_Name[0],
    283                      (CPU_SIZE_T) CPU_CFG_NAME_SIZE);
   \   0000000E   0x2110             MOVS     R1,#+16
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000014   0x.... 0x....      BL       Mem_Clr
    284              CPU_CRITICAL_EXIT();
   \   00000018   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       CPU_SR_Restore
    285          }
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    286          #endif
    287          
    288          
    289          /*
    290          *********************************************************************************************************
    291          *                                            CPU_NameGet()
    292          *
    293          * Description : Get CPU host name.
    294          *
    295          * Argument(s) : p_name      Pointer to an ASCII character array that will receive the return CPU host
    296          *                               name ASCII string from this function (see Note #1).
    297          *
    298          *               p_err       Pointer to variable that will receive the return error code from this function :
    299          *
    300          *                               CPU_ERR_NONE                    CPU host name successfully returned.
    301          *                               CPU_ERR_NULL_PTR                Argument 'p_name' passed a NULL pointer.
    302          *
    303          * Return(s)   : none.
    304          *
    305          * Caller(s)   : Application.
    306          *
    307          *               This function is a CPU module application programming interface (API) function & MAY
    308          *               be called by application function(s).
    309          *
    310          * Note(s)     : (1) The size of the ASCII character array that will receive the return CPU host name
    311          *                   ASCII string :
    312          *
    313          *                   (a) MUST   be greater than or equal to the current CPU host name's ASCII string
    314          *                           size including the terminating NULL character;
    315          *                   (b) SHOULD be greater than or equal to CPU_CFG_NAME_SIZE
    316          *********************************************************************************************************
    317          */
    318          
    319          #if (CPU_CFG_NAME_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    320          void  CPU_NameGet (CPU_CHAR  *p_name,
    321                             CPU_ERR   *p_err)
    322          {
   \                     CPU_NameGet: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    323              CPU_SR_ALLOC();
   \   00000006   0x2600             MOVS     R6,#+0
    324          
    325          
    326              if (p_err == (CPU_ERR *)0) {
   \   00000008   0x2D00             CMP      R5,#+0
   \   0000000A   0xD101             BNE.N    ??CPU_NameGet_0
    327                  CPU_SW_EXCEPTION(;);
   \   0000000C   0x.... 0x....      BL       CPU_SW_Exception
    328              }
    329          
    330              if (p_name == (CPU_CHAR *)0) {
   \                     ??CPU_NameGet_0: (+1)
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD102             BNE.N    ??CPU_NameGet_1
    331                 *p_err = CPU_ERR_NULL_PTR;
   \   00000014   0x200A             MOVS     R0,#+10
   \   00000016   0x8028             STRH     R0,[R5, #+0]
    332                  return;
   \   00000018   0xE011             B.N      ??CPU_NameGet_2
    333              }
    334          
    335              CPU_CRITICAL_ENTER();
   \                     ??CPU_NameGet_1: (+1)
   \   0000001A   0x.... 0x....      BL       CPU_SR_Save
   \   0000001E   0x0006             MOVS     R6,R0
   \   00000020   0x.... 0x....      BL       CPU_IntDisMeasStart
    336             (void)Str_Copy_N(p_name,
    337                             &CPU_Name[0],
    338                              CPU_CFG_NAME_SIZE);
   \   00000024   0x2210             MOVS     R2,#+16
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable14
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0x.... 0x....      BL       Str_Copy_N
    339              CPU_CRITICAL_EXIT();
   \   00000030   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000034   0x0030             MOVS     R0,R6
   \   00000036   0x.... 0x....      BL       CPU_SR_Restore
    340          
    341             *p_err = CPU_ERR_NONE;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x8028             STRH     R0,[R5, #+0]
    342          }
   \                     ??CPU_NameGet_2: (+1)
   \   0000003E   0xBD70             POP      {R4-R6,PC}       ;; return
    343          #endif
    344          
    345          
    346          /*
    347          *********************************************************************************************************
    348          *                                            CPU_NameSet()
    349          *
    350          * Description : Set CPU host name.
    351          *
    352          * Argument(s) : p_name      Pointer to CPU host name to set.
    353          *
    354          *               p_err       Pointer to variable that will receive the return error code from this function :
    355          *
    356          *                               CPU_ERR_NONE                    CPU host name successfully set.
    357          *                               CPU_ERR_NULL_PTR                Argument 'p_name' passed a NULL pointer.
    358          *                               CPU_ERR_NAME_SIZE               Invalid CPU host name size (see Note #1).
    359          *
    360          * Return(s)   : none.
    361          *
    362          * Caller(s)   : Application.
    363          *
    364          *               This function is a CPU module application programming interface (API) function & MAY be
    365          *               called by application function(s).
    366          *
    367          * Note(s)     : (1) 'p_name' ASCII string size, including the terminating NULL character, MUST be less
    368          *                    than or equal to CPU_CFG_NAME_SIZE.
    369          *********************************************************************************************************
    370          */
    371          
    372          #if (CPU_CFG_NAME_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    373          void  CPU_NameSet (const  CPU_CHAR  *p_name,
    374                                    CPU_ERR   *p_err)
    375          {
   \                     CPU_NameSet: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    376              CPU_SIZE_T  len;
    377              CPU_SR_ALLOC();
   \   00000006   0x2600             MOVS     R6,#+0
    378          
    379          
    380              if (p_err == (CPU_ERR *)0) {
   \   00000008   0x2D00             CMP      R5,#+0
   \   0000000A   0xD101             BNE.N    ??CPU_NameSet_0
    381                  CPU_SW_EXCEPTION(;);
   \   0000000C   0x.... 0x....      BL       CPU_SW_Exception
    382              }
    383          
    384              if (p_name == (const CPU_CHAR *)0) {
   \                     ??CPU_NameSet_0: (+1)
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD102             BNE.N    ??CPU_NameSet_1
    385                 *p_err = CPU_ERR_NULL_PTR;
   \   00000014   0x200A             MOVS     R0,#+10
   \   00000016   0x8028             STRH     R0,[R5, #+0]
    386                  return;
   \   00000018   0xE01A             B.N      ??CPU_NameSet_2
    387              }
    388          
    389              len = Str_Len_N(p_name,
    390                              CPU_CFG_NAME_SIZE);
   \                     ??CPU_NameSet_1: (+1)
   \   0000001A   0x2110             MOVS     R1,#+16
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       Str_Len_N
    391              if (len < CPU_CFG_NAME_SIZE) {                              /* If       cfg name len < max name size, ...           */
   \   00000022   0x2810             CMP      R0,#+16
   \   00000024   0xD211             BCS.N    ??CPU_NameSet_3
    392                  CPU_CRITICAL_ENTER();
   \   00000026   0x.... 0x....      BL       CPU_SR_Save
   \   0000002A   0x0006             MOVS     R6,R0
   \   0000002C   0x.... 0x....      BL       CPU_IntDisMeasStart
    393                 (void)Str_Copy_N(&CPU_Name[0],                           /* ... copy cfg name to CPU host name.                  */
    394                                   p_name,
    395                                   CPU_CFG_NAME_SIZE);
   \   00000030   0x2210             MOVS     R2,#+16
   \   00000032   0x0021             MOVS     R1,R4
   \   00000034   0x....             LDR.N    R0,??DataTable14
   \   00000036   0x.... 0x....      BL       Str_Copy_N
    396                  CPU_CRITICAL_EXIT();
   \   0000003A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000003E   0x0030             MOVS     R0,R6
   \   00000040   0x.... 0x....      BL       CPU_SR_Restore
    397                 *p_err = CPU_ERR_NONE;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x8028             STRH     R0,[R5, #+0]
   \   00000048   0xE002             B.N      ??CPU_NameSet_4
    398          
    399              } else {
    400                 *p_err = CPU_ERR_NAME_SIZE;
   \                     ??CPU_NameSet_3: (+1)
   \   0000004A   0xF44F 0x707A      MOV      R0,#+1000
   \   0000004E   0x8028             STRH     R0,[R5, #+0]
    401              }
    402          }
   \                     ??CPU_NameSet_4: (+1)
   \                     ??CPU_NameSet_2: (+1)
   \   00000050   0xBD70             POP      {R4-R6,PC}       ;; return
    403          #endif
    404          
    405          
    406          /*
    407          *********************************************************************************************************
    408          *                                           CPU_TS_Get32()
    409          *
    410          * Description : Get current 32-bit CPU timestamp.
    411          *
    412          * Argument(s) : none.
    413          *
    414          * Return(s)   : Current 32-bit CPU timestamp (in timestamp timer counts).
    415          *
    416          * Caller(s)   : Application.
    417          *
    418          *               This function is a CPU module application programming interface (API) function & MAY
    419          *               be called by application function(s).
    420          *
    421          * Note(s)     : (1) When applicable, the amount of time measured by CPU timestamps is calculated by
    422          *                   either of the following equations :
    423          *
    424          *                       (a) Time measured  =  Number timer counts  *  Timer period
    425          *
    426          *                               where
    427          *
    428          *                                   Number timer counts     Number of timer counts measured
    429          *                                   Timer period            Timer's period in some units of
    430          *                                                               (fractional) seconds
    431          *                                   Time measured           Amount of time measured, in same
    432          *                                                               units of (fractional) seconds
    433          *                                                               as the Timer period
    434          *
    435          *                                              Number timer counts
    436          *                       (b) Time measured  =  ---------------------
    437          *                                                Timer frequency
    438          *
    439          *                               where
    440          *
    441          *                                   Number timer counts     Number of timer counts measured
    442          *                                   Timer frequency         Timer's frequency in some units
    443          *                                                               of counts per second
    444          *                                   Time measured           Amount of time measured, in seconds
    445          *
    446          *                   See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()  Note #2c1'.
    447          *
    448          *               (2) In case the CPU timestamp timer has lower precision than the 32-bit CPU timestamp;
    449          *                   its precision is extended via periodic updates by accumulating the deltas of the
    450          *                   timestamp timer count values into the higher-precision 32-bit CPU timestamp.
    451          *
    452          *               (3) After initialization, 'CPU_TS_32_Accum' & 'CPU_TS_32_TmrPrev' MUST ALWAYS
    453          *                   be accessed AND updated exclusively with interrupts disabled -- but NOT
    454          *                   with critical sections.
    455          *********************************************************************************************************
    456          */
    457          
    458          #if (CPU_CFG_TS_32_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    459          CPU_TS32  CPU_TS_Get32 (void)
    460          {
   \                     CPU_TS_Get32: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    461              CPU_TS32    ts;
    462          #if (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_32)
    463              CPU_TS_TMR  tmr_cur;
    464              CPU_TS_TMR  tmr_delta;
    465              CPU_SR_ALLOC();
    466          
    467          #endif
    468          
    469          #if (CPU_CFG_TS_TMR_SIZE >= CPU_WORD_SIZE_32)
    470              ts = (CPU_TS32)CPU_TS_TmrRd();                                  /* Get cur ts tmr val (in 32-bit ts cnts).          */
   \   00000002   0x.... 0x....      BL       CPU_TS_TmrRd
    471          
    472          #else
    473              CPU_INT_DIS();
    474              tmr_cur            = (CPU_TS_TMR) CPU_TS_TmrRd();               /* Get cur ts tmr val (in ts tmr cnts).             */
    475              tmr_delta          = (CPU_TS_TMR)(tmr_cur - CPU_TS_32_TmrPrev); /* Calc      delta ts tmr cnts.                     */
    476              CPU_TS_32_Accum   += (CPU_TS32  ) tmr_delta;                    /* Inc ts by delta ts tmr cnts (see Note #2).       */
    477              CPU_TS_32_TmrPrev  = (CPU_TS_TMR) tmr_cur;                      /* Save cur ts tmr cnts for next update.            */
    478              ts                 = (CPU_TS32  ) CPU_TS_32_Accum;
    479              CPU_INT_EN();
    480          #endif
    481          
    482              return (ts);
   \   00000006   0xBD02             POP      {R1,PC}          ;; return
    483          }
    484          #endif
    485          
    486          
    487          /*
    488          *********************************************************************************************************
    489          *                                           CPU_TS_Get64()
    490          *
    491          * Description : Get current 64-bit CPU timestamp.
    492          *
    493          * Argument(s) : none.
    494          *
    495          * Return(s)   : Current 64-bit CPU timestamp (in timestamp timer counts).
    496          *
    497          * Caller(s)   : Application.
    498          *
    499          *               This function is a CPU module application programming interface (API) function & MAY
    500          *               be called by application function(s).
    501          *
    502          * Note(s)     : (1) When applicable, the amount of time measured by CPU timestamps is calculated by
    503          *                   either of the following equations :
    504          *
    505          *                       (a) Time measured  =  Number timer counts  *  Timer period
    506          *
    507          *                               where
    508          *
    509          *                                   Number timer counts     Number of timer counts measured
    510          *                                   Timer period            Timer's period in some units of
    511          *                                                               (fractional) seconds
    512          *                                   Time measured           Amount of time measured, in same
    513          *                                                               units of (fractional) seconds
    514          *                                                               as the Timer period
    515          *
    516          *                                              Number timer counts
    517          *                       (b) Time measured  =  ---------------------
    518          *                                                Timer frequency
    519          *
    520          *                               where
    521          *
    522          *                                   Number timer counts     Number of timer counts measured
    523          *                                   Timer frequency         Timer's frequency in some units
    524          *                                                               of counts per second
    525          *                                   Time measured           Amount of time measured, in seconds
    526          *
    527          *                   See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()  Note #2c1'.
    528          *
    529          *               (2) In case the CPU timestamp timer has lower precision than the 64-bit CPU timestamp;
    530          *                   its precision is extended via periodic updates by accumulating the deltas of the
    531          *                   timestamp timer count values into the higher-precision 64-bit CPU timestamp.
    532          *
    533          *               (3) After initialization, 'CPU_TS_64_Accum' & 'CPU_TS_64_TmrPrev' MUST ALWAYS
    534          *                   be accessed AND updated exclusively with interrupts disabled -- but NOT
    535          *                   with critical sections.
    536          *********************************************************************************************************
    537          */
    538          
    539          #if (CPU_CFG_TS_64_EN == DEF_ENABLED)
    540          CPU_TS64  CPU_TS_Get64 (void)
    541          {
    542              CPU_TS64    ts;
    543          #if (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_64)
    544              CPU_TS_TMR  tmr_cur;
    545              CPU_TS_TMR  tmr_delta;
    546              CPU_SR_ALLOC();
    547          #endif
    548          
    549          
    550          #if (CPU_CFG_TS_TMR_SIZE >= CPU_WORD_SIZE_64)
    551              ts = (CPU_TS64)CPU_TS_TmrRd();                                  /* Get cur ts tmr val (in 64-bit ts cnts).          */
    552          
    553          #else
    554              CPU_INT_DIS();
    555              tmr_cur            = (CPU_TS_TMR) CPU_TS_TmrRd();               /* Get cur ts tmr val (in ts tmr cnts).             */
    556              tmr_delta          = (CPU_TS_TMR)(tmr_cur - CPU_TS_64_TmrPrev); /* Calc      delta ts tmr cnts.                     */
    557              CPU_TS_64_Accum   += (CPU_TS64  ) tmr_delta;                    /* Inc ts by delta ts tmr cnts (see Note #2).       */
    558              CPU_TS_64_TmrPrev  = (CPU_TS_TMR) tmr_cur;                      /* Save cur ts tmr cnts for next update.            */
    559              ts                 = (CPU_TS64  ) CPU_TS_64_Accum;
    560              CPU_INT_EN();
    561          #endif
    562          
    563              return (ts);
    564          }
    565          #endif
    566          
    567          
    568          /*
    569          *********************************************************************************************************
    570          *                                           CPU_TS_Update()
    571          *
    572          * Description : Update current CPU timestamp(s).
    573          *
    574          * Argument(s) : none.
    575          *
    576          * Return(s)   : none.
    577          *
    578          * Caller(s)   : Application/BSP periodic time handler (see Note #1).
    579          *
    580          *               This function is a CPU timestamp BSP function & SHOULD be called only by appropriate
    581          *               application/BSP function(s).
    582          *
    583          * Note(s)     : (1) (a) CPU timestamp(s) MUST be updated periodically by some application (or BSP) time
    584          *                       handler in order to (adequately) maintain CPU timestamp(s)' time.
    585          *
    586          *                   (b) CPU timestamp(s) MUST be updated more frequently than the CPU timestamp timer
    587          *                       overflows; otherwise, CPU timestamp(s) will lose time.
    588          *
    589          *                       See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()  Note #2c2'.
    590          *********************************************************************************************************
    591          */
    592          
    593          #if (CPU_CFG_TS_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    594          void  CPU_TS_Update (void)
    595          {
    596          #if ((CPU_CFG_TS_32_EN    == DEF_ENABLED)  && \
    597               (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_32))
    598             (void)CPU_TS_Get32();
    599          #endif
    600          
    601          #if ((CPU_CFG_TS_64_EN    == DEF_ENABLED)  && \
    602               (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_64))
    603             (void)CPU_TS_Get64();
    604          #endif
    605          }
   \                     CPU_TS_Update: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    606          #endif
    607          
    608          
    609          /*
    610          *********************************************************************************************************
    611          *                                         CPU_TS_TmrFreqGet()
    612          *
    613          * Description : Get CPU timestamp's timer frequency.
    614          *
    615          * Argument(s) : p_err       Pointer to variable that will receive the return error code from this function :
    616          *
    617          *                               CPU_ERR_NONE                    CPU timestamp's timer frequency successfully
    618          *                                                                   returned.
    619          *                               CPU_ERR_TS_FREQ_INVALID         CPU timestamp's timer frequency invalid &/or
    620          *                                                                   NOT yet configured.
    621          *
    622          * Return(s)   : CPU timestamp's timer frequency (in Hertz), if NO error(s).
    623          *
    624          *               0,                                          otherwise.
    625          *
    626          * Caller(s)   : Application.
    627          *
    628          *               This function is a CPU module application programming interface (API) function & MAY be
    629          *               called by application function(s).
    630          *
    631          * Note(s)     : none.
    632          *********************************************************************************************************
    633          */
    634          
    635          #if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    636          CPU_TS_TMR_FREQ  CPU_TS_TmrFreqGet (CPU_ERR  *p_err)
    637          {
   \                     CPU_TS_TmrFreqGet: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    638              CPU_TS_TMR_FREQ  freq_hz;
    639          
    640          
    641              if (p_err == (CPU_ERR *)0) {
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE.N    ??CPU_TS_TmrFreqGet_0
    642                  CPU_SW_EXCEPTION(0);
   \   00000008   0x.... 0x....      BL       CPU_SW_Exception
    643              }
    644          
    645              freq_hz =  CPU_TS_TmrFreq_Hz;
   \                     ??CPU_TS_TmrFreqGet_0: (+1)
   \   0000000C   0x....             LDR.N    R0,??DataTable14_1
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
    646             *p_err   = (freq_hz != 0u) ? CPU_ERR_NONE : CPU_ERR_TS_FREQ_INVALID;
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD001             BEQ.N    ??CPU_TS_TmrFreqGet_1
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0xE001             B.N      ??CPU_TS_TmrFreqGet_2
   \                     ??CPU_TS_TmrFreqGet_1: (+1)
   \   00000018   0xF44F 0x61FA      MOV      R1,#+2000
   \                     ??CPU_TS_TmrFreqGet_2: (+1)
   \   0000001C   0x8021             STRH     R1,[R4, #+0]
    647          
    648              return (freq_hz);
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
    649          }
    650          #endif
    651          
    652          
    653          /*
    654          *********************************************************************************************************
    655          *                                         CPU_TS_TmrFreqSet()
    656          *
    657          * Description : Set CPU timestamp's timer frequency.
    658          *
    659          * Argument(s) : freq_hz     Frequency (in Hertz) to set for CPU timestamp's timer.
    660          *
    661          * Return(s)   : none.
    662          *
    663          * Caller(s)   : CPU_TS_TmrInit(),
    664          *               Application/BSP initialization function(s).
    665          *
    666          *               This function is a CPU module BSP function & SHOULD be called only by appropriate
    667          *               application/BSP function(s) [see Note #1].
    668          *
    669          * Note(s)     : (1) (a) (1) CPU timestamp timer frequency is NOT required for internal CPU timestamp
    670          *                           operations but may OPTIONALLY be configured by CPU_TS_TmrInit() or other
    671          *                           application/BSP initialization functions.
    672          *
    673          *                       (2) CPU timestamp timer frequency MAY be used with optional CPU_TSxx_to_uSec()
    674          *                           to convert CPU timestamps from timer counts into microseconds.
    675          *
    676          *                           See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TSxx_to_uSec()  Note #2a'.
    677          *
    678          *                   (b) CPU timestamp timer period SHOULD be less than the typical measured time but MUST
    679          *                       be less than the maximum measured time; otherwise, timer resolution inadequate to
    680          *                       measure desired times.
    681          *
    682          *                       See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TSxx_to_uSec()  Note #2b'.
    683          *********************************************************************************************************
    684          */
    685          
    686          #if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    687          void  CPU_TS_TmrFreqSet (CPU_TS_TMR_FREQ  freq_hz)
    688          {
    689              CPU_TS_TmrFreq_Hz = freq_hz;
   \                     CPU_TS_TmrFreqSet: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable14_1
   \   00000002   0x6008             STR      R0,[R1, #+0]
    690          }
   \   00000004   0x4770             BX       LR               ;; return
    691          #endif
    692          
    693          
    694          /*
    695          *********************************************************************************************************
    696          *                                     CPU_IntDisMeasMaxCurReset()
    697          *
    698          * Description : Reset current maximum interrupts disabled time.
    699          *
    700          * Argument(s) : none.
    701          *
    702          * Return(s)   : Maximum interrupts disabled time (in CPU timestamp timer counts) before resetting.
    703          *
    704          *               See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()      Note #2c'
    705          *                      & 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TSxx_to_uSec()  Note #2'.
    706          *
    707          * Caller(s)   : Application.
    708          *
    709          *               This function is a CPU module application programming interface (API) function
    710          *               & MAY be called by application function(s).
    711          *
    712          * Note(s)     : (1) After initialization, 'CPU_IntDisMeasMaxCur_cnts' MUST ALWAYS be accessed
    713          *                   exclusively with interrupts disabled -- but NOT with critical sections.
    714          *********************************************************************************************************
    715          */
    716          
    717          #ifdef  CPU_CFG_INT_DIS_MEAS_EN

   \                                 In section .text, align 2, keep-with-next
    718          CPU_TS_TMR  CPU_IntDisMeasMaxCurReset (void)
    719          {
   \                     CPU_IntDisMeasMaxCurReset: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    720              CPU_TS_TMR  time_max_cnts;
    721              CPU_SR_ALLOC();
   \   00000002   0x2000             MOVS     R0,#+0
    722          
    723          
    724              time_max_cnts             = CPU_IntDisMeasMaxCurGet();
   \   00000004   0x.... 0x....      BL       CPU_IntDisMeasMaxCurGet
   \   00000008   0x0004             MOVS     R4,R0
    725              CPU_INT_DIS();
   \   0000000A   0x.... 0x....      BL       CPU_SR_Save
    726              CPU_IntDisMeasMaxCur_cnts = 0u;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x....             LDR.N    R2,??DataTable14_2
   \   00000012   0x6011             STR      R1,[R2, #+0]
    727              CPU_INT_EN();
   \   00000014   0x.... 0x....      BL       CPU_SR_Restore
    728          
    729              return (time_max_cnts);
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
    730          }
    731          #endif
    732          
    733          
    734          /*
    735          *********************************************************************************************************
    736          *                                      CPU_IntDisMeasMaxCurGet()
    737          *
    738          * Description : Get current maximum interrupts disabled time.
    739          *
    740          * Argument(s) : none.
    741          *
    742          * Return(s)   : Current maximum interrupts disabled time (in CPU timestamp timer counts).
    743          *
    744          *               See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()      Note #2c'
    745          *                      & 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TSxx_to_uSec()  Note #2'.
    746          *
    747          * Caller(s)   : CPU_IntDisMeasMaxCurReset(),
    748          *               Application.
    749          *
    750          *               This function is a CPU module application programming interface (API) function
    751          *               & MAY be called by application function(s).
    752          *
    753          * Note(s)     : (1) After initialization, 'CPU_IntDisMeasMaxCur_cnts' MUST ALWAYS be accessed
    754          *                   exclusively with interrupts disabled -- but NOT with critical sections.
    755          *********************************************************************************************************
    756          */
    757          
    758          #ifdef  CPU_CFG_INT_DIS_MEAS_EN

   \                                 In section .text, align 2, keep-with-next
    759          CPU_TS_TMR  CPU_IntDisMeasMaxCurGet (void)
    760          {
   \                     CPU_IntDisMeasMaxCurGet: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    761              CPU_TS_TMR  time_tot_cnts;
    762              CPU_TS_TMR  time_max_cnts;
    763              CPU_SR_ALLOC();
   \   00000002   0x2000             MOVS     R0,#+0
    764          
    765          
    766              CPU_INT_DIS();
   \   00000004   0x.... 0x....      BL       CPU_SR_Save
    767              time_tot_cnts = CPU_IntDisMeasMaxCur_cnts;
   \   00000008   0x....             LDR.N    R1,??DataTable14_2
   \   0000000A   0x680C             LDR      R4,[R1, #+0]
    768              CPU_INT_EN();
   \   0000000C   0x.... 0x....      BL       CPU_SR_Restore
    769              time_max_cnts = CPU_IntDisMeasMaxCalc(time_tot_cnts);
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       CPU_IntDisMeasMaxCalc
    770          
    771              return (time_max_cnts);
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
    772          }
    773          #endif
    774          
    775          
    776          /*
    777          *********************************************************************************************************
    778          *                                       CPU_IntDisMeasMaxGet()
    779          *
    780          * Description : Get (non-resetable) maximum interrupts disabled time.
    781          *
    782          * Argument(s) : none.
    783          *
    784          * Return(s)   : (Non-resetable) maximum interrupts disabled time (in CPU timestamp timer counts).
    785          *
    786          *               See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()      Note #2c'
    787          *                      & 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TSxx_to_uSec()  Note #2'.
    788          *
    789          * Caller(s)   : CPU_IntDisMeasInit(),
    790          *               Application.
    791          *
    792          *               This function is a CPU module application programming interface (API) function
    793          *               & MAY be called by application function(s).
    794          *
    795          * Note(s)     : (1) After initialization, 'CPU_IntDisMeasMax_cnts' MUST ALWAYS be accessed
    796          *                   exclusively with interrupts disabled -- but NOT with critical sections.
    797          *********************************************************************************************************
    798          */
    799          
    800          #ifdef  CPU_CFG_INT_DIS_MEAS_EN

   \                                 In section .text, align 2, keep-with-next
    801          CPU_TS_TMR  CPU_IntDisMeasMaxGet (void)
    802          {
   \                     CPU_IntDisMeasMaxGet: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    803              CPU_TS_TMR  time_tot_cnts;
    804              CPU_TS_TMR  time_max_cnts;
    805              CPU_SR_ALLOC();
   \   00000002   0x2000             MOVS     R0,#+0
    806          
    807          
    808              CPU_INT_DIS();
   \   00000004   0x.... 0x....      BL       CPU_SR_Save
    809              time_tot_cnts = CPU_IntDisMeasMax_cnts;
   \   00000008   0x....             LDR.N    R1,??DataTable14_3
   \   0000000A   0x680C             LDR      R4,[R1, #+0]
    810              CPU_INT_EN();
   \   0000000C   0x.... 0x....      BL       CPU_SR_Restore
    811              time_max_cnts = CPU_IntDisMeasMaxCalc(time_tot_cnts);
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       CPU_IntDisMeasMaxCalc
    812          
    813              return (time_max_cnts);
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
    814          }
    815          #endif
    816          
    817          
    818          /*
    819          *********************************************************************************************************
    820          *                                        CPU_IntDisMeasStart()
    821          *
    822          * Description : Start interrupts disabled time measurement.
    823          *
    824          * Argument(s) : none.
    825          *
    826          * Return(s)   : none.
    827          *
    828          * Caller(s)   : CPU_CRITICAL_ENTER().
    829          *
    830          *               This function is an INTERNAL CPU module function & MUST NOT be called by application
    831          *               function(s).
    832          *
    833          * Note(s)     : none.
    834          *********************************************************************************************************
    835          */
    836          
    837          #ifdef  CPU_CFG_INT_DIS_MEAS_EN

   \                                 In section .text, align 2, keep-with-next
    838          void  CPU_IntDisMeasStart (void)
    839          {
   \                     CPU_IntDisMeasStart: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    840              CPU_IntDisMeasCtr++;
   \   00000002   0x....             LDR.N    R0,??DataTable14_4
   \   00000004   0x8800             LDRH     R0,[R0, #+0]
   \   00000006   0x1C40             ADDS     R0,R0,#+1
   \   00000008   0x....             LDR.N    R1,??DataTable14_4
   \   0000000A   0x8008             STRH     R0,[R1, #+0]
    841              if (CPU_IntDisNestCtr == 0u) {                                  /* If ints NOT yet dis'd, ...                       */
   \   0000000C   0x....             LDR.N    R0,??DataTable14_5
   \   0000000E   0x8800             LDRH     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD103             BNE.N    ??CPU_IntDisMeasStart_0
    842                  CPU_IntDisMeasStart_cnts = CPU_TS_TmrRd();                  /* ... get ints dis'd start time.                   */
   \   00000014   0x.... 0x....      BL       CPU_TS_TmrRd
   \   00000018   0x....             LDR.N    R1,??DataTable14_6
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    843              }
    844              CPU_IntDisNestCtr++;
   \                     ??CPU_IntDisMeasStart_0: (+1)
   \   0000001C   0x....             LDR.N    R0,??DataTable14_5
   \   0000001E   0x8800             LDRH     R0,[R0, #+0]
   \   00000020   0x1C40             ADDS     R0,R0,#+1
   \   00000022   0x....             LDR.N    R1,??DataTable14_5
   \   00000024   0x8008             STRH     R0,[R1, #+0]
    845          }
   \   00000026   0xBD01             POP      {R0,PC}          ;; return
    846          #endif
    847          
    848          
    849          /*
    850          *********************************************************************************************************
    851          *                                        CPU_IntDisMeasStop()
    852          *
    853          * Description : Stop interrupts disabled time measurement.
    854          *
    855          * Argument(s) : none.
    856          *
    857          * Return(s)   : none.
    858          *
    859          * Caller(s)   : CPU_CRITICAL_EXIT().
    860          *
    861          *               This function is an INTERNAL CPU module function & MUST NOT be called by application
    862          *               function(s).
    863          *
    864          * Note(s)     : (1) (a) The total amount of time interrupts are disabled by system &/or application code
    865          *                       during critical sections is calculated by the following equations :
    866          *
    867          *                       (1) When interrupts disabled time measurements are disabled :
    868          *
    869          *
    870          *                               |   CRITICAL  |                           |   CRITICAL  |
    871          *                               |<- SECTION ->|                           |<- SECTION ->|
    872          *                               |    ENTER    |                           |    EXIT     |
    873          *
    874          *                            Disable                                    Enable
    875          *                           Interrupts                                Interrupts
    876          *
    877          *                               ||           ||                           ||           ||
    878          *                               ||           ||                           ||           ||
    879          *                               ||       |   ||<------------------------->||       |   ||
    880          *                               ||       |<->||             |             ||<----->|   ||
    881          *                               ||       | | ||             |             ||   |   |   ||
    882          *                                        | |                |                  |   |
    883          *                                   interrupts            time                 interrupts
    884          *                                    disabled                 interrupts       |enabled
    885          *                                          |                   disabled        |
    886          *                                          |              (via application)    |
    887          *                                       time                                 time
    888          *                                           interrupts                           interrupts
    889          *                                         disabled ovrhd                        enabled ovrhd
    890          *
    891          *
    892          *                           (A) time            =  [ time            -  time           ]  -  time
    893          *                                   interrupts     [     interrupts         interrupts ]         total
    894          *                                    disabled      [      enabled            disabled  ]         ovrhd
    895          *                               (via application)
    896          *
    897          *
    898          *                           (B) time       =  time              +  time
    899          *                                   total         interrupts           interrupts
    900          *                                   ovrhd        enabled ovrhd       disabled ovrhd
    901          *
    902          *
    903          *                                   where
    904          *
    905          *                                           time                    time interrupts are disabled between
    906          *                                               interrupts              first critical section enter &
    907          *                                                disabled               last  critical section exit (i.e.
    908          *                                           (via application)           minus total overhead time)
    909          *
    910          *                                           time                    time when interrupts are disabled
    911          *                                               interrupts
    912          *                                                disabled
    913          *
    914          *                                           time                    time when interrupts are  enabled
    915          *                                               interrupts
    916          *                                                enabled
    917          *
    918          *
    919          *                                           time                    total overhead time to disable/enable
    920          *                                               total                   interrupts during critical section
    921          *                                               ovrhd                   enter & exit
    922          *
    923          *                                           time                    total overhead time to disable interrupts
    924          *                                               interrupts              during critical section enter
    925          *                                             disabled ovrhd
    926          *
    927          *                                           time                    total overhead time to enable  interrupts
    928          *                                               interrupts              during critical section exit
    929          *                                              enabled ovrhd
    930          *
    931          *
    932          *                       (2) When interrupts disabled time measurements are enabled :
    933          *
    934          *
    935          *        |                                    |                           |                                       |
    936          *        |<----- CRITICAL SECTION ENTER ----->|                           |<------- CRITICAL SECTION EXIT ------->|
    937          *        |                                    |                           |                                       |
    938          *
    939          *                   Time                                                 Time
    940          *     Disable    Measurement                                          Measurement                  Enable
    941          *    Interrupts     Start                                                Stop                    Interrupts
    942          *
    943          *        ||           |                      ||                           ||                         |           ||
    944          *        ||           |                      ||                           ||                         |           ||
    945          *        ||           |        |             ||<------------------------->||               |         |           ||
    946          *        ||       |   |        |<----------->||             |             ||<------------->|         |       |   ||
    947          *        ||       |   |        |      |      ||             |             ||       |       |         |       |   ||
    948          *                 |            |      |                     |                      |       |                 |
    949          *            interrupts       get     |                   time                     |      get            interrupts
    950          *             disabled    start time  |                       interrupts           |   stop time          enabled
    951          *                            meas     |                        disabled            |     meas
    952          *                                   time                  (via application)      time
    953          *                                       start meas                                   stop meas
    954          *                                         ovrhd                                        ovrhd
    955          *
    956          *
    957          *                           (A) time            =  [ time       -  time      ]  -  time
    958          *                                   interrupts     [      stop         start ]         total meas
    959          *                                    disabled      [      meas         meas  ]           ovrhd
    960          *                               (via application)
    961          *
    962          *
    963          *                           (B) time            =  time            +  time
    964          *                                   total meas         start meas         stop meas
    965          *                                     ovrhd              ovrhd              ovrhd
    966          *
    967          *
    968          *                                   where
    969          *
    970          *                                           time                    time interrupts are disabled between first
    971          *                                               interrupts              critical section enter & last critical
    972          *                                                disabled               section exit (i.e. minus measurement
    973          *                                           (via application)           overhead time; however, this does NOT
    974          *                                                                       include any overhead time to disable
    975          *                                                                       or enable interrupts during critical
    976          *                                                                       section enter & exit)
    977          *
    978          *                                           time                    time of disable interrupts start time
    979          *                                               start                   measurement (in timer counts)
    980          *                                               meas
    981          *
    982          *                                           time                    time of disable interrupts stop  time
    983          *                                               stop                    measurement (in timer counts)
    984          *                                               meas
    985          *
    986          *
    987          *                                           time                    total overhead time to start/stop disabled
    988          *                                               total meas              interrupts time measurements (in timer
    989          *                                                 ovrhd                 counts)
    990          *
    991          *                                           time                    total overhead time after getting start
    992          *                                               start meas              time until end of start measurement
    993          *                                                 ovrhd                 function  (in timer counts)
    994          *
    995          *                                           time                    total overhead time from beginning of stop
    996          *                                               stop meas               measurement function until after getting
    997          *                                                 ovrhd                 stop time (in timer counts)
    998          *
    999          *
   1000          *                   (b) (1) (A) In order to correctly handle unsigned subtraction overflows of start times
   1001          *                               from stop times, CPU timestamp timer count values MUST be returned via
   1002          *                               word-size-configurable 'CPU_TS_TMR' data type.
   1003          *
   1004          *                               See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()  Note #2a'.
   1005          *
   1006          *                           (B) Since unsigned subtraction of start times from stop times assumes increasing
   1007          *                               values, timestamp timer count values MUST increase with each time count.
   1008          *
   1009          *                               See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()  Note #2b'.
   1010          *
   1011          *                       (2) (A) To expedite & reduce interrupts disabled time measurement overhead; only the
   1012          *                               subtraction of start times from stop times is performed.
   1013          *
   1014          *                           (B) The final calculations to subtract the interrupts disabled time measurement
   1015          *                               overhead is performed asynchronously in appropriate API functions.
   1016          *
   1017          *                               See also 'CPU_IntDisMeasMaxCalc()  Note #1b'.
   1018          *********************************************************************************************************
   1019          */
   1020          
   1021          #ifdef  CPU_CFG_INT_DIS_MEAS_EN

   \                                 In section .text, align 2, keep-with-next
   1022          void  CPU_IntDisMeasStop (void)
   1023          {
   \                     CPU_IntDisMeasStop: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1024              CPU_TS_TMR  time_ints_disd_cnts;
   1025          
   1026          
   1027              CPU_IntDisNestCtr--;
   \   00000002   0x....             LDR.N    R0,??DataTable14_5
   \   00000004   0x8800             LDRH     R0,[R0, #+0]
   \   00000006   0x1E40             SUBS     R0,R0,#+1
   \   00000008   0x....             LDR.N    R1,??DataTable14_5
   \   0000000A   0x8008             STRH     R0,[R1, #+0]
   1028              if (CPU_IntDisNestCtr == 0u) {                                  /* If ints NO longer dis'd,        ...              */
   \   0000000C   0x....             LDR.N    R0,??DataTable14_5
   \   0000000E   0x8800             LDRH     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD114             BNE.N    ??CPU_IntDisMeasStop_0
   1029                  CPU_IntDisMeasStop_cnts = CPU_TS_TmrRd();                   /* ... get  ints dis'd stop time & ...              */
   \   00000014   0x.... 0x....      BL       CPU_TS_TmrRd
   \   00000018   0x....             LDR.N    R1,??DataTable14_7
   \   0000001A   0x6008             STR      R0,[R1, #+0]
   1030                                                                              /* ... calc ints dis'd tot  time (see Note #1b2A).  */
   1031                  time_ints_disd_cnts     = CPU_IntDisMeasStop_cnts -
   1032                                            CPU_IntDisMeasStart_cnts;
   \   0000001C   0x....             LDR.N    R0,??DataTable14_7
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x....             LDR.N    R1,??DataTable14_6
   \   00000022   0x6809             LDR      R1,[R1, #+0]
   \   00000024   0x1A40             SUBS     R0,R0,R1
   1033                                                                              /* Calc max ints dis'd times.                       */
   1034                  if (CPU_IntDisMeasMaxCur_cnts < time_ints_disd_cnts) {
   \   00000026   0x....             LDR.N    R1,??DataTable14_2
   \   00000028   0x6809             LDR      R1,[R1, #+0]
   \   0000002A   0x4281             CMP      R1,R0
   \   0000002C   0xD201             BCS.N    ??CPU_IntDisMeasStop_1
   1035                      CPU_IntDisMeasMaxCur_cnts = time_ints_disd_cnts;
   \   0000002E   0x....             LDR.N    R1,??DataTable14_2
   \   00000030   0x6008             STR      R0,[R1, #+0]
   1036                  }
   1037                  if (CPU_IntDisMeasMax_cnts    < time_ints_disd_cnts) {
   \                     ??CPU_IntDisMeasStop_1: (+1)
   \   00000032   0x....             LDR.N    R1,??DataTable14_3
   \   00000034   0x6809             LDR      R1,[R1, #+0]
   \   00000036   0x4281             CMP      R1,R0
   \   00000038   0xD201             BCS.N    ??CPU_IntDisMeasStop_0
   1038                      CPU_IntDisMeasMax_cnts    = time_ints_disd_cnts;
   \   0000003A   0x....             LDR.N    R1,??DataTable14_3
   \   0000003C   0x6008             STR      R0,[R1, #+0]
   1039                  }
   1040              }
   1041          }
   \                     ??CPU_IntDisMeasStop_0: (+1)
   \   0000003E   0xBD01             POP      {R0,PC}          ;; return
   1042          #endif
   1043          
   1044          
   1045          /*
   1046          *********************************************************************************************************
   1047          *                                         CPU_CntLeadZeros()
   1048          *
   1049          * Description : Count the number of contiguous, most-significant, leading zero bits in a data value.
   1050          *
   1051          * Argument(s) : val         Data value to count leading zero bits.
   1052          *
   1053          * Return(s)   : Number of contiguous, most-significant, leading zero bits in 'val', if NO error(s).
   1054          *
   1055          *               DEF_INT_CPU_U_MAX_VAL,                                              otherwise.
   1056          *
   1057          * Caller(s)   : CPU_CntTrailZeros(),
   1058          *               Application.
   1059          *
   1060          *               This function is a CPU module application programming interface (API) function & MAY
   1061          *               be called by application function(s).
   1062          *
   1063          * Note(s)     : (1) (a) Supports the following data value sizes :
   1064          *
   1065          *                       (1)  8-bits
   1066          *                       (2) 16-bits
   1067          *                       (3) 32-bits
   1068          *                       (4) 64-bits
   1069          *
   1070          *                       See also 'cpu_def.h  CPU WORD CONFIGURATION  Note #1'.
   1071          *
   1072          *                   (b) (1) For  8-bit values :
   1073          *
   1074          *                                  b07  b06  b05  b04  b03  b02  b01  b00    # Leading Zeros
   1075          *                                  ---  ---  ---  ---  ---  ---  ---  ---    ---------------
   1076          *                                   1    x    x    x    x    x    x    x            0
   1077          *                                   0    1    x    x    x    x    x    x            1
   1078          *                                   0    0    1    x    x    x    x    x            2
   1079          *                                   0    0    0    1    x    x    x    x            3
   1080          *                                   0    0    0    0    1    x    x    x            4
   1081          *                                   0    0    0    0    0    1    x    x            5
   1082          *                                   0    0    0    0    0    0    1    x            6
   1083          *                                   0    0    0    0    0    0    0    1            7
   1084          *                                   0    0    0    0    0    0    0    0            8
   1085          *
   1086          *
   1087          *                       (2) For 16-bit values :
   1088          *
   1089          *                             b15  b14  b13  ...  b04  b03  b02  b01  b00    # Leading Zeros
   1090          *                             ---  ---  ---       ---  ---  ---  ---  ---    ---------------
   1091          *                              1    x    x         x    x    x    x    x            0
   1092          *                              0    1    x         x    x    x    x    x            1
   1093          *                              0    0    1         x    x    x    x    x            2
   1094          *                              :    :    :         :    :    :    :    :            :
   1095          *                              :    :    :         :    :    :    :    :            :
   1096          *                              0    0    0         1    x    x    x    x           11
   1097          *                              0    0    0         0    1    x    x    x           12
   1098          *                              0    0    0         0    0    1    x    x           13
   1099          *                              0    0    0         0    0    0    1    x           14
   1100          *                              0    0    0         0    0    0    0    1           15
   1101          *                              0    0    0         0    0    0    0    0           16
   1102          *
   1103          *                       (3) For 32-bit values :
   1104          *
   1105          *                             b31  b30  b29  ...  b04  b03  b02  b01  b00    # Leading Zeros
   1106          *                             ---  ---  ---       ---  ---  ---  ---  ---    ---------------
   1107          *                              1    x    x         x    x    x    x    x            0
   1108          *                              0    1    x         x    x    x    x    x            1
   1109          *                              0    0    1         x    x    x    x    x            2
   1110          *                              :    :    :         :    :    :    :    :            :
   1111          *                              :    :    :         :    :    :    :    :            :
   1112          *                              0    0    0         1    x    x    x    x           27
   1113          *                              0    0    0         0    1    x    x    x           28
   1114          *                              0    0    0         0    0    1    x    x           29
   1115          *                              0    0    0         0    0    0    1    x           30
   1116          *                              0    0    0         0    0    0    0    1           31
   1117          *                              0    0    0         0    0    0    0    0           32
   1118          *
   1119          *
   1120          *                       (4) For 64-bit values :
   1121          *
   1122          *                             b63  b62  b61  ...  b04  b03  b02  b01  b00    # Leading Zeros
   1123          *                             ---  ---  ---       ---  ---  ---  ---  ---    ---------------
   1124          *                              1    x    x         x    x    x    x    x            0
   1125          *                              0    1    x         x    x    x    x    x            1
   1126          *                              0    0    1         x    x    x    x    x            2
   1127          *                              :    :    :         :    :    :    :    :            :
   1128          *                              :    :    :         :    :    :    :    :            :
   1129          *                              0    0    0         1    x    x    x    x           59
   1130          *                              0    0    0         0    1    x    x    x           60
   1131          *                              0    0    0         0    0    1    x    x           61
   1132          *                              0    0    0         0    0    0    1    x           62
   1133          *                              0    0    0         0    0    0    0    1           63
   1134          *                              0    0    0         0    0    0    0    0           64
   1135          *
   1136          *
   1137          *                       See also 'CPU COUNT LEAD ZEROs LOOKUP TABLE  Note #1'.
   1138          *********************************************************************************************************
   1139          */
   1140          
   1141          #ifndef   CPU_CFG_LEAD_ZEROS_ASM_PRESENT
   1142          CPU_DATA  CPU_CntLeadZeros (CPU_DATA  val)
   1143          {
   1144              CPU_DATA  nbr_lead_zeros;
   1145          
   1146          
   1147          #if   (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_08)
   1148              nbr_lead_zeros = CPU_CntLeadZeros08((CPU_INT08U)val);
   1149          
   1150          #elif (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_16)
   1151              nbr_lead_zeros = CPU_CntLeadZeros16((CPU_INT16U)val);
   1152          
   1153          #elif (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_32)
   1154              nbr_lead_zeros = CPU_CntLeadZeros32((CPU_INT32U)val);
   1155          
   1156          #elif (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_64)
   1157              nbr_lead_zeros = CPU_CntLeadZeros64((CPU_INT64U)val);
   1158          
   1159          #else                                                           /* See Note #1a.                                        */
   1160              nbr_lead_zeros = DEF_INT_CPU_U_MAX_VAL;
   1161          #endif
   1162          
   1163          
   1164              return (nbr_lead_zeros);
   1165          }
   1166          #endif
   1167          
   1168          
   1169          /*
   1170          *********************************************************************************************************
   1171          *                                        CPU_CntLeadZeros08()
   1172          *
   1173          * Description : Count the number of contiguous, most-significant, leading zero bits in an 8-bit data value.
   1174          *
   1175          * Argument(s) : val         Data value to count leading zero bits.
   1176          *
   1177          * Return(s)   : Number of contiguous, most-significant, leading zero bits in 'val'.
   1178          *
   1179          * Caller(s)   : CPU_CntLeadZeros(),
   1180          *               CPU_CntTrailZeros08(),
   1181          *               Application.
   1182          *
   1183          *               This function is a CPU module application programming interface (API) function & MAY be
   1184          *               called by application function(s).
   1185          *
   1186          * Note(s)     : (1) Supports  8-bit values :
   1187          *
   1188          *                               b07  b06  b05  b04  b03  b02  b01  b00    # Leading Zeros
   1189          *                               ---  ---  ---  ---  ---  ---  ---  ---    ---------------
   1190          *                                1    x    x    x    x    x    x    x            0
   1191          *                                0    1    x    x    x    x    x    x            1
   1192          *                                0    0    1    x    x    x    x    x            2
   1193          *                                0    0    0    1    x    x    x    x            3
   1194          *                                0    0    0    0    1    x    x    x            4
   1195          *                                0    0    0    0    0    1    x    x            5
   1196          *                                0    0    0    0    0    0    1    x            6
   1197          *                                0    0    0    0    0    0    0    1            7
   1198          *                                0    0    0    0    0    0    0    0            8
   1199          *
   1200          *
   1201          *                   See also 'CPU COUNT LEAD ZEROs LOOKUP TABLE  Note #1'.
   1202          *********************************************************************************************************
   1203          */
   1204          
   1205          #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_08)

   \                                 In section .text, align 2, keep-with-next
   1206          CPU_DATA  CPU_CntLeadZeros08 (CPU_INT08U  val)
   1207          {
   \                     CPU_CntLeadZeros08: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1208          #if  (!((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
   1209                  (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_08)))
   1210              CPU_DATA  ix;
   1211          #endif
   1212              CPU_DATA  nbr_lead_zeros;
   1213          
   1214                                                                                          /* ---------- ASM-OPTIMIZED ----------- */
   1215          #if ((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
   1216               (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_08))
   1217              nbr_lead_zeros  =  CPU_CntLeadZeros((CPU_DATA)val);
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x.... 0x....      BL       CPU_CntLeadZeros
   1218              nbr_lead_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_08) * DEF_OCTET_NBR_BITS;
   \   00000008   0x3818             SUBS     R0,R0,#+24
   1219          
   1220          
   1221          #else                                                                           /* ----------- C-OPTIMIZED ------------ */
   1222                                                                                          /* Chk bits [07:00] :                   */
   1223                                                                                          /* .. Nbr lead zeros =               .. */
   1224              ix              = (CPU_DATA)(val);                                          /* .. lookup tbl ix  = 'val' >>  0 bits */
   1225              nbr_lead_zeros  = (CPU_DATA)(CPU_CntLeadZerosTbl[ix]);                      /* .. plus nbr msb lead zeros =  0 bits.*/
   1226          #endif
   1227          
   1228          
   1229              return (nbr_lead_zeros);
   \   0000000A   0xBD02             POP      {R1,PC}          ;; return
   1230          }
   1231          #endif
   1232          
   1233          
   1234          /*
   1235          *********************************************************************************************************
   1236          *                                        CPU_CntLeadZeros16()
   1237          *
   1238          * Description : Count the number of contiguous, most-significant, leading zero bits in a 16-bit data value.
   1239          *
   1240          * Argument(s) : val         Data value to count leading zero bits.
   1241          *
   1242          * Return(s)   : Number of contiguous, most-significant, leading zero bits in 'val'.
   1243          *
   1244          * Caller(s)   : CPU_CntLeadZeros(),
   1245          *               CPU_CntTrailZeros16(),
   1246          *               Application.
   1247          *
   1248          *               This function is a CPU module application programming interface (API) function & MAY be
   1249          *               called by application function(s).
   1250          *
   1251          * Note(s)     : (1) Supports 16-bit values :
   1252          *
   1253          *                          b15  b14  b13  ...  b04  b03  b02  b01  b00    # Leading Zeros
   1254          *                          ---  ---  ---       ---  ---  ---  ---  ---    ---------------
   1255          *                           1    x    x         x    x    x    x    x            0
   1256          *                           0    1    x         x    x    x    x    x            1
   1257          *                           0    0    1         x    x    x    x    x            2
   1258          *                           :    :    :         :    :    :    :    :            :
   1259          *                           :    :    :         :    :    :    :    :            :
   1260          *                           0    0    0         1    x    x    x    x           11
   1261          *                           0    0    0         0    1    x    x    x           12
   1262          *                           0    0    0         0    0    1    x    x           13
   1263          *                           0    0    0         0    0    0    1    x           14
   1264          *                           0    0    0         0    0    0    0    1           15
   1265          *                           0    0    0         0    0    0    0    0           16
   1266          *
   1267          *
   1268          *                   See also 'CPU COUNT LEAD ZEROs LOOKUP TABLE  Note #1'.
   1269          *********************************************************************************************************
   1270          */
   1271          
   1272          #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_16)

   \                                 In section .text, align 2, keep-with-next
   1273          CPU_DATA  CPU_CntLeadZeros16 (CPU_INT16U  val)
   1274          {
   \                     CPU_CntLeadZeros16: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1275          #if  (!((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
   1276                  (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_16)))
   1277              CPU_DATA  ix;
   1278          #endif
   1279              CPU_DATA  nbr_lead_zeros;
   1280          
   1281                                                                                          /* ---------- ASM-OPTIMIZED ----------- */
   1282          #if ((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
   1283               (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_16))
   1284              nbr_lead_zeros  =  CPU_CntLeadZeros((CPU_DATA)val);
   \   00000002   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000004   0x.... 0x....      BL       CPU_CntLeadZeros
   1285              nbr_lead_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_16) * DEF_OCTET_NBR_BITS;
   \   00000008   0x3810             SUBS     R0,R0,#+16
   1286          
   1287          
   1288          #else                                                                           /* ----------- C-OPTIMIZED ------------ */
   1289              if (val > 0x00FFu) {                                                        /* Chk bits [15:08] :                   */
   1290                                                                                          /* .. Nbr lead zeros =               .. */
   1291                  ix             = (CPU_DATA)(val >> 8u);									/* .. lookup tbl ix  = 'val' >>  8 bits */
   1292                  nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix]);                   /* .. plus nbr msb lead zeros =  0 bits.*/
   1293          
   1294              } else {                                                                    /* Chk bits [07:00] :                   */
   1295                                                                                          /* .. Nbr lead zeros =               .. */
   1296                  ix             = (CPU_DATA)(val);                                       /* .. lookup tbl ix  = 'val' >>  0 bits */
   1297                  nbr_lead_zeros = (CPU_DATA)((CPU_DATA)CPU_CntLeadZerosTbl[ix] +  8u);   /* .. plus nbr msb lead zeros =  8 bits.*/
   1298              }
   1299          #endif
   1300          
   1301          
   1302              return (nbr_lead_zeros);
   \   0000000A   0xBD02             POP      {R1,PC}          ;; return
   1303          }
   1304          #endif
   1305          
   1306          
   1307          /*
   1308          *********************************************************************************************************
   1309          *                                        CPU_CntLeadZeros32()
   1310          *
   1311          * Description : Count the number of contiguous, most-significant, leading zero bits in a 32-bit data value.
   1312          *
   1313          * Argument(s) : val         Data value to count leading zero bits.
   1314          *
   1315          * Return(s)   : Number of contiguous, most-significant, leading zero bits in 'val'.
   1316          *
   1317          * Caller(s)   : CPU_CntLeadZeros(),
   1318          *               CPU_CntTrailZeros32(),
   1319          *               Application.
   1320          *
   1321          *               This function is a CPU module application programming interface (API) function & MAY be
   1322          *               called by application function(s).
   1323          *
   1324          * Note(s)     : (1) Supports 32-bit values :
   1325          *
   1326          *                          b31  b30  b29  ...  b04  b03  b02  b01  b00    # Leading Zeros
   1327          *                          ---  ---  ---       ---  ---  ---  ---  ---    ---------------
   1328          *                           1    x    x         x    x    x    x    x            0
   1329          *                           0    1    x         x    x    x    x    x            1
   1330          *                           0    0    1         x    x    x    x    x            2
   1331          *                           :    :    :         :    :    :    :    :            :
   1332          *                           :    :    :         :    :    :    :    :            :
   1333          *                           0    0    0         1    x    x    x    x           27
   1334          *                           0    0    0         0    1    x    x    x           28
   1335          *                           0    0    0         0    0    1    x    x           29
   1336          *                           0    0    0         0    0    0    1    x           30
   1337          *                           0    0    0         0    0    0    0    1           31
   1338          *                           0    0    0         0    0    0    0    0           32
   1339          *
   1340          *
   1341          *                   See also 'CPU COUNT LEAD ZEROs LOOKUP TABLE  Note #1'.
   1342          *********************************************************************************************************
   1343          */
   1344          
   1345          #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_32)

   \                                 In section .text, align 2, keep-with-next
   1346          CPU_DATA  CPU_CntLeadZeros32 (CPU_INT32U  val)
   1347          {
   \                     CPU_CntLeadZeros32: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1348          #if  (!((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
   1349                  (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_32)))
   1350              CPU_DATA  ix;
   1351          #endif
   1352              CPU_DATA  nbr_lead_zeros;
   1353          
   1354                                                                                          /* ---------- ASM-OPTIMIZED ----------- */
   1355          #if ((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
   1356               (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_32))
   1357              nbr_lead_zeros  =  CPU_CntLeadZeros((CPU_DATA)val);
   \   00000002   0x.... 0x....      BL       CPU_CntLeadZeros
   1358              nbr_lead_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_32) * DEF_OCTET_NBR_BITS;
   1359          
   1360          
   1361          #else                                                                           /* ----------- C-OPTIMIZED ------------ */
   1362              if (val > 0x0000FFFFu) {
   1363                  if (val > 0x00FFFFFFu) {                                                /* Chk bits [31:24] :                   */
   1364                                                                                          /* .. Nbr lead zeros =               .. */
   1365                      ix             = (CPU_DATA)(val >> 24u);                            /* .. lookup tbl ix  = 'val' >> 24 bits */
   1366                      nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix]);               /* .. plus nbr msb lead zeros =  0 bits.*/
   1367          
   1368                  } else {                                                                /* Chk bits [23:16] :                   */
   1369                                                                                          /* .. Nbr lead zeros =               .. */
   1370                      ix             = (CPU_DATA)(val >> 16u);                            /* .. lookup tbl ix  = 'val' >> 16 bits */
   1371                      nbr_lead_zeros = (CPU_DATA)((CPU_DATA)CPU_CntLeadZerosTbl[ix] +  8u);/* .. plus nbr msb lead zeros =  8 bits.*/
   1372                  }
   1373          
   1374              } else {
   1375                  if (val > 0x000000FFu) {                                                /* Chk bits [15:08] :                   */
   1376                                                                                          /* .. Nbr lead zeros =               .. */
   1377                      ix             = (CPU_DATA)(val >>  8u);                            /* .. lookup tbl ix  = 'val' >>  8 bits */
   1378                      nbr_lead_zeros = (CPU_DATA)((CPU_DATA)CPU_CntLeadZerosTbl[ix] + 16u);/* .. plus nbr msb lead zeros = 16 bits.*/
   1379          
   1380                  } else {                                                                /* Chk bits [07:00] :                   */
   1381                                                                                          /* .. Nbr lead zeros =               .. */
   1382                      ix             = (CPU_DATA)(val);                                   /* .. lookup tbl ix  = 'val' >>  0 bits */
   1383                      nbr_lead_zeros = (CPU_DATA)((CPU_DATA)CPU_CntLeadZerosTbl[ix] + 24u);/* .. plus nbr msb lead zeros = 24 bits.*/
   1384                  }
   1385              }
   1386          #endif
   1387          
   1388          
   1389              return (nbr_lead_zeros);
   \   00000006   0xBD02             POP      {R1,PC}          ;; return
   1390          }
   1391          #endif
   1392          
   1393          
   1394          /*
   1395          *********************************************************************************************************
   1396          *                                        CPU_CntLeadZeros64()
   1397          *
   1398          * Description : Count the number of contiguous, most-significant, leading zero bits in a 64-bit data value.
   1399          *
   1400          * Argument(s) : val         Data value to count leading zero bits.
   1401          *
   1402          * Return(s)   : Number of contiguous, most-significant, leading zero bits in 'val'.
   1403          *
   1404          * Caller(s)   : CPU_CntLeadZeros(),
   1405          *               CPU_CntTrailZeros64(),
   1406          *               Application.
   1407          *
   1408          *               This function is a CPU module application programming interface (API) function & MAY be
   1409          *               called by application function(s).
   1410          *
   1411          * Note(s)     : (1) Supports 64-bit values :
   1412          *
   1413          *                          b63  b62  b61  ...  b04  b03  b02  b01  b00    # Leading Zeros
   1414          *                          ---  ---  ---       ---  ---  ---  ---  ---    ---------------
   1415          *                           1    x    x         x    x    x    x    x            0
   1416          *                           0    1    x         x    x    x    x    x            1
   1417          *                           0    0    1         x    x    x    x    x            2
   1418          *                           :    :    :         :    :    :    :    :            :
   1419          *                           :    :    :         :    :    :    :    :            :
   1420          *                           0    0    0         1    x    x    x    x           59
   1421          *                           0    0    0         0    1    x    x    x           60
   1422          *                           0    0    0         0    0    1    x    x           61
   1423          *                           0    0    0         0    0    0    1    x           62
   1424          *                           0    0    0         0    0    0    0    1           63
   1425          *                           0    0    0         0    0    0    0    0           64
   1426          *
   1427          *
   1428          *                   See also 'CPU COUNT LEAD ZEROs LOOKUP TABLE  Note #1'.
   1429          *********************************************************************************************************
   1430          */
   1431          
   1432          #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_64)

   \                                 In section .text, align 2, keep-with-next
   1433          CPU_DATA  CPU_CntLeadZeros64 (CPU_INT64U  val)
   1434          {
   \                     CPU_CntLeadZeros64: (+1)
   \   00000000   0xB500             PUSH     {LR}
   1435          #if  (!((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
   1436                  (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_64)))
   1437              CPU_DATA  ix;
   1438          #endif
   1439              CPU_DATA  nbr_lead_zeros;
   1440          
   1441                                                                                          /* ---------- ASM-OPTIMIZED ----------- */
   1442          #if ((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
   1443               (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_64))
   1444              nbr_lead_zeros  =  CPU_CntLeadZeros((CPU_DATA)val);
   1445              nbr_lead_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_64) * DEF_OCTET_NBR_BITS;
   1446          
   1447          
   1448          #else                                                                           /* ----------- C-OPTIMIZED ------------ */
   1449              if (val > 0x00000000FFFFFFFFull) {
   \   00000002   0x2901             CMP      R1,#+1
   \   00000004   0xD32D             BCC.N    ??CPU_CntLeadZeros64_0
   \   00000006   0xD801             BHI.N    ??CPU_CntLeadZeros64_1
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD32A             BCC.N    ??CPU_CntLeadZeros64_0
   1450                  if (val > 0x0000FFFFFFFFFFFFull) {
   \                     ??CPU_CntLeadZeros64_1: (+1)
   \   0000000C   0xF5B1 0x3F80      CMP      R1,#+65536
   \   00000010   0xD315             BCC.N    ??CPU_CntLeadZeros64_2
   \   00000012   0xD801             BHI.N    ??CPU_CntLeadZeros64_3
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD312             BCC.N    ??CPU_CntLeadZeros64_2
   1451                      if (val > 0x00FFFFFFFFFFFFFFull) {                                  /* Chk bits [63:56] :                   */
   \                     ??CPU_CntLeadZeros64_3: (+1)
   \   00000018   0xF1B1 0x7F80      CMP      R1,#+16777216
   \   0000001C   0xD308             BCC.N    ??CPU_CntLeadZeros64_4
   \   0000001E   0xD801             BHI.N    ??CPU_CntLeadZeros64_5
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD305             BCC.N    ??CPU_CntLeadZeros64_4
   1452                                                                                          /* .. Nbr lead zeros =               .. */
   1453                          ix             = (CPU_DATA)(val >> 56u);                        /* .. lookup tbl ix  = 'val' >> 56 bits */
   \                     ??CPU_CntLeadZeros64_5: (+1)
   \   00000024   0x2238             MOVS     R2,#+56
   \   00000026   0x.... 0x....      BL       __aeabi_llsr
   1454                          nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix]);           /* .. plus nbr msb lead zeros =  0 bits.*/
   \   0000002A   0x....             LDR.N    R1,??DataTable14_8
   \   0000002C   0x5C40             LDRB     R0,[R0, R1]
   \   0000002E   0xE045             B.N      ??CPU_CntLeadZeros64_6
   1455          
   1456                      } else {                                                            /* Chk bits [55:48] :                   */
   1457                                                                                          /* .. Nbr lead zeros =               .. */
   1458                          ix             = (CPU_DATA)(val >> 48u);                        /* .. lookup tbl ix  = 'val' >> 48 bits */
   \                     ??CPU_CntLeadZeros64_4: (+1)
   \   00000030   0x2230             MOVS     R2,#+48
   \   00000032   0x.... 0x....      BL       __aeabi_llsr
   1459                          nbr_lead_zeros = (CPU_DATA)((CPU_INT64U)CPU_CntLeadZerosTbl[ix] +  8u);/* .. plus nbr msb lead zeros =  8 bits.*/
   \   00000036   0x....             LDR.N    R1,??DataTable14_8
   \   00000038   0x5C40             LDRB     R0,[R0, R1]
   \   0000003A   0x3008             ADDS     R0,R0,#+8
   \   0000003C   0xE03E             B.N      ??CPU_CntLeadZeros64_6
   1460                      }
   1461          
   1462                  } else {
   1463                      if (val > 0x000000FFFFFFFFFFull) {                                  /* Chk bits [47:40] :                   */
   \                     ??CPU_CntLeadZeros64_2: (+1)
   \   0000003E   0xF5B1 0x7F80      CMP      R1,#+256
   \   00000042   0xD309             BCC.N    ??CPU_CntLeadZeros64_7
   \   00000044   0xD801             BHI.N    ??CPU_CntLeadZeros64_8
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD306             BCC.N    ??CPU_CntLeadZeros64_7
   1464                                                                                          /* .. Nbr lead zeros =               .. */
   1465                          ix             = (CPU_DATA)(val >> 40u);                        /* .. lookup tbl ix  = 'val' >> 40 bits */
   \                     ??CPU_CntLeadZeros64_8: (+1)
   \   0000004A   0x2228             MOVS     R2,#+40
   \   0000004C   0x.... 0x....      BL       __aeabi_llsr
   1466                          nbr_lead_zeros = (CPU_DATA)((CPU_INT64U)CPU_CntLeadZerosTbl[ix] + 16u);/* .. plus nbr msb lead zeros = 16 bits.*/
   \   00000050   0x....             LDR.N    R1,??DataTable14_8
   \   00000052   0x5C40             LDRB     R0,[R0, R1]
   \   00000054   0x3010             ADDS     R0,R0,#+16
   \   00000056   0xE031             B.N      ??CPU_CntLeadZeros64_6
   1467          
   1468                      } else {                                                            /* Chk bits [39:32] :                   */
   1469                                                                                          /* .. Nbr lead zeros =               .. */
   1470                          ix             = (CPU_DATA)(val >> 32u);                        /* .. lookup tbl ix  = 'val' >> 32 bits */
   \                     ??CPU_CntLeadZeros64_7: (+1)
   \   00000058   0x0008             MOVS     R0,R1
   1471                          nbr_lead_zeros = (CPU_DATA)((CPU_INT64U)CPU_CntLeadZerosTbl[ix] + 24u);/* .. plus nbr msb lead zeros = 24 bits.*/
   \   0000005A   0x....             LDR.N    R1,??DataTable14_8
   \   0000005C   0x5C40             LDRB     R0,[R0, R1]
   \   0000005E   0x3018             ADDS     R0,R0,#+24
   \   00000060   0xE02C             B.N      ??CPU_CntLeadZeros64_6
   1472                      }
   1473                  }
   1474          
   1475              } else {
   1476                  if (val > 0x000000000000FFFFull) {
   \                     ??CPU_CntLeadZeros64_0: (+1)
   \   00000062   0x2900             CMP      R1,#+0
   \   00000064   0xD319             BCC.N    ??CPU_CntLeadZeros64_9
   \   00000066   0xD802             BHI.N    ??CPU_CntLeadZeros64_10
   \   00000068   0xF5B0 0x3F80      CMP      R0,#+65536
   \   0000006C   0xD315             BCC.N    ??CPU_CntLeadZeros64_9
   1477                      if (val > 0x0000000000FFFFFFull) {                                  /* Chk bits [31:24] :                   */
   \                     ??CPU_CntLeadZeros64_10: (+1)
   \   0000006E   0x2900             CMP      R1,#+0
   \   00000070   0xD30B             BCC.N    ??CPU_CntLeadZeros64_11
   \   00000072   0xD802             BHI.N    ??CPU_CntLeadZeros64_12
   \   00000074   0xF1B0 0x7F80      CMP      R0,#+16777216
   \   00000078   0xD307             BCC.N    ??CPU_CntLeadZeros64_11
   1478                                                                                          /* .. Nbr lead zeros =               .. */
   1479                          ix             = (CPU_DATA)(val >> 24u);                        /* .. lookup tbl ix  = 'val' >> 24 bits */
   \                     ??CPU_CntLeadZeros64_12: (+1)
   \   0000007A   0x0E00             LSRS     R0,R0,#+24
   \   0000007C   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \   00000080   0x0E09             LSRS     R1,R1,#+24
   1480                          nbr_lead_zeros = (CPU_DATA)((CPU_INT64U)CPU_CntLeadZerosTbl[ix] + 32u);/* .. plus nbr msb lead zeros = 32 bits.*/
   \   00000082   0x....             LDR.N    R1,??DataTable14_8
   \   00000084   0x5C40             LDRB     R0,[R0, R1]
   \   00000086   0x3020             ADDS     R0,R0,#+32
   \   00000088   0xE018             B.N      ??CPU_CntLeadZeros64_6
   1481          
   1482                      } else {                                                            /* Chk bits [23:16] :                   */
   1483                                                                                          /* .. Nbr lead zeros =               .. */
   1484                          ix             = (CPU_DATA)(val >> 16u);                        /* .. lookup tbl ix  = 'val' >> 16 bits */
   \                     ??CPU_CntLeadZeros64_11: (+1)
   \   0000008A   0x0C00             LSRS     R0,R0,#+16
   \   0000008C   0xEA40 0x4001      ORR      R0,R0,R1, LSL #+16
   \   00000090   0x0C09             LSRS     R1,R1,#+16
   1485                          nbr_lead_zeros = (CPU_DATA)((CPU_INT64U)CPU_CntLeadZerosTbl[ix] + 40u);/* .. plus nbr msb lead zeros = 40 bits.*/
   \   00000092   0x....             LDR.N    R1,??DataTable14_8
   \   00000094   0x5C40             LDRB     R0,[R0, R1]
   \   00000096   0x3028             ADDS     R0,R0,#+40
   \   00000098   0xE010             B.N      ??CPU_CntLeadZeros64_6
   1486                      }
   1487          
   1488                  } else {
   1489                      if (val > 0x00000000000000FFull) {                                  /* Chk bits [15:08] :                   */
   \                     ??CPU_CntLeadZeros64_9: (+1)
   \   0000009A   0x2900             CMP      R1,#+0
   \   0000009C   0xD30B             BCC.N    ??CPU_CntLeadZeros64_13
   \   0000009E   0xD802             BHI.N    ??CPU_CntLeadZeros64_14
   \   000000A0   0xF5B0 0x7F80      CMP      R0,#+256
   \   000000A4   0xD307             BCC.N    ??CPU_CntLeadZeros64_13
   1490                                                                                          /* .. Nbr lead zeros =               .. */
   1491                          ix             = (CPU_DATA)(val >>  8u);                        /* .. lookup tbl ix  = 'val' >>  8 bits */
   \                     ??CPU_CntLeadZeros64_14: (+1)
   \   000000A6   0x0A00             LSRS     R0,R0,#+8
   \   000000A8   0xEA40 0x6001      ORR      R0,R0,R1, LSL #+24
   \   000000AC   0x0A09             LSRS     R1,R1,#+8
   1492                          nbr_lead_zeros = (CPU_DATA)((CPU_INT64U)CPU_CntLeadZerosTbl[ix] + 48u);/* .. plus nbr msb lead zeros = 48 bits.*/
   \   000000AE   0x....             LDR.N    R1,??DataTable14_8
   \   000000B0   0x5C40             LDRB     R0,[R0, R1]
   \   000000B2   0x3030             ADDS     R0,R0,#+48
   \   000000B4   0xE002             B.N      ??CPU_CntLeadZeros64_6
   1493          
   1494                      } else {                                                            /* Chk bits [07:00] :                   */
   1495                                                                                          /* .. Nbr lead zeros =               .. */
   1496                          ix             = (CPU_DATA)(val);                               /* .. lookup tbl ix  = 'val' >>  0 bits */
   1497                          nbr_lead_zeros = (CPU_DATA)((CPU_INT64U)CPU_CntLeadZerosTbl[ix] + 56u);/* .. plus nbr msb lead zeros = 56 bits.*/
   \                     ??CPU_CntLeadZeros64_13: (+1)
   \   000000B6   0x....             LDR.N    R1,??DataTable14_8
   \   000000B8   0x5C40             LDRB     R0,[R0, R1]
   \   000000BA   0x3038             ADDS     R0,R0,#+56
   1498                      }
   1499                  }
   1500              }
   1501          #endif
   1502          
   1503          
   1504              return (nbr_lead_zeros);
   \                     ??CPU_CntLeadZeros64_6: (+1)
   \   000000BC   0xBD00             POP      {PC}             ;; return
   1505          }
   1506          #endif
   1507          
   1508          
   1509          /*
   1510          *********************************************************************************************************
   1511          *                                         CPU_CntTrailZeros()
   1512          *
   1513          * Description : Count the number of contiguous, least-significant, trailing zero bits in a data value.
   1514          *
   1515          * Argument(s) : val         Data value to count trailing zero bits.
   1516          *
   1517          * Return(s)   : Number of contiguous, least-significant, trailing zero bits in 'val'.
   1518          *
   1519          * Caller(s)   : Application.
   1520          *
   1521          *               This function is a CPU module application programming interface (API) function & MAY
   1522          *               be called by application function(s).
   1523          *
   1524          * Note(s)     : (1) (a) Supports the following data value sizes :
   1525          *
   1526          *                       (1)  8-bits
   1527          *                       (2) 16-bits
   1528          *                       (3) 32-bits
   1529          *                       (4) 64-bits
   1530          *
   1531          *                       See also 'cpu_def.h  CPU WORD CONFIGURATION  Note #1'.
   1532          *
   1533          *                   (b) (1) For  8-bit values :
   1534          *
   1535          *                                  b07  b06  b05  b04  b03  b02  b01  b00    # Trailing Zeros
   1536          *                                  ---  ---  ---  ---  ---  ---  ---  ---    ----------------
   1537          *                                   x    x    x    x    x    x    x    1            0
   1538          *                                   x    x    x    x    x    x    1    0            1
   1539          *                                   x    x    x    x    x    1    0    0            2
   1540          *                                   x    x    x    x    1    0    0    0            3
   1541          *                                   x    x    x    1    0    0    0    0            4
   1542          *                                   x    x    1    0    0    0    0    0            5
   1543          *                                   x    1    0    0    0    0    0    0            6
   1544          *                                   1    0    0    0    0    0    0    0            7
   1545          *                                   0    0    0    0    0    0    0    0            8
   1546          *
   1547          *
   1548          *                       (2) For 16-bit values :
   1549          *
   1550          *                             b15  b14  b13  b12  b11  ...  b02  b01  b00    # Trailing Zeros
   1551          *                             ---  ---  ---  ---  ---       ---  ---  ---    ----------------
   1552          *                              x    x    x    x    x         x    x    1            0
   1553          *                              x    x    x    x    x         x    1    0            1
   1554          *                              x    x    x    x    x         1    0    0            2
   1555          *                              :    :    :    :    :         :    :    :            :
   1556          *                              :    :    :    :    :         :    :    :            :
   1557          *                              x    x    x    x    1         0    0    0           11
   1558          *                              x    x    x    1    0         0    0    0           12
   1559          *                              x    x    1    0    0         0    0    0           13
   1560          *                              x    1    0    0    0         0    0    0           14
   1561          *                              1    0    0    0    0         0    0    0           15
   1562          *                              0    0    0    0    0         0    0    0           16
   1563          *
   1564          *
   1565          *                       (3) For 32-bit values :
   1566          *
   1567          *                             b31  b30  b29  b28  b27  ...  b02  b01  b00    # Trailing Zeros
   1568          *                             ---  ---  ---  ---  ---       ---  ---  ---    ----------------
   1569          *                              x    x    x    x    x         x    x    1            0
   1570          *                              x    x    x    x    x         x    1    0            1
   1571          *                              x    x    x    x    x         1    0    0            2
   1572          *                              :    :    :    :    :         :    :    :            :
   1573          *                              :    :    :    :    :         :    :    :            :
   1574          *                              x    x    x    x    1         0    0    0           27
   1575          *                              x    x    x    1    0         0    0    0           28
   1576          *                              x    x    1    0    0         0    0    0           29
   1577          *                              x    1    0    0    0         0    0    0           30
   1578          *                              1    0    0    0    0         0    0    0           31
   1579          *                              0    0    0    0    0         0    0    0           32
   1580          *
   1581          *
   1582          *                       (4) For 64-bit values :
   1583          *
   1584          *                             b63  b62  b61  b60  b59  ...  b02  b01  b00    # Trailing Zeros
   1585          *                             ---  ---  ---  ---  ---       ---  ---  ---    ----------------
   1586          *                              x    x    x    x    x         x    x    1            0
   1587          *                              x    x    x    x    x         x    1    0            1
   1588          *                              x    x    x    x    x         1    0    0            2
   1589          *                              :    :    :    :    :         :    :    :            :
   1590          *                              :    :    :    :    :         :    :    :            :
   1591          *                              x    x    x    x    1         0    0    0           59
   1592          *                              x    x    x    1    0         0    0    0           60
   1593          *                              x    x    1    0    0         0    0    0           61
   1594          *                              x    1    0    0    0         0    0    0           62
   1595          *                              1    0    0    0    0         0    0    0           63
   1596          *                              0    0    0    0    0         0    0    0           64
   1597          *
   1598          *               (2) For non-zero values, the returned number of contiguous, least-significant, trailing
   1599          *                   zero bits is also equivalent to the bit position of the least-significant set bit.
   1600          *
   1601          *               (3) 'val' SHOULD be validated for non-'0' PRIOR to all other counting zero calculations :
   1602          *
   1603          *                   (a) CPU_CntTrailZeros()'s final conditional statement calculates 'val's number of
   1604          *                       trailing zeros based on its return data size, 'CPU_CFG_DATA_SIZE', & 'val's
   1605          *                       calculated number of lead zeros ONLY if the initial 'val' is non-'0' :
   1606          *
   1607          *                           if (val != 0u) {
   1608          *                               nbr_trail_zeros = ((CPU_CFG_DATA_SIZE * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
   1609          *                           } else {
   1610          *                               nbr_trail_zeros = nbr_lead_zeros;
   1611          *                           }
   1612          *
   1613          *                       Therefore, initially validating all non-'0' values avoids having to conditionally
   1614          *                       execute the final 'if' statement.
   1615          *********************************************************************************************************
   1616          */
   1617          
   1618          #ifndef   CPU_CFG_TRAIL_ZEROS_ASM_PRESENT
   1619          CPU_DATA  CPU_CntTrailZeros (CPU_DATA  val)
   1620          {
   1621              CPU_DATA  val_bit_mask;
   1622              CPU_DATA  nbr_lead_zeros;
   1623              CPU_DATA  nbr_trail_zeros;
   1624          
   1625          
   1626              if (val == 0u) {                                            /* Rtn ALL val bits as zero'd (see Note #3).            */
   1627                  return (CPU_CFG_DATA_SIZE * DEF_OCTET_NBR_BITS);
   1628              }
   1629          
   1630          
   1631              val_bit_mask    = val & ((CPU_DATA)~val + 1u);              /* Zero/clr all bits EXCEPT least-sig set bit.          */
   1632              nbr_lead_zeros  = CPU_CntLeadZeros(val_bit_mask);           /* Cnt  nbr lead  0s.                                   */
   1633                                                                          /* Calc nbr trail 0s = (nbr val bits - 1) - nbr lead 0s.*/
   1634              nbr_trail_zeros = ((CPU_CFG_DATA_SIZE * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
   1635          
   1636          
   1637              return (nbr_trail_zeros);
   1638          }
   1639          #endif
   1640          
   1641          
   1642          /*
   1643          *********************************************************************************************************
   1644          *                                        CPU_CntTrailZeros08()
   1645          *
   1646          * Description : Count the number of contiguous, least-significant, trailing zero bits in an 8-bit data value.
   1647          *
   1648          * Argument(s) : val         Data value to count trailing zero bits.
   1649          *
   1650          * Return(s)   : Number of contiguous, least-significant, trailing zero bits in 'val'.
   1651          *
   1652          * Caller(s)   : Application.
   1653          *
   1654          *               This function is a CPU module application programming interface (API) function & MAY be
   1655          *               called by application function(s).
   1656          *
   1657          * Note(s)     : (1) Supports  8-bit values :
   1658          *
   1659          *                               b07  b06  b05  b04  b03  b02  b01  b00    # Trailing Zeros
   1660          *                               ---  ---  ---  ---  ---  ---  ---  ---    ----------------
   1661          *                                x    x    x    x    x    x    x    1            0
   1662          *                                x    x    x    x    x    x    1    0            1
   1663          *                                x    x    x    x    x    1    0    0            2
   1664          *                                x    x    x    x    1    0    0    0            3
   1665          *                                x    x    x    1    0    0    0    0            4
   1666          *                                x    x    1    0    0    0    0    0            5
   1667          *                                x    1    0    0    0    0    0    0            6
   1668          *                                1    0    0    0    0    0    0    0            7
   1669          *                                0    0    0    0    0    0    0    0            8
   1670          *
   1671          *
   1672          *               (2) For non-zero values, the returned number of contiguous, least-significant, trailing
   1673          *                   zero bits is also equivalent to the bit position of the least-significant set bit.
   1674          *
   1675          *               (3) 'val' SHOULD be validated for non-'0' PRIOR to all other counting zero calculations :
   1676          *
   1677          *                   (a) For assembly-optimized implementations, CPU_CntTrailZeros() returns 'val's
   1678          *                       number of trailing zeros via CPU's native data size, 'CPU_CFG_DATA_SIZE'.
   1679          *                       If the returned number of zeros exceeds CPU_CntTrailZeros08()'s  8-bit return
   1680          *                       data size, then the returned number of zeros must be offset by the difference
   1681          *                       between CPU_CntTrailZeros()'s  & CPU_CntTrailZeros08()'s return data size :
   1682          *
   1683          *                           nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
   1684          *                           if (nbr_trail_zeros >  (CPU_WORD_SIZE_08  * DEF_OCTET_NBR_BITS)) {
   1685          *                               nbr_trail_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_08) * DEF_OCTET_NBR_BITS;
   1686          *                           }
   1687          *
   1688          *                       However, this ONLY occurs for an initial 'val' of '0' since all non-'0'  8-bit
   1689          *                       values would return a number of trailing zeros less than or equal to  8 bits.
   1690          *
   1691          *                       Therefore, initially validating all non-'0' values prior to calling assembly-
   1692          *                       optimized CPU_CntTrailZeros() avoids having to offset the number of returned
   1693          *                       trailing zeros by the difference in CPU data size and  8-bit data value bits.
   1694          *
   1695          *                   (b) For CPU_CntTrailZeros08()'s C implementation, the final conditional statement
   1696          *                       calculates 'val's number of trailing zeros based on CPU_CntTrailZeros08()'s
   1697          *                        8-bit return data size & 'val's calculated number of lead zeros ONLY if the
   1698          *                       initial 'val' is non-'0' :
   1699          *
   1700          *                           if (val != 0u) {
   1701          *                               nbr_trail_zeros = ((CPU_WORD_SIZE_08 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
   1702          *                           } else {
   1703          *                               nbr_trail_zeros = nbr_lead_zeros;
   1704          *                           }
   1705          *
   1706          *                       Therefore, initially validating all non-'0' values avoids having to conditionally
   1707          *                       execute the final 'if' statement.
   1708          *********************************************************************************************************
   1709          */
   1710          
   1711          #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_08)

   \                                 In section .text, align 2, keep-with-next
   1712          CPU_DATA  CPU_CntTrailZeros08 (CPU_INT08U  val)
   1713          {
   \                     CPU_CntTrailZeros08: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1714          #if  (!((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
   1715                  (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_08)))
   1716              CPU_INT08U  val_bit_mask;
   1717              CPU_DATA    nbr_lead_zeros;
   1718          #endif
   1719              CPU_DATA    nbr_trail_zeros;
   1720          
   1721          
   1722              if (val == 0u) {                                            /* Rtn ALL val bits as zero'd (see Note #3).            */
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD101             BNE.N    ??CPU_CntTrailZeros08_0
   1723                  return (CPU_WORD_SIZE_08 * DEF_OCTET_NBR_BITS);
   \   00000008   0x2008             MOVS     R0,#+8
   \   0000000A   0xE002             B.N      ??CPU_CntTrailZeros08_1
   1724              }
   1725          
   1726                                                                          /* ------------------ ASM-OPTIMIZED ------------------- */
   1727          #if ((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
   1728               (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_08))
   1729              nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
   \                     ??CPU_CntTrailZeros08_0: (+1)
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x.... 0x....      BL       CPU_CntTrailZeros
   1730          
   1731          #else                                                           /* ------------------- C-OPTIMIZED -------------------- */
   1732              val_bit_mask    = val & ((CPU_INT08U)~val + 1u);            /* Zero/clr all bits EXCEPT least-sig set bit.          */
   1733              nbr_lead_zeros  = CPU_CntLeadZeros08(val_bit_mask);         /* Cnt  nbr lead  0s.                                   */
   1734                                                                          /* Calc nbr trail 0s = (nbr val bits - 1) - nbr lead 0s.*/
   1735              nbr_trail_zeros = ((CPU_WORD_SIZE_08 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
   1736          #endif
   1737          
   1738          
   1739              return (nbr_trail_zeros);
   \                     ??CPU_CntTrailZeros08_1: (+1)
   \   00000012   0xBD02             POP      {R1,PC}          ;; return
   1740          }
   1741          #endif
   1742          
   1743          
   1744          /*
   1745          *********************************************************************************************************
   1746          *                                        CPU_CntTrailZeros16()
   1747          *
   1748          * Description : Count the number of contiguous, least-significant, trailing zero bits in a 16-bit data value.
   1749          *
   1750          * Argument(s) : val         Data value to count trailing zero bits.
   1751          *
   1752          * Return(s)   : Number of contiguous, least-significant, trailing zero bits in 'val'.
   1753          *
   1754          * Caller(s)   : Application.
   1755          *
   1756          *               This function is a CPU module application programming interface (API) function & MAY be
   1757          *               called by application function(s).
   1758          *
   1759          * Note(s)     : (1) Supports 16-bit values :
   1760          *
   1761          *                          b15  b14  b13  b12  b11  ...  b02  b01  b00    # Trailing Zeros
   1762          *                          ---  ---  ---  ---  ---       ---  ---  ---    ----------------
   1763          *                           x    x    x    x    x         x    x    1            0
   1764          *                           x    x    x    x    x         x    1    0            1
   1765          *                           x    x    x    x    x         1    0    0            2
   1766          *                           :    :    :    :    :         :    :    :            :
   1767          *                           :    :    :    :    :         :    :    :            :
   1768          *                           x    x    x    x    1         0    0    0           11
   1769          *                           x    x    x    1    0         0    0    0           12
   1770          *                           x    x    1    0    0         0    0    0           13
   1771          *                           x    1    0    0    0         0    0    0           14
   1772          *                           1    0    0    0    0         0    0    0           15
   1773          *                           0    0    0    0    0         0    0    0           16
   1774          *
   1775          *
   1776          *               (2) For non-zero values, the returned number of contiguous, least-significant, trailing
   1777          *                   zero bits is also equivalent to the bit position of the least-significant set bit.
   1778          *
   1779          *               (3) 'val' SHOULD be validated for non-'0' PRIOR to all other counting zero calculations :
   1780          *
   1781          *                   (a) For assembly-optimized implementations, CPU_CntTrailZeros() returns 'val's
   1782          *                       number of trailing zeros via CPU's native data size, 'CPU_CFG_DATA_SIZE'.
   1783          *                       If the returned number of zeros exceeds CPU_CntTrailZeros16()'s 16-bit return
   1784          *                       data size, then the returned number of zeros must be offset by the difference
   1785          *                       between CPU_CntTrailZeros()'s  & CPU_CntTrailZeros16()'s return data size :
   1786          *
   1787          *                           nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
   1788          *                           if (nbr_trail_zeros >  (CPU_WORD_SIZE_16  * DEF_OCTET_NBR_BITS)) {
   1789          *                               nbr_trail_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_16) * DEF_OCTET_NBR_BITS;
   1790          *                           }
   1791          *
   1792          *                       However, this ONLY occurs for an initial 'val' of '0' since all non-'0' 16-bit
   1793          *                       values would return a number of trailing zeros less than or equal to 16 bits.
   1794          *
   1795          *                       Therefore, initially validating all non-'0' values prior to calling assembly-
   1796          *                       optimized CPU_CntTrailZeros() avoids having to offset the number of returned
   1797          *                       trailing zeros by the difference in CPU data size and 16-bit data value bits.
   1798          *
   1799          *                   (b) For CPU_CntTrailZeros16()'s C implementation, the final conditional statement
   1800          *                       calculates 'val's number of trailing zeros based on CPU_CntTrailZeros16()'s
   1801          *                       16-bit return data size & 'val's calculated number of lead zeros ONLY if the
   1802          *                       initial 'val' is non-'0' :
   1803          *
   1804          *                           if (val != 0u) {
   1805          *                               nbr_trail_zeros = ((CPU_WORD_SIZE_16 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
   1806          *                           } else {
   1807          *                               nbr_trail_zeros = nbr_lead_zeros;
   1808          *                           }
   1809          *
   1810          *                       Therefore, initially validating all non-'0' values avoids having to conditionally
   1811          *                       execute the final 'if' statement.
   1812          *********************************************************************************************************
   1813          */
   1814          
   1815          #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_16)

   \                                 In section .text, align 2, keep-with-next
   1816          CPU_DATA  CPU_CntTrailZeros16 (CPU_INT16U  val)
   1817          {
   \                     CPU_CntTrailZeros16: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1818          #if  (!((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
   1819                  (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_16)))
   1820              CPU_INT16U  val_bit_mask;
   1821              CPU_DATA    nbr_lead_zeros;
   1822          #endif
   1823              CPU_DATA    nbr_trail_zeros;
   1824          
   1825          
   1826              if (val == 0u) {                                            /* Rtn ALL val bits as zero'd (see Note #3).            */
   \   00000002   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD101             BNE.N    ??CPU_CntTrailZeros16_0
   1827                  return (CPU_WORD_SIZE_16 * DEF_OCTET_NBR_BITS);
   \   00000008   0x2010             MOVS     R0,#+16
   \   0000000A   0xE002             B.N      ??CPU_CntTrailZeros16_1
   1828              }
   1829          
   1830                                                                          /* ------------------ ASM-OPTIMIZED ------------------- */
   1831          #if ((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
   1832               (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_16))
   1833              nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
   \                     ??CPU_CntTrailZeros16_0: (+1)
   \   0000000C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000000E   0x.... 0x....      BL       CPU_CntTrailZeros
   1834          
   1835          #else                                                           /* ------------------- C-OPTIMIZED -------------------- */
   1836              val_bit_mask    = val & ((CPU_INT16U)~val + 1u);            /* Zero/clr all bits EXCEPT least-sig set bit.          */
   1837              nbr_lead_zeros  = CPU_CntLeadZeros16(val_bit_mask);         /* Cnt  nbr lead  0s.                                   */
   1838                                                                          /* Calc nbr trail 0s = (nbr val bits - 1) - nbr lead 0s.*/
   1839              nbr_trail_zeros = ((CPU_WORD_SIZE_16 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
   1840          #endif
   1841          
   1842          
   1843              return (nbr_trail_zeros);
   \                     ??CPU_CntTrailZeros16_1: (+1)
   \   00000012   0xBD02             POP      {R1,PC}          ;; return
   1844          }
   1845          #endif
   1846          
   1847          
   1848          /*
   1849          *********************************************************************************************************
   1850          *                                        CPU_CntTrailZeros32()
   1851          *
   1852          * Description : Count the number of contiguous, least-significant, trailing zero bits in a 32-bit data value.
   1853          *
   1854          * Argument(s) : val         Data value to count trailing zero bits.
   1855          *
   1856          * Return(s)   : Number of contiguous, least-significant, trailing zero bits in 'val'.
   1857          *
   1858          * Caller(s)   : Application.
   1859          *
   1860          *               This function is a CPU module application programming interface (API) function & MAY be
   1861          *               called by application function(s).
   1862          *
   1863          * Note(s)     : (1) Supports 32-bit values :
   1864          *
   1865          *                          b31  b30  b29  b28  b27  ...  b02  b01  b00    # Trailing Zeros
   1866          *                          ---  ---  ---  ---  ---       ---  ---  ---    ----------------
   1867          *                           x    x    x    x    x         x    x    1            0
   1868          *                           x    x    x    x    x         x    1    0            1
   1869          *                           x    x    x    x    x         1    0    0            2
   1870          *                           :    :    :    :    :         :    :    :            :
   1871          *                           :    :    :    :    :         :    :    :            :
   1872          *                           x    x    x    x    1         0    0    0           27
   1873          *                           x    x    x    1    0         0    0    0           28
   1874          *                           x    x    1    0    0         0    0    0           29
   1875          *                           x    1    0    0    0         0    0    0           30
   1876          *                           1    0    0    0    0         0    0    0           31
   1877          *                           0    0    0    0    0         0    0    0           32
   1878          *
   1879          *
   1880          *               (2) For non-zero values, the returned number of contiguous, least-significant, trailing
   1881          *                   zero bits is also equivalent to the bit position of the least-significant set bit.
   1882          *
   1883          *               (3) 'val' SHOULD be validated for non-'0' PRIOR to all other counting zero calculations :
   1884          *
   1885          *                   (a) For assembly-optimized implementations, CPU_CntTrailZeros() returns 'val's
   1886          *                       number of trailing zeros via CPU's native data size, 'CPU_CFG_DATA_SIZE'.
   1887          *                       If the returned number of zeros exceeds CPU_CntTrailZeros32()'s 32-bit return
   1888          *                       data size, then the returned number of zeros must be offset by the difference
   1889          *                       between CPU_CntTrailZeros()'s  & CPU_CntTrailZeros32()'s return data size :
   1890          *
   1891          *                           nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
   1892          *                           if (nbr_trail_zeros >  (CPU_WORD_SIZE_32  * DEF_OCTET_NBR_BITS)) {
   1893          *                               nbr_trail_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_32) * DEF_OCTET_NBR_BITS;
   1894          *                           }
   1895          *
   1896          *                       However, this ONLY occurs for an initial 'val' of '0' since all non-'0' 32-bit
   1897          *                       values would return a number of trailing zeros less than or equal to 32 bits.
   1898          *
   1899          *                       Therefore, initially validating all non-'0' values prior to calling assembly-
   1900          *                       optimized CPU_CntTrailZeros() avoids having to offset the number of returned
   1901          *                       trailing zeros by the difference in CPU data size and 32-bit data value bits.
   1902          *
   1903          *                   (b) For CPU_CntTrailZeros32()'s C implementation, the final conditional statement
   1904          *                       calculates 'val's number of trailing zeros based on CPU_CntTrailZeros32()'s
   1905          *                       32-bit return data size & 'val's calculated number of lead zeros ONLY if the
   1906          *                       initial 'val' is non-'0' :
   1907          *
   1908          *                           if (val != 0u) {
   1909          *                               nbr_trail_zeros = ((CPU_WORD_SIZE_32 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
   1910          *                           } else {
   1911          *                               nbr_trail_zeros = nbr_lead_zeros;
   1912          *                           }
   1913          *
   1914          *                       Therefore, initially validating all non-'0' values avoids having to conditionally
   1915          *                       execute the final 'if' statement.
   1916          *********************************************************************************************************
   1917          */
   1918          
   1919          #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_32)

   \                                 In section .text, align 2, keep-with-next
   1920          CPU_DATA  CPU_CntTrailZeros32 (CPU_INT32U  val)
   1921          {
   \                     CPU_CntTrailZeros32: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1922          #if  (!((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
   1923                  (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_32)))
   1924              CPU_INT32U  val_bit_mask;
   1925              CPU_DATA    nbr_lead_zeros;
   1926          #endif
   1927              CPU_DATA    nbr_trail_zeros;
   1928          
   1929          
   1930              if (val == 0u) {                                            /* Rtn ALL val bits as zero'd (see Note #3).            */
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD101             BNE.N    ??CPU_CntTrailZeros32_0
   1931                  return (CPU_WORD_SIZE_32 * DEF_OCTET_NBR_BITS);
   \   00000006   0x2020             MOVS     R0,#+32
   \   00000008   0xE001             B.N      ??CPU_CntTrailZeros32_1
   1932              }
   1933          
   1934                                                                          /* ------------------ ASM-OPTIMIZED ------------------- */
   1935          #if ((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
   1936               (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_32))
   1937              nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
   \                     ??CPU_CntTrailZeros32_0: (+1)
   \   0000000A   0x.... 0x....      BL       CPU_CntTrailZeros
   1938          
   1939          #else                                                           /* ------------------- C-OPTIMIZED -------------------- */
   1940              val_bit_mask    = val & ((CPU_INT32U)~val + 1u);            /* Zero/clr all bits EXCEPT least-sig set bit.          */
   1941              nbr_lead_zeros  = CPU_CntLeadZeros32(val_bit_mask);         /* Cnt  nbr lead  0s.                                   */
   1942                                                                          /* Calc nbr trail 0s = (nbr val bits - 1) - nbr lead 0s.*/
   1943              nbr_trail_zeros = ((CPU_WORD_SIZE_32 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
   1944          #endif
   1945          
   1946          
   1947              return (nbr_trail_zeros);
   \                     ??CPU_CntTrailZeros32_1: (+1)
   \   0000000E   0xBD02             POP      {R1,PC}          ;; return
   1948          }
   1949          #endif
   1950          
   1951          
   1952          /*
   1953          *********************************************************************************************************
   1954          *                                        CPU_CntTrailZeros64()
   1955          *
   1956          * Description : Count the number of contiguous, least-significant, trailing zero bits in a 64-bit data value.
   1957          *
   1958          * Argument(s) : val         Data value to count trailing zero bits.
   1959          *
   1960          * Return(s)   : Number of contiguous, least-significant, trailing zero bits in 'val'.
   1961          *
   1962          * Caller(s)   : Application.
   1963          *
   1964          *               This function is a CPU module application programming interface (API) function & MAY be
   1965          *               called by application function(s).
   1966          *
   1967          * Note(s)     : (1) Supports 64-bit values :
   1968          *
   1969          *                          b63  b62  b61  b60  b59  ...  b02  b01  b00    # Trailing Zeros
   1970          *                          ---  ---  ---  ---  ---       ---  ---  ---    ----------------
   1971          *                           x    x    x    x    x         x    x    1            0
   1972          *                           x    x    x    x    x         x    1    0            1
   1973          *                           x    x    x    x    x         1    0    0            2
   1974          *                           :    :    :    :    :         :    :    :            :
   1975          *                           :    :    :    :    :         :    :    :            :
   1976          *                           x    x    x    x    1         0    0    0           59
   1977          *                           x    x    x    1    0         0    0    0           60
   1978          *                           x    x    1    0    0         0    0    0           61
   1979          *                           x    1    0    0    0         0    0    0           62
   1980          *                           1    0    0    0    0         0    0    0           63
   1981          *                           0    0    0    0    0         0    0    0           64
   1982          *
   1983          *
   1984          *               (2) For non-zero values, the returned number of contiguous, least-significant, trailing
   1985          *                   zero bits is also equivalent to the bit position of the least-significant set bit.
   1986          *
   1987          *               (3) 'val' SHOULD be validated for non-'0' PRIOR to all other counting zero calculations :
   1988          *
   1989          *                   (a) For assembly-optimized implementations, CPU_CntTrailZeros() returns 'val's
   1990          *                       number of trailing zeros via CPU's native data size, 'CPU_CFG_DATA_SIZE'.
   1991          *                       If the returned number of zeros exceeds CPU_CntTrailZeros64()'s 64-bit return
   1992          *                       data size, then the returned number of zeros must be offset by the difference
   1993          *                       between CPU_CntTrailZeros()'s  & CPU_CntTrailZeros64()'s return data size :
   1994          *
   1995          *                           nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
   1996          *                           if (nbr_trail_zeros >  (CPU_WORD_SIZE_64  * DEF_OCTET_NBR_BITS)) {
   1997          *                               nbr_trail_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_64) * DEF_OCTET_NBR_BITS;
   1998          *                           }
   1999          *
   2000          *                       However, this ONLY occurs for an initial 'val' of '0' since all non-'0' 64-bit
   2001          *                       values would return a number of trailing zeros less than or equal to 64 bits.
   2002          *
   2003          *                       Therefore, initially validating all non-'0' values prior to calling assembly-
   2004          *                       optimized CPU_CntTrailZeros() avoids having to offset the number of returned
   2005          *                       trailing zeros by the difference in CPU data size and 64-bit data value bits.
   2006          *
   2007          *                   (b) For CPU_CntTrailZeros64()'s C implementation, the final conditional statement
   2008          *                       calculates 'val's number of trailing zeros based on CPU_CntTrailZeros64()'s
   2009          *                       64-bit return data size & 'val's calculated number of lead zeros ONLY if the
   2010          *                       initial 'val' is non-'0' :
   2011          *
   2012          *                           if (val != 0u) {
   2013          *                               nbr_trail_zeros = ((CPU_WORD_SIZE_64 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
   2014          *                           } else {
   2015          *                               nbr_trail_zeros = nbr_lead_zeros;
   2016          *                           }
   2017          *
   2018          *                       Therefore, initially validating all non-'0' values avoids having to conditionally
   2019          *                       execute the final 'if' statement.
   2020          *********************************************************************************************************
   2021          */
   2022          
   2023          #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_64)

   \                                 In section .text, align 2, keep-with-next
   2024          CPU_DATA  CPU_CntTrailZeros64 (CPU_INT64U  val)
   2025          {
   \                     CPU_CntTrailZeros64: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2026          #if  (!((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
   2027                  (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_64)))
   2028              CPU_INT64U  val_bit_mask;
   2029              CPU_DATA    nbr_lead_zeros;
   2030          #endif
   2031              CPU_DATA    nbr_trail_zeros;
   2032          
   2033          
   2034              if (val == 0u) {                                            /* Rtn ALL val bits as zero'd (see Note #3).            */
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD103             BNE.N    ??CPU_CntTrailZeros64_0
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD101             BNE.N    ??CPU_CntTrailZeros64_0
   2035                  return (CPU_WORD_SIZE_64 * DEF_OCTET_NBR_BITS);
   \   0000000A   0x2040             MOVS     R0,#+64
   \   0000000C   0xE00A             B.N      ??CPU_CntTrailZeros64_1
   2036              }
   2037          
   2038                                                                          /* ------------------ ASM-OPTIMIZED ------------------- */
   2039          #if ((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
   2040               (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_64))
   2041              nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
   2042          
   2043          #else                                                           /* ------------------- C-OPTIMIZED -------------------- */
   2044              val_bit_mask    = val & ((CPU_INT64U)~val + 1u);            /* Zero/clr all bits EXCEPT least-sig set bit.          */
   \                     ??CPU_CntTrailZeros64_0: (+1)
   \   0000000E   0x43C2             MVNS     R2,R0
   \   00000010   0x43CB             MVNS     R3,R1
   \   00000012   0x1C52             ADDS     R2,R2,#+1
   \   00000014   0xF153 0x0300      ADCS     R3,R3,#+0
   \   00000018   0x4010             ANDS     R0,R0,R2
   \   0000001A   0x4019             ANDS     R1,R1,R3
   2045              nbr_lead_zeros  = CPU_CntLeadZeros64(val_bit_mask);         /* Cnt  nbr lead  0s.                                   */
   \   0000001C   0x.... 0x....      BL       CPU_CntLeadZeros64
   2046                                                                          /* Calc nbr trail 0s = (nbr val bits - 1) - nbr lead 0s.*/
   2047              nbr_trail_zeros = ((CPU_WORD_SIZE_64 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
   \   00000020   0xF1D0 0x003F      RSBS     R0,R0,#+63
   2048          #endif
   2049          
   2050          
   2051              return (nbr_trail_zeros);
   \                     ??CPU_CntTrailZeros64_1: (+1)
   \   00000024   0xBD02             POP      {R1,PC}          ;; return
   2052          }
   2053          #endif
   2054          
   2055          
   2056          /*
   2057          *********************************************************************************************************
   2058          *                                           CRCUtil_PopCnt_32()
   2059          *
   2060          * Description : Compute population count (hamming weight) for value (number of bits set).
   2061          *
   2062          * Argument(s) : value           Value to compute population count on.
   2063          *
   2064          *
   2065          * Return(s)   : value's population count.
   2066          *
   2067          * Caller(s)   : various.
   2068          *
   2069          * Note(s)     : (1) Algorithm taken from http://en.wikipedia.org/wiki/Hamming_weight
   2070          *********************************************************************************************************
   2071          */
   2072          

   \                                 In section .text, align 2, keep-with-next
   2073          CPU_INT08U  CPU_PopCnt32 (CPU_INT32U  value)
   2074          {
   2075              CPU_INT32U  even_cnt;
   2076              CPU_INT32U  odd_cnt;
   2077              CPU_INT32U  result;
   2078          
   2079          
   2080              odd_cnt  = (value >> 1u) & CRC_UTIL_POPCNT_MASK01010101_32; /* 2-bits pieces.                                       */
   \                     CPU_PopCnt32: (+1)
   \   00000000   0x0841             LSRS     R1,R0,#+1
   \   00000002   0xF011 0x3255      ANDS     R2,R1,#0x55555555
   2081              result   =  value - odd_cnt;                                /* Same result as result=odd_cnt+(value & 0x55555555).  */
   \   00000006   0x1A80             SUBS     R0,R0,R2
   2082          
   2083              even_cnt =  result & CRC_UTIL_POPCNT_MASK00110011_32;       /* 4-bits pieces.                                       */
   \   00000008   0xF010 0x3133      ANDS     R1,R0,#0x33333333
   2084              odd_cnt  = (result >> 2u) & CRC_UTIL_POPCNT_MASK00110011_32;
   \   0000000C   0x0880             LSRS     R0,R0,#+2
   \   0000000E   0xF010 0x3233      ANDS     R2,R0,#0x33333333
   2085              result   =  even_cnt + odd_cnt;
   \   00000012   0x1850             ADDS     R0,R2,R1
   2086          
   2087              even_cnt =  result & CRC_UTIL_POPCNT_MASK00001111_32;       /* 8-bits pieces.                                       */
   \   00000014   0xF010 0x310F      ANDS     R1,R0,#0xF0F0F0F
   2088              odd_cnt  = (result >> 4u) & CRC_UTIL_POPCNT_MASK00001111_32;
   \   00000018   0x0900             LSRS     R0,R0,#+4
   \   0000001A   0xF010 0x320F      ANDS     R2,R0,#0xF0F0F0F
   2089              result   =  even_cnt + odd_cnt;
   \   0000001E   0x1850             ADDS     R0,R2,R1
   2090          
   2091              result = (result * CRC_UTIL_POPCNT_POWERSOF256_32) >> 24u;
   \   00000020   0xF05F 0x3101      MOVS     R1,#+16843009
   \   00000024   0x4348             MULS     R0,R1,R0
   \   00000026   0x0E00             LSRS     R0,R0,#+24
   2092          
   2093              return ((CPU_INT08U)result);
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0x4770             BX       LR               ;; return
   2094          }
   2095          
   2096          
   2097          /*
   2098          *********************************************************************************************************
   2099          *                                            CPU_StatReset()
   2100          *
   2101          * Description : Reset all performance monitors.
   2102          *
   2103          * Argument(s) : none.
   2104          *
   2105          * Return(s)   : none.
   2106          *
   2107          * Caller(s)   : OSStatReset().
   2108          *
   2109          * Note(s)     : Critical section provided by caller.
   2110          *********************************************************************************************************
   2111          */
   2112          
   2113          #if (CPU_CFG_PERF_MON_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   2114          void  CPU_StatReset (void)
   2115          {
   2116          #ifdef  CPU_CFG_INT_DIS_MEAS_EN
   2117              CPU_IntDisMeasMax_cnts = 0u;
   \                     CPU_StatReset: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x....             LDR.N    R1,??DataTable14_3
   \   00000004   0x6008             STR      R0,[R1, #+0]
   2118          #endif
   2119          }
   \   00000006   0x4770             BX       LR               ;; return
   2120          #endif
   2121          
   2122          
   2123          /*
   2124          *********************************************************************************************************
   2125          *********************************************************************************************************
   2126          *                                           LOCAL FUNCTIONS
   2127          *********************************************************************************************************
   2128          *********************************************************************************************************
   2129          */
   2130          
   2131          /*
   2132          *********************************************************************************************************
   2133          *                                           CPU_NameInit()
   2134          *
   2135          * Description : Initialize CPU Name.
   2136          *
   2137          * Argument(s) : none.
   2138          *
   2139          * Return(s)   : none.
   2140          *
   2141          * Caller(s)   : CPU_Init().
   2142          *
   2143          * Note(s)     : none.
   2144          *********************************************************************************************************
   2145          */
   2146          
   2147          #if (CPU_CFG_NAME_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   2148          static  void  CPU_NameInit (void)
   2149          {
   \                     CPU_NameInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2150              CPU_NameClr();
   \   00000002   0x.... 0x....      BL       CPU_NameClr
   2151          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
   2152          #endif
   2153          
   2154          
   2155          /*
   2156          *********************************************************************************************************
   2157          *                                            CPU_TS_Init()
   2158          *
   2159          * Description : (1) Initialize CPU timestamp :
   2160          *
   2161          *                   (a) Initialize/start CPU timestamp timer                            See Note #1
   2162          *                   (b) Initialize       CPU timestamp controls
   2163          *
   2164          *
   2165          * Argument(s) : none.
   2166          *
   2167          * Return(s)   : none.
   2168          *
   2169          * Caller(s)   : CPU_Init().
   2170          *
   2171          * Note(s)     : (1) The following initialization MUST be sequenced as follows :
   2172          *
   2173          *                   (a) CPU_TS_TmrFreq_Hz     MUST be initialized prior to CPU_TS_TmrInit()
   2174          *                   (b) CPU_TS_TmrInit()      SHOULD precede calls to all other CPU timestamp functions;
   2175          *                                                 otherwise, invalid time measurements may be calculated/
   2176          *                                                 returned.
   2177          *
   2178          *                   See also 'CPU_Init()  Note #3a'.
   2179          *********************************************************************************************************
   2180          */
   2181          
   2182          #if ((CPU_CFG_TS_EN     == DEF_ENABLED) || \
   2183               (CPU_CFG_TS_TMR_EN == DEF_ENABLED))

   \                                 In section .text, align 2, keep-with-next
   2184          static  void  CPU_TS_Init (void)
   2185          {
   \                     CPU_TS_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2186          #if (((CPU_CFG_TS_32_EN    == DEF_ENABLED     )  && \
   2187                (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_32)) || \
   2188               ((CPU_CFG_TS_64_EN    == DEF_ENABLED     )  && \
   2189                (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_64)))
   2190              CPU_TS_TMR  ts_tmr_cnts;
   2191          #endif
   2192          
   2193          
   2194                                                                          /* ----------------- INIT CPU TS TMR ------------------ */
   2195          #if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)
   2196              CPU_TS_TmrFreq_Hz   = 0u;                                   /* Init/clr     ts tmr freq (see Note #1a).             */
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x....             LDR.N    R1,??DataTable14_1
   \   00000006   0x6008             STR      R0,[R1, #+0]
   2197              CPU_TS_TmrInit();                                           /* Init & start ts tmr      (see Note #1b).             */
   \   00000008   0x.... 0x....      BL       CPU_TS_TmrInit
   2198          #endif
   2199          
   2200          
   2201                                                                          /* ------------------- INIT CPU TS -------------------- */
   2202          #if (((CPU_CFG_TS_32_EN    == DEF_ENABLED     )  && \
   2203                (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_32)) || \
   2204               ((CPU_CFG_TS_64_EN    == DEF_ENABLED     )  && \
   2205                (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_64)))
   2206              ts_tmr_cnts = CPU_TS_TmrRd();                               /* Get init ts tmr val (in ts tmr cnts).                */
   2207          #endif
   2208          
   2209          #if  ((CPU_CFG_TS_32_EN    == DEF_ENABLED)  && \
   2210                (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_32))
   2211              CPU_TS_32_Accum   = 0u;                                     /* Init 32-bit accum'd ts.                              */
   2212              CPU_TS_32_TmrPrev = ts_tmr_cnts;                            /* Init 32-bit ts prev tmr val.                         */
   2213          #endif
   2214          
   2215          #if  ((CPU_CFG_TS_64_EN    == DEF_ENABLED)  && \
   2216                (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_64))
   2217              CPU_TS_64_Accum   = 0u;                                     /* Init 64-bit accum'd ts.                              */
   2218              CPU_TS_64_TmrPrev = ts_tmr_cnts;                            /* Init 64-bit ts prev tmr val.                         */
   2219          #endif
   2220          }
   \   0000000C   0xBD01             POP      {R0,PC}          ;; return
   2221          #endif
   2222          
   2223          
   2224          /*
   2225          *********************************************************************************************************
   2226          *                                        CPU_IntDisMeasInit()
   2227          *
   2228          * Description : (1) Initialize interrupts disabled time measurements feature :
   2229          *
   2230          *                   (a) Initialize interrupts disabled time measurement controls
   2231          *                   (b) Calculate  interrupts disabled time measurement overhead
   2232          *
   2233          *
   2234          * Argument(s) : none.
   2235          *
   2236          * Return(s)   : none.
   2237          *
   2238          * Caller(s)   : CPU_Init().
   2239          *
   2240          * Note(s)     : (2) CPU_IntDisMeasInit() SHOULD precede ALL calls to CPU_CRITICAL_ENTER()/CPU_CRITICAL_EXIT()
   2241          *                   & other CPU interrupts disabled time measurement functions; otherwise, invalid interrupts
   2242          *                   disabled time measurements may be calculated/returned.
   2243          *
   2244          *                   See also 'CPU_Init()  Note #3b'.
   2245          *
   2246          *               (3) (a) (1) Interrupts disabled time measurement overhead performed multiple times to calculate
   2247          *                           a rounded average with better accuracy, hopefully of +/- one timer count.
   2248          *
   2249          *                       (2) However, a single overhead time measurement is recommended, even for instruction-
   2250          *                           cache-enabled CPUs, since critical sections are NOT typically called within
   2251          *                           instruction-cached loops.  Thus a single non-cached/non-averaged time measurement
   2252          *                           is a more realistic overhead for the majority of non-cached interrupts disabled
   2253          *                           time measurements.
   2254          *
   2255          *                   (b) Interrupts MUST be disabled while measuring the interrupts disabled time measurement
   2256          *                       overhead; otherwise, overhead measurements could be interrupted which would incorrectly
   2257          *                       calculate an inflated overhead time which would then incorrectly calculate deflated
   2258          *                       interrupts disabled times.
   2259          *********************************************************************************************************
   2260          */
   2261          
   2262          #ifdef  CPU_CFG_INT_DIS_MEAS_EN

   \                                 In section .text, align 2, keep-with-next
   2263          static  void  CPU_IntDisMeasInit (void)
   2264          {
   \                     CPU_IntDisMeasInit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   2265              CPU_TS_TMR  time_meas_tot_cnts;
   2266              CPU_INT16U  i;
   2267              CPU_SR_ALLOC();
   \   00000002   0x2400             MOVS     R4,#+0
   2268          
   2269                                                                          /* ----------- INIT INT DIS TIME MEAS CTRLS ----------- */
   2270              CPU_IntDisMeasCtr         = 0u;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x....             LDR.N    R1,??DataTable14_4
   \   00000008   0x8008             STRH     R0,[R1, #+0]
   2271              CPU_IntDisNestCtr         = 0u;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x....             LDR.N    R1,??DataTable14_5
   \   0000000E   0x8008             STRH     R0,[R1, #+0]
   2272              CPU_IntDisMeasStart_cnts  = 0u;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x....             LDR.N    R1,??DataTable14_6
   \   00000014   0x6008             STR      R0,[R1, #+0]
   2273              CPU_IntDisMeasStop_cnts   = 0u;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x....             LDR.N    R1,??DataTable14_7
   \   0000001A   0x6008             STR      R0,[R1, #+0]
   2274              CPU_IntDisMeasMaxCur_cnts = 0u;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x....             LDR.N    R1,??DataTable14_2
   \   00000020   0x6008             STR      R0,[R1, #+0]
   2275              CPU_IntDisMeasMax_cnts    = 0u;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x....             LDR.N    R1,??DataTable14_3
   \   00000026   0x6008             STR      R0,[R1, #+0]
   2276              CPU_IntDisMeasOvrhd_cnts  = 0u;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x....             LDR.N    R1,??DataTable14_9
   \   0000002C   0x6008             STR      R0,[R1, #+0]
   2277          
   2278                                                                          /* ----------- CALC INT DIS TIME MEAS OVRHD ----------- */
   2279              time_meas_tot_cnts = 0u;
   \   0000002E   0x2500             MOVS     R5,#+0
   2280              CPU_INT_DIS();                                              /* Ints MUST be dis'd for ovrhd calc (see Note #3b).    */
   \   00000030   0x.... 0x....      BL       CPU_SR_Save
   \   00000034   0x0004             MOVS     R4,R0
   2281              for (i = 0u; i < CPU_CFG_INT_DIS_MEAS_OVRHD_NBR; i++) {
   \   00000036   0x2600             MOVS     R6,#+0
   \   00000038   0xE00A             B.N      ??CPU_IntDisMeasInit_0
   2282                  CPU_IntDisMeasMaxCur_cnts = 0u;
   \                     ??CPU_IntDisMeasInit_1: (+1)
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x....             LDR.N    R1,??DataTable14_2
   \   0000003E   0x6008             STR      R0,[R1, #+0]
   2283                  CPU_IntDisMeasStart();                                  /* Perform multiple consecutive start/stop time meas's  */
   \   00000040   0x.... 0x....      BL       CPU_IntDisMeasStart
   2284                  CPU_IntDisMeasStop();
   \   00000044   0x.... 0x....      BL       CPU_IntDisMeasStop
   2285                  time_meas_tot_cnts += CPU_IntDisMeasMaxCur_cnts;        /* ...       & sum time meas max's                  ... */
   \   00000048   0x....             LDR.N    R0,??DataTable14_2
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x1945             ADDS     R5,R0,R5
   2286              }
   \   0000004E   0x1C76             ADDS     R6,R6,#+1
   \                     ??CPU_IntDisMeasInit_0: (+1)
   \   00000050   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000052   0x2E00             CMP      R6,#+0
   \   00000054   0xD0F1             BEQ.N    ??CPU_IntDisMeasInit_1
   2287                                                                          /* ... to calc avg time meas ovrhd (see Note #3a).      */
   2288              CPU_IntDisMeasOvrhd_cnts  = (time_meas_tot_cnts + (CPU_CFG_INT_DIS_MEAS_OVRHD_NBR / 2u))
   2289                                                              /  CPU_CFG_INT_DIS_MEAS_OVRHD_NBR;
   \   00000056   0x2001             MOVS     R0,#+1
   \   00000058   0xFBB5 0xF0F0      UDIV     R0,R5,R0
   \   0000005C   0x....             LDR.N    R1,??DataTable14_9
   \   0000005E   0x6008             STR      R0,[R1, #+0]
   2290              CPU_IntDisMeasMaxCur_cnts =  0u;                            /* Reset max ints dis'd times.                          */
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x....             LDR.N    R1,??DataTable14_2
   \   00000064   0x6008             STR      R0,[R1, #+0]
   2291              CPU_IntDisMeasMax_cnts    =  0u;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x....             LDR.N    R1,??DataTable14_3
   \   0000006A   0x6008             STR      R0,[R1, #+0]
   2292              CPU_INT_EN();
   \   0000006C   0x0020             MOVS     R0,R4
   \   0000006E   0x.... 0x....      BL       CPU_SR_Restore
   2293          }
   \   00000072   0xBD70             POP      {R4-R6,PC}       ;; return
   2294          #endif
   2295          
   2296          
   2297          /*
   2298          *********************************************************************************************************
   2299          *                                       CPU_IntDisMeasMaxCalc()
   2300          *
   2301          * Description : Calculate maximum interrupts disabled time.
   2302          *
   2303          * Argument(s) : time_tot_cnts   Total interrupt disabled time, in timer counts.
   2304          *
   2305          * Return(s)   : Maximum interrupts disabled time (in CPU timestamp timer counts).
   2306          *
   2307          * Caller(s)   : CPU_IntDisMeasMaxCurGet(),
   2308          *               CPU_IntDisMeasMaxGet().
   2309          *
   2310          * Note(s)     : (1) (a) The total amount of time interrupts are disabled by system &/or application code
   2311          *                       during critical sections is calculated by the following equations :
   2312          *
   2313          *                       (1) time            =   [ time      -  time      ]  -  time
   2314          *                               interrupts      [     stop         start ]         total meas
   2315          *                                disabled       [     meas         meas  ]           ovrhd
   2316          *                           (via application)
   2317          *
   2318          *
   2319          *                       (2) time            =  time            +  time
   2320          *                               total meas         start meas         stop meas
   2321          *                                 ovrhd              ovrhd              ovrhd
   2322          *
   2323          *
   2324          *                               where
   2325          *
   2326          *                                       time                    time interrupts are disabled between
   2327          *                                           interrupts              first critical section enter &
   2328          *                                            disabled               last  critical section exit minus
   2329          *                                       (via application)           time measurement overhead
   2330          *
   2331          *                                       time                    time of disable interrupts start time
   2332          *                                           start                   measurement (in timer counts)
   2333          *                                           meas
   2334          *
   2335          *                                       time                    time of disable interrupts stop  time
   2336          *                                           stop                    measurement (in timer counts)
   2337          *                                           meas
   2338          *
   2339          *                                       time                    total overhead time to start/stop disabled
   2340          *                                           total meas              interrupts time measurements (in timer
   2341          *                                             ovrhd                 counts)
   2342          *
   2343          *                                       time                    total overhead time after getting start
   2344          *                                           start meas              time until end of start measurement
   2345          *                                             ovrhd                 function  (in timer counts)
   2346          *
   2347          *                                       time                    total overhead time from beginning of stop
   2348          *                                           stop meas               measurement function until after getting
   2349          *                                             ovrhd                 stop time (in timer counts)
   2350          *
   2351          *
   2352          *                   (b) To expedite & reduce interrupts disabled time measurement overhead, the final
   2353          *                       calculations to subtract the interrupts disabled time measurement overhead is
   2354          *                       performed asynchronously in API functions.
   2355          *
   2356          *                       See also 'CPU_IntDisMeasStop()  Note #1b2'.
   2357          *
   2358          *                   (c) The amount of time interrupts are disabled is calculated by either of the
   2359          *                       following equations :
   2360          *
   2361          *                       (1) Interrupts disabled time  =  Number timer counts  *  Timer period
   2362          *
   2363          *                               where
   2364          *
   2365          *                                   Number timer counts             Number of timer counts measured
   2366          *                                   Timer period                    Timer's period in some units of
   2367          *                                                                       (fractional) seconds
   2368          *                                   Interrupts disabled time        Amount of time interrupts are
   2369          *                                                                       disabled, in same units of
   2370          *                                                                       (fractional) seconds as the
   2371          *                                                                       Timer period
   2372          *
   2373          *                                                         Number timer counts
   2374          *                       (2) Interrupts disabled time  =  ---------------------
   2375          *                                                           Timer frequency
   2376          *
   2377          *                               where
   2378          *
   2379          *                                   Number timer counts             Number of timer counts measured
   2380          *                                   Timer frequency                 Timer's frequency in some units
   2381          *                                                                       of counts per second
   2382          *                                   Interrupts disabled time        Amount of time interrupts are
   2383          *                                                                       disabled, in seconds
   2384          *
   2385          *                       See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()      Note #2c'
   2386          *                              & 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TSxx_to_uSec()  Note #2'.
   2387          *
   2388          *               (2) Although it is not typical, it is possible for an interrupts disabled time
   2389          *                   measurement to be less than the interrupts disabled time measurement overhead;
   2390          *                   especially if the overhead was calculated with a single, non-cached measurement
   2391          *                   & critical sections are called within instruction-cached loops.
   2392          *********************************************************************************************************
   2393          */
   2394          
   2395          #ifdef  CPU_CFG_INT_DIS_MEAS_EN

   \                                 In section .text, align 2, keep-with-next
   2396          static  CPU_TS_TMR  CPU_IntDisMeasMaxCalc (CPU_TS_TMR  time_tot_cnts)
   2397          {
   2398              CPU_TS_TMR  time_max_cnts;
   2399          
   2400          
   2401              time_max_cnts = time_tot_cnts;
   2402              if (time_max_cnts >  CPU_IntDisMeasOvrhd_cnts) {            /* If       max ints dis'd time >  ovrhd time, ...      */
   \                     CPU_IntDisMeasMaxCalc: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable14_9
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0x4281             CMP      R1,R0
   \   00000006   0xD203             BCS.N    ??CPU_IntDisMeasMaxCalc_0
   2403                  time_max_cnts -= CPU_IntDisMeasOvrhd_cnts;              /* ... adj  max ints dis'd time by ovrhd time; ...      */
   \   00000008   0x....             LDR.N    R1,??DataTable14_9
   \   0000000A   0x6809             LDR      R1,[R1, #+0]
   \   0000000C   0x1A40             SUBS     R0,R0,R1
   \   0000000E   0xE000             B.N      ??CPU_IntDisMeasMaxCalc_1
   2404              } else {                                                    /* ... else max ints dis'd time <  ovrhd time, ...      */
   2405                  time_max_cnts  = 0u;                                    /* ... clr  max ints dis'd time (see Note #2).          */
   \                     ??CPU_IntDisMeasMaxCalc_0: (+1)
   \   00000010   0x2000             MOVS     R0,#+0
   2406              }
   2407          
   2408              return (time_max_cnts);
   \                     ??CPU_IntDisMeasMaxCalc_1: (+1)
   \   00000012   0x4770             BX       LR               ;; return
   2409          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x........         DC32     CPU_Name

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x........         DC32     CPU_TS_TmrFreq_Hz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   0x........         DC32     CPU_IntDisMeasMaxCur_cnts

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \   00000000   0x........         DC32     CPU_IntDisMeasMax_cnts

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \   00000000   0x........         DC32     CPU_IntDisMeasCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \   00000000   0x........         DC32     CPU_IntDisNestCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_6:
   \   00000000   0x........         DC32     CPU_IntDisMeasStart_cnts

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_7:
   \   00000000   0x........         DC32     CPU_IntDisMeasStop_cnts

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_8:
   \   00000000   0x........         DC32     CPU_CntLeadZerosTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_9:
   \   00000000   0x........         DC32     CPU_IntDisMeasOvrhd_cnts
   2410          #endif
   2411          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   CPU_CntLeadZeros08
         8   -> CPU_CntLeadZeros
       8   CPU_CntLeadZeros16
         8   -> CPU_CntLeadZeros
       8   CPU_CntLeadZeros32
         8   -> CPU_CntLeadZeros
       4   CPU_CntLeadZeros64
         4 __aeabi_llsr
       8   CPU_CntTrailZeros08
         8   -> CPU_CntTrailZeros
       8   CPU_CntTrailZeros16
         8   -> CPU_CntTrailZeros
       8   CPU_CntTrailZeros32
         8   -> CPU_CntTrailZeros
       8   CPU_CntTrailZeros64
         8   -> CPU_CntLeadZeros64
       8   CPU_Init
         8   -> CPU_IntDisMeasInit
         8   -> CPU_NameInit
         8   -> CPU_TS_Init
      16   CPU_IntDisMeasInit
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
       0   CPU_IntDisMeasMaxCalc
       8   CPU_IntDisMeasMaxCurGet
         8   -> CPU_IntDisMeasMaxCalc
         8   -> CPU_SR_Restore
         8   -> CPU_SR_Save
       8   CPU_IntDisMeasMaxCurReset
         8   -> CPU_IntDisMeasMaxCurGet
         8   -> CPU_SR_Restore
         8   -> CPU_SR_Save
       8   CPU_IntDisMeasMaxGet
         8   -> CPU_IntDisMeasMaxCalc
         8   -> CPU_SR_Restore
         8   -> CPU_SR_Save
       8   CPU_IntDisMeasStart
         8   -> CPU_TS_TmrRd
       8   CPU_IntDisMeasStop
         8   -> CPU_TS_TmrRd
       8   CPU_NameClr
         8   -> CPU_IntDisMeasStart
         8   -> CPU_IntDisMeasStop
         8   -> CPU_SR_Restore
         8   -> CPU_SR_Save
         8   -> Mem_Clr
      16   CPU_NameGet
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> CPU_SW_Exception
        16   -> Str_Copy_N
       8   CPU_NameInit
         8   -> CPU_NameClr
      16   CPU_NameSet
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> CPU_SW_Exception
        16   -> Str_Copy_N
        16   -> Str_Len_N
       0   CPU_PopCnt32
       0   CPU_SW_Exception
       0   CPU_StatReset
       8   CPU_TS_Get32
         8   -> CPU_TS_TmrRd
       8   CPU_TS_Init
         8   -> CPU_TS_TmrInit
       8   CPU_TS_TmrFreqGet
         8   -> CPU_SW_Exception
       0   CPU_TS_TmrFreqSet
       0   CPU_TS_Update


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       4  ??DataTable14_8
       4  ??DataTable14_9
      12  CPU_CntLeadZeros08
      12  CPU_CntLeadZeros16
       8  CPU_CntLeadZeros32
     190  CPU_CntLeadZeros64
     256  CPU_CntLeadZerosTbl
      20  CPU_CntTrailZeros08
      20  CPU_CntTrailZeros16
      16  CPU_CntTrailZeros32
      38  CPU_CntTrailZeros64
       4  CPU_EndiannessTest
      16  CPU_Init
       2  CPU_IntDisMeasCtr
     116  CPU_IntDisMeasInit
      20  CPU_IntDisMeasMaxCalc
      24  CPU_IntDisMeasMaxCurGet
      28  CPU_IntDisMeasMaxCurReset
       4  CPU_IntDisMeasMaxCur_cnts
      24  CPU_IntDisMeasMaxGet
       4  CPU_IntDisMeasMax_cnts
       4  CPU_IntDisMeasOvrhd_cnts
      40  CPU_IntDisMeasStart
       4  CPU_IntDisMeasStart_cnts
      64  CPU_IntDisMeasStop
       4  CPU_IntDisMeasStop_cnts
       2  CPU_IntDisNestCtr
      16  CPU_Name
      36  CPU_NameClr
      64  CPU_NameGet
       8  CPU_NameInit
      82  CPU_NameSet
      44  CPU_PopCnt32
       2  CPU_SW_Exception
       8  CPU_StatReset
       8  CPU_TS_Get32
      14  CPU_TS_Init
      32  CPU_TS_TmrFreqGet
       6  CPU_TS_TmrFreqSet
       4  CPU_TS_TmrFreq_Hz
       2  CPU_TS_Update

 
  44 bytes in section .bss
 260 bytes in section .rodata
 994 bytes in section .text
 
 994 bytes of CODE  memory
 260 bytes of CONST memory
  44 bytes of DATA  memory

Errors: none
Warnings: none
