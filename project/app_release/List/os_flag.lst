###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       11/Jul/2018  11:13:10
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC210\NC210-200处理板\source\Software\uCOS-III\Source\os_flag.c
#    Command line =  
#        F:\iar\NC210\NC210-200处理板\source\Software\uCOS-III\Source\os_flag.c
#        -D USE_STDPERIPH_DRIVER -D APP_RELEASE -lCN
#        F:\iar\NC210\NC210-200处理板\project\app_release\List -o
#        F:\iar\NC210\NC210-200处理板\project\app_release\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC210\NC210-200处理板\project\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\config\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\task\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\user\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\OS\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\Ports\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\driver\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-LIB\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Source\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\ST\STM32\inc\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Ports\STM32\STM32F103\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Source\
#        -Ol --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC210\NC210-200处理板\project\app_release\List\os_flag.lst
#    Object file  =  
#        F:\iar\NC210\NC210-200处理板\project\app_release\Obj\os_flag.o
#
###############################################################################

F:\iar\NC210\NC210-200处理板\source\Software\uCOS-III\Source\os_flag.c
      1          /*
      2          ************************************************************************************************************************
      3          *                                                      uC/OS-III
      4          *                                                 The Real-Time Kernel
      5          *
      6          *                                  (c) Copyright 2009-2016; Micrium, Inc.; Weston, FL
      7          *                           All rights reserved.  Protected by international copyright laws.
      8          *
      9          *                                                EVENT FLAG MANAGEMENT
     10          *
     11          * File    : OS_FLAG.C
     12          * By      : JJL
     13          * Version : V3.06.00
     14          *
     15          * LICENSING TERMS:
     16          * ---------------
     17          *           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or
     18          *           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
     19          *           product then, you need to contact Micrium to properly license uC/OS-III for its use in your
     20          *           application/product.   We provide ALL the source code for your convenience and to help you
     21          *           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use
     22          *           it commercially without paying a licensing fee.
     23          *
     24          *           Knowledge of the source code may NOT be used to develop a similar product.
     25          *
     26          *           Please help us continue to provide the embedded community with the finest software available.
     27          *           Your honesty is greatly appreciated.
     28          *
     29          *           You can find our product's user manual, API reference, release notes and
     30          *           more information at https://doc.micrium.com.
     31          *           You can contact us at www.micrium.com.
     32          ************************************************************************************************************************
     33          */
     34          
     35          #define  MICRIUM_SOURCE
     36          #include "os.h"
     37          
     38          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     39          const  CPU_CHAR  *os_flag__c = "$Id: $";
     40          #endif
     41          
     42          
     43          #if (OS_CFG_FLAG_EN == DEF_ENABLED)
     44          
     45          /*
     46          ************************************************************************************************************************
     47          *                                                 CREATE AN EVENT FLAG
     48          *
     49          * Description: This function is called to create an event flag group.
     50          *
     51          * Arguments  : p_grp          is a pointer to the event flag group to create
     52          *
     53          *              p_name         is the name of the event flag group
     54          *
     55          *              flags          contains the initial value to store in the event flag group (typically 0).
     56          *
     57          *              p_err          is a pointer to an error code which will be returned to your application:
     58          *
     59          *                                 OS_ERR_NONE                    If the call was successful
     60          *                                 OS_ERR_CREATE_ISR              If you attempted to create an Event Flag from an ISR
     61          *                                 OS_ERR_ILLEGAL_CREATE_RUN_TIME If you are trying to create the Event Flag after you
     62          *                                                                   called OSSafetyCriticalStart().
     63          *                                 OS_ERR_OBJ_PTR_NULL            If 'p_grp' is a NULL pointer
     64          *
     65          * Returns    : none
     66          ************************************************************************************************************************
     67          */
     68          

   \                                 In section .text, align 2, keep-with-next
     69          void  OSFlagCreate (OS_FLAG_GRP  *p_grp,
     70                              CPU_CHAR     *p_name,
     71                              OS_FLAGS      flags,
     72                              OS_ERR       *p_err)
     73          {
   \                     OSFlagCreate: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000F             MOVS     R7,R1
   \   00000008   0x4690             MOV      R8,R2
   \   0000000A   0x001C             MOVS     R4,R3
     74              CPU_SR_ALLOC();
   \   0000000C   0x2600             MOVS     R6,#+0
     75          
     76          
     77          #ifdef OS_SAFETY_CRITICAL
     78              if (p_err == DEF_NULL) {
     79                  OS_SAFETY_CRITICAL_EXCEPTION();
     80                  return;
     81              }
     82          #endif
     83          
     84          #ifdef OS_SAFETY_CRITICAL_IEC61508
     85              if (OSSafetyCriticalStartFlag == DEF_TRUE) {
     86                 *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
     87                  return;
     88              }
     89          #endif
     90          
     91          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
     92              if (OSIntNestingCtr > 0u) {                                 /* See if called from ISR ...                           */
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable9_1
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD003             BEQ.N    ??OSFlagCreate_0
     93                 *p_err = OS_ERR_CREATE_ISR;                              /* ... can't CREATE from an ISR                         */
   \   00000018   0xF642 0x60E1      MOVW     R0,#+12001
   \   0000001C   0x8020             STRH     R0,[R4, #+0]
     94                  return;
   \   0000001E   0xE027             B.N      ??OSFlagCreate_1
     95              }
     96          #endif
     97          
     98          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
     99              if (p_grp == DEF_NULL) {                                    /* Validate 'p_grp'                                     */
   \                     ??OSFlagCreate_0: (+1)
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD103             BNE.N    ??OSFlagCreate_2
    100                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000024   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000028   0x8020             STRH     R0,[R4, #+0]
    101                  return;
   \   0000002A   0xE021             B.N      ??OSFlagCreate_1
    102              }
    103          #endif
    104          
    105              CPU_CRITICAL_ENTER();
   \                     ??OSFlagCreate_2: (+1)
   \   0000002C   0x.... 0x....      BL       CPU_SR_Save
   \   00000030   0x0006             MOVS     R6,R0
   \   00000032   0x.... 0x....      BL       CPU_IntDisMeasStart
    106          #if (OS_OBJ_TYPE_REQ == DEF_ENABLED)
    107              p_grp->Type    = OS_OBJ_TYPE_FLAG;                          /* Set to event flag group type                         */
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable9_2  ;; 0x47414c46
   \   0000003A   0x6028             STR      R0,[R5, #+0]
    108          #endif
    109          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    110              p_grp->NamePtr = p_name;
   \   0000003C   0x606F             STR      R7,[R5, #+4]
    111          #else
    112              (void)p_name;
    113          #endif
    114              p_grp->Flags   = flags;                                     /* Set to desired initial value                         */
   \   0000003E   0xF8C5 0x8020      STR      R8,[R5, #+32]
    115          #if (OS_CFG_TS_EN == DEF_ENABLED)
    116              p_grp->TS      = 0u;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x6268             STR      R0,[R5, #+36]
    117          #endif
    118              OS_PendListInit(&p_grp->PendList);
   \   00000046   0xF115 0x0008      ADDS     R0,R5,#+8
   \   0000004A   0x.... 0x....      BL       OS_PendListInit
    119          
    120          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    121              OS_FlagDbgListAdd(p_grp);
   \   0000004E   0x0028             MOVS     R0,R5
   \   00000050   0x.... 0x....      BL       OS_FlagDbgListAdd
    122              OSFlagQty++;
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable9_3
   \   00000058   0x8800             LDRH     R0,[R0, #+0]
   \   0000005A   0x1C40             ADDS     R0,R0,#+1
   \   0000005C   0x.... 0x....      LDR.W    R1,??DataTable9_3
   \   00000060   0x8008             STRH     R0,[R1, #+0]
    123          #endif
    124          
    125              OS_TRACE_FLAG_CREATE(p_grp, p_name);
    126          
    127              CPU_CRITICAL_EXIT();
   \   00000062   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000066   0x0030             MOVS     R0,R6
   \   00000068   0x.... 0x....      BL       CPU_SR_Restore
    128             *p_err = OS_ERR_NONE;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x8020             STRH     R0,[R4, #+0]
    129          }
   \                     ??OSFlagCreate_1: (+1)
   \   00000070   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    130          
    131          
    132          /*
    133          ************************************************************************************************************************
    134          *                                             DELETE AN EVENT FLAG GROUP
    135          *
    136          * Description: This function deletes an event flag group and readies all tasks pending on the event flag group.
    137          *
    138          * Arguments  : p_grp     is a pointer to the desired event flag group.
    139          *
    140          *              opt       determines delete options as follows:
    141          *
    142          *                            OS_OPT_DEL_NO_PEND           Deletes the event flag group ONLY if no task pending
    143          *                            OS_OPT_DEL_ALWAYS            Deletes the event flag group even if tasks are waiting.
    144          *                                                         In this case, all the tasks pending will be readied.
    145          *
    146          *              p_err     is a pointer to an error code that can contain one of the following values:
    147          *
    148          *                            OS_ERR_NONE                    The call was successful and the event flag group was deleted
    149          *                            OS_ERR_DEL_ISR                 If you attempted to delete the event flag group from an ISR
    150          *                            OS_ERR_ILLEGAL_DEL_RUN_TIME    If you are trying to delete the event flag group after you
    151          *                                                             called OSStart()
    152          *                            OS_ERR_OBJ_PTR_NULL            If 'p_grp' is a NULL pointer
    153          *                            OS_ERR_OBJ_TYPE                If you didn't pass a pointer to an event flag group
    154          *                            OS_ERR_OPT_INVALID             An invalid option was specified
    155          *                            OS_ERR_OS_NOT_RUNNING          If uC/OS-III is not running yet
    156          *                            OS_ERR_TASK_WAITING            One or more tasks were waiting on the event flag group
    157          *
    158          * Returns    : == 0          if no tasks were waiting on the event flag group, or upon error.
    159          *              >  0          if one or more tasks waiting on the event flag group are now readied and informed.
    160          *
    161          * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of the event flag
    162          *                 group MUST check the return code of OSFlagPost and OSFlagPend().
    163          ************************************************************************************************************************
    164          */
    165          
    166          #if (OS_CFG_FLAG_DEL_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    167          OS_OBJ_QTY  OSFlagDel (OS_FLAG_GRP  *p_grp,
    168                                 OS_OPT        opt,
    169                                 OS_ERR       *p_err)
    170          {
   \                     OSFlagDel: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0015             MOVS     R5,R2
    171              OS_OBJ_QTY     nbr_tasks;
    172              OS_PEND_LIST  *p_pend_list;
    173              OS_TCB        *p_tcb;
    174              CPU_TS         ts;
    175              CPU_SR_ALLOC();
   \   0000000A   0x2700             MOVS     R7,#+0
    176          
    177          
    178          #ifdef OS_SAFETY_CRITICAL
    179              if (p_err == DEF_NULL) {
    180                  OS_SAFETY_CRITICAL_EXCEPTION();
    181                  return (0u);
    182              }
    183          #endif
    184          
    185              OS_TRACE_FLAG_DEL_ENTER(p_grp, opt);
    186          
    187          #ifdef OS_SAFETY_CRITICAL_IEC61508
    188              if (OSSafetyCriticalStartFlag == DEF_TRUE) {
    189                  OS_TRACE_FLAG_DEL_EXIT(OS_ERR_ILLEGAL_DEL_RUN_TIME);
    190                 *p_err = OS_ERR_ILLEGAL_DEL_RUN_TIME;
    191                  return (0u);
    192              }
    193          #endif
    194          
    195          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
    196              if (OSIntNestingCtr > 0u) {                                 /* See if called from ISR ...                           */
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable9_1
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD004             BEQ.N    ??OSFlagDel_0
    197                 *p_err = OS_ERR_DEL_ISR;                                 /* ... can't DELETE from an ISR                         */
   \   00000016   0xF243 0x20C9      MOVW     R0,#+13001
   \   0000001A   0x8028             STRH     R0,[R5, #+0]
    198                  OS_TRACE_FLAG_DEL_EXIT(OS_ERR_DEL_ISR);
    199                  return (0u);
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE072             B.N      ??OSFlagDel_1
    200              }
    201          #endif
    202          
    203          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?.                              */
    204              if (OSRunning != OS_STATE_OS_RUNNING) {
    205                  OS_TRACE_FLAG_DEL_EXIT(OS_ERR_OS_NOT_RUNNING);
    206                 *p_err = OS_ERR_OS_NOT_RUNNING;
    207                  return (0u);
    208              }
    209          #endif
    210          
    211          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
    212              if (p_grp == DEF_NULL) {                                    /* Validate 'p_grp'                                     */
   \                     ??OSFlagDel_0: (+1)
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD104             BNE.N    ??OSFlagDel_2
    213                  OS_TRACE_FLAG_DEL_EXIT(OS_ERR_OBJ_PTR_NULL);
    214                 *p_err  = OS_ERR_OBJ_PTR_NULL;
   \   00000024   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000028   0x8028             STRH     R0,[R5, #+0]
    215                  return (0u);
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xE06B             B.N      ??OSFlagDel_1
    216              }
    217          #endif
    218          
    219          #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
    220              if (p_grp->Type != OS_OBJ_TYPE_FLAG) {                      /* Validate event group object                          */
   \                     ??OSFlagDel_2: (+1)
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable9_2  ;; 0x47414c46
   \   00000034   0x4288             CMP      R0,R1
   \   00000036   0xD004             BEQ.N    ??OSFlagDel_3
    221                  OS_TRACE_FLAG_DEL_EXIT(OS_ERR_OBJ_TYPE);
    222                 *p_err = OS_ERR_OBJ_TYPE;
   \   00000038   0xF645 0x50C4      MOVW     R0,#+24004
   \   0000003C   0x8028             STRH     R0,[R5, #+0]
    223                  return (0u);
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xE061             B.N      ??OSFlagDel_1
    224              }
    225          #endif
    226              CPU_CRITICAL_ENTER();
   \                     ??OSFlagDel_3: (+1)
   \   00000042   0x.... 0x....      BL       CPU_SR_Save
   \   00000046   0x0007             MOVS     R7,R0
   \   00000048   0x.... 0x....      BL       CPU_IntDisMeasStart
    227              p_pend_list = &p_grp->PendList;
   \   0000004C   0xF114 0x0908      ADDS     R9,R4,#+8
    228              nbr_tasks   = 0u;
   \   00000050   0xF05F 0x0800      MOVS     R8,#+0
    229              switch (opt) {
   \   00000054   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000056   0x2E00             CMP      R6,#+0
   \   00000058   0xD002             BEQ.N    ??OSFlagDel_4
   \   0000005A   0x2E01             CMP      R6,#+1
   \   0000005C   0xD022             BEQ.N    ??OSFlagDel_5
   \   0000005E   0xE048             B.N      ??OSFlagDel_6
    230                  case OS_OPT_DEL_NO_PEND:                                /* Delete group if no task waiting                      */
    231                       if (p_pend_list->HeadPtr == DEF_NULL) {
   \                     ??OSFlagDel_4: (+1)
   \   00000060   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD114             BNE.N    ??OSFlagDel_7
    232          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    233                           OS_FlagDbgListRemove(p_grp);
   \   00000068   0x0020             MOVS     R0,R4
   \   0000006A   0x.... 0x....      BL       OS_FlagDbgListRemove
    234                           OSFlagQty--;
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable9_3
   \   00000072   0x8800             LDRH     R0,[R0, #+0]
   \   00000074   0x1E40             SUBS     R0,R0,#+1
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable9_3
   \   0000007A   0x8008             STRH     R0,[R1, #+0]
    235          #endif
    236                           OS_TRACE_FLAG_DEL(p_grp);
    237                           OS_FlagClr(p_grp);
   \   0000007C   0x0020             MOVS     R0,R4
   \   0000007E   0x.... 0x....      BL       OS_FlagClr
    238          
    239                           CPU_CRITICAL_EXIT();
   \   00000082   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000086   0x0038             MOVS     R0,R7
   \   00000088   0x.... 0x....      BL       CPU_SR_Restore
    240          
    241                          *p_err = OS_ERR_NONE;
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0x8028             STRH     R0,[R5, #+0]
   \   00000090   0xE007             B.N      ??OSFlagDel_8
    242                       } else {
    243                           CPU_CRITICAL_EXIT();
   \                     ??OSFlagDel_7: (+1)
   \   00000092   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000096   0x0038             MOVS     R0,R7
   \   00000098   0x.... 0x....      BL       CPU_SR_Restore
    244                          *p_err = OS_ERR_TASK_WAITING;
   \   0000009C   0xF247 0x105F      MOVW     R0,#+29023
   \   000000A0   0x8028             STRH     R0,[R5, #+0]
    245                       }
    246                       break;
   \                     ??OSFlagDel_8: (+1)
   \   000000A2   0xE02E             B.N      ??OSFlagDel_9
    247          
    248                  case OS_OPT_DEL_ALWAYS:                                 /* Always delete the event flag group                   */
    249          #if (OS_CFG_TS_EN == DEF_ENABLED)
    250                       ts = OS_TS_GET();                                  /* Get local time stamp so all tasks get the same time  */
   \                     ??OSFlagDel_5: (+1)
   \   000000A4   0x.... 0x....      BL       CPU_TS_TmrRd
   \   000000A8   0x0006             MOVS     R6,R0
   \   000000AA   0xE007             B.N      ??OSFlagDel_10
    251          #else
    252                       ts = 0u;
    253          #endif
    254                       while (p_pend_list->HeadPtr != DEF_NULL) {         /* Remove all tasks from the pend list                  */
    255                           p_tcb = p_pend_list->HeadPtr;
   \                     ??OSFlagDel_11: (+1)
   \   000000AC   0xF8D9 0x0000      LDR      R0,[R9, #+0]
    256                           OS_PendAbort(p_tcb,
    257                                        ts,
    258                                        OS_STATUS_PEND_DEL);
   \   000000B0   0x2202             MOVS     R2,#+2
   \   000000B2   0x0031             MOVS     R1,R6
   \   000000B4   0x.... 0x....      BL       OS_PendAbort
    259                           nbr_tasks++;
   \   000000B8   0xF118 0x0801      ADDS     R8,R8,#+1
    260                       }
   \                     ??OSFlagDel_10: (+1)
   \   000000BC   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   000000C0   0x2800             CMP      R0,#+0
   \   000000C2   0xD1F3             BNE.N    ??OSFlagDel_11
    261          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    262                       OS_FlagDbgListRemove(p_grp);
   \   000000C4   0x0020             MOVS     R0,R4
   \   000000C6   0x.... 0x....      BL       OS_FlagDbgListRemove
    263                       OSFlagQty--;
   \   000000CA   0x.... 0x....      LDR.W    R0,??DataTable9_3
   \   000000CE   0x8800             LDRH     R0,[R0, #+0]
   \   000000D0   0x1E40             SUBS     R0,R0,#+1
   \   000000D2   0x.... 0x....      LDR.W    R1,??DataTable9_3
   \   000000D6   0x8008             STRH     R0,[R1, #+0]
    264          #endif
    265                       OS_TRACE_FLAG_DEL(p_grp);
    266          
    267                       OS_FlagClr(p_grp);
   \   000000D8   0x0020             MOVS     R0,R4
   \   000000DA   0x.... 0x....      BL       OS_FlagClr
    268                       CPU_CRITICAL_EXIT();
   \   000000DE   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000E2   0x0038             MOVS     R0,R7
   \   000000E4   0x.... 0x....      BL       CPU_SR_Restore
    269          
    270                       OSSched();                                         /* Find highest priority task ready to run              */
   \   000000E8   0x.... 0x....      BL       OSSched
    271                      *p_err = OS_ERR_NONE;
   \   000000EC   0x2000             MOVS     R0,#+0
   \   000000EE   0x8028             STRH     R0,[R5, #+0]
    272                       break;
   \   000000F0   0xE007             B.N      ??OSFlagDel_9
    273          
    274                  default:
    275                       CPU_CRITICAL_EXIT();
   \                     ??OSFlagDel_6: (+1)
   \   000000F2   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000F6   0x0038             MOVS     R0,R7
   \   000000F8   0x.... 0x....      BL       CPU_SR_Restore
    276                      *p_err = OS_ERR_OPT_INVALID;
   \   000000FC   0xF645 0x6025      MOVW     R0,#+24101
   \   00000100   0x8028             STRH     R0,[R5, #+0]
    277                       break;
    278              }
    279          
    280              OS_TRACE_FLAG_DEL_EXIT(*p_err);
    281          
    282              return (nbr_tasks);
   \                     ??OSFlagDel_9: (+1)
   \   00000102   0x4640             MOV      R0,R8
   \   00000104   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSFlagDel_1: (+1)
   \   00000106   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    283          }
    284          #endif
    285          
    286          
    287          /*
    288          ************************************************************************************************************************
    289          *                                             WAIT ON AN EVENT FLAG GROUP
    290          *
    291          * Description: This function is called to wait for a combination of bits to be set in an event flag group.  Your
    292          *              application can wait for ANY bit to be set or ALL bits to be set.
    293          *
    294          * Arguments  : p_grp         is a pointer to the desired event flag group.
    295          *
    296          *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to wait for.
    297          *                            The bits you want are specified by setting the corresponding bits in 'flags'.
    298          *                            e.g. if your application wants to wait for bits 0 and 1 then 'flags' would contain 0x03.
    299          *
    300          *              timeout       is an optional timeout (in clock ticks) that your task will wait for the
    301          *                            desired bit combination.  If you specify 0, however, your task will wait
    302          *                            forever at the specified event flag group or, until a message arrives.
    303          *
    304          *              opt           specifies whether you want ALL bits to be set or ANY of the bits to be set.
    305          *                            You can specify the 'ONE' of the following arguments:
    306          *
    307          *                                OS_OPT_PEND_FLAG_CLR_ALL   You will wait for ALL bits in 'flags' to be clear (0)
    308          *                                OS_OPT_PEND_FLAG_CLR_ANY   You will wait for ANY bit  in 'flags' to be clear (0)
    309          *                                OS_OPT_PEND_FLAG_SET_ALL   You will wait for ALL bits in 'flags' to be set   (1)
    310          *                                OS_OPT_PEND_FLAG_SET_ANY   You will wait for ANY bit  in 'flags' to be set   (1)
    311          *
    312          *                            You can 'ADD' OS_OPT_PEND_FLAG_CONSUME if you want the event flag to be 'consumed' by
    313          *                                      the call.  Example, to wait for any flag in a group AND then clear
    314          *                                      the flags that are present, set 'wait_opt' to:
    315          *
    316          *                                      OS_OPT_PEND_FLAG_SET_ANY + OS_OPT_PEND_FLAG_CONSUME
    317          *
    318          *                            You can also 'ADD' the type of pend with 'ONE' of the two option:
    319          *
    320          *                                OS_OPT_PEND_NON_BLOCKING   Task will NOT block if flags are not available
    321          *                                OS_OPT_PEND_BLOCKING       Task will     block if flags are not available
    322          *
    323          *              p_ts          is a pointer to a variable that will receive the timestamp of when the event flag group was
    324          *                            posted, aborted or the event flag group deleted.  If you pass a NULL pointer (i.e. (CPU_TS *)0)
    325          *                            then you will not get the timestamp.  In other words, passing a NULL pointer is valid and
    326          *                            indicates that you don't need the timestamp.
    327          *
    328          *              p_err         is a pointer to an error code and can be:
    329          *
    330          *                                OS_ERR_NONE                The desired bits have been set within the specified 'timeout'
    331          *                                OS_ERR_OBJ_DEL             If the event group was deleted
    332          *                                OS_ERR_OBJ_PTR_NULL        If 'p_grp' is a NULL pointer.
    333          *                                OS_ERR_OBJ_TYPE            You are not pointing to an event flag group
    334          *                                OS_ERR_OPT_INVALID         You didn't specify a proper 'opt' argument
    335          *                                OS_ERR_OS_NOT_RUNNING      If uC/OS-III is not running yet
    336          *                                OS_ERR_PEND_ABORT          The wait on the flag was aborted
    337          *                                OS_ERR_PEND_ISR            If you tried to PEND from an ISR
    338          *                                OS_ERR_PEND_WOULD_BLOCK    If you specified non-blocking but the flags were not
    339          *                                                           available
    340          *                                OS_ERR_SCHED_LOCKED        If you called this function when the scheduler is locked
    341          *                                OS_ERR_STATUS_INVALID      If the pend status has an invalid value
    342          *                                OS_ERR_TIMEOUT             The bit(s) have not been set in the specified 'timeout'
    343          *
    344          * Returns    : The flags in the event flag group that made the task ready or, 0 if a timeout or an error
    345          *              occurred.
    346          *
    347          * Note(s)    : none
    348          ************************************************************************************************************************
    349          */
    350          

   \                                 In section .text, align 2, keep-with-next
    351          OS_FLAGS  OSFlagPend (OS_FLAG_GRP  *p_grp,
    352                                OS_FLAGS      flags,
    353                                OS_TICK       timeout,
    354                                OS_OPT        opt,
    355                                CPU_TS       *p_ts,
    356                                OS_ERR       *p_err)
    357          {
   \                     OSFlagPend: (+1)
   \   00000000   0xE92D 0x4FF4      PUSH     {R2,R4-R11,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x001E             MOVS     R6,R3
    358              CPU_BOOLEAN  consume;
    359              OS_FLAGS     flags_rdy;
    360              OS_OPT       mode;
    361              CPU_SR_ALLOC();
   \   0000000C   0xF05F 0x0A00      MOVS     R10,#+0
   \   00000010   0x9F0D             LDR      R7,[SP, #+52]
    362          
    363          
    364          #ifdef OS_SAFETY_CRITICAL
    365              if (p_err == DEF_NULL) {
    366                  OS_SAFETY_CRITICAL_EXCEPTION();
    367                  return (0u);
    368              }
    369          #endif
    370          
    371              OS_TRACE_FLAG_PEND_ENTER(p_grp, flags, timeout, opt, p_ts);
    372          
    373          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
    374              if (OSIntNestingCtr > 0u) {                                 /* See if called from ISR ...                           */
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable9_1
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD004             BEQ.N    ??OSFlagPend_0
    375                 *p_err = OS_ERR_PEND_ISR;                                /* ... can't PEND from an ISR                           */
   \   0000001C   0xF246 0x10AE      MOVW     R0,#+25006
   \   00000020   0x8038             STRH     R0,[R7, #+0]
    376                  OS_TRACE_FLAG_PEND_FAILED(p_grp);
    377                  OS_TRACE_FLAG_PEND_EXIT(OS_ERR_PEND_ISR);
    378                  return ((OS_FLAGS)0);
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xE215             B.N      ??OSFlagPend_1
    379              }
    380          #endif
    381          
    382          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
    383              if (OSRunning != OS_STATE_OS_RUNNING) {
    384                  OS_TRACE_FLAG_PEND_EXIT(OS_ERR_OS_NOT_RUNNING);
    385                 *p_err = OS_ERR_OS_NOT_RUNNING;
    386                  return (0u);
    387              }
    388          #endif
    389          
    390          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
    391              if (p_grp == DEF_NULL) {                                    /* Validate 'p_grp'                                     */
   \                     ??OSFlagPend_0: (+1)
   \   00000026   0x2C00             CMP      R4,#+0
   \   00000028   0xD104             BNE.N    ??OSFlagPend_2
    392                  OS_TRACE_FLAG_PEND_FAILED(p_grp);
    393                  OS_TRACE_FLAG_PEND_EXIT(OS_ERR_OBJ_PTR_NULL);
    394                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   0000002A   0xF645 0x50C3      MOVW     R0,#+24003
   \   0000002E   0x8038             STRH     R0,[R7, #+0]
    395                  return (0u);
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xE20E             B.N      ??OSFlagPend_1
    396              }
    397              switch (opt) {                                              /* Validate 'opt'                                       */
   \                     ??OSFlagPend_2: (+1)
   \   00000034   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000036   0x0030             MOVS     R0,R6
   \   00000038   0x1E40             SUBS     R0,R0,#+1
   \   0000003A   0x2801             CMP      R0,#+1
   \   0000003C   0xD91A             BLS.N    ??OSFlagPend_3
   \   0000003E   0x1EC0             SUBS     R0,R0,#+3
   \   00000040   0xD018             BEQ.N    ??OSFlagPend_3
   \   00000042   0x1F00             SUBS     R0,R0,#+4
   \   00000044   0xD016             BEQ.N    ??OSFlagPend_3
   \   00000046   0x38F9             SUBS     R0,R0,#+249
   \   00000048   0x2801             CMP      R0,#+1
   \   0000004A   0xD913             BLS.N    ??OSFlagPend_3
   \   0000004C   0x1EC0             SUBS     R0,R0,#+3
   \   0000004E   0xD011             BEQ.N    ??OSFlagPend_3
   \   00000050   0x1F00             SUBS     R0,R0,#+4
   \   00000052   0xD00F             BEQ.N    ??OSFlagPend_3
   \   00000054   0xF647 0x61F9      MOVW     R1,#+32505
   \   00000058   0x1A40             SUBS     R0,R0,R1
   \   0000005A   0x2801             CMP      R0,#+1
   \   0000005C   0xD90A             BLS.N    ??OSFlagPend_3
   \   0000005E   0x1EC0             SUBS     R0,R0,#+3
   \   00000060   0xD008             BEQ.N    ??OSFlagPend_3
   \   00000062   0x1F00             SUBS     R0,R0,#+4
   \   00000064   0xD006             BEQ.N    ??OSFlagPend_3
   \   00000066   0x38F9             SUBS     R0,R0,#+249
   \   00000068   0x2801             CMP      R0,#+1
   \   0000006A   0xD903             BLS.N    ??OSFlagPend_3
   \   0000006C   0x1EC0             SUBS     R0,R0,#+3
   \   0000006E   0xD001             BEQ.N    ??OSFlagPend_3
   \   00000070   0x1F00             SUBS     R0,R0,#+4
   \   00000072   0xD10A             BNE.N    ??OSFlagPend_4
    398                  case OS_OPT_PEND_FLAG_CLR_ALL:
    399                  case OS_OPT_PEND_FLAG_CLR_ANY:
    400                  case OS_OPT_PEND_FLAG_SET_ALL:
    401                  case OS_OPT_PEND_FLAG_SET_ANY:
    402                  case OS_OPT_PEND_FLAG_CLR_ALL | OS_OPT_PEND_FLAG_CONSUME:
    403                  case OS_OPT_PEND_FLAG_CLR_ANY | OS_OPT_PEND_FLAG_CONSUME:
    404                  case OS_OPT_PEND_FLAG_SET_ALL | OS_OPT_PEND_FLAG_CONSUME:
    405                  case OS_OPT_PEND_FLAG_SET_ANY | OS_OPT_PEND_FLAG_CONSUME:
    406                  case OS_OPT_PEND_FLAG_CLR_ALL | OS_OPT_PEND_NON_BLOCKING:
    407                  case OS_OPT_PEND_FLAG_CLR_ANY | OS_OPT_PEND_NON_BLOCKING:
    408                  case OS_OPT_PEND_FLAG_SET_ALL | OS_OPT_PEND_NON_BLOCKING:
    409                  case OS_OPT_PEND_FLAG_SET_ANY | OS_OPT_PEND_NON_BLOCKING:
    410                  case OS_OPT_PEND_FLAG_CLR_ALL | OS_OPT_PEND_FLAG_CONSUME | OS_OPT_PEND_NON_BLOCKING:
    411                  case OS_OPT_PEND_FLAG_CLR_ANY | OS_OPT_PEND_FLAG_CONSUME | OS_OPT_PEND_NON_BLOCKING:
    412                  case OS_OPT_PEND_FLAG_SET_ALL | OS_OPT_PEND_FLAG_CONSUME | OS_OPT_PEND_NON_BLOCKING:
    413                  case OS_OPT_PEND_FLAG_SET_ANY | OS_OPT_PEND_FLAG_CONSUME | OS_OPT_PEND_NON_BLOCKING:
    414                       break;
    415          
    416                  default:
    417                       OS_TRACE_FLAG_PEND_FAILED(p_grp);
    418                       OS_TRACE_FLAG_PEND_EXIT(OS_ERR_OPT_INVALID);
    419                      *p_err = OS_ERR_OPT_INVALID;
    420                       return (0u);
    421              }
    422          #endif
    423          
    424          #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
    425              if (p_grp->Type != OS_OBJ_TYPE_FLAG) {                      /* Validate that we are pointing at an event flag       */
   \                     ??OSFlagPend_3: (+1)
   \   00000074   0x6820             LDR      R0,[R4, #+0]
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable9_2  ;; 0x47414c46
   \   0000007A   0x4288             CMP      R0,R1
   \   0000007C   0xD10A             BNE.N    ??OSFlagPend_5
    426                  OS_TRACE_FLAG_PEND_FAILED(p_grp);
    427                  OS_TRACE_FLAG_PEND_EXIT(OS_ERR_OBJ_TYPE);
    428                 *p_err = OS_ERR_OBJ_TYPE;
    429                  return (0u);
    430              }
    431          #endif
    432          
    433              if ((opt & OS_OPT_PEND_FLAG_CONSUME) != 0u) {               /* See if we need to consume the flags                  */
   \   0000007E   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000080   0x05F0             LSLS     R0,R6,#+23
   \   00000082   0xD50C             BPL.N    ??OSFlagPend_6
    434                  consume = DEF_TRUE;
   \   00000084   0xF05F 0x0801      MOVS     R8,#+1
   \   00000088   0xE00B             B.N      ??OSFlagPend_7
    435              } else {
   \                     ??OSFlagPend_4: (+1)
   \   0000008A   0xF645 0x6025      MOVW     R0,#+24101
   \   0000008E   0x8038             STRH     R0,[R7, #+0]
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0xE1DE             B.N      ??OSFlagPend_1
   \                     ??OSFlagPend_5: (+1)
   \   00000094   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000098   0x8038             STRH     R0,[R7, #+0]
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0xE1D9             B.N      ??OSFlagPend_1
    436                  consume = DEF_FALSE;
   \                     ??OSFlagPend_6: (+1)
   \   0000009E   0xF05F 0x0800      MOVS     R8,#+0
   \                     ??OSFlagPend_7: (+1)
   \   000000A2   0xF8DD 0x9030      LDR      R9,[SP, #+48]
    437              }
    438          
    439              if (p_ts != DEF_NULL) {
   \   000000A6   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000AA   0xD002             BEQ.N    ??OSFlagPend_8
    440                 *p_ts = 0u;                                              /* Initialize the returned timestamp                    */
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0xF8C9 0x0000      STR      R0,[R9, #+0]
    441              }
    442          
    443              mode = opt & OS_OPT_PEND_FLAG_MASK;
   \                     ??OSFlagPend_8: (+1)
   \   000000B2   0xF016 0x000F      ANDS     R0,R6,#0xF
   \   000000B6   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    444              CPU_CRITICAL_ENTER();
   \   000000BA   0x.... 0x....      BL       CPU_SR_Save
   \   000000BE   0x4682             MOV      R10,R0
   \   000000C0   0x.... 0x....      BL       CPU_IntDisMeasStart
    445              switch (mode) {
   \   000000C4   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   000000C8   0x2801             CMP      R0,#+1
   \   000000CA   0xF000 0x80C1      BEQ.W    ??OSFlagPend_9
   \   000000CE   0x2802             CMP      R0,#+2
   \   000000D0   0xF000 0x8109      BEQ.W    ??OSFlagPend_10
   \   000000D4   0x2804             CMP      R0,#+4
   \   000000D6   0xD002             BEQ.N    ??OSFlagPend_11
   \   000000D8   0x2808             CMP      R0,#+8
   \   000000DA   0xD06D             BEQ.N    ??OSFlagPend_12
   \   000000DC   0xE14F             B.N      ??OSFlagPend_13
    446                  case OS_OPT_PEND_FLAG_SET_ALL:                          /* See if all required flags are set                    */
    447                       flags_rdy = (p_grp->Flags & flags);                /* Extract only the bits we want                        */
   \                     ??OSFlagPend_11: (+1)
   \   000000DE   0x6A20             LDR      R0,[R4, #+32]
   \   000000E0   0xEA15 0x0B00      ANDS     R11,R5,R0
    448                       if (flags_rdy == flags) {                          /* Must match ALL the bits that we want                 */
   \   000000E4   0x45AB             CMP      R11,R5
   \   000000E6   0xD11C             BNE.N    ??OSFlagPend_14
    449                           if (consume == DEF_TRUE) {                     /* See if we need to consume the flags                  */
   \   000000E8   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000EC   0xF1B8 0x0F01      CMP      R8,#+1
   \   000000F0   0xD103             BNE.N    ??OSFlagPend_15
    450                               p_grp->Flags &= ~flags_rdy;                /* Clear ONLY the flags that we wanted                  */
   \   000000F2   0x6A20             LDR      R0,[R4, #+32]
   \   000000F4   0xEA30 0x000B      BICS     R0,R0,R11
   \   000000F8   0x6220             STR      R0,[R4, #+32]
    451                           }
    452                           OSTCBCurPtr->FlagsRdy = flags_rdy;             /* Save flags that were ready                           */
   \                     ??OSFlagPend_15: (+1)
   \   000000FA   0x.... 0x....      LDR.W    R0,??DataTable9_4
   \   000000FE   0x6800             LDR      R0,[R0, #+0]
   \   00000100   0xF8C0 0xB080      STR      R11,[R0, #+128]
    453          #if (OS_CFG_TS_EN == DEF_ENABLED)
    454                           if (p_ts != DEF_NULL) {
   \   00000104   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000108   0xD002             BEQ.N    ??OSFlagPend_16
    455                              *p_ts = p_grp->TS;
   \   0000010A   0x6A60             LDR      R0,[R4, #+36]
   \   0000010C   0xF8C9 0x0000      STR      R0,[R9, #+0]
    456                           }
    457          #endif
    458                           CPU_CRITICAL_EXIT();                           /* Yes, condition met, return to caller                 */
   \                     ??OSFlagPend_16: (+1)
   \   00000110   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000114   0x4650             MOV      R0,R10
   \   00000116   0x.... 0x....      BL       CPU_SR_Restore
    459                           OS_TRACE_FLAG_PEND(p_grp);
    460                           OS_TRACE_FLAG_PEND_EXIT(OS_ERR_NONE);
    461                          *p_err = OS_ERR_NONE;
   \   0000011A   0x2000             MOVS     R0,#+0
   \   0000011C   0x8038             STRH     R0,[R7, #+0]
    462                           return (flags_rdy);
   \   0000011E   0x4658             MOV      R0,R11
   \   00000120   0xE197             B.N      ??OSFlagPend_1
    463                       } else {                                           /* Block task until events occur or timeout             */
    464                           if ((opt & OS_OPT_PEND_NON_BLOCKING) != 0u) {
   \                     ??OSFlagPend_14: (+1)
   \   00000122   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000124   0x0430             LSLS     R0,R6,#+16
   \   00000126   0xD509             BPL.N    ??OSFlagPend_17
    465                               CPU_CRITICAL_EXIT();
   \   00000128   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000012C   0x4650             MOV      R0,R10
   \   0000012E   0x.... 0x....      BL       CPU_SR_Restore
    466                               OS_TRACE_FLAG_PEND_FAILED(p_grp);
    467                               OS_TRACE_FLAG_PEND_EXIT(OS_ERR_PEND_WOULD_BLOCK);
    468                              *p_err = OS_ERR_PEND_WOULD_BLOCK;           /* Specified non-blocking so task would block           */
   \   00000132   0xF246 0x10B0      MOVW     R0,#+25008
   \   00000136   0x8038             STRH     R0,[R7, #+0]
    469                               return ((OS_FLAGS)0);
   \   00000138   0x2000             MOVS     R0,#+0
   \   0000013A   0xE18A             B.N      ??OSFlagPend_1
    470                           } else {                                       /* Specified blocking so check is scheduler is locked   */
    471                               if (OSSchedLockNestingCtr > 0u) {          /* See if called with scheduler locked ...        */
   \                     ??OSFlagPend_17: (+1)
   \   0000013C   0x.... 0x....      LDR.W    R0,??DataTable9_5
   \   00000140   0x7800             LDRB     R0,[R0, #+0]
   \   00000142   0x2800             CMP      R0,#+0
   \   00000144   0xD009             BEQ.N    ??OSFlagPend_18
    472                                   CPU_CRITICAL_EXIT();
   \   00000146   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000014A   0x4650             MOV      R0,R10
   \   0000014C   0x.... 0x....      BL       CPU_SR_Restore
    473                                   OS_TRACE_FLAG_PEND_FAILED(p_grp);
    474                                   OS_TRACE_FLAG_PEND_EXIT(OS_ERR_SCHED_LOCKED);
    475                                  *p_err = OS_ERR_SCHED_LOCKED;           /* ... can't PEND when locked                           */
   \   00000150   0xF646 0x5063      MOVW     R0,#+28003
   \   00000154   0x8038             STRH     R0,[R7, #+0]
    476                                   return (0u);
   \   00000156   0x2000             MOVS     R0,#+0
   \   00000158   0xE17B             B.N      ??OSFlagPend_1
    477                               }
    478                           }
    479                                                                          /* Lock the scheduler/re-enable interrupts              */
    480                           OS_FlagBlock(p_grp,
    481                                        flags,
    482                                        opt,
    483                                        timeout);
   \                     ??OSFlagPend_18: (+1)
   \   0000015A   0x9B02             LDR      R3,[SP, #+8]
   \   0000015C   0x0032             MOVS     R2,R6
   \   0000015E   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000160   0x0029             MOVS     R1,R5
   \   00000162   0x0020             MOVS     R0,R4
   \   00000164   0x.... 0x....      BL       OS_FlagBlock
    484                           CPU_CRITICAL_EXIT();
   \   00000168   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000016C   0x4650             MOV      R0,R10
   \   0000016E   0x.... 0x....      BL       CPU_SR_Restore
    485                       }
    486                       break;
    487          
    488                  case OS_OPT_PEND_FLAG_SET_ANY:
    489                       flags_rdy = (p_grp->Flags & flags);                /* Extract only the bits we want                        */
    490                       if (flags_rdy != 0u) {                             /* See if any flag set                                  */
    491                           if (consume == DEF_TRUE) {                     /* See if we need to consume the flags                  */
    492                               p_grp->Flags &= ~flags_rdy;                /* Clear ONLY the flags that we got                     */
    493                           }
    494                           OSTCBCurPtr->FlagsRdy = flags_rdy;             /* Save flags that were ready                           */
    495          #if (OS_CFG_TS_EN == DEF_ENABLED)
    496                           if (p_ts != DEF_NULL) {
    497                              *p_ts  = p_grp->TS;
    498                           }
    499          #endif
    500                           CPU_CRITICAL_EXIT();                           /* Yes, condition met, return to caller                 */
    501                           OS_TRACE_FLAG_PEND(p_grp);
    502                           OS_TRACE_FLAG_PEND_EXIT(OS_ERR_NONE);
    503                          *p_err = OS_ERR_NONE;
    504                           return (flags_rdy);
    505                       } else {                                           /* Block task until events occur or timeout             */
    506                           if ((opt & OS_OPT_PEND_NON_BLOCKING) != 0u) {
    507                               CPU_CRITICAL_EXIT();
    508                               OS_TRACE_FLAG_PEND_EXIT(OS_ERR_PEND_WOULD_BLOCK);
    509                              *p_err = OS_ERR_PEND_WOULD_BLOCK;           /* Specified non-blocking so task would block           */
    510                               return ((OS_FLAGS)0);
    511                           } else {                                       /* Specified blocking so check is scheduler is locked   */
    512                               if (OSSchedLockNestingCtr > 0u) {          /* See if called with scheduler locked ...        */
    513                                   CPU_CRITICAL_EXIT();
    514                                   OS_TRACE_FLAG_PEND_EXIT(OS_ERR_SCHED_LOCKED);
    515                                  *p_err = OS_ERR_SCHED_LOCKED;           /* ... can't PEND when locked                           */
    516                                   return ((OS_FLAGS)0);
    517                               }
    518                           }
    519          
    520                           OS_FlagBlock(p_grp,
    521                                        flags,
    522                                        opt,
    523                                        timeout);
    524                           CPU_CRITICAL_EXIT();
    525                       }
    526                       break;
    527          
    528          #if (OS_CFG_FLAG_MODE_CLR_EN == DEF_ENABLED)
    529                  case OS_OPT_PEND_FLAG_CLR_ALL:                          /* See if all required flags are cleared                */
    530                       flags_rdy = (OS_FLAGS)(~p_grp->Flags & flags);     /* Extract only the bits we want                        */
    531                       if (flags_rdy == flags) {                          /* Must match ALL the bits that we want                 */
    532                           if (consume == DEF_TRUE) {                     /* See if we need to consume the flags                  */
    533                               p_grp->Flags |= flags_rdy;                 /* Set ONLY the flags that we wanted                    */
    534                           }
    535                           OSTCBCurPtr->FlagsRdy = flags_rdy;             /* Save flags that were ready                           */
    536          #if (OS_CFG_TS_EN == DEF_ENABLED)
    537                           if (p_ts != DEF_NULL) {
    538                              *p_ts  = p_grp->TS;
    539                           }
    540          #endif
    541                           CPU_CRITICAL_EXIT();                           /* Yes, condition met, return to caller                 */
    542                           OS_TRACE_FLAG_PEND(p_grp);
    543                           OS_TRACE_FLAG_PEND_EXIT(OS_ERR_NONE);
    544                          *p_err = OS_ERR_NONE;
    545                           return (flags_rdy);
    546                       } else {                                           /* Block task until events occur or timeout             */
    547                           if ((opt & OS_OPT_PEND_NON_BLOCKING) != 0u) {
    548                               CPU_CRITICAL_EXIT();
    549                               OS_TRACE_FLAG_PEND_EXIT(OS_ERR_PEND_WOULD_BLOCK);
    550                              *p_err = OS_ERR_PEND_WOULD_BLOCK;           /* Specified non-blocking so task would block           */
    551                               return ((OS_FLAGS)0);
    552                           } else {                                       /* Specified blocking so check is scheduler is locked   */
    553                               if (OSSchedLockNestingCtr > 0u) {          /* See if called with scheduler locked ...        */
    554                                   CPU_CRITICAL_EXIT();
    555                                   OS_TRACE_FLAG_PEND_EXIT(OS_ERR_SCHED_LOCKED);
    556                                  *p_err = OS_ERR_SCHED_LOCKED;           /* ... can't PEND when locked                           */
    557                                   return (0);
    558                               }
    559                           }
    560          
    561                           OS_FlagBlock(p_grp,
    562                                        flags,
    563                                        opt,
    564                                        timeout);
    565                           CPU_CRITICAL_EXIT();
    566                       }
    567                       break;
    568          
    569                  case OS_OPT_PEND_FLAG_CLR_ANY:
    570                       flags_rdy = (~p_grp->Flags & flags);               /* Extract only the bits we want                        */
    571                       if (flags_rdy != 0u) {                             /* See if any flag cleared                              */
    572                           if (consume == DEF_TRUE) {                     /* See if we need to consume the flags                  */
    573                               p_grp->Flags |= flags_rdy;                 /* Set ONLY the flags that we got                       */
    574                           }
    575                           OSTCBCurPtr->FlagsRdy = flags_rdy;             /* Save flags that were ready                           */
    576          #if (OS_CFG_TS_EN == DEF_ENABLED)
    577                           if (p_ts != DEF_NULL) {
    578                              *p_ts  = p_grp->TS;
    579                           }
    580          #endif
    581                           CPU_CRITICAL_EXIT();                           /* Yes, condition met, return to caller                 */
    582                           OS_TRACE_FLAG_PEND(p_grp);
    583                           OS_TRACE_FLAG_PEND_EXIT(OS_ERR_NONE);
    584                          *p_err = OS_ERR_NONE;
    585                           return (flags_rdy);
    586                       } else {                                           /* Block task until events occur or timeout             */
    587                           if ((opt & OS_OPT_PEND_NON_BLOCKING) != 0u) {
    588                               CPU_CRITICAL_EXIT();
    589                               OS_TRACE_FLAG_PEND_EXIT(OS_ERR_PEND_WOULD_BLOCK);
    590                              *p_err = OS_ERR_PEND_WOULD_BLOCK;           /* Specified non-blocking so task would block           */
    591                               return ((OS_FLAGS)0);
    592                           } else {                                       /* Specified blocking so check is scheduler is locked   */
    593                               if (OSSchedLockNestingCtr > 0u) {          /* See if called with scheduler locked ...        */
    594                                   CPU_CRITICAL_EXIT();
    595                                   OS_TRACE_FLAG_PEND_EXIT(OS_ERR_SCHED_LOCKED);
    596                                  *p_err = OS_ERR_SCHED_LOCKED;           /* ... can't PEND when locked                           */
    597                                   return (0u);
    598                               }
    599                           }
    600          
    601                           OS_FlagBlock(p_grp,
    602                                        flags,
    603                                        opt,
    604                                        timeout);
    605                           CPU_CRITICAL_EXIT();
    606                       }
    607                       break;
    608          #endif
    609          
    610                  default:
    611                       CPU_CRITICAL_EXIT();
    612                       OS_TRACE_FLAG_PEND_FAILED(p_grp);
    613                       OS_TRACE_FLAG_PEND_EXIT(OS_ERR_OPT_INVALID);
    614                      *p_err = OS_ERR_OPT_INVALID;
    615                       return (0u);
    616              }
    617          
    618              OS_TRACE_FLAG_PEND_BLOCK(p_grp);
    619          
    620              OSSched();                                                  /* Find next HPT ready to run                           */
   \                     ??OSFlagPend_19: (+1)
   \   00000172   0x.... 0x....      BL       OSSched
    621          
    622              CPU_CRITICAL_ENTER();
   \   00000176   0x.... 0x....      BL       CPU_SR_Save
   \   0000017A   0x4682             MOV      R10,R0
   \   0000017C   0x.... 0x....      BL       CPU_IntDisMeasStart
    623              switch (OSTCBCurPtr->PendStatus) {
   \   00000180   0x.... 0x....      LDR.W    R0,??DataTable9_4
   \   00000184   0x6800             LDR      R0,[R0, #+0]
   \   00000186   0xF890 0x003D      LDRB     R0,[R0, #+61]
   \   0000018A   0x2800             CMP      R0,#+0
   \   0000018C   0xD008             BEQ.N    ??OSFlagPend_20
   \   0000018E   0x2802             CMP      R0,#+2
   \   00000190   0xF000 0x8120      BEQ.W    ??OSFlagPend_21
   \   00000194   0xF0C0 0x80FD      BCC.W    ??OSFlagPend_22
   \   00000198   0x2803             CMP      R0,#+3
   \   0000019A   0xF000 0x810C      BEQ.W    ??OSFlagPend_23
   \   0000019E   0xE12B             B.N      ??OSFlagPend_24
    624                  case OS_STATUS_PEND_OK:                                 /* We got the event flags                               */
    625          #if (OS_CFG_TS_EN == DEF_ENABLED)
    626                       if (p_ts != DEF_NULL) {
   \                     ??OSFlagPend_20: (+1)
   \   000001A0   0xF1B9 0x0F00      CMP      R9,#+0
   \   000001A4   0xD005             BEQ.N    ??OSFlagPend_25
    627                          *p_ts = OSTCBCurPtr->TS;
   \   000001A6   0x.... 0x....      LDR.W    R0,??DataTable9_4
   \   000001AA   0x6800             LDR      R0,[R0, #+0]
   \   000001AC   0x6D00             LDR      R0,[R0, #+80]
   \   000001AE   0xF8C9 0x0000      STR      R0,[R9, #+0]
    628                       }
    629          #endif
    630                       OS_TRACE_FLAG_PEND(p_grp);
    631                      *p_err = OS_ERR_NONE;
   \                     ??OSFlagPend_25: (+1)
   \   000001B2   0x2000             MOVS     R0,#+0
   \   000001B4   0x8038             STRH     R0,[R7, #+0]
    632                       break;
   \   000001B6   0xE127             B.N      ??OSFlagPend_26
   \                     ??OSFlagPend_12: (+1)
   \   000001B8   0x6A20             LDR      R0,[R4, #+32]
   \   000001BA   0xEA15 0x0B00      ANDS     R11,R5,R0
   \   000001BE   0xF1BB 0x0F00      CMP      R11,#+0
   \   000001C2   0xD01C             BEQ.N    ??OSFlagPend_27
   \   000001C4   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001C8   0xF1B8 0x0F01      CMP      R8,#+1
   \   000001CC   0xD103             BNE.N    ??OSFlagPend_28
   \   000001CE   0x6A20             LDR      R0,[R4, #+32]
   \   000001D0   0xEA30 0x000B      BICS     R0,R0,R11
   \   000001D4   0x6220             STR      R0,[R4, #+32]
   \                     ??OSFlagPend_28: (+1)
   \   000001D6   0x.... 0x....      LDR.W    R0,??DataTable9_4
   \   000001DA   0x6800             LDR      R0,[R0, #+0]
   \   000001DC   0xF8C0 0xB080      STR      R11,[R0, #+128]
   \   000001E0   0xF1B9 0x0F00      CMP      R9,#+0
   \   000001E4   0xD002             BEQ.N    ??OSFlagPend_29
   \   000001E6   0x6A60             LDR      R0,[R4, #+36]
   \   000001E8   0xF8C9 0x0000      STR      R0,[R9, #+0]
   \                     ??OSFlagPend_29: (+1)
   \   000001EC   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000001F0   0x4650             MOV      R0,R10
   \   000001F2   0x.... 0x....      BL       CPU_SR_Restore
   \   000001F6   0x2000             MOVS     R0,#+0
   \   000001F8   0x8038             STRH     R0,[R7, #+0]
   \   000001FA   0x4658             MOV      R0,R11
   \   000001FC   0xE129             B.N      ??OSFlagPend_1
   \                     ??OSFlagPend_27: (+1)
   \   000001FE   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000200   0x0430             LSLS     R0,R6,#+16
   \   00000202   0xD509             BPL.N    ??OSFlagPend_30
   \   00000204   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000208   0x4650             MOV      R0,R10
   \   0000020A   0x.... 0x....      BL       CPU_SR_Restore
   \   0000020E   0xF246 0x10B0      MOVW     R0,#+25008
   \   00000212   0x8038             STRH     R0,[R7, #+0]
   \   00000214   0x2000             MOVS     R0,#+0
   \   00000216   0xE11C             B.N      ??OSFlagPend_1
   \                     ??OSFlagPend_30: (+1)
   \   00000218   0x.... 0x....      LDR.W    R0,??DataTable9_5
   \   0000021C   0x7800             LDRB     R0,[R0, #+0]
   \   0000021E   0x2800             CMP      R0,#+0
   \   00000220   0xD009             BEQ.N    ??OSFlagPend_31
   \   00000222   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000226   0x4650             MOV      R0,R10
   \   00000228   0x.... 0x....      BL       CPU_SR_Restore
   \   0000022C   0xF646 0x5063      MOVW     R0,#+28003
   \   00000230   0x8038             STRH     R0,[R7, #+0]
   \   00000232   0x2000             MOVS     R0,#+0
   \   00000234   0xE10D             B.N      ??OSFlagPend_1
   \                     ??OSFlagPend_31: (+1)
   \   00000236   0x9B02             LDR      R3,[SP, #+8]
   \   00000238   0x0032             MOVS     R2,R6
   \   0000023A   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000023C   0x0029             MOVS     R1,R5
   \   0000023E   0x0020             MOVS     R0,R4
   \   00000240   0x.... 0x....      BL       OS_FlagBlock
   \   00000244   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000248   0x4650             MOV      R0,R10
   \   0000024A   0x.... 0x....      BL       CPU_SR_Restore
   \   0000024E   0xE790             B.N      ??OSFlagPend_19
   \                     ??OSFlagPend_9: (+1)
   \   00000250   0x6A20             LDR      R0,[R4, #+32]
   \   00000252   0xEA35 0x0B00      BICS     R11,R5,R0
   \   00000256   0x45AB             CMP      R11,R5
   \   00000258   0xD11C             BNE.N    ??OSFlagPend_32
   \   0000025A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000025E   0xF1B8 0x0F01      CMP      R8,#+1
   \   00000262   0xD103             BNE.N    ??OSFlagPend_33
   \   00000264   0x6A20             LDR      R0,[R4, #+32]
   \   00000266   0xEA5B 0x0000      ORRS     R0,R11,R0
   \   0000026A   0x6220             STR      R0,[R4, #+32]
   \                     ??OSFlagPend_33: (+1)
   \   0000026C   0x.... 0x....      LDR.W    R0,??DataTable9_4
   \   00000270   0x6800             LDR      R0,[R0, #+0]
   \   00000272   0xF8C0 0xB080      STR      R11,[R0, #+128]
   \   00000276   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000027A   0xD002             BEQ.N    ??OSFlagPend_34
   \   0000027C   0x6A60             LDR      R0,[R4, #+36]
   \   0000027E   0xF8C9 0x0000      STR      R0,[R9, #+0]
   \                     ??OSFlagPend_34: (+1)
   \   00000282   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000286   0x4650             MOV      R0,R10
   \   00000288   0x.... 0x....      BL       CPU_SR_Restore
   \   0000028C   0x2000             MOVS     R0,#+0
   \   0000028E   0x8038             STRH     R0,[R7, #+0]
   \   00000290   0x4658             MOV      R0,R11
   \   00000292   0xE0DE             B.N      ??OSFlagPend_1
   \                     ??OSFlagPend_32: (+1)
   \   00000294   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000296   0x0430             LSLS     R0,R6,#+16
   \   00000298   0xD509             BPL.N    ??OSFlagPend_35
   \   0000029A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000029E   0x4650             MOV      R0,R10
   \   000002A0   0x.... 0x....      BL       CPU_SR_Restore
   \   000002A4   0xF246 0x10B0      MOVW     R0,#+25008
   \   000002A8   0x8038             STRH     R0,[R7, #+0]
   \   000002AA   0x2000             MOVS     R0,#+0
   \   000002AC   0xE0D1             B.N      ??OSFlagPend_1
   \                     ??OSFlagPend_35: (+1)
   \   000002AE   0x.... 0x....      LDR.W    R0,??DataTable9_5
   \   000002B2   0x7800             LDRB     R0,[R0, #+0]
   \   000002B4   0x2800             CMP      R0,#+0
   \   000002B6   0xD009             BEQ.N    ??OSFlagPend_36
   \   000002B8   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000002BC   0x4650             MOV      R0,R10
   \   000002BE   0x.... 0x....      BL       CPU_SR_Restore
   \   000002C2   0xF646 0x5063      MOVW     R0,#+28003
   \   000002C6   0x8038             STRH     R0,[R7, #+0]
   \   000002C8   0x2000             MOVS     R0,#+0
   \   000002CA   0xE0C2             B.N      ??OSFlagPend_1
   \                     ??OSFlagPend_36: (+1)
   \   000002CC   0x9B02             LDR      R3,[SP, #+8]
   \   000002CE   0x0032             MOVS     R2,R6
   \   000002D0   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000002D2   0x0029             MOVS     R1,R5
   \   000002D4   0x0020             MOVS     R0,R4
   \   000002D6   0x.... 0x....      BL       OS_FlagBlock
   \   000002DA   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000002DE   0x4650             MOV      R0,R10
   \   000002E0   0x.... 0x....      BL       CPU_SR_Restore
   \   000002E4   0xE745             B.N      ??OSFlagPend_19
   \                     ??OSFlagPend_10: (+1)
   \   000002E6   0x6A20             LDR      R0,[R4, #+32]
   \   000002E8   0xEA35 0x0B00      BICS     R11,R5,R0
   \   000002EC   0xF1BB 0x0F00      CMP      R11,#+0
   \   000002F0   0xD01C             BEQ.N    ??OSFlagPend_37
   \   000002F2   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000002F6   0xF1B8 0x0F01      CMP      R8,#+1
   \   000002FA   0xD103             BNE.N    ??OSFlagPend_38
   \   000002FC   0x6A20             LDR      R0,[R4, #+32]
   \   000002FE   0xEA5B 0x0000      ORRS     R0,R11,R0
   \   00000302   0x6220             STR      R0,[R4, #+32]
   \                     ??OSFlagPend_38: (+1)
   \   00000304   0x.... 0x....      LDR.W    R0,??DataTable9_4
   \   00000308   0x6800             LDR      R0,[R0, #+0]
   \   0000030A   0xF8C0 0xB080      STR      R11,[R0, #+128]
   \   0000030E   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000312   0xD002             BEQ.N    ??OSFlagPend_39
   \   00000314   0x6A60             LDR      R0,[R4, #+36]
   \   00000316   0xF8C9 0x0000      STR      R0,[R9, #+0]
   \                     ??OSFlagPend_39: (+1)
   \   0000031A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000031E   0x4650             MOV      R0,R10
   \   00000320   0x.... 0x....      BL       CPU_SR_Restore
   \   00000324   0x2000             MOVS     R0,#+0
   \   00000326   0x8038             STRH     R0,[R7, #+0]
   \   00000328   0x4658             MOV      R0,R11
   \   0000032A   0xE092             B.N      ??OSFlagPend_1
   \                     ??OSFlagPend_37: (+1)
   \   0000032C   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000032E   0x0430             LSLS     R0,R6,#+16
   \   00000330   0xD509             BPL.N    ??OSFlagPend_40
   \   00000332   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000336   0x4650             MOV      R0,R10
   \   00000338   0x.... 0x....      BL       CPU_SR_Restore
   \   0000033C   0xF246 0x10B0      MOVW     R0,#+25008
   \   00000340   0x8038             STRH     R0,[R7, #+0]
   \   00000342   0x2000             MOVS     R0,#+0
   \   00000344   0xE085             B.N      ??OSFlagPend_1
   \                     ??OSFlagPend_40: (+1)
   \   00000346   0x.... 0x....      LDR.W    R0,??DataTable9_5
   \   0000034A   0x7800             LDRB     R0,[R0, #+0]
   \   0000034C   0x2800             CMP      R0,#+0
   \   0000034E   0xD009             BEQ.N    ??OSFlagPend_41
   \   00000350   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000354   0x4650             MOV      R0,R10
   \   00000356   0x.... 0x....      BL       CPU_SR_Restore
   \   0000035A   0xF646 0x5063      MOVW     R0,#+28003
   \   0000035E   0x8038             STRH     R0,[R7, #+0]
   \   00000360   0x2000             MOVS     R0,#+0
   \   00000362   0xE076             B.N      ??OSFlagPend_1
   \                     ??OSFlagPend_41: (+1)
   \   00000364   0x9B02             LDR      R3,[SP, #+8]
   \   00000366   0x0032             MOVS     R2,R6
   \   00000368   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000036A   0x0029             MOVS     R1,R5
   \   0000036C   0x0020             MOVS     R0,R4
   \   0000036E   0x.... 0x....      BL       OS_FlagBlock
   \   00000372   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000376   0x4650             MOV      R0,R10
   \   00000378   0x.... 0x....      BL       CPU_SR_Restore
   \   0000037C   0xE6F9             B.N      ??OSFlagPend_19
   \                     ??OSFlagPend_13: (+1)
   \   0000037E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000382   0x4650             MOV      R0,R10
   \   00000384   0x.... 0x....      BL       CPU_SR_Restore
   \   00000388   0xF645 0x6025      MOVW     R0,#+24101
   \   0000038C   0x8038             STRH     R0,[R7, #+0]
   \   0000038E   0x2000             MOVS     R0,#+0
   \   00000390   0xE05F             B.N      ??OSFlagPend_1
    633          
    634                  case OS_STATUS_PEND_ABORT:                              /* Indicate that we aborted                             */
    635          #if (OS_CFG_TS_EN == DEF_ENABLED)
    636                       if (p_ts != DEF_NULL) {
   \                     ??OSFlagPend_22: (+1)
   \   00000392   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000396   0xD005             BEQ.N    ??OSFlagPend_42
    637                          *p_ts = OSTCBCurPtr->TS;
   \   00000398   0x.... 0x....      LDR.W    R0,??DataTable9_4
   \   0000039C   0x6800             LDR      R0,[R0, #+0]
   \   0000039E   0x6D00             LDR      R0,[R0, #+80]
   \   000003A0   0xF8C9 0x0000      STR      R0,[R9, #+0]
    638                       }
    639          #endif
    640                       CPU_CRITICAL_EXIT();
   \                     ??OSFlagPend_42: (+1)
   \   000003A4   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000003A8   0x4650             MOV      R0,R10
   \   000003AA   0x.... 0x....      BL       CPU_SR_Restore
    641                       OS_TRACE_FLAG_PEND_FAILED(p_grp);
    642                      *p_err = OS_ERR_PEND_ABORT;
   \   000003AE   0xF246 0x10A9      MOVW     R0,#+25001
   \   000003B2   0x8038             STRH     R0,[R7, #+0]
    643                       break;
   \   000003B4   0xE028             B.N      ??OSFlagPend_26
    644          
    645                  case OS_STATUS_PEND_TIMEOUT:                            /* Indicate that we didn't get semaphore within timeout */
    646                       if (p_ts != DEF_NULL) {
   \                     ??OSFlagPend_23: (+1)
   \   000003B6   0xF1B9 0x0F00      CMP      R9,#+0
   \   000003BA   0xD002             BEQ.N    ??OSFlagPend_43
    647                          *p_ts = 0u;
   \   000003BC   0x2000             MOVS     R0,#+0
   \   000003BE   0xF8C9 0x0000      STR      R0,[R9, #+0]
    648                       }
    649                       CPU_CRITICAL_EXIT();
   \                     ??OSFlagPend_43: (+1)
   \   000003C2   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000003C6   0x4650             MOV      R0,R10
   \   000003C8   0x.... 0x....      BL       CPU_SR_Restore
    650                       OS_TRACE_FLAG_PEND_FAILED(p_grp);
    651                      *p_err = OS_ERR_TIMEOUT;
   \   000003CC   0xF247 0x20D9      MOVW     R0,#+29401
   \   000003D0   0x8038             STRH     R0,[R7, #+0]
    652                       break;
   \   000003D2   0xE019             B.N      ??OSFlagPend_26
    653          
    654                  case OS_STATUS_PEND_DEL:                                /* Indicate that object pended on has been deleted      */
    655          #if (OS_CFG_TS_EN == DEF_ENABLED)
    656                       if (p_ts != DEF_NULL) {
   \                     ??OSFlagPend_21: (+1)
   \   000003D4   0xF1B9 0x0F00      CMP      R9,#+0
   \   000003D8   0xD005             BEQ.N    ??OSFlagPend_44
    657                          *p_ts = OSTCBCurPtr->TS;
   \   000003DA   0x.... 0x....      LDR.W    R0,??DataTable9_4
   \   000003DE   0x6800             LDR      R0,[R0, #+0]
   \   000003E0   0x6D00             LDR      R0,[R0, #+80]
   \   000003E2   0xF8C9 0x0000      STR      R0,[R9, #+0]
    658                       }
    659          #endif
    660                       CPU_CRITICAL_EXIT();
   \                     ??OSFlagPend_44: (+1)
   \   000003E6   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000003EA   0x4650             MOV      R0,R10
   \   000003EC   0x.... 0x....      BL       CPU_SR_Restore
    661                       OS_TRACE_FLAG_PEND_FAILED(p_grp);
    662                      *p_err = OS_ERR_OBJ_DEL;
   \   000003F0   0xF645 0x50C2      MOVW     R0,#+24002
   \   000003F4   0x8038             STRH     R0,[R7, #+0]
    663                       break;
   \   000003F6   0xE007             B.N      ??OSFlagPend_26
    664          
    665                  default:
    666                       CPU_CRITICAL_EXIT();
   \                     ??OSFlagPend_24: (+1)
   \   000003F8   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000003FC   0x4650             MOV      R0,R10
   \   000003FE   0x.... 0x....      BL       CPU_SR_Restore
    667                       OS_TRACE_FLAG_PEND_FAILED(p_grp);
    668                      *p_err = OS_ERR_STATUS_INVALID;
   \   00000402   0xF646 0x602E      MOVW     R0,#+28206
   \   00000406   0x8038             STRH     R0,[R7, #+0]
    669                       break;
    670              }
    671              if (*p_err != OS_ERR_NONE) {
   \                     ??OSFlagPend_26: (+1)
   \   00000408   0x8838             LDRH     R0,[R7, #+0]
   \   0000040A   0x2800             CMP      R0,#+0
   \   0000040C   0xD001             BEQ.N    ??OSFlagPend_45
    672                  OS_TRACE_FLAG_PEND_EXIT(*p_err);
    673                  return (0u);
   \   0000040E   0x2000             MOVS     R0,#+0
   \   00000410   0xE01F             B.N      ??OSFlagPend_1
    674              }
    675          
    676              flags_rdy = OSTCBCurPtr->FlagsRdy;
   \                     ??OSFlagPend_45: (+1)
   \   00000412   0x.... 0x....      LDR.W    R0,??DataTable9_4
   \   00000416   0x6800             LDR      R0,[R0, #+0]
   \   00000418   0xF8D0 0xB080      LDR      R11,[R0, #+128]
    677              if (consume == DEF_TRUE) {                                  /* See if we need to consume the flags                  */
   \   0000041C   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000420   0xF1B8 0x0F01      CMP      R8,#+1
   \   00000424   0xD10D             BNE.N    ??OSFlagPend_46
    678                  switch (mode) {
   \   00000426   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000042A   0x2801             CMP      R0,#+1
   \   0000042C   0xD013             BEQ.N    ??OSFlagPend_47
   \   0000042E   0x2802             CMP      R0,#+2
   \   00000430   0xD011             BEQ.N    ??OSFlagPend_47
   \   00000432   0x2804             CMP      R0,#+4
   \   00000434   0xD001             BEQ.N    ??OSFlagPend_48
   \   00000436   0x2808             CMP      R0,#+8
   \   00000438   0xD112             BNE.N    ??OSFlagPend_49
    679                      case OS_OPT_PEND_FLAG_SET_ALL:
    680                      case OS_OPT_PEND_FLAG_SET_ANY:                      /* Clear ONLY the flags we got                          */
    681                           p_grp->Flags &= ~flags_rdy;
   \                     ??OSFlagPend_48: (+1)
   \   0000043A   0x6A20             LDR      R0,[R4, #+32]
   \   0000043C   0xEA30 0x000B      BICS     R0,R0,R11
   \   00000440   0x6220             STR      R0,[R4, #+32]
    682                           break;
    683          
    684          #if (OS_CFG_FLAG_MODE_CLR_EN == DEF_ENABLED)
    685                      case OS_OPT_PEND_FLAG_CLR_ALL:
    686                      case OS_OPT_PEND_FLAG_CLR_ANY:                      /* Set   ONLY the flags we got                          */
    687                           p_grp->Flags |=  flags_rdy;
    688                           break;
    689          #endif
    690                      default:
    691                           CPU_CRITICAL_EXIT();
    692                           OS_TRACE_FLAG_PEND_EXIT(OS_ERR_OPT_INVALID);
    693                          *p_err = OS_ERR_OPT_INVALID;
    694                           return (0u);
    695                  }
    696              }
    697              CPU_CRITICAL_EXIT();
   \                     ??OSFlagPend_46: (+1)
   \   00000442   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000446   0x4650             MOV      R0,R10
   \   00000448   0x.... 0x....      BL       CPU_SR_Restore
    698              OS_TRACE_FLAG_PEND_EXIT(OS_ERR_NONE);
    699             *p_err = OS_ERR_NONE;                                        /* Event(s) must have occurred                          */
   \   0000044C   0x2000             MOVS     R0,#+0
   \   0000044E   0x8038             STRH     R0,[R7, #+0]
    700              return (flags_rdy);
   \   00000450   0x4658             MOV      R0,R11
   \                     ??OSFlagPend_1: (+1)
   \   00000452   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
   \                     ??OSFlagPend_47: (+1)
   \   00000456   0x6A20             LDR      R0,[R4, #+32]
   \   00000458   0xEA5B 0x0000      ORRS     R0,R11,R0
   \   0000045C   0x6220             STR      R0,[R4, #+32]
   \   0000045E   0xE7F0             B.N      ??OSFlagPend_46
   \                     ??OSFlagPend_49: (+1)
   \   00000460   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000464   0x4650             MOV      R0,R10
   \   00000466   0x.... 0x....      BL       CPU_SR_Restore
   \   0000046A   0xF645 0x6025      MOVW     R0,#+24101
   \   0000046E   0x8038             STRH     R0,[R7, #+0]
   \   00000470   0x2000             MOVS     R0,#+0
   \   00000472   0xE7EE             B.N      ??OSFlagPend_1
    701          }
    702          
    703          
    704          /*
    705          ************************************************************************************************************************
    706          *                                          ABORT WAITING ON AN EVENT FLAG GROUP
    707          *
    708          * Description: This function aborts & readies any tasks currently waiting on an event flag group.  This function should
    709          *              be used to fault-abort the wait on the event flag group, rather than to normally post to the event flag
    710          *              group OSFlagPost().
    711          *
    712          * Arguments  : p_grp     is a pointer to the event flag group
    713          *
    714          *              opt       determines the type of ABORT performed:
    715          *
    716          *                            OS_OPT_PEND_ABORT_1          ABORT wait for a single task (HPT) waiting on the event flag
    717          *                            OS_OPT_PEND_ABORT_ALL        ABORT wait for ALL tasks that are  waiting on the event flag
    718          *                            OS_OPT_POST_NO_SCHED         Do not call the scheduler
    719          *
    720          *              p_err     is a pointer to a variable that will contain an error code returned by this function.
    721          *
    722          *                            OS_ERR_NONE                  At least one task waiting on the event flag group and was
    723          *                                                         readied and informed of the aborted wait; check return value
    724          *                                                         for the number of tasks whose wait on the event flag group
    725          *                                                         was aborted
    726          *                            OS_ERR_OBJ_PTR_NULL          If 'p_grp' is a NULL pointer
    727          *                            OS_ERR_OBJ_TYPE              If 'p_grp' is not pointing at an event flag group
    728          *                            OS_ERR_OPT_INVALID           If you specified an invalid option
    729          *                            OS_ERR_OS_NOT_RUNNING        If uC/OS-III is not running yet
    730          *                            OS_ERR_PEND_ABORT_ISR        If you called this function from an ISR
    731          *                            OS_ERR_PEND_ABORT_NONE       No task were pending
    732          *
    733          * Returns    : == 0          if no tasks were waiting on the event flag group, or upon error.
    734          *              >  0          if one or more tasks waiting on the event flag group are now readied and informed.
    735          *
    736          * Note(s)    : none
    737          ************************************************************************************************************************
    738          */
    739          
    740          #if (OS_CFG_FLAG_PEND_ABORT_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    741          OS_OBJ_QTY  OSFlagPendAbort (OS_FLAG_GRP  *p_grp,
    742                                       OS_OPT        opt,
    743                                       OS_ERR       *p_err)
    744          {
   \                     OSFlagPendAbort: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0006             MOVS     R6,R0
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0x0015             MOVS     R5,R2
    745              OS_PEND_LIST  *p_pend_list;
    746              OS_TCB        *p_tcb;
    747              CPU_TS         ts;
    748              OS_OBJ_QTY     nbr_tasks;
    749              CPU_SR_ALLOC();
   \   0000000A   0x2700             MOVS     R7,#+0
    750          
    751          
    752          #ifdef OS_SAFETY_CRITICAL
    753              if (p_err == DEF_NULL) {
    754                  OS_SAFETY_CRITICAL_EXCEPTION();
    755                  return ((OS_OBJ_QTY)0u);
    756              }
    757          #endif
    758          
    759          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
    760              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to Pend Abort from an ISR                */
   \   0000000C   0x....             LDR.N    R0,??DataTable9_1
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD004             BEQ.N    ??OSFlagPendAbort_0
    761                 *p_err = OS_ERR_PEND_ABORT_ISR;
   \   00000014   0xF246 0x10AA      MOVW     R0,#+25002
   \   00000018   0x8028             STRH     R0,[R5, #+0]
    762                  return (0u);
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE057             B.N      ??OSFlagPendAbort_1
    763              }
    764          #endif
    765          
    766          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
    767              if (OSRunning != OS_STATE_OS_RUNNING) {
    768                 *p_err = OS_ERR_OS_NOT_RUNNING;
    769                  return (0u);
    770              }
    771          #endif
    772          
    773          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
    774              if (p_grp == DEF_NULL) {                                    /* Validate 'p_grp'                                     */
   \                     ??OSFlagPendAbort_0: (+1)
   \   0000001E   0x2E00             CMP      R6,#+0
   \   00000020   0xD104             BNE.N    ??OSFlagPendAbort_2
    775                 *p_err  =  OS_ERR_OBJ_PTR_NULL;
   \   00000022   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000026   0x8028             STRH     R0,[R5, #+0]
    776                  return (0u);
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xE050             B.N      ??OSFlagPendAbort_1
    777              }
    778              switch (opt) {                                              /* Validate 'opt'                                       */
   \                     ??OSFlagPendAbort_2: (+1)
   \   0000002C   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD008             BEQ.N    ??OSFlagPendAbort_3
   \   00000034   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000038   0xD005             BEQ.N    ??OSFlagPendAbort_3
   \   0000003A   0xF5B0 0x4F00      CMP      R0,#+32768
   \   0000003E   0xD002             BEQ.N    ??OSFlagPendAbort_3
   \   00000040   0xF5B0 0x4F01      CMP      R0,#+33024
   \   00000044   0xD118             BNE.N    ??OSFlagPendAbort_4
    779                  case OS_OPT_PEND_ABORT_1:
    780                  case OS_OPT_PEND_ABORT_ALL:
    781                  case OS_OPT_PEND_ABORT_1   | OS_OPT_POST_NO_SCHED:
    782                  case OS_OPT_PEND_ABORT_ALL | OS_OPT_POST_NO_SCHED:
    783                       break;
    784          
    785                  default:
    786                      *p_err = OS_ERR_OPT_INVALID;
    787                       return (0u);
    788              }
    789          #endif
    790          
    791          #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
    792              if (p_grp->Type != OS_OBJ_TYPE_FLAG) {                      /* Make sure event flag group was created               */
   \                     ??OSFlagPendAbort_3: (+1)
   \   00000046   0x6830             LDR      R0,[R6, #+0]
   \   00000048   0x....             LDR.N    R1,??DataTable9_2  ;; 0x47414c46
   \   0000004A   0x4288             CMP      R0,R1
   \   0000004C   0xD119             BNE.N    ??OSFlagPendAbort_5
    793                 *p_err = OS_ERR_OBJ_TYPE;
    794                  return (0u);
    795              }
    796          #endif
    797          
    798              CPU_CRITICAL_ENTER();
   \   0000004E   0x.... 0x....      BL       CPU_SR_Save
   \   00000052   0x0007             MOVS     R7,R0
   \   00000054   0x.... 0x....      BL       CPU_IntDisMeasStart
    799              p_pend_list = &p_grp->PendList;
   \   00000058   0xF116 0x0808      ADDS     R8,R6,#+8
    800              if (p_pend_list->HeadPtr == DEF_NULL) {                     /* Any task waiting on flag group?                      */
   \   0000005C   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD113             BNE.N    ??OSFlagPendAbort_6
    801                  CPU_CRITICAL_EXIT();                                    /* No                                                   */
   \   00000064   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000068   0x0038             MOVS     R0,R7
   \   0000006A   0x.... 0x....      BL       CPU_SR_Restore
    802                 *p_err = OS_ERR_PEND_ABORT_NONE;
   \   0000006E   0xF246 0x10AB      MOVW     R0,#+25003
   \   00000072   0x8028             STRH     R0,[R5, #+0]
    803                  return (0u);
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0xE02A             B.N      ??OSFlagPendAbort_1
    804              }
   \                     ??OSFlagPendAbort_4: (+1)
   \   00000078   0xF645 0x6025      MOVW     R0,#+24101
   \   0000007C   0x8028             STRH     R0,[R5, #+0]
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xE025             B.N      ??OSFlagPendAbort_1
   \                     ??OSFlagPendAbort_5: (+1)
   \   00000082   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000086   0x8028             STRH     R0,[R5, #+0]
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0xE020             B.N      ??OSFlagPendAbort_1
    805          
    806              nbr_tasks = 0u;
   \                     ??OSFlagPendAbort_6: (+1)
   \   0000008C   0x2600             MOVS     R6,#+0
    807          #if (OS_CFG_TS_EN == DEF_ENABLED)
    808              ts        = OS_TS_GET();                                    /* Get local time stamp so all tasks get the same time  */
   \   0000008E   0x.... 0x....      BL       CPU_TS_TmrRd
   \   00000092   0x4681             MOV      R9,R0
    809          #else
    810              ts        = 0u;
    811          #endif
    812          
    813              while (p_pend_list->HeadPtr != DEF_NULL) {
   \                     ??OSFlagPendAbort_7: (+1)
   \   00000094   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000098   0x2800             CMP      R0,#+0
   \   0000009A   0xD00A             BEQ.N    ??OSFlagPendAbort_8
    814                  p_tcb = p_pend_list->HeadPtr;
   \   0000009C   0xF8D8 0x0000      LDR      R0,[R8, #+0]
    815                  OS_PendAbort(p_tcb,
    816                               ts,
    817                               OS_STATUS_PEND_ABORT);
   \   000000A0   0x2201             MOVS     R2,#+1
   \   000000A2   0x4649             MOV      R1,R9
   \   000000A4   0x.... 0x....      BL       OS_PendAbort
    818                  nbr_tasks++;
   \   000000A8   0x1C76             ADDS     R6,R6,#+1
    819                  if (opt != OS_OPT_PEND_ABORT_ALL) {                     /* Pend abort all tasks waiting?                        */
   \   000000AA   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000AC   0xF5B4 0x7F80      CMP      R4,#+256
   \   000000B0   0xD0F0             BEQ.N    ??OSFlagPendAbort_7
    820                      break;                                              /* No                                                   */
    821                  }
    822              }
    823              CPU_CRITICAL_EXIT();
   \                     ??OSFlagPendAbort_8: (+1)
   \   000000B2   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000B6   0x0038             MOVS     R0,R7
   \   000000B8   0x.... 0x....      BL       CPU_SR_Restore
    824          
    825              if ((opt & OS_OPT_POST_NO_SCHED) == 0u) {
   \   000000BC   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000BE   0x0420             LSLS     R0,R4,#+16
   \   000000C0   0xD401             BMI.N    ??OSFlagPendAbort_9
    826                  OSSched();                                              /* Run the scheduler                                    */
   \   000000C2   0x.... 0x....      BL       OSSched
    827              }
    828          
    829             *p_err = OS_ERR_NONE;
   \                     ??OSFlagPendAbort_9: (+1)
   \   000000C6   0x2000             MOVS     R0,#+0
   \   000000C8   0x8028             STRH     R0,[R5, #+0]
    830              return (nbr_tasks);
   \   000000CA   0x0030             MOVS     R0,R6
   \   000000CC   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSFlagPendAbort_1: (+1)
   \   000000CE   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    831          }
    832          #endif
    833          
    834          
    835          /*
    836          ************************************************************************************************************************
    837          *                                       GET FLAGS WHO CAUSED TASK TO BECOME READY
    838          *
    839          * Description: This function is called to obtain the flags that caused the task to become ready to run.
    840          *              In other words, this function allows you to tell "Who done it!".
    841          *
    842          * Arguments  : p_err     is a pointer to an error code
    843          *
    844          *                            OS_ERR_NONE              If the call was successful
    845          *                            OS_ERR_OS_NOT_RUNNING    If uC/OS-III is not running yet
    846          *                            OS_ERR_PEND_ISR          If called from an ISR
    847          *
    848          * Returns    : The flags that caused the task to be ready.
    849          *
    850          * Note(s)    : none
    851          ************************************************************************************************************************
    852          */
    853          

   \                                 In section .text, align 2, keep-with-next
    854          OS_FLAGS  OSFlagPendGetFlagsRdy (OS_ERR  *p_err)
    855          {
   \                     OSFlagPendGetFlagsRdy: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    856              OS_FLAGS  flags;
    857              CPU_SR_ALLOC();
   \   00000004   0x2600             MOVS     R6,#+0
    858          
    859          
    860          #ifdef OS_SAFETY_CRITICAL
    861              if (p_err == DEF_NULL) {
    862                  OS_SAFETY_CRITICAL_EXCEPTION();
    863                  return ((OS_FLAGS)0);
    864              }
    865          #endif
    866          
    867          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
    868              if (OSRunning != OS_STATE_OS_RUNNING) {
    869                 *p_err = OS_ERR_OS_NOT_RUNNING;
    870                  return (0u);
    871              }
    872          #endif
    873          
    874          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
    875              if (OSIntNestingCtr > 0u) {                                 /* See if called from ISR ...                           */
   \   00000006   0x....             LDR.N    R0,??DataTable9_1
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD004             BEQ.N    ??OSFlagPendGetFlagsRdy_0
    876                 *p_err = OS_ERR_PEND_ISR;                                /* ... can't get from an ISR                            */
   \   0000000E   0xF246 0x10AE      MOVW     R0,#+25006
   \   00000012   0x8020             STRH     R0,[R4, #+0]
    877                  return (0u);
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xE010             B.N      ??OSFlagPendGetFlagsRdy_1
    878              }
    879          #endif
    880          
    881              CPU_CRITICAL_ENTER();
   \                     ??OSFlagPendGetFlagsRdy_0: (+1)
   \   00000018   0x.... 0x....      BL       CPU_SR_Save
   \   0000001C   0x0006             MOVS     R6,R0
   \   0000001E   0x.... 0x....      BL       CPU_IntDisMeasStart
    882              flags = OSTCBCurPtr->FlagsRdy;
   \   00000022   0x....             LDR.N    R0,??DataTable9_4
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0xF8D0 0x5080      LDR      R5,[R0, #+128]
    883              CPU_CRITICAL_EXIT();
   \   0000002A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000002E   0x0030             MOVS     R0,R6
   \   00000030   0x.... 0x....      BL       CPU_SR_Restore
    884             *p_err = OS_ERR_NONE;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x8020             STRH     R0,[R4, #+0]
    885              return (flags);
   \   00000038   0x0028             MOVS     R0,R5
   \                     ??OSFlagPendGetFlagsRdy_1: (+1)
   \   0000003A   0xBD70             POP      {R4-R6,PC}       ;; return
    886          }
    887          
    888          
    889          /*
    890          ************************************************************************************************************************
    891          *                                                POST EVENT FLAG BIT(S)
    892          *
    893          * Description: This function is called to set or clear some bits in an event flag group.  The bits to set or clear are
    894          *              specified by a 'bit mask'.
    895          *
    896          * Arguments  : p_grp         is a pointer to the desired event flag group.
    897          *
    898          *              flags         If 'opt' (see below) is OS_OPT_POST_FLAG_SET, each bit that is set in 'flags' will
    899          *                            set the corresponding bit in the event flag group.  e.g. to set bits 0, 4
    900          *                            and 5 you would set 'flags' to:
    901          *
    902          *                                0x31     (note, bit 0 is least significant bit)
    903          *
    904          *                            If 'opt' (see below) is OS_OPT_POST_FLAG_CLR, each bit that is set in 'flags' will
    905          *                            CLEAR the corresponding bit in the event flag group.  e.g. to clear bits 0,
    906          *                            4 and 5 you would specify 'flags' as:
    907          *
    908          *                                0x31     (note, bit 0 is least significant bit)
    909          *
    910          *              opt           indicates whether the flags will be:
    911          *
    912          *                                OS_OPT_POST_FLAG_SET       set
    913          *                                OS_OPT_POST_FLAG_CLR       cleared
    914          *
    915          *                            you can also 'add' OS_OPT_POST_NO_SCHED to prevent the scheduler from being called.
    916          *
    917          *              p_err         is a pointer to an error code and can be:
    918          *
    919          *                                OS_ERR_NONE                The call was successful
    920          *                                OS_ERR_OBJ_PTR_NULL        You passed a NULL pointer
    921          *                                OS_ERR_OBJ_TYPE            You are not pointing to an event flag group
    922          *                                OS_ERR_OPT_INVALID         You specified an invalid option
    923          *                                OS_ERR_OS_NOT_RUNNING      If uC/OS-III is not running yet
    924          *
    925          * Returns    : the new value of the event flags bits that are still set.
    926          *
    927          * Note(s)    : 1) The execution time of this function depends on the number of tasks waiting on the event flag group.
    928          ************************************************************************************************************************
    929          */
    930          

   \                                 In section .text, align 2, keep-with-next
    931          OS_FLAGS  OSFlagPost (OS_FLAG_GRP  *p_grp,
    932                                OS_FLAGS      flags,
    933                                OS_OPT        opt,
    934                                OS_ERR       *p_err)
    935          {
   \                     OSFlagPost: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0006             MOVS     R6,R0
   \   00000006   0x4689             MOV      R9,R1
   \   00000008   0x0017             MOVS     R7,R2
   \   0000000A   0x001C             MOVS     R4,R3
    936          
    937              OS_FLAGS       flags_cur;
    938              OS_FLAGS       flags_rdy;
    939              OS_OPT         mode;
    940              OS_PEND_LIST  *p_pend_list;
    941              OS_TCB        *p_tcb;
    942              OS_TCB        *p_tcb_next;
    943              CPU_TS         ts;
    944              CPU_SR_ALLOC();
   \   0000000C   0x2500             MOVS     R5,#+0
    945          
    946          
    947          #ifdef OS_SAFETY_CRITICAL
    948              if (p_err == DEF_NULL) {
    949                  OS_SAFETY_CRITICAL_EXCEPTION();
    950                  return (0u);
    951              }
    952          #endif
    953          
    954              OS_TRACE_FLAG_POST_ENTER(p_grp, flags, opt);
    955          
    956          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
    957              if (OSRunning != OS_STATE_OS_RUNNING) {
    958                  OS_TRACE_FLAG_POST_EXIT(OS_ERR_OS_NOT_RUNNING);
    959                 *p_err = OS_ERR_OS_NOT_RUNNING;
    960                  return (0u);
    961              }
    962          #endif
    963          
    964          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
    965              if (p_grp == DEF_NULL) {                                    /* Validate 'p_grp'                                     */
   \   0000000E   0x2E00             CMP      R6,#+0
   \   00000010   0xD104             BNE.N    ??OSFlagPost_0
    966                  OS_TRACE_FLAG_POST_FAILED(p_grp);
    967                  OS_TRACE_FLAG_POST_EXIT(OS_ERR_OBJ_PTR_NULL);
    968                 *p_err  = OS_ERR_OBJ_PTR_NULL;
   \   00000012   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000016   0x8020             STRH     R0,[R4, #+0]
    969                  return (0u);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE09E             B.N      ??OSFlagPost_1
    970              }
    971          #endif
    972          
    973          #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
    974              if (p_grp->Type != OS_OBJ_TYPE_FLAG) {                      /* Make sure we are pointing to an event flag grp       */
   \                     ??OSFlagPost_0: (+1)
   \   0000001C   0x6830             LDR      R0,[R6, #+0]
   \   0000001E   0x....             LDR.N    R1,??DataTable9_2  ;; 0x47414c46
   \   00000020   0x4288             CMP      R0,R1
   \   00000022   0xD004             BEQ.N    ??OSFlagPost_2
    975                  OS_TRACE_FLAG_POST_FAILED(p_grp);
    976                  OS_TRACE_FLAG_POST_EXIT(OS_ERR_OBJ_TYPE);
    977                 *p_err = OS_ERR_OBJ_TYPE;
   \   00000024   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000028   0x8020             STRH     R0,[R4, #+0]
    978                  return (0u);
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xE095             B.N      ??OSFlagPost_1
    979              }
    980          #endif
    981          
    982          #if (OS_CFG_TS_EN == DEF_ENABLED)
    983              ts = OS_TS_GET();                                           /* Get timestamp                                        */
   \                     ??OSFlagPost_2: (+1)
   \   0000002E   0x.... 0x....      BL       CPU_TS_TmrRd
   \   00000032   0x4680             MOV      R8,R0
    984          #else
    985              ts = 0u;
    986          #endif
    987          
    988              OS_TRACE_FLAG_POST(p_grp);
    989          
    990              switch (opt) {
   \   00000034   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000036   0x0038             MOVS     R0,R7
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD009             BEQ.N    ??OSFlagPost_3
   \   0000003C   0x2801             CMP      R0,#+1
   \   0000003E   0xD020             BEQ.N    ??OSFlagPost_4
   \   00000040   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000044   0xD004             BEQ.N    ??OSFlagPost_3
   \   00000046   0xF248 0x0101      MOVW     R1,#+32769
   \   0000004A   0x4288             CMP      R0,R1
   \   0000004C   0xD019             BEQ.N    ??OSFlagPost_4
   \   0000004E   0xE022             B.N      ??OSFlagPost_5
    991                  case OS_OPT_POST_FLAG_SET:
    992                  case OS_OPT_POST_FLAG_SET | OS_OPT_POST_NO_SCHED:
    993                       CPU_CRITICAL_ENTER();
   \                     ??OSFlagPost_3: (+1)
   \   00000050   0x.... 0x....      BL       CPU_SR_Save
   \   00000054   0x0005             MOVS     R5,R0
   \   00000056   0x.... 0x....      BL       CPU_IntDisMeasStart
    994                       p_grp->Flags |=  flags;                            /* Set   the flags specified in the group               */
   \   0000005A   0x6A30             LDR      R0,[R6, #+32]
   \   0000005C   0xEA59 0x0000      ORRS     R0,R9,R0
   \   00000060   0x6230             STR      R0,[R6, #+32]
    995                       break;
    996          
    997                  case OS_OPT_POST_FLAG_CLR:
    998                  case OS_OPT_POST_FLAG_CLR | OS_OPT_POST_NO_SCHED:
    999                       CPU_CRITICAL_ENTER();
   1000                       p_grp->Flags &= ~flags;                            /* Clear the flags specified in the group               */
   1001                       break;
   1002          
   1003                  default:
   1004                      *p_err = OS_ERR_OPT_INVALID;                        /* INVALID option                                       */
   1005                       OS_TRACE_FLAG_POST_EXIT(*p_err);
   1006                       return (0u);
   1007              }
   1008          #if (OS_CFG_TS_EN == DEF_ENABLED)
   1009              p_grp->TS   = ts;
   \                     ??OSFlagPost_6: (+1)
   \   00000062   0xF8C6 0x8024      STR      R8,[R6, #+36]
   1010          #endif
   1011              p_pend_list = &p_grp->PendList;
   \   00000066   0xF116 0x0008      ADDS     R0,R6,#+8
   1012              if (p_pend_list->HeadPtr == DEF_NULL) {                     /* Any task waiting on event flag group?                */
   \   0000006A   0x6801             LDR      R1,[R0, #+0]
   \   0000006C   0x2900             CMP      R1,#+0
   \   0000006E   0xD117             BNE.N    ??OSFlagPost_7
   1013                  CPU_CRITICAL_EXIT();                                    /* No                                                   */
   \   00000070   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000074   0x0028             MOVS     R0,R5
   \   00000076   0x.... 0x....      BL       CPU_SR_Restore
   1014                 *p_err = OS_ERR_NONE;
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x8020             STRH     R0,[R4, #+0]
   1015                  OS_TRACE_FLAG_POST_EXIT(*p_err);
   1016                  return (p_grp->Flags);
   \   0000007E   0x6A30             LDR      R0,[R6, #+32]
   \   00000080   0xE06B             B.N      ??OSFlagPost_1
   1017              }
   \                     ??OSFlagPost_4: (+1)
   \   00000082   0x.... 0x....      BL       CPU_SR_Save
   \   00000086   0x0005             MOVS     R5,R0
   \   00000088   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   0000008C   0x6A30             LDR      R0,[R6, #+32]
   \   0000008E   0xEA30 0x0009      BICS     R0,R0,R9
   \   00000092   0x6230             STR      R0,[R6, #+32]
   \   00000094   0xE7E5             B.N      ??OSFlagPost_6
   \                     ??OSFlagPost_5: (+1)
   \   00000096   0xF645 0x6025      MOVW     R0,#+24101
   \   0000009A   0x8020             STRH     R0,[R4, #+0]
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0xE05C             B.N      ??OSFlagPost_1
   1018          
   1019              p_tcb = p_pend_list->HeadPtr;
   \                     ??OSFlagPost_7: (+1)
   \   000000A0   0x6800             LDR      R0,[R0, #+0]
   \   000000A2   0xE009             B.N      ??OSFlagPost_8
   1020              while (p_tcb != DEF_NULL) {                                 /* Go through all tasks waiting on event flag(s)        */
   1021                  p_tcb_next = p_tcb->PendNextPtr;
   1022                  mode       = p_tcb->FlagsOpt & OS_OPT_PEND_FLAG_MASK;
   1023                  switch (mode) {
   1024                      case OS_OPT_PEND_FLAG_SET_ALL:                      /* See if all req. flags are set for current node       */
   1025                           flags_rdy = (p_grp->Flags & p_tcb->FlagsPend);
   \                     ??OSFlagPost_9: (+1)
   \   000000A4   0x6A31             LDR      R1,[R6, #+32]
   \   000000A6   0x6FC2             LDR      R2,[R0, #+124]
   \   000000A8   0x4011             ANDS     R1,R2,R1
   1026                           if (flags_rdy == p_tcb->FlagsPend) {
   \   000000AA   0x6FC2             LDR      R2,[R0, #+124]
   \   000000AC   0x4291             CMP      R1,R2
   \   000000AE   0xD102             BNE.N    ??OSFlagPost_10
   1027                               OS_FlagTaskRdy(p_tcb,                      /* Make task RTR, event(s) Rx'd                         */
   1028                                              flags_rdy,
   1029                                              ts);
   \   000000B0   0x4642             MOV      R2,R8
   \   000000B2   0x.... 0x....      BL       OS_FlagTaskRdy
   1030                           }
   1031                           break;
   1032          
   1033                      case OS_OPT_PEND_FLAG_SET_ANY:                      /* See if any flag set                                  */
   1034                           flags_rdy = (p_grp->Flags & p_tcb->FlagsPend);
   1035                           if (flags_rdy != 0u) {
   1036                               OS_FlagTaskRdy(p_tcb,                      /* Make task RTR, event(s) Rx'd                         */
   1037                                              flags_rdy,
   1038                                              ts);
   1039                           }
   1040                           break;
   1041          
   1042          #if (OS_CFG_FLAG_MODE_CLR_EN == DEF_ENABLED)
   1043                      case OS_OPT_PEND_FLAG_CLR_ALL:                      /* See if all req. flags are set for current node       */
   1044                           flags_rdy = (OS_FLAGS)(~p_grp->Flags & p_tcb->FlagsPend);
   1045                           if (flags_rdy == p_tcb->FlagsPend) {
   1046                               OS_FlagTaskRdy(p_tcb,                      /* Make task RTR, event(s) Rx'd                         */
   1047                                              flags_rdy,
   1048                                              ts);
   1049                           }
   1050                           break;
   1051          
   1052                      case OS_OPT_PEND_FLAG_CLR_ANY:                      /* See if any flag set                                  */
   1053                           flags_rdy = (OS_FLAGS)(~p_grp->Flags & p_tcb->FlagsPend);
   1054                           if (flags_rdy != 0u) {
   1055                               OS_FlagTaskRdy(p_tcb,                      /* Make task RTR, event(s) Rx'd                         */
   1056                                              flags_rdy,
   1057                                              ts);
   1058                           }
   1059                           break;
   1060          #endif
   1061                      default:
   1062                           CPU_CRITICAL_EXIT();
   1063                          *p_err = OS_ERR_FLAG_PEND_OPT;
   1064                           OS_TRACE_FLAG_POST_EXIT(*p_err);
   1065                           return (0u);
   1066                  }
   1067                                                                          /* Point to next task waiting for event flag(s)         */
   1068                  p_tcb = p_tcb_next;
   \                     ??OSFlagPost_10: (+1)
   \                     ??OSFlagPost_11: (+1)
   \   000000B6   0x4648             MOV      R0,R9
   \                     ??OSFlagPost_8: (+1)
   \   000000B8   0x2800             CMP      R0,#+0
   \   000000BA   0xD036             BEQ.N    ??OSFlagPost_12
   \   000000BC   0xF8D0 0x9030      LDR      R9,[R0, #+48]
   \   000000C0   0xF890 0x1084      LDRB     R1,[R0, #+132]
   \   000000C4   0xF011 0x010F      ANDS     R1,R1,#0xF
   \   000000C8   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000CA   0x2901             CMP      R1,#+1
   \   000000CC   0xD00E             BEQ.N    ??OSFlagPost_13
   \   000000CE   0x2902             CMP      R1,#+2
   \   000000D0   0xD017             BEQ.N    ??OSFlagPost_14
   \   000000D2   0x2904             CMP      R1,#+4
   \   000000D4   0xD0E6             BEQ.N    ??OSFlagPost_9
   \   000000D6   0x2908             CMP      R1,#+8
   \   000000D8   0xD11D             BNE.N    ??OSFlagPost_15
   \                     ??OSFlagPost_16: (+1)
   \   000000DA   0x6A31             LDR      R1,[R6, #+32]
   \   000000DC   0x6FC2             LDR      R2,[R0, #+124]
   \   000000DE   0x4011             ANDS     R1,R2,R1
   \   000000E0   0x2900             CMP      R1,#+0
   \   000000E2   0xD002             BEQ.N    ??OSFlagPost_17
   \   000000E4   0x4642             MOV      R2,R8
   \   000000E6   0x.... 0x....      BL       OS_FlagTaskRdy
   \                     ??OSFlagPost_17: (+1)
   \   000000EA   0xE7E4             B.N      ??OSFlagPost_11
   \                     ??OSFlagPost_13: (+1)
   \   000000EC   0x6A31             LDR      R1,[R6, #+32]
   \   000000EE   0x6FC2             LDR      R2,[R0, #+124]
   \   000000F0   0xEA32 0x0101      BICS     R1,R2,R1
   \   000000F4   0x6FC2             LDR      R2,[R0, #+124]
   \   000000F6   0x4291             CMP      R1,R2
   \   000000F8   0xD102             BNE.N    ??OSFlagPost_18
   \   000000FA   0x4642             MOV      R2,R8
   \   000000FC   0x.... 0x....      BL       OS_FlagTaskRdy
   \                     ??OSFlagPost_18: (+1)
   \   00000100   0xE7D9             B.N      ??OSFlagPost_11
   \                     ??OSFlagPost_14: (+1)
   \   00000102   0x6A31             LDR      R1,[R6, #+32]
   \   00000104   0x6FC2             LDR      R2,[R0, #+124]
   \   00000106   0xEA32 0x0101      BICS     R1,R2,R1
   \   0000010A   0x2900             CMP      R1,#+0
   \   0000010C   0xD002             BEQ.N    ??OSFlagPost_19
   \   0000010E   0x4642             MOV      R2,R8
   \   00000110   0x.... 0x....      BL       OS_FlagTaskRdy
   \                     ??OSFlagPost_19: (+1)
   \   00000114   0xE7CF             B.N      ??OSFlagPost_11
   \                     ??OSFlagPost_15: (+1)
   \   00000116   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000011A   0x0028             MOVS     R0,R5
   \   0000011C   0x.... 0x....      BL       CPU_SR_Restore
   \   00000120   0xF643 0x20FF      MOVW     R0,#+15103
   \   00000124   0x8020             STRH     R0,[R4, #+0]
   \   00000126   0x2000             MOVS     R0,#+0
   \   00000128   0xE017             B.N      ??OSFlagPost_1
   1069              }
   1070              CPU_CRITICAL_EXIT();
   \                     ??OSFlagPost_12: (+1)
   \   0000012A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000012E   0x0028             MOVS     R0,R5
   \   00000130   0x.... 0x....      BL       CPU_SR_Restore
   1071          
   1072              if ((opt & OS_OPT_POST_NO_SCHED) == 0u) {
   \   00000134   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000136   0x0438             LSLS     R0,R7,#+16
   \   00000138   0xD401             BMI.N    ??OSFlagPost_20
   1073                  OSSched();
   \   0000013A   0x.... 0x....      BL       OSSched
   1074              }
   1075          
   1076              CPU_CRITICAL_ENTER();
   \                     ??OSFlagPost_20: (+1)
   \   0000013E   0x.... 0x....      BL       CPU_SR_Save
   \   00000142   0x0005             MOVS     R5,R0
   \   00000144   0x.... 0x....      BL       CPU_IntDisMeasStart
   1077              flags_cur = p_grp->Flags;
   \   00000148   0x6A36             LDR      R6,[R6, #+32]
   1078              CPU_CRITICAL_EXIT();
   \   0000014A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000014E   0x0028             MOVS     R0,R5
   \   00000150   0x.... 0x....      BL       CPU_SR_Restore
   1079             *p_err     = OS_ERR_NONE;
   \   00000154   0x2000             MOVS     R0,#+0
   \   00000156   0x8020             STRH     R0,[R4, #+0]
   1080          
   1081              OS_TRACE_FLAG_POST_EXIT(*p_err);
   1082              return (flags_cur);
   \   00000158   0x0030             MOVS     R0,R6
   \                     ??OSFlagPost_1: (+1)
   \   0000015A   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1083          }
   1084          
   1085          
   1086          /*
   1087          ************************************************************************************************************************
   1088          *                         SUSPEND TASK UNTIL EVENT FLAG(s) RECEIVED OR TIMEOUT OCCURS
   1089          *
   1090          * Description: This function is internal to uC/OS-III and is used to put a task to sleep until the desired
   1091          *              event flag bit(s) are set.
   1092          *
   1093          * Arguments  : p_grp         is a pointer to the desired event flag group.
   1094          *              -----
   1095          *
   1096          *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to check.
   1097          *                            The bits you want are specified by setting the corresponding bits in
   1098          *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
   1099          *                            'flags' would contain 0x03.
   1100          *
   1101          *              opt           specifies whether you want ALL bits to be set/cleared or ANY of the bits
   1102          *                            to be set/cleared.
   1103          *                            You can specify the following argument:
   1104          *
   1105          *                                OS_OPT_PEND_FLAG_CLR_ALL   You will check ALL bits in 'mask' to be clear (0)
   1106          *                                OS_OPT_PEND_FLAG_CLR_ANY   You will check ANY bit  in 'mask' to be clear (0)
   1107          *                                OS_OPT_PEND_FLAG_SET_ALL   You will check ALL bits in 'mask' to be set   (1)
   1108          *                                OS_OPT_PEND_FLAG_SET_ANY   You will check ANY bit  in 'mask' to be set   (1)
   1109          *
   1110          *              timeout       is the desired amount of time that the task will wait for the event flag
   1111          *                            bit(s) to be set.
   1112          *
   1113          * Returns    : none
   1114          *
   1115          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   1116          ************************************************************************************************************************
   1117          */
   1118          

   \                                 In section .text, align 2, keep-with-next
   1119          void  OS_FlagBlock (OS_FLAG_GRP  *p_grp,
   1120                              OS_FLAGS      flags,
   1121                              OS_OPT        opt,
   1122                              OS_TICK       timeout)
   1123          {
   \                     OS_FlagBlock: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1124              OSTCBCurPtr->FlagsPend = flags;                             /* Save the flags that we need to wait for              */
   \   00000002   0x....             LDR.N    R4,??DataTable9_4
   \   00000004   0x6824             LDR      R4,[R4, #+0]
   \   00000006   0x67E1             STR      R1,[R4, #+124]
   1125              OSTCBCurPtr->FlagsOpt  = opt;                               /* Save the type of wait we are doing                   */
   \   00000008   0x....             LDR.N    R1,??DataTable9_4
   \   0000000A   0x6809             LDR      R1,[R1, #+0]
   \   0000000C   0xF8A1 0x2084      STRH     R2,[R1, #+132]
   1126              OSTCBCurPtr->FlagsRdy  = 0u;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x....             LDR.N    R2,??DataTable9_4
   \   00000014   0x6812             LDR      R2,[R2, #+0]
   \   00000016   0xF8C2 0x1080      STR      R1,[R2, #+128]
   1127          
   1128              OS_Pend((OS_PEND_OBJ *)((void *)p_grp),
   1129                       OS_TASK_PEND_ON_FLAG,
   1130                       timeout);
   \   0000001A   0x001A             MOVS     R2,R3
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x.... 0x....      BL       OS_Pend
   1131          }
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
   1132          
   1133          
   1134          /*
   1135          ************************************************************************************************************************
   1136          *                                      CLEAR THE CONTENTS OF AN EVENT FLAG GROUP
   1137          *
   1138          * Description: This function is called by OSFlagDel() to clear the contents of an event flag group
   1139          *
   1140          
   1141          * Argument(s): p_grp     is a pointer to the event flag group to clear
   1142          *              -----
   1143          *
   1144          * Returns    : none
   1145          *
   1146          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   1147          ************************************************************************************************************************
   1148          */
   1149          

   \                                 In section .text, align 2, keep-with-next
   1150          void  OS_FlagClr (OS_FLAG_GRP  *p_grp)
   1151          {
   \                     OS_FlagClr: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1152              OS_PEND_LIST  *p_pend_list;
   1153          
   1154          
   1155          #if (OS_OBJ_TYPE_REQ == DEF_ENABLED)
   1156              p_grp->Type             = OS_OBJ_TYPE_NONE;
   \   00000002   0x....             LDR.N    R1,??DataTable9_6  ;; 0x454e4f4e
   \   00000004   0x6001             STR      R1,[R0, #+0]
   1157          #endif
   1158          #if (OS_CFG_DBG_EN == DEF_ENABLED)
   1159              p_grp->NamePtr          = (CPU_CHAR *)((void *)"?FLAG");    /* Unknown name                                         */
   \   00000006   0x....             LDR.N    R1,??DataTable9_7
   \   00000008   0x6041             STR      R1,[R0, #+4]
   1160          #endif
   1161              p_grp->Flags            =  0u;
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x6201             STR      R1,[R0, #+32]
   1162              p_pend_list             = &p_grp->PendList;
   \   0000000E   0x3008             ADDS     R0,R0,#+8
   1163              OS_PendListInit(p_pend_list);
   \   00000010   0x.... 0x....      BL       OS_PendListInit
   1164          }
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
   1165          
   1166          
   1167          /*
   1168          ************************************************************************************************************************
   1169          *                                    ADD/REMOVE EVENT FLAG GROUP TO/FROM DEBUG LIST
   1170          *
   1171          * Description: These functions are called by uC/OS-III to add or remove an event flag group from the event flag debug
   1172          *              list.
   1173          *
   1174          * Arguments  : p_grp     is a pointer to the event flag group to add/remove
   1175          *
   1176          * Returns    : none
   1177          *
   1178          * Note(s)    : These functions are INTERNAL to uC/OS-III and your application should not call it.
   1179          ************************************************************************************************************************
   1180          */
   1181          
   1182          #if (OS_CFG_DBG_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   1183          void  OS_FlagDbgListAdd (OS_FLAG_GRP  *p_grp)
   1184          {
   1185              p_grp->DbgNamePtr                = (CPU_CHAR *)((void *)" ");
   \                     OS_FlagDbgListAdd: (+1)
   \   00000000   0x....             ADR.N    R1,??DataTable9  ;; " "
   \   00000002   0x61C1             STR      R1,[R0, #+28]
   1186              p_grp->DbgPrevPtr                = DEF_NULL;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6141             STR      R1,[R0, #+20]
   1187              if (OSFlagDbgListPtr == DEF_NULL) {
   \   00000008   0x....             LDR.N    R1,??DataTable9_8
   \   0000000A   0x6809             LDR      R1,[R1, #+0]
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD102             BNE.N    ??OS_FlagDbgListAdd_0
   1188                  p_grp->DbgNextPtr            = DEF_NULL;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6181             STR      R1,[R0, #+24]
   \   00000014   0xE005             B.N      ??OS_FlagDbgListAdd_1
   1189              } else {
   1190                  p_grp->DbgNextPtr            = OSFlagDbgListPtr;
   \                     ??OS_FlagDbgListAdd_0: (+1)
   \   00000016   0x....             LDR.N    R1,??DataTable9_8
   \   00000018   0x6809             LDR      R1,[R1, #+0]
   \   0000001A   0x6181             STR      R1,[R0, #+24]
   1191                  OSFlagDbgListPtr->DbgPrevPtr = p_grp;
   \   0000001C   0x....             LDR.N    R1,??DataTable9_8
   \   0000001E   0x6809             LDR      R1,[R1, #+0]
   \   00000020   0x6148             STR      R0,[R1, #+20]
   1192              }
   1193              OSFlagDbgListPtr                 = p_grp;
   \                     ??OS_FlagDbgListAdd_1: (+1)
   \   00000022   0x....             LDR.N    R1,??DataTable9_8
   \   00000024   0x6008             STR      R0,[R1, #+0]
   1194          }
   \   00000026   0x4770             BX       LR               ;; return
   1195          
   1196          

   \                                 In section .text, align 2, keep-with-next
   1197          void  OS_FlagDbgListRemove (OS_FLAG_GRP  *p_grp)
   1198          {
   1199              OS_FLAG_GRP  *p_grp_next;
   1200              OS_FLAG_GRP  *p_grp_prev;
   1201          
   1202          
   1203              p_grp_prev = p_grp->DbgPrevPtr;
   \                     OS_FlagDbgListRemove: (+1)
   \   00000000   0x6942             LDR      R2,[R0, #+20]
   1204              p_grp_next = p_grp->DbgNextPtr;
   \   00000002   0x6981             LDR      R1,[R0, #+24]
   1205          
   1206              if (p_grp_prev == DEF_NULL) {
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD108             BNE.N    ??OS_FlagDbgListRemove_0
   1207                  OSFlagDbgListPtr = p_grp_next;
   \   00000008   0x....             LDR.N    R2,??DataTable9_8
   \   0000000A   0x6011             STR      R1,[R2, #+0]
   1208                  if (p_grp_next != DEF_NULL) {
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD001             BEQ.N    ??OS_FlagDbgListRemove_1
   1209                      p_grp_next->DbgPrevPtr = DEF_NULL;
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x614A             STR      R2,[R1, #+20]
   1210                  }
   1211                  p_grp->DbgNextPtr = DEF_NULL;
   \                     ??OS_FlagDbgListRemove_1: (+1)
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x6181             STR      R1,[R0, #+24]
   \   00000018   0xE00C             B.N      ??OS_FlagDbgListRemove_2
   1212          
   1213              } else if (p_grp_next == DEF_NULL) {
   \                     ??OS_FlagDbgListRemove_0: (+1)
   \   0000001A   0x2900             CMP      R1,#+0
   \   0000001C   0xD104             BNE.N    ??OS_FlagDbgListRemove_3
   1214                  p_grp_prev->DbgNextPtr = DEF_NULL;
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x6191             STR      R1,[R2, #+24]
   1215                  p_grp->DbgPrevPtr      = DEF_NULL;
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0x6141             STR      R1,[R0, #+20]
   \   00000026   0xE005             B.N      ??OS_FlagDbgListRemove_2
   1216          
   1217              } else {
   1218                  p_grp_prev->DbgNextPtr =  p_grp_next;
   \                     ??OS_FlagDbgListRemove_3: (+1)
   \   00000028   0x6191             STR      R1,[R2, #+24]
   1219                  p_grp_next->DbgPrevPtr =  p_grp_prev;
   \   0000002A   0x614A             STR      R2,[R1, #+20]
   1220                  p_grp->DbgNextPtr      = DEF_NULL;
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x6181             STR      R1,[R0, #+24]
   1221                  p_grp->DbgPrevPtr      = DEF_NULL;
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0x6141             STR      R1,[R0, #+20]
   1222              }
   1223          }
   \                     ??OS_FlagDbgListRemove_2: (+1)
   \   00000034   0x4770             BX       LR               ;; return
   1224          #endif
   1225          
   1226          
   1227          /*
   1228          ************************************************************************************************************************
   1229          *                                        MAKE TASK READY-TO-RUN, EVENT(s) OCCURRED
   1230          *
   1231          * Description: This function is internal to uC/OS-III and is used to make a task ready-to-run because the desired event
   1232          *              flag bits have been set.
   1233          *
   1234          * Arguments  : p_tcb         is a pointer to the OS_TCB of the task to remove
   1235          *              -----
   1236          *
   1237          *              flags_rdy     contains the bit pattern of the event flags that cause the task to become ready-to-run.
   1238          *
   1239          *              ts            is a timestamp associated with the post
   1240          *
   1241          * Returns    : none
   1242          *
   1243          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   1244          ************************************************************************************************************************
   1245          */
   1246          

   \                                 In section .text, align 2, keep-with-next
   1247          void   OS_FlagTaskRdy (OS_TCB    *p_tcb,
   1248                                 OS_FLAGS   flags_rdy,
   1249                                 CPU_TS     ts)
   1250          {
   \                     OS_FlagTaskRdy: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1251          #if (OS_CFG_TS_EN == DEF_DISABLED)
   1252              (void)ts;                                                   /* Prevent compiler warning for not using 'ts'          */
   1253          #endif
   1254          
   1255              p_tcb->FlagsRdy   = flags_rdy;
   \   00000004   0xF8C4 0x1080      STR      R1,[R4, #+128]
   1256              p_tcb->PendStatus = OS_STATUS_PEND_OK;                      /* Clear pend status                                    */
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF884 0x003D      STRB     R0,[R4, #+61]
   1257              p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;                /* Indicate no longer pending                           */
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xF884 0x003C      STRB     R0,[R4, #+60]
   1258          #if (OS_CFG_TS_EN == DEF_ENABLED)
   1259              p_tcb->TS         = ts;
   \   00000014   0x6522             STR      R2,[R4, #+80]
   1260          #endif
   1261              switch (p_tcb->TaskState) {
   \   00000016   0xF894 0x003E      LDRB     R0,[R4, #+62]
   \   0000001A   0x1E80             SUBS     R0,R0,#+2
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD903             BLS.N    ??OS_FlagTaskRdy_0
   \   00000020   0x1F00             SUBS     R0,R0,#+4
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xD90E             BLS.N    ??OS_FlagTaskRdy_1
   \   00000026   0xE011             B.N      ??OS_FlagTaskRdy_2
   1262                  case OS_TASK_STATE_PEND:
   1263                  case OS_TASK_STATE_PEND_TIMEOUT:
   1264          #if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
   1265                       if (p_tcb->TaskState == OS_TASK_STATE_PEND_TIMEOUT) {
   \                     ??OS_FlagTaskRdy_0: (+1)
   \   00000028   0xF894 0x003E      LDRB     R0,[R4, #+62]
   \   0000002C   0x2803             CMP      R0,#+3
   \   0000002E   0xD102             BNE.N    ??OS_FlagTaskRdy_3
   1266                           OS_TickListRemove(p_tcb);                      /* Remove from tick list                                */
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       OS_TickListRemove
   1267                       }
   1268          #endif
   1269                       OS_RdyListInsert(p_tcb);                           /* Insert the task in the ready list                    */
   \                     ??OS_FlagTaskRdy_3: (+1)
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x.... 0x....      BL       OS_RdyListInsert
   1270                       p_tcb->TaskState = OS_TASK_STATE_RDY;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xF884 0x003E      STRB     R0,[R4, #+62]
   1271                       break;
   \   00000042   0xE003             B.N      ??OS_FlagTaskRdy_4
   1272          
   1273                  case OS_TASK_STATE_PEND_SUSPENDED:
   1274                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
   1275                       p_tcb->TaskState = OS_TASK_STATE_SUSPENDED;
   \                     ??OS_FlagTaskRdy_1: (+1)
   \   00000044   0x2004             MOVS     R0,#+4
   \   00000046   0xF884 0x003E      STRB     R0,[R4, #+62]
   1276                       break;
   \   0000004A   0xE7FF             B.N      ??OS_FlagTaskRdy_4
   1277          
   1278                  case OS_TASK_STATE_RDY:
   1279                  case OS_TASK_STATE_DLY:
   1280                  case OS_TASK_STATE_DLY_SUSPENDED:
   1281                  case OS_TASK_STATE_SUSPENDED:
   1282                  default:
   1283                       break;
   1284              }
   1285              OS_PendListRemove(p_tcb);
   \                     ??OS_FlagTaskRdy_2: (+1)
   \                     ??OS_FlagTaskRdy_4: (+1)
   \   0000004C   0x0020             MOVS     R0,R4
   \   0000004E   0x.... 0x....      BL       OS_PendListRemove
   1286          }
   \   00000052   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x20 0x00          DC8      " ",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x........         DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x47414C46         DC32     0x47414c46

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x........         DC32     OSFlagQty

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x........         DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x........         DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x454E4F4E         DC32     0x454e4f4e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   0x........         DC32     OSFlagDbgListPtr

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x3F 0x46          DC8 "?FLAG"
   \              0x4C 0x41    
   \              0x47 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 2
   \   00000000   0x20 0x00          DC8 " "
   1287          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   OSFlagCreate
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OS_FlagDbgListAdd
        24   -> OS_PendListInit
      32   OSFlagDel
        32   -> CPU_IntDisMeasStart
        32   -> CPU_IntDisMeasStop
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> CPU_TS_TmrRd
        32   -> OSSched
        32   -> OS_FlagClr
        32   -> OS_FlagDbgListRemove
        32   -> OS_PendAbort
      48   OSFlagPend
        48   -> CPU_IntDisMeasStart
        48   -> CPU_IntDisMeasStop
        48   -> CPU_SR_Restore
        48   -> CPU_SR_Save
        48   -> OSSched
        48   -> OS_FlagBlock
      32   OSFlagPendAbort
        32   -> CPU_IntDisMeasStart
        32   -> CPU_IntDisMeasStop
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> CPU_TS_TmrRd
        32   -> OSSched
        32   -> OS_PendAbort
      16   OSFlagPendGetFlagsRdy
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
      32   OSFlagPost
        32   -> CPU_IntDisMeasStart
        32   -> CPU_IntDisMeasStop
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> CPU_TS_TmrRd
        32   -> OSSched
        32   -> OS_FlagTaskRdy
       8   OS_FlagBlock
         8   -> OS_Pend
       8   OS_FlagClr
         8   -> OS_PendListInit
       0   OS_FlagDbgListAdd
       0   OS_FlagDbgListRemove
       8   OS_FlagTaskRdy
         8   -> OS_PendListRemove
         8   -> OS_RdyListInsert
         8   -> OS_TickListRemove


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       8  ?_0
       2  ?_1
     116  OSFlagCreate
     266  OSFlagDel
    1140  OSFlagPend
     210  OSFlagPendAbort
      60  OSFlagPendGetFlagsRdy
     350  OSFlagPost
      36  OS_FlagBlock
      22  OS_FlagClr
      40  OS_FlagDbgListAdd
      54  OS_FlagDbgListRemove
      84  OS_FlagTaskRdy

 
    10 bytes in section .rodata
 2 414 bytes in section .text
 
 2 414 bytes of CODE  memory
    10 bytes of CONST memory

Errors: none
Warnings: none
