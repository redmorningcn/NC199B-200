###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       11/Jul/2018  11:13:08
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC210\NC210-200处理板\source\Software\uC-LIB\lib_mem.c
#    Command line =  
#        F:\iar\NC210\NC210-200处理板\source\Software\uC-LIB\lib_mem.c -D
#        USE_STDPERIPH_DRIVER -D APP_RELEASE -lCN
#        F:\iar\NC210\NC210-200处理板\project\app_release\List -o
#        F:\iar\NC210\NC210-200处理板\project\app_release\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC210\NC210-200处理板\project\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\config\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\task\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\user\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\OS\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\Ports\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\driver\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-LIB\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Source\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\ST\STM32\inc\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Ports\STM32\STM32F103\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Source\
#        -Ol --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC210\NC210-200处理板\project\app_release\List\lib_mem.lst
#    Object file  =  
#        F:\iar\NC210\NC210-200处理板\project\app_release\Obj\lib_mem.o
#
###############################################################################

F:\iar\NC210\NC210-200处理板\source\Software\uC-LIB\lib_mem.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/LIB
      4          *                                        CUSTOM LIBRARY MODULES
      5          *
      6          *                         (c) Copyright 2004-2015; Micrium, Inc.; Weston, FL
      7          *
      8          *                  All rights reserved.  Protected by international copyright laws.
      9          *
     10          *                  uC/LIB is provided in source form to registered licensees ONLY.  It is
     11          *                  illegal to distribute this source code to any third party unless you receive
     12          *                  written permission by an authorized Micrium representative.  Knowledge of
     13          *                  the source code may NOT be used to develop a similar product.
     14          *
     15          *                  Please help us continue to provide the Embedded community with the finest
     16          *                  software available.  Your honesty is greatly appreciated.
     17          *
     18          *                  You can find our product's user manual, API reference, release notes and
     19          *                  more information at: https://doc.micrium.com
     20          *
     21          *                  You can contact us at: http://www.micrium.com
     22          *********************************************************************************************************
     23          */
     24          
     25          /*
     26          *********************************************************************************************************
     27          *
     28          *                                     STANDARD MEMORY OPERATIONS
     29          *
     30          * Filename      : lib_mem.c
     31          * Version       : V1.38.02
     32          * Programmer(s) : ITJ
     33          *                 FGK
     34          *                 JFD
     35          *                 FBJ
     36          *                 EJ
     37          *********************************************************************************************************
     38          * Note(s)       : (1) NO compiler-supplied standard library functions are used in library or product software.
     39          *
     40          *                     (a) ALL standard library functions are implemented in the custom library modules :
     41          *
     42          *                         (1) \<Custom Library Directory>\lib_*.*
     43          *
     44          *                         (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
     45          *
     46          *                               where
     47          *                                       <Custom Library Directory>      directory path for custom library software
     48          *                                       <cpu>                           directory name for specific processor (CPU)
     49          *                                       <compiler>                      directory name for specific compiler
     50          *
     51          *                     (b) Product-specific library functions are implemented in individual products.
     52          *********************************************************************************************************
     53          */
     54          
     55          
     56          /*
     57          *********************************************************************************************************
     58          *                                            INCLUDE FILES
     59          *********************************************************************************************************
     60          */
     61          
     62          #define    MICRIUM_SOURCE
     63          #define    LIB_MEM_MODULE
     64          #include  "lib_mem.h"
     65          #include  "lib_math.h"
     66          #include  "lib_str.h"
     67          
     68          
     69          /*
     70          *********************************************************************************************************
     71          *                                            LOCAL DEFINES
     72          *********************************************************************************************************
     73          */
     74          
     75          
     76          /*
     77          *********************************************************************************************************
     78          *                                           LOCAL CONSTANTS
     79          *********************************************************************************************************
     80          */
     81          
     82          
     83          /*
     84          *********************************************************************************************************
     85          *                                          LOCAL DATA TYPES
     86          *********************************************************************************************************
     87          */
     88          
     89          
     90          /*
     91          *********************************************************************************************************
     92          *                                            LOCAL TABLES
     93          *********************************************************************************************************
     94          */
     95          
     96          
     97          /*
     98          *********************************************************************************************************
     99          *                                       LOCAL GLOBAL VARIABLES
    100          *********************************************************************************************************
    101          */
    102          
    103          
    104          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
    105          #ifndef  LIB_MEM_CFG_HEAP_BASE_ADDR

   \                                 In section .bss, align 4
    106          CPU_INT08U   Mem_Heap[LIB_MEM_CFG_HEAP_SIZE];                   /* Mem heap.                                            */
   \                     Mem_Heap:
   \   00000000                      DS8 27648
    107          #endif
    108          

   \                                 In section .bss, align 4
    109          MEM_SEG      Mem_SegHeap;                                       /* Heap mem seg.                                        */
   \                     Mem_SegHeap:
   \   00000000                      DS8 20
    110          #endif
    111          

   \                                 In section .bss, align 4
    112          MEM_SEG     *Mem_SegHeadPtr;                                    /* Ptr to head of seg list.                             */
   \                     Mem_SegHeadPtr:
   \   00000000                      DS8 4
    113          
    114          
    115          /*
    116          *********************************************************************************************************
    117          *                                      LOCAL FUNCTION PROTOTYPES
    118          *********************************************************************************************************
    119          */
    120          
    121          static  void          Mem_SegCreateCritical    (const  CPU_CHAR      *p_name,
    122                                                                 MEM_SEG       *p_seg,
    123                                                                 CPU_ADDR       seg_base_addr,
    124                                                                 CPU_SIZE_T     padding_align,
    125                                                                 CPU_SIZE_T     size);
    126          
    127          #if  (LIB_MEM_CFG_HEAP_SIZE > 0u)
    128          static  MEM_SEG      *Mem_SegOverlapChkCritical(       CPU_ADDR       seg_base_addr,
    129                                                                 CPU_SIZE_T     size,
    130                                                                 LIB_ERR       *p_err);
    131          #endif
    132          
    133          static  void         *Mem_SegAllocInternal     (const  CPU_CHAR      *p_name,
    134                                                                 MEM_SEG       *p_seg,
    135                                                                 CPU_SIZE_T     size,
    136                                                                 CPU_SIZE_T     align,
    137                                                                 CPU_SIZE_T     padding_align,
    138                                                                 CPU_SIZE_T    *p_bytes_reqd,
    139                                                                 LIB_ERR       *p_err);
    140          
    141          static  void         *Mem_SegAllocExtCritical  (       MEM_SEG       *p_seg,
    142                                                                 CPU_SIZE_T     size,
    143                                                                 CPU_SIZE_T     align,
    144                                                                 CPU_SIZE_T     padding_align,
    145                                                                 CPU_SIZE_T    *p_bytes_reqd,
    146                                                                 LIB_ERR       *p_err);
    147          
    148          static  void          Mem_DynPoolCreateInternal(const  CPU_CHAR      *p_name,
    149                                                                 MEM_DYN_POOL  *p_pool,
    150                                                                 MEM_SEG       *p_seg,
    151                                                                 CPU_SIZE_T     blk_size,
    152                                                                 CPU_SIZE_T     blk_align,
    153                                                                 CPU_SIZE_T     blk_padding_align,
    154                                                                 CPU_SIZE_T     blk_qty_init,
    155                                                                 CPU_SIZE_T     blk_qty_max,
    156                                                                 LIB_ERR       *p_err);
    157          
    158          #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
    159          static  void          Mem_SegAllocTrackCritical(const  CPU_CHAR      *p_name,
    160                                                                 MEM_SEG       *p_seg,
    161                                                                 CPU_SIZE_T     size,
    162                                                                 LIB_ERR       *p_err);
    163          #endif
    164          
    165          #if ((LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED) && \
    166               (LIB_MEM_CFG_HEAP_SIZE      >  0u))
    167          static  CPU_BOOLEAN   Mem_PoolBlkIsValidAddr   (       MEM_POOL      *p_pool,
    168                                                                 void          *p_mem);
    169          #endif
    170          
    171          
    172          /*
    173          *********************************************************************************************************
    174          *                                     LOCAL CONFIGURATION ERRORS
    175          *********************************************************************************************************
    176          */
    177          
    178          /*
    179          *********************************************************************************************************
    180          *********************************************************************************************************
    181          *                                            GLOBAL FUNCTIONS
    182          *********************************************************************************************************
    183          *********************************************************************************************************
    184          */
    185          
    186          /*
    187          *********************************************************************************************************
    188          *                                             Mem_Init()
    189          *
    190          * Description : (1) Initializes Memory Management Module :
    191          *
    192          *                   (a) Initialize heap memory pool
    193          *                   (b) Initialize      memory pool table
    194          *
    195          *
    196          * Argument(s) : none.
    197          *
    198          * Return(s)   : none.
    199          *
    200          * Caller(s)   : Application.
    201          *
    202          * Note(s)     : (2) Mem_Init() MUST be called ... :
    203          *
    204          *                   (a) ONLY ONCE from a product's application; ...
    205          *                   (b) BEFORE product's application calls any memory library module function(s)
    206          *********************************************************************************************************
    207          */
    208          

   \                                 In section .text, align 2, keep-with-next
    209          void  Mem_Init (void)
    210          {
   \                     Mem_Init: (+1)
   \   00000000   0xB5E0             PUSH     {R5-R7,LR}
    211          
    212                                                                          /* ------------------ INIT SEG LIST ------------------- */
    213              Mem_SegHeadPtr = DEF_NULL;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable12
   \   00000008   0x6008             STR      R0,[R1, #+0]
    214          
    215          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
    216              {
    217                  LIB_ERR   err;
    218                  CPU_ADDR  heap_base_addr;
    219          
    220          
    221                                                                          /* ------------------ INIT HEAP SEG ------------------- */
    222          #ifdef  LIB_MEM_CFG_HEAP_BASE_ADDR
    223                  heap_base_addr = LIB_MEM_CFG_HEAP_BASE_ADDR;
    224          #else
    225                  heap_base_addr = (CPU_ADDR)&Mem_Heap[0u];
   \   0000000A   0x.... 0x....      LDR.W    R2,??DataTable12_1
    226          #endif
    227          
    228                  Mem_SegCreate("Heap",
    229                                &Mem_SegHeap,                             /* Create heap seg.                                     */
    230                                 heap_base_addr,
    231                                 LIB_MEM_CFG_HEAP_SIZE,
    232                                 LIB_MEM_PADDING_ALIGN_NONE,
    233                                &err);
   \   0000000E   0xA802             ADD      R0,SP,#+8
   \   00000010   0x9001             STR      R0,[SP, #+4]
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x9000             STR      R0,[SP, #+0]
   \   00000016   0xF44F 0x43D8      MOV      R3,#+27648
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable12_3
   \   00000022   0x.... 0x....      BL       Mem_SegCreate
    234                  if (err != LIB_MEM_ERR_NONE) {
   \   00000026   0xF9BD 0x0008      LDRSH    R0,[SP, #+8]
   \   0000002A   0xF242 0x7110      MOVW     R1,#+10000
   \   0000002E   0x4288             CMP      R0,R1
   \   00000030   0xD001             BEQ.N    ??Mem_Init_0
    235                      CPU_SW_EXCEPTION(;);
   \   00000032   0x.... 0x....      BL       CPU_SW_Exception
    236                  }
    237              }
    238          #endif
    239          }
   \                     ??Mem_Init_0: (+1)
   \   00000036   0xBD07             POP      {R0-R2,PC}       ;; return
    240          
    241          
    242          /*
    243          *********************************************************************************************************
    244          *                                              Mem_Clr()
    245          *
    246          * Description : Clears data buffer (see Note #2).
    247          *
    248          * Argument(s) : pmem        Pointer to memory buffer to clear.
    249          *
    250          *               size        Number of data buffer octets to clear (see Note #1).
    251          *
    252          * Return(s)   : none.
    253          *
    254          * Caller(s)   : Application.
    255          *
    256          * Note(s)     : (1) Null clears allowed (i.e. zero-length clears).
    257          *
    258          *                   See also 'Mem_Set()  Note #1'.
    259          *
    260          *               (2) Clear data by setting each data octet to 0.
    261          *********************************************************************************************************
    262          */
    263          

   \                                 In section .text, align 2, keep-with-next
    264          void  Mem_Clr (void        *pmem,
    265                         CPU_SIZE_T   size)
    266          {
   \                     Mem_Clr: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    267              Mem_Set(pmem,
    268                      0u,                                                 /* See Note #2.                                         */
    269                      size);
   \   00000002   0x000A             MOVS     R2,R1
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x.... 0x....      BL       Mem_Set
    270          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    271          
    272          
    273          /*
    274          *********************************************************************************************************
    275          *                                              Mem_Set()
    276          *
    277          * Description : Fills data buffer with specified data octet.
    278          *
    279          * Argument(s) : pmem        Pointer to memory buffer to fill with specified data octet.
    280          *
    281          *               data_val    Data fill octet value.
    282          *
    283          *               size        Number of data buffer octets to fill (see Note #1).
    284          *
    285          * Return(s)   : none.
    286          *
    287          * Caller(s)   : Application.
    288          *
    289          * Note(s)     : (1) Null sets allowed (i.e. zero-length sets).
    290          *
    291          *               (2) For best CPU performance, optimized to fill data buffer using 'CPU_ALIGN'-sized data
    292          *                   words. Since many word-aligned processors REQUIRE that multi-octet words be accessed on
    293          *                   word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on 'CPU_ALIGN'd
    294          *                   addresses.
    295          *
    296          *               (3) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
    297          *                   address boundary.
    298          *
    299          *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus
    300          *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
    301          *                  'mem_align_mod' arithmetic operation.
    302          *********************************************************************************************************
    303          */
    304          

   \                                 In section .text, align 2, keep-with-next
    305          void  Mem_Set (void        *pmem,
    306                         CPU_INT08U   data_val,
    307                         CPU_SIZE_T   size)
    308          {
   \                     Mem_Set: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    309              CPU_SIZE_T   size_rem;
    310              CPU_ALIGN    data_align;
    311              CPU_ALIGN   *pmem_align;
    312              CPU_INT08U  *pmem_08;
    313              CPU_DATA     mem_align_mod;
    314              CPU_DATA     i;
    315          
    316          
    317          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    318              if (size < 1) {                                             /* See Note #1.                                         */
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD027             BEQ.N    ??Mem_Set_0
    319                  return;
    320              }
    321              if (pmem == (void *)0) {
   \                     ??Mem_Set_1: (+1)
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD025             BEQ.N    ??Mem_Set_0
    322                  return;
    323              }
    324          #endif
    325          
    326          
    327              data_align = 0u;
   \                     ??Mem_Set_2: (+1)
   \   0000000A   0x2300             MOVS     R3,#+0
    328              for (i = 0u; i < sizeof(CPU_ALIGN); i++) {                  /* Fill each data_align octet with data val.            */
   \   0000000C   0x2400             MOVS     R4,#+0
   \   0000000E   0xE003             B.N      ??Mem_Set_3
    329                  data_align <<=  DEF_OCTET_NBR_BITS;
   \                     ??Mem_Set_4: (+1)
   \   00000010   0x021B             LSLS     R3,R3,#+8
    330                  data_align  |= (CPU_ALIGN)data_val;
   \   00000012   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000014   0x430B             ORRS     R3,R1,R3
    331              }
   \   00000016   0x1C64             ADDS     R4,R4,#+1
   \                     ??Mem_Set_3: (+1)
   \   00000018   0x2C04             CMP      R4,#+4
   \   0000001A   0xD3F9             BCC.N    ??Mem_Set_4
    332          
    333              size_rem      =  size;
    334              mem_align_mod = (CPU_INT08U)((CPU_ADDR)pmem % sizeof(CPU_ALIGN));   /* See Note #3.                                 */
   \   0000001C   0x2504             MOVS     R5,#+4
   \   0000001E   0xFBB0 0xF4F5      UDIV     R4,R0,R5
   \   00000022   0xFB04 0x0415      MLS      R4,R4,R5,R0
   \   00000026   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
    335          
    336              pmem_08 = (CPU_INT08U *)pmem;
    337              if (mem_align_mod != 0u) {                                  /* If leading octets avail,                   ...       */
   \   00000028   0x2C00             CMP      R4,#+0
   \   0000002A   0xD008             BEQ.N    ??Mem_Set_5
    338                  i = mem_align_mod;
   \   0000002C   0xE003             B.N      ??Mem_Set_6
    339                  while ((size_rem > 0) &&                                /* ... start mem buf fill with leading octets ...       */
    340                         (i        < sizeof(CPU_ALIGN ))) {               /* ... until next CPU_ALIGN word boundary.              */
    341                     *pmem_08++ = data_val;
   \                     ??Mem_Set_7: (+1)
   \   0000002E   0x7001             STRB     R1,[R0, #+0]
   \   00000030   0x1C40             ADDS     R0,R0,#+1
    342                      size_rem -= sizeof(CPU_INT08U);
   \   00000032   0x1E52             SUBS     R2,R2,#+1
    343                      i++;
   \   00000034   0x1C64             ADDS     R4,R4,#+1
    344                  }
   \                     ??Mem_Set_6: (+1)
   \   00000036   0x2A00             CMP      R2,#+0
   \   00000038   0xD001             BEQ.N    ??Mem_Set_5
   \   0000003A   0x2C04             CMP      R4,#+4
   \   0000003C   0xD3F7             BCC.N    ??Mem_Set_7
    345              }
    346          
    347              pmem_align = (CPU_ALIGN *)pmem_08;                          /* See Note #2.                                         */
   \                     ??Mem_Set_5: (+1)
   \   0000003E   0xE002             B.N      ??Mem_Set_8
    348              while (size_rem >= sizeof(CPU_ALIGN)) {                     /* While mem buf aligned on CPU_ALIGN word boundaries,  */
    349                 *pmem_align++ = data_align;                              /* ... fill mem buf with    CPU_ALIGN-sized data.       */
   \                     ??Mem_Set_9: (+1)
   \   00000040   0x6003             STR      R3,[R0, #+0]
   \   00000042   0x1D00             ADDS     R0,R0,#+4
    350                  size_rem    -= sizeof(CPU_ALIGN);
   \   00000044   0x1F12             SUBS     R2,R2,#+4
    351              }
   \                     ??Mem_Set_8: (+1)
   \   00000046   0x2A04             CMP      R2,#+4
   \   00000048   0xD2FA             BCS.N    ??Mem_Set_9
    352          
    353              pmem_08 = (CPU_INT08U *)pmem_align;
   \   0000004A   0xE002             B.N      ??Mem_Set_10
    354              while (size_rem > 0) {                                      /* Finish mem buf fill with trailing octets.            */
    355                 *pmem_08++   = data_val;
   \                     ??Mem_Set_11: (+1)
   \   0000004C   0x7001             STRB     R1,[R0, #+0]
   \   0000004E   0x1C40             ADDS     R0,R0,#+1
    356                  size_rem   -= sizeof(CPU_INT08U);
   \   00000050   0x1E52             SUBS     R2,R2,#+1
    357              }
   \                     ??Mem_Set_10: (+1)
   \   00000052   0x2A00             CMP      R2,#+0
   \   00000054   0xD1FA             BNE.N    ??Mem_Set_11
    358          }
   \                     ??Mem_Set_0: (+1)
   \   00000056   0xBC30             POP      {R4,R5}
   \   00000058   0x4770             BX       LR               ;; return
    359          
    360          
    361          /*
    362          *********************************************************************************************************
    363          *                                             Mem_Copy()
    364          *
    365          * Description : Copies data octets from one memory buffer to another memory buffer.
    366          *
    367          * Argument(s) : pdest       Pointer to destination memory buffer.
    368          *
    369          *               psrc        Pointer to source      memory buffer.
    370          *
    371          *               size        Number of octets to copy (see Note #1).
    372          *
    373          * Return(s)   : none.
    374          *
    375          * Caller(s)   : Application.
    376          *
    377          * Note(s)     : (1) Null copies allowed (i.e. zero-length copies).
    378          *
    379          *               (2) Memory buffers NOT checked for overlapping.
    380          *
    381          *                   (a) IEEE Std 1003.1, 2004 Edition, Section 'memcpy() : DESCRIPTION' states that "if
    382          *                       copying takes place between objects that overlap, the behavior is undefined".
    383          *
    384          *                   (b) However, data octets from a source memory buffer at a higher address value SHOULD
    385          *                       successfully copy to a destination memory buffer at a lower  address value even
    386          *                       if any octets of the memory buffers overlap as long as no individual, atomic CPU
    387          *                       word copy overlaps.
    388          *
    389          *                       Since Mem_Copy() performs the data octet copy via 'CPU_ALIGN'-sized words &/or
    390          *                       octets; & since 'CPU_ALIGN'-sized words MUST be accessed on word-aligned addresses
    391          *                       (see Note #3b), neither 'CPU_ALIGN'-sized words nor octets at unique addresses can
    392          *                       ever overlap.
    393          *
    394          *                       Therefore, Mem_Copy() SHOULD be able to successfully copy overlapping memory
    395          *                       buffers as long as the source memory buffer is at a higher address value than the
    396          *                       destination memory buffer.
    397          *
    398          *               (3) For best CPU performance, optimized to copy data buffer using 'CPU_ALIGN'-sized data
    399          *                   words. Since many word-aligned processors REQUIRE that multi-octet words be accessed on
    400          *                   word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on 'CPU_ALIGN'd
    401          *                   addresses.
    402          *
    403          *               (4) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
    404          *                   address boundary.
    405          *
    406          *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus
    407          *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
    408          *                  'mem_align_mod' arithmetic operation.
    409          *********************************************************************************************************
    410          */
    411          
    412          #if (LIB_MEM_CFG_OPTIMIZE_ASM_EN != DEF_ENABLED)
    413          void  Mem_Copy (       void        *pdest,
    414                          const  void        *psrc,
    415                                 CPU_SIZE_T   size)
    416          {
    417                     CPU_SIZE_T    size_rem;
    418                     CPU_SIZE_T    mem_gap_octets;
    419                     CPU_ALIGN    *pmem_align_dest;
    420              const  CPU_ALIGN    *pmem_align_src;
    421                     CPU_INT08U   *pmem_08_dest;
    422              const  CPU_INT08U   *pmem_08_src;
    423                     CPU_DATA      i;
    424                     CPU_DATA      mem_align_mod_dest;
    425                     CPU_DATA      mem_align_mod_src;
    426                     CPU_BOOLEAN   mem_aligned;
    427          
    428          
    429          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    430              if (size < 1) {                                             /* See Note #1.                                         */
    431                  return;
    432              }
    433              if (pdest == (void *)0) {
    434                  return;
    435              }
    436              if (psrc  == (void *)0) {
    437                  return;
    438              }
    439          #endif
    440          
    441          
    442              size_rem           =  size;
    443          
    444              pmem_08_dest       = (      CPU_INT08U *)pdest;
    445              pmem_08_src        = (const CPU_INT08U *)psrc;
    446          
    447              mem_gap_octets     = (CPU_SIZE_T)(pmem_08_src - pmem_08_dest);
    448          
    449          
    450              if (mem_gap_octets >= sizeof(CPU_ALIGN)) {                  /* Avoid bufs overlap.                                  */
    451                                                                          /* See Note #4.                                         */
    452                  mem_align_mod_dest = (CPU_INT08U)((CPU_ADDR)pmem_08_dest % sizeof(CPU_ALIGN));
    453                  mem_align_mod_src  = (CPU_INT08U)((CPU_ADDR)pmem_08_src  % sizeof(CPU_ALIGN));
    454          
    455                  mem_aligned        = (mem_align_mod_dest == mem_align_mod_src) ? DEF_YES : DEF_NO;
    456          
    457                  if (mem_aligned == DEF_YES) {                           /* If mem bufs' alignment offset equal, ...             */
    458                                                                          /* ... optimize copy for mem buf alignment.             */
    459                      if (mem_align_mod_dest != 0u) {                     /* If leading octets avail,                   ...       */
    460                          i = mem_align_mod_dest;
    461                          while ((size_rem   >  0) &&                     /* ... start mem buf copy with leading octets ...       */
    462                                 (i          <  sizeof(CPU_ALIGN ))) {    /* ... until next CPU_ALIGN word boundary.              */
    463                             *pmem_08_dest++ = *pmem_08_src++;
    464                              size_rem      -=  sizeof(CPU_INT08U);
    465                              i++;
    466                          }
    467                      }
    468          
    469                      pmem_align_dest = (      CPU_ALIGN *)pmem_08_dest;  /* See Note #3.                                         */
    470                      pmem_align_src  = (const CPU_ALIGN *)pmem_08_src;
    471                      while (size_rem      >=  sizeof(CPU_ALIGN)) {       /* While mem bufs aligned on CPU_ALIGN word boundaries, */
    472                         *pmem_align_dest++ = *pmem_align_src++;          /* ... copy psrc to pdest with CPU_ALIGN-sized words.   */
    473                          size_rem         -=  sizeof(CPU_ALIGN);
    474                      }
    475          
    476                      pmem_08_dest = (      CPU_INT08U *)pmem_align_dest;
    477                      pmem_08_src  = (const CPU_INT08U *)pmem_align_src;
    478                  }
    479              }
    480          
    481              while (size_rem > 0) {                                      /* For unaligned mem bufs or trailing octets, ...       */
    482                 *pmem_08_dest++ = *pmem_08_src++;                        /* ... copy psrc to pdest by octets.                    */
    483                  size_rem      -=  sizeof(CPU_INT08U);
    484              }
    485          }
    486          #endif
    487          
    488          
    489          /*
    490          *********************************************************************************************************
    491          *                                             Mem_Move()
    492          *
    493          * Description : Moves data octets from one memory buffer to another memory buffer, or within the same
    494          *               memory buffer. Overlapping is correctly handled for all move operations.
    495          *
    496          * Argument(s) : pdest       Pointer to destination memory buffer.
    497          *
    498          *               psrc        Pointer to source      memory buffer.
    499          *
    500          *               size        Number of octets to move (see Note #1).
    501          *
    502          * Return(s)   : none.
    503          *
    504          * Caller(s)   : Application.
    505          *
    506          * Note(s)     : (1) Null move operations allowed (i.e. zero-length).
    507          *
    508          *               (2) Memory buffers checked for overlapping.
    509          *
    510          *               (3) For best CPU performance, optimized to copy data buffer using 'CPU_ALIGN'-sized data
    511          *                   words. Since many word-aligned processors REQUIRE that multi-octet words be accessed on
    512          *                   word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on 'CPU_ALIGN'd
    513          *                   addresses.
    514          *
    515          *               (4) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
    516          *                   address boundary.
    517          *
    518          *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus
    519          *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
    520          *                  'mem_align_mod' arithmetic operation.
    521          *********************************************************************************************************
    522          */
    523          

   \                                 In section .text, align 2, keep-with-next
    524          void  Mem_Move (       void        *pdest,
    525                          const  void        *psrc,
    526                                 CPU_SIZE_T   size)
    527          {
   \                     Mem_Move: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    528                     CPU_SIZE_T    size_rem;
    529                     CPU_SIZE_T    mem_gap_octets;
    530                     CPU_ALIGN    *pmem_align_dest;
    531              const  CPU_ALIGN    *pmem_align_src;
    532                     CPU_INT08U   *pmem_08_dest;
    533              const  CPU_INT08U   *pmem_08_src;
    534                     CPU_INT08S    i;
    535                     CPU_DATA      mem_align_mod_dest;
    536                     CPU_DATA      mem_align_mod_src;
    537                     CPU_BOOLEAN   mem_aligned;
    538          
    539          
    540          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    541              if (size < 1) {
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD045             BEQ.N    ??Mem_Move_0
    542                  return;
    543              }
    544              if (pdest == (void *)0) {
   \                     ??Mem_Move_1: (+1)
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD043             BEQ.N    ??Mem_Move_0
    545                  return;
    546              }
    547              if (psrc  == (void *)0) {
   \                     ??Mem_Move_2: (+1)
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD041             BEQ.N    ??Mem_Move_0
    548                  return;
    549              }
    550          #endif
    551          
    552              pmem_08_src  = (const CPU_INT08U *)psrc;
    553              pmem_08_dest = (      CPU_INT08U *)pdest;
    554              if (pmem_08_src > pmem_08_dest) {
   \                     ??Mem_Move_3: (+1)
   \   0000000E   0x4288             CMP      R0,R1
   \   00000010   0xD202             BCS.N    ??Mem_Move_4
    555                  Mem_Copy(pdest, psrc, size);
   \   00000012   0x.... 0x....      BL       Mem_Copy
    556                  return;
   \   00000016   0xE03C             B.N      ??Mem_Move_0
    557              }
    558          
    559              size_rem           =  size;
    560          
    561              pmem_08_dest       = (      CPU_INT08U *)pdest + size - 1;
   \                     ??Mem_Move_4: (+1)
   \   00000018   0x1810             ADDS     R0,R2,R0
   \   0000001A   0x1E40             SUBS     R0,R0,#+1
    562              pmem_08_src        = (const CPU_INT08U *)psrc  + size - 1;
   \   0000001C   0x1851             ADDS     R1,R2,R1
   \   0000001E   0x1E49             SUBS     R1,R1,#+1
    563          
    564              mem_gap_octets     = (CPU_SIZE_T)(pmem_08_dest - pmem_08_src);
   \   00000020   0x1A43             SUBS     R3,R0,R1
    565          
    566          
    567              if (mem_gap_octets >= sizeof(CPU_ALIGN)) {                  /* Avoid bufs overlap.                                  */
   \   00000022   0x2B04             CMP      R3,#+4
   \   00000024   0xD333             BCC.N    ??Mem_Move_5
    568          
    569                                                                          /* See Note #4.                                         */
    570                  mem_align_mod_dest = (CPU_INT08U)((CPU_ADDR)pmem_08_dest % sizeof(CPU_ALIGN));
   \   00000026   0x2404             MOVS     R4,#+4
   \   00000028   0xFBB0 0xF3F4      UDIV     R3,R0,R4
   \   0000002C   0xFB03 0x0314      MLS      R3,R3,R4,R0
   \   00000030   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
    571                  mem_align_mod_src  = (CPU_INT08U)((CPU_ADDR)pmem_08_src  % sizeof(CPU_ALIGN));
   \   00000032   0x2504             MOVS     R5,#+4
   \   00000034   0xFBB1 0xF4F5      UDIV     R4,R1,R5
   \   00000038   0xFB04 0x1415      MLS      R4,R4,R5,R1
   \   0000003C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
    572          
    573                  mem_aligned        = (mem_align_mod_dest == mem_align_mod_src) ? DEF_YES : DEF_NO;
   \   0000003E   0x42A3             CMP      R3,R4
   \   00000040   0xD101             BNE.N    ??Mem_Move_6
   \   00000042   0x2401             MOVS     R4,#+1
   \   00000044   0xE000             B.N      ??Mem_Move_7
   \                     ??Mem_Move_6: (+1)
   \   00000046   0x2400             MOVS     R4,#+0
    574          
    575                  if (mem_aligned == DEF_YES) {                           /* If mem bufs' alignment offset equal, ...             */
   \                     ??Mem_Move_7: (+1)
   \   00000048   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004A   0x2C01             CMP      R4,#+1
   \   0000004C   0xD11F             BNE.N    ??Mem_Move_5
    576                                                                          /* ... optimize copy for mem buf alignment.             */
    577                      if (mem_align_mod_dest != (sizeof(CPU_ALIGN) - 1)) {/* If leading octets avail,                   ...       */
   \   0000004E   0x2B03             CMP      R3,#+3
   \   00000050   0xD00B             BEQ.N    ??Mem_Move_8
    578                          i = (CPU_INT08S)mem_align_mod_dest;
   \   00000052   0xE005             B.N      ??Mem_Move_9
    579                          while ((size_rem   >  0) &&                     /* ... start mem buf copy with leading octets ...       */
    580                                 (i          >= 0)) {                     /* ... until next CPU_ALIGN word boundary.              */
    581                             *pmem_08_dest-- = *pmem_08_src--;
   \                     ??Mem_Move_10: (+1)
   \   00000054   0x780C             LDRB     R4,[R1, #+0]
   \   00000056   0x7004             STRB     R4,[R0, #+0]
   \   00000058   0x1E49             SUBS     R1,R1,#+1
   \   0000005A   0x1E40             SUBS     R0,R0,#+1
    582                              size_rem      -=  sizeof(CPU_INT08U);
   \   0000005C   0x1E52             SUBS     R2,R2,#+1
    583                              i--;
   \   0000005E   0x1E5B             SUBS     R3,R3,#+1
    584                          }
   \                     ??Mem_Move_9: (+1)
   \   00000060   0x2A00             CMP      R2,#+0
   \   00000062   0xD002             BEQ.N    ??Mem_Move_8
   \   00000064   0xB25B             SXTB     R3,R3            ;; SignExt  R3,R3,#+24,#+24
   \   00000066   0x2B00             CMP      R3,#+0
   \   00000068   0xD5F4             BPL.N    ??Mem_Move_10
    585                      }
    586          
    587                                                                          /* See Note #3.                                         */
    588                      pmem_align_dest = (      CPU_ALIGN *)(((CPU_INT08U *)pmem_08_dest - sizeof(CPU_ALIGN)) + 1);
   \                     ??Mem_Move_8: (+1)
   \   0000006A   0x1EC0             SUBS     R0,R0,#+3
    589                      pmem_align_src  = (const CPU_ALIGN *)(((CPU_INT08U *)pmem_08_src  - sizeof(CPU_ALIGN)) + 1);
   \   0000006C   0x1EC9             SUBS     R1,R1,#+3
   \   0000006E   0xE004             B.N      ??Mem_Move_11
    590                      while (size_rem      >=  sizeof(CPU_ALIGN)) {       /* While mem bufs aligned on CPU_ALIGN word boundaries, */
    591                         *pmem_align_dest-- = *pmem_align_src--;          /* ... copy psrc to pdest with CPU_ALIGN-sized words.   */
   \                     ??Mem_Move_12: (+1)
   \   00000070   0x680B             LDR      R3,[R1, #+0]
   \   00000072   0x6003             STR      R3,[R0, #+0]
   \   00000074   0x1F09             SUBS     R1,R1,#+4
   \   00000076   0x1F00             SUBS     R0,R0,#+4
    592                          size_rem         -=  sizeof(CPU_ALIGN);
   \   00000078   0x1F12             SUBS     R2,R2,#+4
    593                      }
   \                     ??Mem_Move_11: (+1)
   \   0000007A   0x2A04             CMP      R2,#+4
   \   0000007C   0xD2F8             BCS.N    ??Mem_Move_12
    594          
    595                      pmem_08_dest = (      CPU_INT08U *)pmem_align_dest + sizeof(CPU_ALIGN) - 1;
   \   0000007E   0x1CC0             ADDS     R0,R0,#+3
    596                      pmem_08_src  = (const CPU_INT08U *)pmem_align_src  + sizeof(CPU_ALIGN) - 1;
   \   00000080   0x1CC9             ADDS     R1,R1,#+3
   \   00000082   0xE004             B.N      ??Mem_Move_5
    597          
    598                  }
    599              }
    600          
    601              while (size_rem > 0) {                                      /* For unaligned mem bufs or trailing octets, ...       */
    602                 *pmem_08_dest-- = *pmem_08_src--;                        /* ... copy psrc to pdest by octets.                    */
   \                     ??Mem_Move_13: (+1)
   \   00000084   0x780B             LDRB     R3,[R1, #+0]
   \   00000086   0x7003             STRB     R3,[R0, #+0]
   \   00000088   0x1E49             SUBS     R1,R1,#+1
   \   0000008A   0x1E40             SUBS     R0,R0,#+1
    603                  size_rem      -=  sizeof(CPU_INT08U);
   \   0000008C   0x1E52             SUBS     R2,R2,#+1
    604              }
   \                     ??Mem_Move_5: (+1)
   \   0000008E   0x2A00             CMP      R2,#+0
   \   00000090   0xD1F8             BNE.N    ??Mem_Move_13
    605          }
   \                     ??Mem_Move_0: (+1)
   \   00000092   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    606          
    607          
    608          /*
    609          *********************************************************************************************************
    610          *                                              Mem_Cmp()
    611          *
    612          * Description : Verifies that ALL data octets in two memory buffers are identical in sequence.
    613          *
    614          * Argument(s) : p1_mem      Pointer to first  memory buffer.
    615          *
    616          *               p2_mem      Pointer to second memory buffer.
    617          *
    618          *               size        Number of data buffer octets to compare (see Note #1).
    619          *
    620          * Return(s)   : DEF_YES, if 'size' number of data octets are identical in both memory buffers.
    621          *
    622          *               DEF_NO,  otherwise.
    623          *
    624          * Caller(s)   : Application.
    625          *
    626          * Note(s)     : (1) Null compares allowed (i.e. zero-length compares); 'DEF_YES' returned to indicate
    627          *                   identical null compare.
    628          *
    629          *               (2) Many memory buffer comparisons vary ONLY in the least significant octets -- e.g.
    630          *                   network address buffers.  Consequently, memory buffer comparison is more efficient
    631          *                   if the comparison starts from the end of the memory buffers which will abort sooner
    632          *                   on dissimilar memory buffers that vary only in the least significant octets.
    633          *
    634          *               (3) For best CPU performance, optimized to compare data buffers using 'CPU_ALIGN'-sized
    635          *                   data words. Since many word-aligned processors REQUIRE that multi-octet words be accessed on
    636          *                   word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on 'CPU_ALIGN'd
    637          *                   addresses.
    638          *
    639          *               (4) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
    640          *                   address boundary.
    641          *
    642          *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus
    643          *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
    644          *                  'mem_align_mod' arithmetic operation.
    645          *********************************************************************************************************
    646          */
    647          

   \                                 In section .text, align 2, keep-with-next
    648          CPU_BOOLEAN  Mem_Cmp (const  void        *p1_mem,
    649                                const  void        *p2_mem,
    650                                       CPU_SIZE_T   size)
    651          {
   \                     Mem_Cmp: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x0013             MOVS     R3,R2
    652                     CPU_SIZE_T    size_rem;
    653                     CPU_ALIGN    *p1_mem_align;
    654                     CPU_ALIGN    *p2_mem_align;
    655              const  CPU_INT08U   *p1_mem_08;
    656              const  CPU_INT08U   *p2_mem_08;
    657                     CPU_DATA      i;
    658                     CPU_DATA      mem_align_mod_1;
    659                     CPU_DATA      mem_align_mod_2;
    660                     CPU_BOOLEAN   mem_aligned;
    661                     CPU_BOOLEAN   mem_cmp;
    662          
    663          
    664              if (size < 1) {                                             /* See Note #1.                                         */
   \   00000004   0x2B00             CMP      R3,#+0
   \   00000006   0xD101             BNE.N    ??Mem_Cmp_0
    665                  return (DEF_YES);
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE052             B.N      ??Mem_Cmp_1
    666              }
    667              if (p1_mem == (void *)0) {
   \                     ??Mem_Cmp_0: (+1)
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD101             BNE.N    ??Mem_Cmp_2
    668                  return (DEF_NO);
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE04E             B.N      ??Mem_Cmp_1
    669              }
    670              if (p2_mem == (void *)0) {
   \                     ??Mem_Cmp_2: (+1)
   \   00000014   0x2900             CMP      R1,#+0
   \   00000016   0xD101             BNE.N    ??Mem_Cmp_3
    671                  return (DEF_NO);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE04A             B.N      ??Mem_Cmp_1
    672              }
    673          
    674          
    675              mem_cmp         =  DEF_YES;                                 /* Assume mem bufs are identical until cmp fails.       */
   \                     ??Mem_Cmp_3: (+1)
   \   0000001C   0x2201             MOVS     R2,#+1
    676              size_rem        =  size;
    677                                                                          /* Start @ end of mem bufs (see Note #2).               */
    678              p1_mem_08       = (const CPU_INT08U *)p1_mem + size;
   \   0000001E   0x1818             ADDS     R0,R3,R0
    679              p2_mem_08       = (const CPU_INT08U *)p2_mem + size;
   \   00000020   0x1859             ADDS     R1,R3,R1
    680                                                                          /* See Note #4.                                         */
    681              mem_align_mod_1 = (CPU_INT08U)((CPU_ADDR)p1_mem_08 % sizeof(CPU_ALIGN));
   \   00000022   0x2504             MOVS     R5,#+4
   \   00000024   0xFBB0 0xF4F5      UDIV     R4,R0,R5
   \   00000028   0xFB04 0x0415      MLS      R4,R4,R5,R0
   \   0000002C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
    682              mem_align_mod_2 = (CPU_INT08U)((CPU_ADDR)p2_mem_08 % sizeof(CPU_ALIGN));
   \   0000002E   0x2604             MOVS     R6,#+4
   \   00000030   0xFBB1 0xF5F6      UDIV     R5,R1,R6
   \   00000034   0xFB05 0x1516      MLS      R5,R5,R6,R1
   \   00000038   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
    683          
    684              mem_aligned     = (mem_align_mod_1 == mem_align_mod_2) ? DEF_YES : DEF_NO;
   \   0000003A   0x42AC             CMP      R4,R5
   \   0000003C   0xD101             BNE.N    ??Mem_Cmp_4
   \   0000003E   0x2501             MOVS     R5,#+1
   \   00000040   0xE000             B.N      ??Mem_Cmp_5
   \                     ??Mem_Cmp_4: (+1)
   \   00000042   0x2500             MOVS     R5,#+0
    685          
    686              if (mem_aligned == DEF_YES) {                               /* If mem bufs' alignment offset equal, ...             */
   \                     ??Mem_Cmp_5: (+1)
   \   00000044   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000046   0x2D01             CMP      R5,#+1
   \   00000048   0xD12C             BNE.N    ??Mem_Cmp_6
    687                                                                          /* ... optimize cmp for mem buf alignment.              */
    688                  if (mem_align_mod_1 != 0u) {                            /* If trailing octets avail,                  ...       */
   \   0000004A   0x2C00             CMP      R4,#+0
   \   0000004C   0xD010             BEQ.N    ??Mem_Cmp_7
    689                      i = mem_align_mod_1;
   \   0000004E   0xE008             B.N      ??Mem_Cmp_8
    690                      while ((mem_cmp == DEF_YES) &&                      /* ... cmp mem bufs while identical &         ...       */
    691                             (size_rem > 0)       &&                      /* ... start mem buf cmp with trailing octets ...       */
    692                             (i        > 0)) {                            /* ... until next CPU_ALIGN word boundary.              */
    693                          p1_mem_08--;
   \                     ??Mem_Cmp_9: (+1)
   \   00000050   0x1E40             SUBS     R0,R0,#+1
    694                          p2_mem_08--;
   \   00000052   0x1E49             SUBS     R1,R1,#+1
    695                          if (*p1_mem_08 != *p2_mem_08) {                 /* If ANY data octet(s) NOT identical, cmp fails.       */
   \   00000054   0x7805             LDRB     R5,[R0, #+0]
   \   00000056   0x780E             LDRB     R6,[R1, #+0]
   \   00000058   0x42B5             CMP      R5,R6
   \   0000005A   0xD000             BEQ.N    ??Mem_Cmp_10
    696                               mem_cmp = DEF_NO;
   \   0000005C   0x2200             MOVS     R2,#+0
    697                          }
    698                          size_rem -= sizeof(CPU_INT08U);
   \                     ??Mem_Cmp_10: (+1)
   \   0000005E   0x1E5B             SUBS     R3,R3,#+1
    699                          i--;
   \   00000060   0x1E64             SUBS     R4,R4,#+1
    700                      }
   \                     ??Mem_Cmp_8: (+1)
   \   00000062   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000064   0x2A01             CMP      R2,#+1
   \   00000066   0xD103             BNE.N    ??Mem_Cmp_7
   \   00000068   0x2B00             CMP      R3,#+0
   \   0000006A   0xD001             BEQ.N    ??Mem_Cmp_7
   \   0000006C   0x2C00             CMP      R4,#+0
   \   0000006E   0xD1EF             BNE.N    ??Mem_Cmp_9
    701                  }
    702          
    703                  if (mem_cmp == DEF_YES) {                               /* If cmp still identical, cmp aligned mem bufs.        */
   \                     ??Mem_Cmp_7: (+1)
   \   00000070   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000072   0x2A01             CMP      R2,#+1
   \   00000074   0xD116             BNE.N    ??Mem_Cmp_6
    704                      p1_mem_align = (CPU_ALIGN *)p1_mem_08;              /* See Note #3.                                         */
    705                      p2_mem_align = (CPU_ALIGN *)p2_mem_08;
   \   00000076   0xE007             B.N      ??Mem_Cmp_11
    706          
    707                      while ((mem_cmp  == DEF_YES) &&                     /* Cmp mem bufs while identical & ...                   */
    708                             (size_rem >= sizeof(CPU_ALIGN))) {           /* ... mem bufs aligned on CPU_ALIGN word boundaries.   */
    709                          p1_mem_align--;
   \                     ??Mem_Cmp_12: (+1)
   \   00000078   0x1F00             SUBS     R0,R0,#+4
    710                          p2_mem_align--;
   \   0000007A   0x1F09             SUBS     R1,R1,#+4
    711                          if (*p1_mem_align != *p2_mem_align) {           /* If ANY data octet(s) NOT identical, cmp fails.       */
   \   0000007C   0x6804             LDR      R4,[R0, #+0]
   \   0000007E   0x680D             LDR      R5,[R1, #+0]
   \   00000080   0x42AC             CMP      R4,R5
   \   00000082   0xD000             BEQ.N    ??Mem_Cmp_13
    712                               mem_cmp = DEF_NO;
   \   00000084   0x2200             MOVS     R2,#+0
    713                          }
    714                          size_rem -= sizeof(CPU_ALIGN);
   \                     ??Mem_Cmp_13: (+1)
   \   00000086   0x1F1B             SUBS     R3,R3,#+4
    715                      }
   \                     ??Mem_Cmp_11: (+1)
   \   00000088   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000008A   0x2A01             CMP      R2,#+1
   \   0000008C   0xD101             BNE.N    ??Mem_Cmp_14
   \   0000008E   0x2B04             CMP      R3,#+4
   \   00000090   0xD2F2             BCS.N    ??Mem_Cmp_12
    716          
    717                      p1_mem_08 = (CPU_INT08U *)p1_mem_align;
    718                      p2_mem_08 = (CPU_INT08U *)p2_mem_align;
   \                     ??Mem_Cmp_14: (+1)
   \   00000092   0xE007             B.N      ??Mem_Cmp_6
    719                  }
    720              }
    721          
    722              while ((mem_cmp == DEF_YES) &&                              /* Cmp mem bufs while identical ...                     */
    723                     (size_rem > 0)) {                                    /* ... for unaligned mem bufs or trailing octets.       */
    724                  p1_mem_08--;
   \                     ??Mem_Cmp_15: (+1)
   \   00000094   0x1E40             SUBS     R0,R0,#+1
    725                  p2_mem_08--;
   \   00000096   0x1E49             SUBS     R1,R1,#+1
    726                  if (*p1_mem_08 != *p2_mem_08) {                         /* If ANY data octet(s) NOT identical, cmp fails.       */
   \   00000098   0x7804             LDRB     R4,[R0, #+0]
   \   0000009A   0x780D             LDRB     R5,[R1, #+0]
   \   0000009C   0x42AC             CMP      R4,R5
   \   0000009E   0xD000             BEQ.N    ??Mem_Cmp_16
    727                       mem_cmp = DEF_NO;
   \   000000A0   0x2200             MOVS     R2,#+0
    728                  }
    729                  size_rem -= sizeof(CPU_INT08U);
   \                     ??Mem_Cmp_16: (+1)
   \   000000A2   0x1E5B             SUBS     R3,R3,#+1
    730              }
   \                     ??Mem_Cmp_6: (+1)
   \   000000A4   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000A6   0x2A01             CMP      R2,#+1
   \   000000A8   0xD101             BNE.N    ??Mem_Cmp_17
   \   000000AA   0x2B00             CMP      R3,#+0
   \   000000AC   0xD1F2             BNE.N    ??Mem_Cmp_15
    731          
    732              return (mem_cmp);
   \                     ??Mem_Cmp_17: (+1)
   \   000000AE   0x0010             MOVS     R0,R2
   \   000000B0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??Mem_Cmp_1: (+1)
   \   000000B2   0xBC70             POP      {R4-R6}
   \   000000B4   0x4770             BX       LR               ;; return
    733          }
    734          
    735          
    736          /*
    737          *********************************************************************************************************
    738          *                                           Mem_HeapAlloc()
    739          *
    740          * Description : Allocates a memory block from the heap memory segment.
    741          *
    742          * Argument(s) : size            Size      of memory block to allocate (in bytes).
    743          *
    744          *               align           Alignment of memory block to specific word boundary (in bytes).
    745          *
    746          *               p_bytes_reqd    Optional pointer to a variable to ... :
    747          *
    748          *                                   (a) Return the number of bytes required to successfully
    749          *                                           allocate the memory block, if any error(s);
    750          *                                   (b) Return 0, otherwise.
    751          *
    752          *               p_err           Pointer to variable that will receive the return error code from this function :
    753          *
    754          *                                   LIB_MEM_ERR_NONE                Operation was successful.
    755          *                                   LIB_MEM_ERR_HEAP_EMPTY          No more memory available on heap.
    756          *
    757          *                                   ---------------------RETURNED BY Mem_SegAllocInternal()---------------------
    758          *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
    759          *                                   LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
    760          *                                   LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
    761          *
    762          * Return(s)   : Pointer to memory block, if NO error(s).
    763          *
    764          *               Pointer to NULL,         otherwise.
    765          *
    766          * Caller(s)   : Application.
    767          *
    768          * Note(s)     : (1) Pointers to variables that return values MUST be initialized PRIOR to all other
    769          *                   validation or function handling in case of any error(s).
    770          *
    771          *               (2) This function is DEPRECATED and will be removed in a future version of this product.
    772          *                   Mem_SegAlloc(), Mem_SegAllocExt() or Mem_SegAllocHW() should be used instead.
    773          *********************************************************************************************************
    774          */
    775          
    776          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)

   \                                 In section .text, align 2, keep-with-next
    777          void  *Mem_HeapAlloc (CPU_SIZE_T   size,
    778                                CPU_SIZE_T   align,
    779                                CPU_SIZE_T  *p_bytes_reqd,
    780                                LIB_ERR     *p_err)
    781          {
   \                     Mem_HeapAlloc: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x001C             MOVS     R4,R3
    782              void  *p_mem;
    783          
    784          
    785              p_mem = Mem_SegAllocInternal(DEF_NULL,
    786                                          &Mem_SegHeap,
    787                                           size,
    788                                           align,
    789                                           LIB_MEM_CFG_HEAP_PADDING_ALIGN,
    790                                           p_bytes_reqd,
    791                                           p_err);
   \   00000006   0x9402             STR      R4,[SP, #+8]
   \   00000008   0x9201             STR      R2,[SP, #+4]
   \   0000000A   0x2201             MOVS     R2,#+1
   \   0000000C   0x9200             STR      R2,[SP, #+0]
   \   0000000E   0x000B             MOVS     R3,R1
   \   00000010   0x0002             MOVS     R2,R0
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x.... 0x....      BL       Mem_SegAllocInternal
    792              if (*p_err == LIB_MEM_ERR_SEG_OVF) {
   \   0000001C   0xF9B4 0x1000      LDRSH    R1,[R4, #+0]
   \   00000020   0xF242 0x72D9      MOVW     R2,#+10201
   \   00000024   0x4291             CMP      R1,R2
   \   00000026   0xD102             BNE.N    ??Mem_HeapAlloc_0
    793                 *p_err = LIB_MEM_ERR_HEAP_OVF;
   \   00000028   0xF242 0x71E3      MOVW     R1,#+10211
   \   0000002C   0x8021             STRH     R1,[R4, #+0]
    794              }
    795          
    796              return (p_mem);
   \                     ??Mem_HeapAlloc_0: (+1)
   \   0000002E   0xB004             ADD      SP,SP,#+16
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
    797          }
    798          #endif
    799          
    800          
    801          /*
    802          *********************************************************************************************************
    803          *                                        Mem_HeapGetSizeRem()
    804          *
    805          * Description : Gets remaining heap memory size available to allocate.
    806          *
    807          * Argument(s) : align       Desired word boundary alignment (in bytes) to return remaining memory size from.
    808          *
    809          *               p_err       Pointer to variable that will receive the return error code from this function
    810          *
    811          *                               LIB_MEM_ERR_NONE                Operation was successful.
    812          *
    813          *                               --------------------RETURNED BY Mem_SegRemSizeGet()--------------------
    814          *                               LIB_MEM_ERR_NULL_PTR            Segment data pointer NULL.
    815          *                               LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory alignment.
    816          *
    817          * Return(s)   : Remaining heap memory size (in bytes), if NO error(s).
    818          *
    819          *               0,                                     otherwise.
    820          *
    821          * Caller(s)   : Application.
    822          *
    823          * Note(s)     : (1) This function is DEPRECATED and will be removed in a future version of this product.
    824          *                   Mem_SegRemSizeGet() should be used instead.
    825          *********************************************************************************************************
    826          */
    827          
    828          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)

   \                                 In section .text, align 2, keep-with-next
    829          CPU_SIZE_T  Mem_HeapGetSizeRem (CPU_SIZE_T   align,
    830                                          LIB_ERR     *p_err)
    831          {
   \                     Mem_HeapGetSizeRem: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x000C             MOVS     R4,R1
    832              CPU_SIZE_T  rem_size;
    833          
    834          
    835              rem_size = Mem_SegRemSizeGet(&Mem_SegHeap,
    836                                            align,
    837                                            DEF_NULL,
    838                                            p_err);
   \   00000004   0x0023             MOVS     R3,R4
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x0001             MOVS     R1,R0
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable12_2
   \   0000000E   0x.... 0x....      BL       Mem_SegRemSizeGet
    839              if (*p_err != LIB_MEM_ERR_NONE) {
   \   00000012   0xF9B4 0x1000      LDRSH    R1,[R4, #+0]
   \   00000016   0xF242 0x7210      MOVW     R2,#+10000
   \   0000001A   0x4291             CMP      R1,R2
   \   0000001C   0xD001             BEQ.N    ??Mem_HeapGetSizeRem_0
    840                  return (0u);
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xE7FF             B.N      ??Mem_HeapGetSizeRem_1
    841              }
    842          
    843              return (rem_size);
   \                     ??Mem_HeapGetSizeRem_0: (+1)
   \                     ??Mem_HeapGetSizeRem_1: (+1)
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    844          }
    845          #endif
    846          
    847          
    848          /*
    849          *********************************************************************************************************
    850          *                                            Mem_SegCreate()
    851          *
    852          * Description : Creates a new memory segment to be used for runtime memory allocation.
    853          *
    854          * Argument(s) : p_name          Pointer to segment name.
    855          *
    856          *               p_seg           Pointer to segment data. Must be allocated by caller.
    857          *
    858          *               seg_base_addr   Address of segment's first byte.
    859          *
    860          *               size            Total size of segment, in bytes.
    861          *
    862          *               padding_align   Padding alignment, in bytes, that will be added to any allocated buffer from
    863          *                               this memory segment. MUST be a power of 2. LIB_MEM_PADDING_ALIGN_NONE
    864          *                               means no padding.
    865          *
    866          *               p_err           Pointer to variable that will receive the return error code from this function :
    867          *
    868          *                                   LIB_MEM_ERR_NONE                    Operation was successful.
    869          *                                   LIB_MEM_ERR_INVALID_SEG_SIZE        Invalid segment size specified.
    870          *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN       Invalid padding alignment.
    871          *                                   LIB_MEM_ERR_NULL_PTR                Error or segment data pointer NULL.
    872          *
    873          *                                   -------------------RETURNED BY Mem_SegOverlapChkCritical()-------------------
    874          *                                   LIB_MEM_ERR_INVALID_SEG_OVERLAP     Segment overlaps another existing segment.
    875          *                                   LIB_MEM_ERR_INVALID_SEG_EXISTS      Segment already exists.
    876          *
    877          * Return(s)   : None.
    878          *
    879          * Caller(s)   : Application.
    880          *
    881          * Note(s)     : (1) New segments are checked for overlap with existing segments. A critical section needs
    882          *                   to be maintained during the whole list search and add procedure to prevent a reentrant
    883          *                   call from creating another segment overlapping with the one being added.
    884          *********************************************************************************************************
    885          */
    886          

   \                                 In section .text, align 2, keep-with-next
    887          void  Mem_SegCreate (const  CPU_CHAR    *p_name,
    888                                      MEM_SEG     *p_seg,
    889                                      CPU_ADDR     seg_base_addr,
    890                                      CPU_SIZE_T   size,
    891                                      CPU_SIZE_T   padding_align,
    892                                      LIB_ERR     *p_err)
    893          {
   \                     Mem_SegCreate: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0005             MOVS     R5,R0
   \   00000008   0x000E             MOVS     R6,R1
   \   0000000A   0x0017             MOVS     R7,R2
   \   0000000C   0x4698             MOV      R8,R3
    894              CPU_SR_ALLOC();
   \   0000000E   0xF05F 0x0A00      MOVS     R10,#+0
   \   00000012   0x9C0B             LDR      R4,[SP, #+44]
    895          
    896          
    897          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    898              if (p_err == DEF_NULL) {                                    /* Chk for null err ptr.                                */
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xD101             BNE.N    ??Mem_SegCreate_0
    899                  CPU_SW_EXCEPTION(;);
   \   00000018   0x.... 0x....      BL       CPU_SW_Exception
    900              }
    901          
    902              if (p_seg == DEF_NULL) {                                    /* Chk for null seg ptr.                                */
   \                     ??Mem_SegCreate_0: (+1)
   \   0000001C   0x2E00             CMP      R6,#+0
   \   0000001E   0xD103             BNE.N    ??Mem_SegCreate_1
    903                 *p_err = LIB_MEM_ERR_NULL_PTR;
   \   00000020   0xF242 0x7011      MOVW     R0,#+10001
   \   00000024   0x8020             STRH     R0,[R4, #+0]
    904                  return;
   \   00000026   0xE04B             B.N      ??Mem_SegCreate_2
    905              }
    906          
    907              if (size < 1u) {                                            /* Chk for invalid sized seg.                           */
   \                     ??Mem_SegCreate_1: (+1)
   \   00000028   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000002C   0xD103             BNE.N    ??Mem_SegCreate_3
    908                 *p_err = LIB_MEM_ERR_INVALID_SEG_SIZE;
   \   0000002E   0xF242 0x707E      MOVW     R0,#+10110
   \   00000032   0x8020             STRH     R0,[R4, #+0]
    909                  return;
   \   00000034   0xE044             B.N      ??Mem_SegCreate_2
    910              }
    911                                                                          /* Chk for addr space ovf.                              */
    912              if (seg_base_addr + (size - 1u) < seg_base_addr) {
   \                     ??Mem_SegCreate_3: (+1)
   \   00000036   0xEB18 0x0007      ADDS     R0,R8,R7
   \   0000003A   0x1E40             SUBS     R0,R0,#+1
   \   0000003C   0x42B8             CMP      R0,R7
   \   0000003E   0xD203             BCS.N    ??Mem_SegCreate_4
    913                 *p_err = LIB_MEM_ERR_INVALID_SEG_SIZE;
   \   00000040   0xF242 0x707E      MOVW     R0,#+10110
   \   00000044   0x8020             STRH     R0,[R4, #+0]
    914                  return;
   \   00000046   0xE03B             B.N      ??Mem_SegCreate_2
    915              }
   \                     ??Mem_SegCreate_4: (+1)
   \   00000048   0xF8DD 0x9028      LDR      R9,[SP, #+40]
    916          
    917              if ((padding_align               != LIB_MEM_PADDING_ALIGN_NONE) &&
    918                  (MATH_IS_PWR2(padding_align) != DEF_YES)) {
   \   0000004C   0xF1B9 0x0F01      CMP      R9,#+1
   \   00000050   0xD010             BEQ.N    ??Mem_SegCreate_5
   \   00000052   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000056   0xD006             BEQ.N    ??Mem_SegCreate_6
   \   00000058   0xF1B9 0x0001      SUBS     R0,R9,#+1
   \   0000005C   0xEA19 0x0F00      TST      R9,R0
   \   00000060   0xD101             BNE.N    ??Mem_SegCreate_6
   \   00000062   0x2001             MOVS     R0,#+1
   \   00000064   0xE000             B.N      ??Mem_SegCreate_7
   \                     ??Mem_SegCreate_6: (+1)
   \   00000066   0x2000             MOVS     R0,#+0
   \                     ??Mem_SegCreate_7: (+1)
   \   00000068   0x2801             CMP      R0,#+1
   \   0000006A   0xD003             BEQ.N    ??Mem_SegCreate_5
    919                 *p_err = LIB_MEM_ERR_INVALID_MEM_ALIGN;
   \   0000006C   0xF242 0x7075      MOVW     R0,#+10101
   \   00000070   0x8020             STRH     R0,[R4, #+0]
    920                  return;
   \   00000072   0xE025             B.N      ??Mem_SegCreate_2
    921              }
    922          #endif
    923          
    924              CPU_CRITICAL_ENTER();
   \                     ??Mem_SegCreate_5: (+1)
   \   00000074   0x.... 0x....      BL       CPU_SR_Save
   \   00000078   0x4682             MOV      R10,R0
   \   0000007A   0x.... 0x....      BL       CPU_IntDisMeasStart
    925          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    926              (void)Mem_SegOverlapChkCritical(seg_base_addr,              /* Chk for overlap.                                     */
    927                                              size,
    928                                              p_err);
   \   0000007E   0x0022             MOVS     R2,R4
   \   00000080   0x4641             MOV      R1,R8
   \   00000082   0x0038             MOVS     R0,R7
   \   00000084   0x.... 0x....      BL       Mem_SegOverlapChkCritical
    929              if (*p_err != LIB_MEM_ERR_NONE) {
   \   00000088   0xF9B4 0x0000      LDRSH    R0,[R4, #+0]
   \   0000008C   0xF242 0x7110      MOVW     R1,#+10000
   \   00000090   0x4288             CMP      R0,R1
   \   00000092   0xD005             BEQ.N    ??Mem_SegCreate_8
    930                  CPU_CRITICAL_EXIT();
   \   00000094   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000098   0x4650             MOV      R0,R10
   \   0000009A   0x.... 0x....      BL       CPU_SR_Restore
    931                  return;
   \   0000009E   0xE00F             B.N      ??Mem_SegCreate_2
    932              }
    933          #endif
    934          
    935              Mem_SegCreateCritical(p_name,                               /* Create seg.                                          */
    936                                    p_seg,
    937                                    seg_base_addr,
    938                                    padding_align,
    939                                    size);
   \                     ??Mem_SegCreate_8: (+1)
   \   000000A0   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   000000A4   0x464B             MOV      R3,R9
   \   000000A6   0x003A             MOVS     R2,R7
   \   000000A8   0x0031             MOVS     R1,R6
   \   000000AA   0x0028             MOVS     R0,R5
   \   000000AC   0x.... 0x....      BL       Mem_SegCreateCritical
    940              CPU_CRITICAL_EXIT();
   \   000000B0   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000B4   0x4650             MOV      R0,R10
   \   000000B6   0x.... 0x....      BL       CPU_SR_Restore
    941          
    942             *p_err = LIB_MEM_ERR_NONE;
   \   000000BA   0xF242 0x7010      MOVW     R0,#+10000
   \   000000BE   0x8020             STRH     R0,[R4, #+0]
    943          }
   \                     ??Mem_SegCreate_2: (+1)
   \   000000C0   0xE8BD 0x87F3      POP      {R0,R1,R4-R10,PC}  ;; return
    944          
    945          
    946          /*
    947          *********************************************************************************************************
    948          *                                            Mem_SegClr()
    949          *
    950          * Description : Clears a memory segment.
    951          *
    952          * Argument(s) : p_seg           Pointer to segment data. Must be allocated by caller.
    953          *
    954          *               p_err           Pointer to variable that will receive the return error code from this function :
    955          *
    956          *                               LIB_MEM_ERR_NONE                Operation was successful.
    957          *                               LIB_MEM_ERR_NULL_PTR            Segment data pointer NULL.
    958          *
    959          * Return(s)   : None.
    960          *
    961          * Caller(s)   : Application.
    962          *
    963          * Note(s)     : (1) This function must be used with extreme caution. It must only be called on memory
    964          *                   segments that are no longer used.
    965          *
    966          *               (2) This function is disabled when debug mode is enabled to avoid heap memory leaks.
    967          *********************************************************************************************************
    968          */
    969          
    970          #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_DISABLED)

   \                                 In section .text, align 2, keep-with-next
    971          void  Mem_SegClr (MEM_SEG  *p_seg,
    972                            LIB_ERR  *p_err)
    973          {
   \                     Mem_SegClr: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    974              CPU_SR_ALLOC();
   \   00000006   0x2600             MOVS     R6,#+0
    975          
    976          
    977          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    978              if (p_err == DEF_NULL) {                                    /* Chk for null err ptr.                                */
   \   00000008   0x2D00             CMP      R5,#+0
   \   0000000A   0xD101             BNE.N    ??Mem_SegClr_0
    979                  CPU_SW_EXCEPTION(;);
   \   0000000C   0x.... 0x....      BL       CPU_SW_Exception
    980              }
    981          
    982              if (p_seg == DEF_NULL) {                                    /* Chk for null seg ptr.                                */
   \                     ??Mem_SegClr_0: (+1)
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD103             BNE.N    ??Mem_SegClr_1
    983                 *p_err = LIB_MEM_ERR_NULL_PTR;
   \   00000014   0xF242 0x7011      MOVW     R0,#+10001
   \   00000018   0x8028             STRH     R0,[R5, #+0]
    984                  return;
   \   0000001A   0xE00E             B.N      ??Mem_SegClr_2
    985              }
    986          #endif
    987          
    988              CPU_CRITICAL_ENTER();
   \                     ??Mem_SegClr_1: (+1)
   \   0000001C   0x.... 0x....      BL       CPU_SR_Save
   \   00000020   0x0006             MOVS     R6,R0
   \   00000022   0x.... 0x....      BL       CPU_IntDisMeasStart
    989              p_seg->AddrNext = p_seg->AddrBase;
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x60A0             STR      R0,[R4, #+8]
    990              CPU_CRITICAL_EXIT();
   \   0000002A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000002E   0x0030             MOVS     R0,R6
   \   00000030   0x.... 0x....      BL       CPU_SR_Restore
    991          
    992             *p_err = LIB_MEM_ERR_NONE;
   \   00000034   0xF242 0x7010      MOVW     R0,#+10000
   \   00000038   0x8028             STRH     R0,[R5, #+0]
    993          }
   \                     ??Mem_SegClr_2: (+1)
   \   0000003A   0xBD70             POP      {R4-R6,PC}       ;; return
    994          #endif
    995          
    996          
    997          /*
    998          *********************************************************************************************************
    999          *                                         Mem_SegRemSizeGet()
   1000          *
   1001          * Description : Gets free space of memory segment.
   1002          *
   1003          * Argument(s) : p_seg       Pointer to segment data.
   1004          *
   1005          *               align       Alignment in bytes to assume for calculation of free space.
   1006          *
   1007          *               p_seg_info  Pointer to structure that will receive further segment info data (used size,
   1008          *                           total size, base address and next allocation address).
   1009          *
   1010          *               p_err       Pointer to variable that will receive the return error code from this function :
   1011          *
   1012          *                           LIB_MEM_ERR_NONE                Operation was successful.
   1013          *                           LIB_MEM_ERR_NULL_PTR            Segment data pointer NULL.
   1014          *                           LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory alignment.
   1015          *
   1016          * Return(s)   : Memory segment remaining size in bytes,     if successful.
   1017          *               0,                                          otherwise or if memory segment empty.
   1018          *
   1019          * Caller(s)   : Application,
   1020          *               Mem_HeapGetSizeRem(),
   1021          *               Mem_OutputUsage().
   1022          *
   1023          * Note(s)     : None.
   1024          *********************************************************************************************************
   1025          */
   1026          

   \                                 In section .text, align 2, keep-with-next
   1027          CPU_SIZE_T  Mem_SegRemSizeGet (MEM_SEG       *p_seg,
   1028                                         CPU_SIZE_T     align,
   1029                                         MEM_SEG_INFO  *p_seg_info,
   1030                                         LIB_ERR       *p_err)
   1031          {
   \                     Mem_SegRemSizeGet: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000F             MOVS     R7,R1
   \   00000008   0x0015             MOVS     R5,R2
   \   0000000A   0x001E             MOVS     R6,R3
   1032              CPU_SIZE_T  rem_size;
   1033              CPU_SIZE_T  total_size;
   1034              CPU_SIZE_T  used_size;
   1035              CPU_ADDR    next_addr_align;
   1036              CPU_SR_ALLOC();
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   1037          
   1038          
   1039          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1040              if (p_err == DEF_NULL) {                                    /* Chk for null err ptr.                                */
   \   00000010   0x2E00             CMP      R6,#+0
   \   00000012   0xD101             BNE.N    ??Mem_SegRemSizeGet_0
   1041                  CPU_SW_EXCEPTION(0);
   \   00000014   0x.... 0x....      BL       CPU_SW_Exception
   1042              }
   1043          
   1044              if (MATH_IS_PWR2(align) != DEF_YES) {                       /* Chk for invalid align val.                           */
   \                     ??Mem_SegRemSizeGet_0: (+1)
   \   00000018   0x2F00             CMP      R7,#+0
   \   0000001A   0xD004             BEQ.N    ??Mem_SegRemSizeGet_1
   \   0000001C   0x1E78             SUBS     R0,R7,#+1
   \   0000001E   0x4207             TST      R7,R0
   \   00000020   0xD101             BNE.N    ??Mem_SegRemSizeGet_1
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xE000             B.N      ??Mem_SegRemSizeGet_2
   \                     ??Mem_SegRemSizeGet_1: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
   \                     ??Mem_SegRemSizeGet_2: (+1)
   \   00000028   0x2801             CMP      R0,#+1
   \   0000002A   0xD004             BEQ.N    ??Mem_SegRemSizeGet_3
   1045                 *p_err = LIB_MEM_ERR_INVALID_MEM_ALIGN;
   \   0000002C   0xF242 0x7075      MOVW     R0,#+10101
   \   00000030   0x8030             STRH     R0,[R6, #+0]
   1046                  return (0u);
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xE032             B.N      ??Mem_SegRemSizeGet_4
   1047              }
   1048          #endif
   1049          
   1050              if (p_seg == DEF_NULL) {                                    /* Dflt to heap in case p_seg is null.                  */
   \                     ??Mem_SegRemSizeGet_3: (+1)
   \   00000036   0x2C00             CMP      R4,#+0
   \   00000038   0xD101             BNE.N    ??Mem_SegRemSizeGet_5
   1051          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
   1052                  p_seg = &Mem_SegHeap;
   \   0000003A   0x.... 0x....      LDR.W    R4,??DataTable12_2
   1053          #else
   1054                 *p_err = LIB_MEM_ERR_NULL_PTR;
   1055                  return (0u);
   1056          #endif
   1057              }
   1058          
   1059              CPU_CRITICAL_ENTER();                                       /* Calc seg stats.                                      */
   \                     ??Mem_SegRemSizeGet_5: (+1)
   \   0000003E   0x.... 0x....      BL       CPU_SR_Save
   \   00000042   0x4680             MOV      R8,R0
   \   00000044   0x.... 0x....      BL       CPU_IntDisMeasStart
   1060              next_addr_align = MATH_ROUND_INC_UP_PWR2(p_seg->AddrNext, align);
   \   00000048   0x68A0             LDR      R0,[R4, #+8]
   \   0000004A   0x1E79             SUBS     R1,R7,#+1
   \   0000004C   0x4208             TST      R0,R1
   \   0000004E   0xD101             BNE.N    ??Mem_SegRemSizeGet_6
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xE000             B.N      ??Mem_SegRemSizeGet_7
   \                     ??Mem_SegRemSizeGet_6: (+1)
   \   00000054   0x0038             MOVS     R0,R7
   \                     ??Mem_SegRemSizeGet_7: (+1)
   \   00000056   0x68A1             LDR      R1,[R4, #+8]
   \   00000058   0x1E7A             SUBS     R2,R7,#+1
   \   0000005A   0x4391             BICS     R1,R1,R2
   \   0000005C   0x1847             ADDS     R7,R0,R1
   1061              CPU_CRITICAL_EXIT();
   \   0000005E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000062   0x4640             MOV      R0,R8
   \   00000064   0x.... 0x....      BL       CPU_SR_Restore
   1062          
   1063              total_size = (p_seg->AddrEnd  - p_seg->AddrBase) + 1u;
   \   00000068   0x6860             LDR      R0,[R4, #+4]
   \   0000006A   0x6821             LDR      R1,[R4, #+0]
   \   0000006C   0x1A40             SUBS     R0,R0,R1
   \   0000006E   0x1C41             ADDS     R1,R0,#+1
   1064              used_size  =  p_seg->AddrNext - p_seg->AddrBase;
   \   00000070   0x68A0             LDR      R0,[R4, #+8]
   \   00000072   0x6822             LDR      R2,[R4, #+0]
   \   00000074   0x1A82             SUBS     R2,R0,R2
   1065          
   1066              if (next_addr_align > p_seg->AddrEnd){
   \   00000076   0x6860             LDR      R0,[R4, #+4]
   \   00000078   0x42B8             CMP      R0,R7
   \   0000007A   0xD202             BCS.N    ??Mem_SegRemSizeGet_8
   1067                  next_addr_align = 0u;
   \   0000007C   0x2700             MOVS     R7,#+0
   1068                  rem_size        = 0u;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xE002             B.N      ??Mem_SegRemSizeGet_9
   1069              } else {
   1070                  rem_size        = total_size - (next_addr_align - p_seg->AddrBase);
   \                     ??Mem_SegRemSizeGet_8: (+1)
   \   00000082   0x1BC8             SUBS     R0,R1,R7
   \   00000084   0x6823             LDR      R3,[R4, #+0]
   \   00000086   0x1818             ADDS     R0,R3,R0
   1071              }
   1072          
   1073              if (p_seg_info != DEF_NULL) {
   \                     ??Mem_SegRemSizeGet_9: (+1)
   \   00000088   0x2D00             CMP      R5,#+0
   \   0000008A   0xD004             BEQ.N    ??Mem_SegRemSizeGet_10
   1074                  p_seg_info->TotalSize     = total_size;
   \   0000008C   0x6069             STR      R1,[R5, #+4]
   1075                  p_seg_info->UsedSize      = used_size;
   \   0000008E   0x602A             STR      R2,[R5, #+0]
   1076                  p_seg_info->AddrBase      = p_seg->AddrBase;
   \   00000090   0x6821             LDR      R1,[R4, #+0]
   \   00000092   0x60A9             STR      R1,[R5, #+8]
   1077                  p_seg_info->AddrNextAlloc = next_addr_align;
   \   00000094   0x60EF             STR      R7,[R5, #+12]
   1078              }
   1079          
   1080             *p_err = LIB_MEM_ERR_NONE;
   \                     ??Mem_SegRemSizeGet_10: (+1)
   \   00000096   0xF242 0x7110      MOVW     R1,#+10000
   \   0000009A   0x8031             STRH     R1,[R6, #+0]
   1081          
   1082              return (rem_size);
   \                     ??Mem_SegRemSizeGet_4: (+1)
   \   0000009C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1083          }
   1084          
   1085          
   1086          /*
   1087          *********************************************************************************************************
   1088          *                                            Mem_SegAlloc()
   1089          *
   1090          * Description : Allocates memory from specified segment. Returned memory block will be aligned on a CPU
   1091          *               word boundary.
   1092          *
   1093          * Argument(s) : p_name  Pointer to allocated object name. Used for allocations tracking. May be DEF_NULL.
   1094          *
   1095          *               p_seg   Pointer to segment from which to allocate memory. Will be allocated from
   1096          *                       general-purpose heap if null.
   1097          *
   1098          *               size    Size of memory block to allocate, in bytes.
   1099          *
   1100          *               p_err   Pointer to variable that will receive the return error code from this function :
   1101          *
   1102          *                           LIB_MEM_ERR_NONE                Operation was successful.
   1103          *
   1104          *                           ------------------RETURNED BY Mem_SegAllocInternal()-------------------
   1105          *                           LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
   1106          *                           LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
   1107          *                           LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
   1108          *                           LIB_MEM_ERR_SEG_OVF             Allocation would overflow memory segment.
   1109          *
   1110          * Return(s)   : Pointer to allocated memory block, if successful.
   1111          *
   1112          *               DEF_NULL, otherwise.
   1113          *
   1114          * Caller(s)   : Application.
   1115          *
   1116          * Note(s)     : (1) The memory block returned  by this function will be aligned on a word boundary. In
   1117          *                   order to specify a specific alignment value, use either Mem_SegAllocExt() or
   1118          *                   Mem_SegAllocHW().
   1119          *********************************************************************************************************
   1120          */
   1121          

   \                                 In section .text, align 2, keep-with-next
   1122          void  *Mem_SegAlloc (const  CPU_CHAR    *p_name,
   1123                                      MEM_SEG     *p_seg,
   1124                                      CPU_SIZE_T   size,
   1125                                      LIB_ERR     *p_err)
   1126          {
   \                     Mem_SegAlloc: (+1)
   \   00000000   0xB5E0             PUSH     {R5-R7,LR}
   1127              void  *p_blk;
   1128          
   1129          
   1130              if (p_seg == DEF_NULL) {                                    /* Alloc from heap if p_seg is null.                    */
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD101             BNE.N    ??Mem_SegAlloc_0
   1131          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
   1132                  p_seg = &Mem_SegHeap;
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable12_2
   1133          #else
   1134                 *p_err = LIB_MEM_ERR_NULL_PTR;
   1135                  return (DEF_NULL);
   1136          #endif
   1137              }
   1138          
   1139              p_blk = Mem_SegAllocInternal(p_name,
   1140                                           p_seg,
   1141                                           size,
   1142                                           sizeof(CPU_ALIGN),
   1143                                           LIB_MEM_PADDING_ALIGN_NONE,
   1144                                           DEF_NULL,
   1145                                           p_err);
   \                     ??Mem_SegAlloc_0: (+1)
   \   0000000A   0x9302             STR      R3,[SP, #+8]
   \   0000000C   0x2300             MOVS     R3,#+0
   \   0000000E   0x9301             STR      R3,[SP, #+4]
   \   00000010   0x2301             MOVS     R3,#+1
   \   00000012   0x9300             STR      R3,[SP, #+0]
   \   00000014   0x2304             MOVS     R3,#+4
   \   00000016   0x.... 0x....      BL       Mem_SegAllocInternal
   1146          
   1147              return (p_blk);
   \   0000001A   0xBD0E             POP      {R1-R3,PC}       ;; return
   1148          }
   1149          
   1150          
   1151          /*
   1152          *********************************************************************************************************
   1153          *                                           Mem_SegAllocExt()
   1154          *
   1155          * Description : Allocates memory from specified memory segment.
   1156          *
   1157          * Argument(s) : p_name          Pointer to allocated object name. Used for allocations tracking. May be DEF_NULL.
   1158          *
   1159          *               p_seg           Pointer to segment from which to allocate memory. Will be allocated from
   1160          *                               general-purpose heap if null.
   1161          *
   1162          *               size            Size of memory block to allocate, in bytes.
   1163          *
   1164          *               align           Required alignment of memory block, in bytes. MUST be a power of 2.
   1165          *
   1166          *               p_bytes_reqd    Pointer to variable that will receive the number of free bytes missing for
   1167          *                               the allocation to succeed. Set to DEF_NULL to skip calculation.
   1168          *
   1169          *               p_err           Pointer to variable that will receive the return error code from this function :
   1170          *
   1171          *                                   LIB_MEM_ERR_NONE                Operation was successful.
   1172          *
   1173          *                                   ------------------RETURNED BY Mem_SegAllocInternal()-------------------
   1174          *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
   1175          *                                   LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
   1176          *                                   LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
   1177          *                                   LIB_MEM_ERR_SEG_OVF             Allocation would overflow memory segment.
   1178          *
   1179          * Return(s)   : Pointer to allocated memory block, if successful.
   1180          *
   1181          *               DEF_NULL, otherwise.
   1182          *
   1183          * Caller(s)   : Application.
   1184          *
   1185          * Note(s)     : none.
   1186          *********************************************************************************************************
   1187          */
   1188          

   \                                 In section .text, align 2, keep-with-next
   1189          void  *Mem_SegAllocExt (const  CPU_CHAR    *p_name,
   1190                                         MEM_SEG     *p_seg,
   1191                                         CPU_SIZE_T   size,
   1192                                         CPU_SIZE_T   align,
   1193                                         CPU_SIZE_T  *p_bytes_reqd,
   1194                                         LIB_ERR     *p_err)
   1195          {
   \                     Mem_SegAllocExt: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   1196              void  *p_blk;
   1197          
   1198          
   1199              if (p_seg == DEF_NULL) {                                    /* Alloc from heap if p_seg is null.                    */
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD101             BNE.N    ??Mem_SegAllocExt_0
   1200          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
   1201                  p_seg = &Mem_SegHeap;
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable12_2
   1202          #else
   1203                 *p_err = LIB_MEM_ERR_NULL_PTR;
   1204                  return (DEF_NULL);
   1205          #endif
   1206              }
   1207          
   1208              p_blk = Mem_SegAllocInternal(p_name,
   1209                                           p_seg,
   1210                                           size,
   1211                                           align,
   1212                                           LIB_MEM_PADDING_ALIGN_NONE,
   1213                                           p_bytes_reqd,
   1214                                           p_err);
   \                     ??Mem_SegAllocExt_0: (+1)
   \   0000000C   0x9C07             LDR      R4,[SP, #+28]
   \   0000000E   0x9402             STR      R4,[SP, #+8]
   \   00000010   0x9C06             LDR      R4,[SP, #+24]
   \   00000012   0x9401             STR      R4,[SP, #+4]
   \   00000014   0x2401             MOVS     R4,#+1
   \   00000016   0x9400             STR      R4,[SP, #+0]
   \   00000018   0x.... 0x....      BL       Mem_SegAllocInternal
   1215          
   1216              return (p_blk);
   \   0000001C   0xB004             ADD      SP,SP,#+16
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
   1217          }
   1218          
   1219          
   1220          /*
   1221          *********************************************************************************************************
   1222          *                                          Mem_SegAllocHW()
   1223          *
   1224          * Description : Allocates memory from specified segment. The returned buffer will be padded in function
   1225          *               of memory segment's properties.
   1226          *
   1227          * Argument(s) : p_name          Pointer to allocated object name. Used for allocations tracking. May be DEF_NULL.
   1228          *
   1229          *               p_seg           Pointer to segment from which to allocate memory. Will be allocated from
   1230          *                               general-purpose heap if null.
   1231          *
   1232          *               size            Size of memory block to allocate, in bytes.
   1233          *
   1234          *               align           Required alignment of memory block, in bytes. MUST be a power of 2.
   1235          *
   1236          *               p_bytes_reqd    Pointer to variable that will receive the number of free bytes missing for
   1237          *                               the allocation to succeed. Set to DEF_NULL to skip calculation.
   1238          *
   1239          *               p_err           Pointer to variable that will receive the return error code from this function :
   1240          *
   1241          *                                   LIB_MEM_ERR_NONE                Operation was successful.
   1242          *
   1243          *                                   ------------------RETURNED BY Mem_SegAllocInternal()-------------------
   1244          *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
   1245          *                                   LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
   1246          *                                   LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
   1247          *                                   LIB_MEM_ERR_SEG_OVF             Allocation would overflow memory segment.
   1248          *
   1249          * Return(s)   : Pointer to allocated memory block, if successful.
   1250          *
   1251          *               DEF_NULL, otherwise.
   1252          *
   1253          * Caller(s)   : Application.
   1254          *
   1255          * Note(s)     : none.
   1256          *********************************************************************************************************
   1257          */
   1258          

   \                                 In section .text, align 2, keep-with-next
   1259          void  *Mem_SegAllocHW (const  CPU_CHAR    *p_name,
   1260                                        MEM_SEG     *p_seg,
   1261                                        CPU_SIZE_T   size,
   1262                                        CPU_SIZE_T   align,
   1263                                        CPU_SIZE_T  *p_bytes_reqd,
   1264                                        LIB_ERR     *p_err)
   1265          {
   \                     Mem_SegAllocHW: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   1266              void  *p_blk;
   1267          
   1268          
   1269              if (p_seg == DEF_NULL) {                                    /* Alloc from heap if p_seg is null.                    */
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD101             BNE.N    ??Mem_SegAllocHW_0
   1270          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
   1271                  p_seg = &Mem_SegHeap;
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable12_2
   1272          #else
   1273                 *p_err = LIB_MEM_ERR_NULL_PTR;
   1274                  return (DEF_NULL);
   1275          #endif
   1276              }
   1277          
   1278              p_blk = Mem_SegAllocInternal(p_name,
   1279                                           p_seg,
   1280                                           size,
   1281                                           align,
   1282                                           p_seg->PaddingAlign,
   1283                                           p_bytes_reqd,
   1284                                           p_err);
   \                     ??Mem_SegAllocHW_0: (+1)
   \   0000000C   0x9C07             LDR      R4,[SP, #+28]
   \   0000000E   0x9402             STR      R4,[SP, #+8]
   \   00000010   0x9C06             LDR      R4,[SP, #+24]
   \   00000012   0x9401             STR      R4,[SP, #+4]
   \   00000014   0x690C             LDR      R4,[R1, #+16]
   \   00000016   0x9400             STR      R4,[SP, #+0]
   \   00000018   0x.... 0x....      BL       Mem_SegAllocInternal
   1285          
   1286              return (p_blk);
   \   0000001C   0xB004             ADD      SP,SP,#+16
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
   1287          }
   1288          
   1289          
   1290          /*
   1291          *********************************************************************************************************
   1292          *                                          Mem_PoolCreate()
   1293          *
   1294          * Description : (1) Creates a memory pool :
   1295          *
   1296          *                   (a) Create    memory pool from heap or dedicated memory
   1297          *                   (b) Allocate  memory pool memory blocks
   1298          *                   (c) Configure memory pool
   1299          *
   1300          *
   1301          * Argument(s) : p_pool          Pointer to a memory pool structure to create (see Note #1).
   1302          *
   1303          *               p_mem_base      Memory pool segment base address :
   1304          *
   1305          *                                       (a)     Null address    Memory pool allocated from general-purpose heap.
   1306          *                                       (b) Non-null address    Memory pool allocated from dedicated memory
   1307          *                                                                   specified by its base address.
   1308          *
   1309          *               mem_size        Size      of memory pool segment          (in bytes).
   1310          *
   1311          *               blk_nbr         Number    of memory pool blocks to create.
   1312          *
   1313          *               blk_size        Size      of memory pool blocks to create (in bytes).
   1314          *
   1315          *               blk_align       Alignment of memory pool blocks to specific word boundary (in bytes).
   1316          *
   1317          *               p_bytes_reqd    Optional pointer to a variable to ... :
   1318          *
   1319          *                                   (a) Return the number of bytes required to successfully
   1320          *                                               allocate the memory pool, if any error(s);
   1321          *                                   (b) Return 0, otherwise.
   1322          *
   1323          *               p_err           Pointer to variable that will receive the return error code from this function :
   1324          *
   1325          *                                   LIB_MEM_ERR_NONE                    Operation was successful.
   1326          *                                   LIB_MEM_ERR_NULL_PTR                Pointer to memory pool is null.
   1327          *                                   LIB_MEM_ERR_INVALID_BLK_ALIGN       Invalid block alignment requested.
   1328          *                                   LIB_MEM_ERR_INVALID_BLK_NBR         Invalid number of blocks specified.
   1329          *                                   LIB_MEM_ERR_INVALID_BLK_SIZE        Invalid block size specified.
   1330          *                                   LIB_MEM_ERR_INVALID_SEG_SIZE        Invalid segment size.
   1331          *                                   LIB_MEM_ERR_HEAP_EMPTY              No more memory available on heap.
   1332          *
   1333          *                                   ---------------RETURNED BY Mem_SegOverlapChkCritical()----------------
   1334          *                                   LIB_MEM_ERR_INVALID_SEG_EXISTS      Segment already exists.
   1335          *                                   LIB_MEM_ERR_INVALID_SEG_OVERLAP     Segment overlaps another existing segment.
   1336          *
   1337          *                                   -----------------RETURNED BY Mem_SegAllocExtCritical()-----------------
   1338          *                                   LIB_MEM_ERR_SEG_OVF                 Allocation would overflow memory segment.
   1339          *
   1340          *                                   ------------------RETURNED BY Mem_SegAllocInternal()-------------------
   1341          *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN       Invalid memory block alignment requested.
   1342          *                                   LIB_MEM_ERR_INVALID_MEM_SIZE        Invalid memory block size specified.
   1343          *                                   LIB_MEM_ERR_NULL_PTR                Error or segment data pointer NULL.
   1344          *                                   LIB_MEM_ERR_SEG_OVF                 Allocation would overflow memory segment.
   1345          *
   1346          *                                   -----------------------RETURNED BY Mem_PoolClr()-----------------------
   1347          *                                   LIB_MEM_ERR_NULL_PTR                Argument 'p_pool' passed a NULL pointer.
   1348          *
   1349          * Return(s)   : none.
   1350          *
   1351          * Caller(s)   : Application.
   1352          *
   1353          * Note(s)     : (1) This function is DEPRECATED and will be removed in a future version of this product.
   1354          *                   Mem_DynPoolCreate() or Mem_DynPoolCreateHW() should be used instead.
   1355          *********************************************************************************************************
   1356          */
   1357          
   1358          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)

   \                                 In section .text, align 2, keep-with-next
   1359          void  Mem_PoolCreate (MEM_POOL          *p_pool,
   1360                                void              *p_mem_base,
   1361                                CPU_SIZE_T         mem_size,
   1362                                MEM_POOL_BLK_QTY   blk_nbr,
   1363                                CPU_SIZE_T         blk_size,
   1364                                CPU_SIZE_T         blk_align,
   1365                                CPU_SIZE_T        *p_bytes_reqd,
   1366                                LIB_ERR           *p_err)
   1367          {
   \                     Mem_PoolCreate: (+1)
   \   00000000   0xE92D 0x4FF4      PUSH     {R2,R4-R11,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x4689             MOV      R9,R1
   \   0000000A   0x001D             MOVS     R5,R3
   1368              MEM_SEG           *p_seg;
   1369              void              *p_pool_mem;
   1370              CPU_SIZE_T         pool_size;
   1371              CPU_SIZE_T         blk_size_align;
   1372              CPU_ADDR           pool_addr_end;
   1373              MEM_POOL_BLK_QTY   blk_ix;
   1374              CPU_INT08U        *p_blk;
   1375              CPU_SR_ALLOC();
   \   0000000C   0xF05F 0x0B00      MOVS     R11,#+0
   \   00000010   0x9E11             LDR      R6,[SP, #+68]
   1376          
   1377          
   1378          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* --------------- VALIDATE RTN ERR PTR --------------- */
   1379              if (p_err == DEF_NULL) {
   \   00000012   0x2E00             CMP      R6,#+0
   \   00000014   0xD101             BNE.N    ??Mem_PoolCreate_0
   1380                  CPU_SW_EXCEPTION(;);
   \   00000016   0x.... 0x....      BL       CPU_SW_Exception
   1381              }
   1382          
   1383                                                                          /* ------------- VALIDATE MEM POOL CREATE ------------- */
   1384              if (p_pool == DEF_NULL) {
   \                     ??Mem_PoolCreate_0: (+1)
   \   0000001A   0x2C00             CMP      R4,#+0
   \   0000001C   0xD103             BNE.N    ??Mem_PoolCreate_1
   1385                 *p_err = LIB_MEM_ERR_NULL_PTR;
   \   0000001E   0xF242 0x7011      MOVW     R0,#+10001
   \   00000022   0x8030             STRH     R0,[R6, #+0]
   1386                  return;
   \   00000024   0xE0BF             B.N      ??Mem_PoolCreate_2
   1387              }
   1388          
   1389              if (p_mem_base != DEF_NULL) {
   \                     ??Mem_PoolCreate_1: (+1)
   \   00000026   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000002A   0xD006             BEQ.N    ??Mem_PoolCreate_3
   1390                  if (mem_size < 1u) {
   \   0000002C   0x9804             LDR      R0,[SP, #+16]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD103             BNE.N    ??Mem_PoolCreate_3
   1391                     *p_err = LIB_MEM_ERR_INVALID_SEG_SIZE;
   \   00000032   0xF242 0x707E      MOVW     R0,#+10110
   \   00000036   0x8030             STRH     R0,[R6, #+0]
   1392                      return;
   \   00000038   0xE0B5             B.N      ??Mem_PoolCreate_2
   1393                  }
   1394              }
   1395          
   1396              if (blk_nbr < 1u) {
   \                     ??Mem_PoolCreate_3: (+1)
   \   0000003A   0x2D00             CMP      R5,#+0
   \   0000003C   0xD103             BNE.N    ??Mem_PoolCreate_4
   1397                 *p_err = LIB_MEM_ERR_INVALID_BLK_NBR;
   \   0000003E   0xF242 0x7092      MOVW     R0,#+10130
   \   00000042   0x8030             STRH     R0,[R6, #+0]
   1398                  return;
   \   00000044   0xE0AF             B.N      ??Mem_PoolCreate_2
   1399              }
   \                     ??Mem_PoolCreate_4: (+1)
   \   00000046   0xF8DD 0xA038      LDR      R10,[SP, #+56]
   1400          
   1401              if (blk_size < 1u) {
   \   0000004A   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000004E   0xD103             BNE.N    ??Mem_PoolCreate_5
   1402                 *p_err = LIB_MEM_ERR_INVALID_BLK_SIZE;
   \   00000050   0xF242 0x7093      MOVW     R0,#+10131
   \   00000054   0x8030             STRH     R0,[R6, #+0]
   1403                  return;
   \   00000056   0xE0A6             B.N      ??Mem_PoolCreate_2
   1404              }
   \                     ??Mem_PoolCreate_5: (+1)
   \   00000058   0x9F0F             LDR      R7,[SP, #+60]
   1405          
   1406              if (MATH_IS_PWR2(blk_align) != DEF_YES) {                   /* Chk that req alignment is a pwr of 2.                */
   \   0000005A   0x2F00             CMP      R7,#+0
   \   0000005C   0xD004             BEQ.N    ??Mem_PoolCreate_6
   \   0000005E   0x1E78             SUBS     R0,R7,#+1
   \   00000060   0x4207             TST      R7,R0
   \   00000062   0xD101             BNE.N    ??Mem_PoolCreate_6
   \   00000064   0x2001             MOVS     R0,#+1
   \   00000066   0xE000             B.N      ??Mem_PoolCreate_7
   \                     ??Mem_PoolCreate_6: (+1)
   \   00000068   0x2000             MOVS     R0,#+0
   \                     ??Mem_PoolCreate_7: (+1)
   \   0000006A   0x2801             CMP      R0,#+1
   \   0000006C   0xD003             BEQ.N    ??Mem_PoolCreate_8
   1407                 *p_err = LIB_MEM_ERR_INVALID_BLK_ALIGN;
   \   0000006E   0xF242 0x7094      MOVW     R0,#+10132
   \   00000072   0x8030             STRH     R0,[R6, #+0]
   1408                  return;
   \   00000074   0xE097             B.N      ??Mem_PoolCreate_2
   1409              }
   1410          #endif
   1411          
   1412              Mem_PoolClr(p_pool, p_err);                                 /* Init mem pool.                                       */
   \                     ??Mem_PoolCreate_8: (+1)
   \   00000076   0x0031             MOVS     R1,R6
   \   00000078   0x0020             MOVS     R0,R4
   \   0000007A   0x.... 0x....      BL       Mem_PoolClr
   1413              if (*p_err != LIB_MEM_ERR_NONE) {
   \   0000007E   0xF9B6 0x0000      LDRSH    R0,[R6, #+0]
   \   00000082   0xF242 0x7110      MOVW     R1,#+10000
   \   00000086   0x4288             CMP      R0,R1
   \   00000088   0xF040 0x808D      BNE.W    ??Mem_PoolCreate_2
   1414                   return;
   1415              }
   1416          
   1417                                                                          /* -------- DETERMINE AND/OR ALLOC SEG TO USE --------- */
   1418              if (p_mem_base == DEF_NULL) {                               /* Use heap seg.                                        */
   \                     ??Mem_PoolCreate_9: (+1)
   \   0000008C   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000090   0xD102             BNE.N    ??Mem_PoolCreate_10
   1419                  p_seg = &Mem_SegHeap;
   \   00000092   0x.... 0x....      LDR.W    R8,??DataTable12_2
   \   00000096   0xE017             B.N      ??Mem_PoolCreate_11
   1420              } else {                                                    /* Use other seg.                                       */
   1421                  CPU_CRITICAL_ENTER();
   \                     ??Mem_PoolCreate_10: (+1)
   \   00000098   0x.... 0x....      BL       CPU_SR_Save
   \   0000009C   0x4683             MOV      R11,R0
   \   0000009E   0x.... 0x....      BL       CPU_IntDisMeasStart
   1422                  p_seg = Mem_SegOverlapChkCritical((CPU_ADDR)p_mem_base,
   1423                                                              mem_size,
   1424                                                              p_err);
   \   000000A2   0x0032             MOVS     R2,R6
   \   000000A4   0x9904             LDR      R1,[SP, #+16]
   \   000000A6   0x4648             MOV      R0,R9
   \   000000A8   0x.... 0x....      BL       Mem_SegOverlapChkCritical
   \   000000AC   0x4680             MOV      R8,R0
   1425                  switch (*p_err) {
   \   000000AE   0xF9B6 0x0000      LDRSH    R0,[R6, #+0]
   \   000000B2   0xF242 0x7110      MOVW     R1,#+10000
   \   000000B6   0x1A40             SUBS     R0,R0,R1
   \   000000B8   0xD00C             BEQ.N    ??Mem_PoolCreate_12
   \   000000BA   0x3870             SUBS     R0,R0,#+112
   \   000000BC   0xD12A             BNE.N    ??Mem_PoolCreate_13
   1426                      case LIB_MEM_ERR_INVALID_SEG_EXISTS:                /* Seg already exists.                                  */
   1427                           break;
   1428          
   1429                      case LIB_MEM_ERR_NONE:                              /* Seg must be created.                                 */
   1430                           p_seg = (MEM_SEG *)Mem_SegAllocExtCritical(&Mem_SegHeap,
   1431                                                                       sizeof(MEM_SEG),
   1432                                                                       sizeof(CPU_ALIGN),
   1433                                                                       LIB_MEM_PADDING_ALIGN_NONE,
   1434                                                                       p_bytes_reqd,
   1435                                                                       p_err);
   1436                           if (*p_err != LIB_MEM_ERR_NONE) {
   1437                               CPU_CRITICAL_EXIT();
   1438                               return;
   1439                           }
   1440          
   1441          #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)                    /* Track alloc if req'd.                                */
   1442                           Mem_SegAllocTrackCritical("Unknown segment data",
   1443                                                     &Mem_SegHeap,
   1444                                                      sizeof(MEM_SEG),
   1445                                                      p_err);
   1446                           if (*p_err != LIB_MEM_ERR_NONE) {
   1447                               CPU_CRITICAL_EXIT();
   1448                               return;
   1449                           }
   1450          #endif
   1451          
   1452                           Mem_SegCreateCritical(          DEF_NULL,
   1453                                                           p_seg,
   1454                                                 (CPU_ADDR)p_mem_base,
   1455                                                           LIB_MEM_PADDING_ALIGN_NONE,
   1456                                                           mem_size);
   1457                           break;
   1458          
   1459          
   1460                      case LIB_MEM_ERR_INVALID_SEG_OVERLAP:
   1461                      default:
   1462                           CPU_CRITICAL_EXIT();
   1463                           return;                                        /* Prevent 'break NOT reachable' compiler warning.      */
   1464                  }
   1465          
   1466                  CPU_CRITICAL_EXIT();
   \                     ??Mem_PoolCreate_14: (+1)
   \                     ??Mem_PoolCreate_15: (+1)
   \   000000BE   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000C2   0x4658             MOV      R0,R11
   \   000000C4   0x.... 0x....      BL       CPU_SR_Restore
   1467              }
   1468          
   1469          
   1470                                                                          /* ---------------- ALLOC MEM FOR POOL ---------------- */
   1471                                                                          /* Calc blk size with align.                            */
   1472              blk_size_align =  MATH_ROUND_INC_UP_PWR2(blk_size, blk_align);
   \                     ??Mem_PoolCreate_11: (+1)
   \   000000C8   0x1E78             SUBS     R0,R7,#+1
   \   000000CA   0xEA1A 0x0F00      TST      R10,R0
   \   000000CE   0xD127             BNE.N    ??Mem_PoolCreate_16
   \   000000D0   0x2000             MOVS     R0,#+0
   \   000000D2   0xE026             B.N      ??Mem_PoolCreate_17
   \                     ??Mem_PoolCreate_12: (+1)
   \   000000D4   0x9601             STR      R6,[SP, #+4]
   \   000000D6   0x9810             LDR      R0,[SP, #+64]
   \   000000D8   0x9000             STR      R0,[SP, #+0]
   \   000000DA   0x2301             MOVS     R3,#+1
   \   000000DC   0x2204             MOVS     R2,#+4
   \   000000DE   0x2114             MOVS     R1,#+20
   \   000000E0   0x.... 0x....      LDR.W    R0,??DataTable12_2
   \   000000E4   0x.... 0x....      BL       Mem_SegAllocExtCritical
   \   000000E8   0x4680             MOV      R8,R0
   \   000000EA   0xF9B6 0x0000      LDRSH    R0,[R6, #+0]
   \   000000EE   0xF242 0x7110      MOVW     R1,#+10000
   \   000000F2   0x4288             CMP      R0,R1
   \   000000F4   0xD005             BEQ.N    ??Mem_PoolCreate_18
   \   000000F6   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000FA   0x4658             MOV      R0,R11
   \   000000FC   0x.... 0x....      BL       CPU_SR_Restore
   \   00000100   0xE051             B.N      ??Mem_PoolCreate_2
   \                     ??Mem_PoolCreate_18: (+1)
   \   00000102   0x9804             LDR      R0,[SP, #+16]
   \   00000104   0x9000             STR      R0,[SP, #+0]
   \   00000106   0x2301             MOVS     R3,#+1
   \   00000108   0x464A             MOV      R2,R9
   \   0000010A   0x4641             MOV      R1,R8
   \   0000010C   0x2000             MOVS     R0,#+0
   \   0000010E   0x.... 0x....      BL       Mem_SegCreateCritical
   \   00000112   0xE7D4             B.N      ??Mem_PoolCreate_15
   \                     ??Mem_PoolCreate_13: (+1)
   \   00000114   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000118   0x4658             MOV      R0,R11
   \   0000011A   0x.... 0x....      BL       CPU_SR_Restore
   \   0000011E   0xE042             B.N      ??Mem_PoolCreate_2
   \                     ??Mem_PoolCreate_16: (+1)
   \   00000120   0x0038             MOVS     R0,R7
   \                     ??Mem_PoolCreate_17: (+1)
   \   00000122   0x1E79             SUBS     R1,R7,#+1
   \   00000124   0xEA3A 0x0101      BICS     R1,R10,R1
   \   00000128   0xEB10 0x0901      ADDS     R9,R0,R1
   1473              pool_size      =  blk_size_align * blk_nbr;                 /* Calc required size for pool.                         */
   \   0000012C   0xFB05 0xFA09      MUL      R10,R5,R9
   1474          
   1475                                                                          /* Alloc mem for pool.                                  */
   1476              p_pool_mem = (void *)Mem_SegAllocInternal("Unnamed static pool",
   1477                                                         p_seg,
   1478                                                         pool_size,
   1479                                                         blk_align,
   1480                                                         LIB_MEM_PADDING_ALIGN_NONE,
   1481                                                         p_bytes_reqd,
   1482                                                         p_err);
   \   00000130   0x9602             STR      R6,[SP, #+8]
   \   00000132   0x9810             LDR      R0,[SP, #+64]
   \   00000134   0x9001             STR      R0,[SP, #+4]
   \   00000136   0x2001             MOVS     R0,#+1
   \   00000138   0x9000             STR      R0,[SP, #+0]
   \   0000013A   0x003B             MOVS     R3,R7
   \   0000013C   0x4652             MOV      R2,R10
   \   0000013E   0x4641             MOV      R1,R8
   \   00000140   0x.... 0x....      LDR.W    R0,??DataTable12_4
   \   00000144   0x.... 0x....      BL       Mem_SegAllocInternal
   \   00000148   0x0007             MOVS     R7,R0
   1483              if (*p_err != LIB_MEM_ERR_NONE) {
   \   0000014A   0xF9B6 0x0000      LDRSH    R0,[R6, #+0]
   \   0000014E   0xF242 0x7110      MOVW     R1,#+10000
   \   00000152   0x4288             CMP      R0,R1
   \   00000154   0xD127             BNE.N    ??Mem_PoolCreate_2
   1484                  return;
   1485              }
   1486          
   1487                                                                          /* ------------ ALLOC MEM FOR FREE BLK TBL ------------ */
   1488              p_pool->BlkFreeTbl = (void **)Mem_SegAllocInternal("Unnamed static pool free blk tbl",
   1489                                                                 &Mem_SegHeap,
   1490                                                                  blk_nbr * sizeof(void *),
   1491                                                                  sizeof(CPU_ALIGN),
   1492                                                                  LIB_MEM_PADDING_ALIGN_NONE,
   1493                                                                  p_bytes_reqd,
   1494                                                                  p_err);
   \                     ??Mem_PoolCreate_19: (+1)
   \   00000156   0x9602             STR      R6,[SP, #+8]
   \   00000158   0x9810             LDR      R0,[SP, #+64]
   \   0000015A   0x9001             STR      R0,[SP, #+4]
   \   0000015C   0x2001             MOVS     R0,#+1
   \   0000015E   0x9000             STR      R0,[SP, #+0]
   \   00000160   0x2304             MOVS     R3,#+4
   \   00000162   0x00AA             LSLS     R2,R5,#+2
   \   00000164   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   00000168   0x.... 0x....      LDR.W    R0,??DataTable12_5
   \   0000016C   0x.... 0x....      BL       Mem_SegAllocInternal
   \   00000170   0x6120             STR      R0,[R4, #+16]
   1495              if (*p_err != LIB_MEM_ERR_NONE) {
   \   00000172   0xF9B6 0x0000      LDRSH    R0,[R6, #+0]
   \   00000176   0xF242 0x7110      MOVW     R1,#+10000
   \   0000017A   0x4288             CMP      R0,R1
   \   0000017C   0xD113             BNE.N    ??Mem_PoolCreate_2
   1496                  return;
   1497              }
   1498          
   1499                                                                          /* ------------------ INIT BLK LIST ------------------- */
   1500              p_blk = (CPU_INT08U *)p_pool_mem;
   \                     ??Mem_PoolCreate_20: (+1)
   \   0000017E   0x0039             MOVS     R1,R7
   1501              for (blk_ix = 0; blk_ix < blk_nbr; blk_ix++) {
   \   00000180   0x2000             MOVS     R0,#+0
   \   00000182   0xE005             B.N      ??Mem_PoolCreate_21
   1502                  p_pool->BlkFreeTbl[blk_ix]  = p_blk;
   \                     ??Mem_PoolCreate_22: (+1)
   \   00000184   0x6922             LDR      R2,[R4, #+16]
   \   00000186   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
   1503                  p_blk                      += blk_size_align;
   \   0000018A   0xEB19 0x0101      ADDS     R1,R9,R1
   1504              }
   \   0000018E   0x1C40             ADDS     R0,R0,#+1
   \                     ??Mem_PoolCreate_21: (+1)
   \   00000190   0x42A8             CMP      R0,R5
   \   00000192   0xD3F7             BCC.N    ??Mem_PoolCreate_22
   1505          
   1506          
   1507                                                                          /* ------------------ INIT POOL DATA ------------------ */
   1508              pool_addr_end         = (CPU_ADDR)p_pool_mem + (pool_size - 1u);
   \   00000194   0xEB1A 0x0007      ADDS     R0,R10,R7
   \   00000198   0x1E40             SUBS     R0,R0,#+1
   1509              p_pool->PoolAddrStart =  p_pool_mem;
   \   0000019A   0x6027             STR      R7,[R4, #+0]
   1510              p_pool->PoolAddrEnd   = (void *)pool_addr_end;
   \   0000019C   0x6060             STR      R0,[R4, #+4]
   1511              p_pool->BlkNbr        =  blk_nbr;
   \   0000019E   0x60A5             STR      R5,[R4, #+8]
   1512              p_pool->BlkSize       =  blk_size_align;
   \   000001A0   0xF8C4 0x900C      STR      R9,[R4, #+12]
   1513              p_pool->BlkFreeTblIx  =  blk_nbr;
   \   000001A4   0x6165             STR      R5,[R4, #+20]
   1514          }
   \                     ??Mem_PoolCreate_2: (+1)
   \   000001A6   0xB005             ADD      SP,SP,#+20
   \   000001A8   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1515          #endif
   1516          
   1517          
   1518          /*
   1519          *********************************************************************************************************
   1520          *                                            Mem_PoolClr()
   1521          *
   1522          * Description : Clears a memory pool (see Note #1).
   1523          *
   1524          * Argument(s) : p_pool   Pointer to a memory pool structure to clear (see Note #2).
   1525          *
   1526          *               p_err    Pointer to variable that will receive the return error code from this function :
   1527          *
   1528          *                               LIB_MEM_ERR_NONE                Operation was successful.
   1529          *                               LIB_MEM_ERR_NULL_PTR            Argument 'p_pool' passed a NULL pointer.
   1530          *
   1531          * Return(s)   : none.
   1532          *
   1533          * Caller(s)   : Application,
   1534          *               Mem_PoolCreate().
   1535          *
   1536          * Note(s)     : (1) (a) Mem_PoolClr() ONLY clears a memory pool structure's variables & should ONLY be
   1537          *                       called to initialize a memory pool structure prior to calling Mem_PoolCreate().
   1538          *
   1539          *                   (b) Mem_PoolClr() does NOT deallocate memory from the memory pool or deallocate the
   1540          *                       memory pool itself & MUST NOT be called after calling Mem_PoolCreate() since
   1541          *                       this will likely corrupt the memory pool management.
   1542          *
   1543          *               (2) Assumes 'p_pool' points to a valid memory pool (if non-NULL).
   1544          *
   1545          *               (3) This function is DEPRECATED and will be removed in a future version of this product.
   1546          *********************************************************************************************************
   1547          */
   1548          
   1549          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)

   \                                 In section .text, align 2, keep-with-next
   1550          void  Mem_PoolClr (MEM_POOL  *p_pool,
   1551                             LIB_ERR   *p_err)
   1552          {
   \                     Mem_PoolClr: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
   1553          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* -------------- VALIDATE RTN ERR  PTR --------------- */
   1554              if (p_err == DEF_NULL) {
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD101             BNE.N    ??Mem_PoolClr_0
   1555                  CPU_SW_EXCEPTION(;);
   \   0000000A   0x.... 0x....      BL       CPU_SW_Exception
   1556              }
   1557          
   1558                                                                          /* -------------- VALIDATE MEM POOL PTR --------------- */
   1559              if (p_pool == DEF_NULL) {
   \                     ??Mem_PoolClr_0: (+1)
   \   0000000E   0x2D00             CMP      R5,#+0
   \   00000010   0xD103             BNE.N    ??Mem_PoolClr_1
   1560                 *p_err = LIB_MEM_ERR_NULL_PTR;
   \   00000012   0xF242 0x7011      MOVW     R0,#+10001
   \   00000016   0x8020             STRH     R0,[R4, #+0]
   1561                  return;
   \   00000018   0xE00E             B.N      ??Mem_PoolClr_2
   1562              }
   1563          #endif
   1564          
   1565              p_pool->PoolAddrStart = DEF_NULL;
   \                     ??Mem_PoolClr_1: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x6028             STR      R0,[R5, #+0]
   1566              p_pool->PoolAddrEnd   = DEF_NULL;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x6068             STR      R0,[R5, #+4]
   1567              p_pool->BlkSize       = 0u;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x60E8             STR      R0,[R5, #+12]
   1568              p_pool->BlkNbr        = 0u;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x60A8             STR      R0,[R5, #+8]
   1569              p_pool->BlkFreeTbl    = DEF_NULL;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x6128             STR      R0,[R5, #+16]
   1570              p_pool->BlkFreeTblIx  = 0u;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x6168             STR      R0,[R5, #+20]
   1571          
   1572             *p_err = LIB_MEM_ERR_NONE;
   \   00000032   0xF242 0x7010      MOVW     R0,#+10000
   \   00000036   0x8020             STRH     R0,[R4, #+0]
   1573          }
   \                     ??Mem_PoolClr_2: (+1)
   \   00000038   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1574          #endif
   1575          
   1576          
   1577          /*
   1578          *********************************************************************************************************
   1579          *                                          Mem_PoolBlkGet()
   1580          *
   1581          * Description : Gets a memory block from memory pool.
   1582          *
   1583          * Argument(s) : p_pool  Pointer to  memory pool to get memory block from.
   1584          *
   1585          *               size    Size of requested memory (in bytes).
   1586          *
   1587          *               p_err   Pointer to variable that will receive the return error code from this function :
   1588          *
   1589          *                           LIB_MEM_ERR_NONE                Operation was successful.
   1590          *                           LIB_MEM_ERR_INVALID_BLK_SIZE    Invalid memory pool block size requested.
   1591          *                           LIB_MEM_ERR_NULL_PTR            Argument 'p_pool' passed a NULL pointer.
   1592          *                           LIB_MEM_ERR_POOL_EMPTY          NO memory blocks available in memory pool.
   1593          *
   1594          * Return(s)   : Pointer to memory block, if NO error(s).
   1595          *
   1596          *               Pointer to NULL,         otherwise.
   1597          *
   1598          * Caller(s)   : Application.
   1599          *
   1600          * Note(s)     : (1) This function is DEPRECATED and will be removed in a future version of this product.
   1601          *                   Mem_DynPoolBlkGet() should be used instead.
   1602          *********************************************************************************************************
   1603          */
   1604          
   1605          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)

   \                                 In section .text, align 2, keep-with-next
   1606          void  *Mem_PoolBlkGet (MEM_POOL    *p_pool,
   1607                                 CPU_SIZE_T   size,
   1608                                 LIB_ERR     *p_err)
   1609          {
   \                     Mem_PoolBlkGet: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000F             MOVS     R7,R1
   \   00000006   0x0014             MOVS     R4,R2
   1610              CPU_INT08U  *p_blk;
   1611              CPU_SR_ALLOC();
   \   00000008   0x2600             MOVS     R6,#+0
   1612          
   1613          
   1614          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* -------------- VALIDATE MEM POOL GET --------------- */
   1615              if (p_err == DEF_NULL) {                                    /* Validate err ptr.                                    */
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD101             BNE.N    ??Mem_PoolBlkGet_0
   1616                  CPU_SW_EXCEPTION(DEF_NULL);
   \   0000000E   0x.... 0x....      BL       CPU_SW_Exception
   1617              }
   1618          
   1619              if (p_pool == DEF_NULL) {                                   /* Validate pool ptr.                                   */
   \                     ??Mem_PoolBlkGet_0: (+1)
   \   00000012   0x2D00             CMP      R5,#+0
   \   00000014   0xD104             BNE.N    ??Mem_PoolBlkGet_1
   1620                 *p_err = LIB_MEM_ERR_NULL_PTR;
   \   00000016   0xF242 0x7011      MOVW     R0,#+10001
   \   0000001A   0x8020             STRH     R0,[R4, #+0]
   1621                  return (DEF_NULL);
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE032             B.N      ??Mem_PoolBlkGet_2
   1622              }
   1623          
   1624              if (size < 1u) {                                            /* Validate req'd size as non-NULL.                     */
   \                     ??Mem_PoolBlkGet_1: (+1)
   \   00000020   0x2F00             CMP      R7,#+0
   \   00000022   0xD104             BNE.N    ??Mem_PoolBlkGet_3
   1625                 *p_err = LIB_MEM_ERR_INVALID_BLK_SIZE;
   \   00000024   0xF242 0x7093      MOVW     R0,#+10131
   \   00000028   0x8020             STRH     R0,[R4, #+0]
   1626                  return (DEF_NULL);
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xE02B             B.N      ??Mem_PoolBlkGet_2
   1627              }
   1628          
   1629              if (size > p_pool->BlkSize) {                               /* Validate req'd size <= mem pool blk size.            */
   \                     ??Mem_PoolBlkGet_3: (+1)
   \   0000002E   0x68E8             LDR      R0,[R5, #+12]
   \   00000030   0x42B8             CMP      R0,R7
   \   00000032   0xD204             BCS.N    ??Mem_PoolBlkGet_4
   1630                 *p_err = LIB_MEM_ERR_INVALID_BLK_SIZE;
   \   00000034   0xF242 0x7093      MOVW     R0,#+10131
   \   00000038   0x8020             STRH     R0,[R4, #+0]
   1631                  return (DEF_NULL);
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xE023             B.N      ??Mem_PoolBlkGet_2
   1632              }
   1633          #else
   1634              (void)size;                                                 /* Prevent possible 'variable unused' warning.          */
   1635          #endif
   1636          
   1637          
   1638                                                                          /* -------------- GET MEM BLK FROM POOL --------------- */
   1639              p_blk = DEF_NULL;
   \                     ??Mem_PoolBlkGet_4: (+1)
   \   0000003E   0x2700             MOVS     R7,#+0
   1640              CPU_CRITICAL_ENTER();
   \   00000040   0x.... 0x....      BL       CPU_SR_Save
   \   00000044   0x0006             MOVS     R6,R0
   \   00000046   0x.... 0x....      BL       CPU_IntDisMeasStart
   1641              if (p_pool->BlkFreeTblIx > 0u) {
   \   0000004A   0x6968             LDR      R0,[R5, #+20]
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD00B             BEQ.N    ??Mem_PoolBlkGet_5
   1642                  p_pool->BlkFreeTblIx                     -=  1u;
   \   00000050   0x6968             LDR      R0,[R5, #+20]
   \   00000052   0x1E40             SUBS     R0,R0,#+1
   \   00000054   0x6168             STR      R0,[R5, #+20]
   1643                  p_blk                                     = (CPU_INT08U *)p_pool->BlkFreeTbl[p_pool->BlkFreeTblIx];
   \   00000056   0x6928             LDR      R0,[R5, #+16]
   \   00000058   0x6969             LDR      R1,[R5, #+20]
   \   0000005A   0xF850 0x7021      LDR      R7,[R0, R1, LSL #+2]
   1644                  p_pool->BlkFreeTbl[p_pool->BlkFreeTblIx]  =  DEF_NULL;
   \   0000005E   0x6928             LDR      R0,[R5, #+16]
   \   00000060   0x6969             LDR      R1,[R5, #+20]
   \   00000062   0x2200             MOVS     R2,#+0
   \   00000064   0xF840 0x2021      STR      R2,[R0, R1, LSL #+2]
   1645              }
   1646              CPU_CRITICAL_EXIT();
   \                     ??Mem_PoolBlkGet_5: (+1)
   \   00000068   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000006C   0x0030             MOVS     R0,R6
   \   0000006E   0x.... 0x....      BL       CPU_SR_Restore
   1647          
   1648              if (p_blk == DEF_NULL) {
   \   00000072   0x2F00             CMP      R7,#+0
   \   00000074   0xD103             BNE.N    ??Mem_PoolBlkGet_6
   1649                 *p_err = LIB_MEM_ERR_POOL_EMPTY;
   \   00000076   0xF242 0x70DE      MOVW     R0,#+10206
   \   0000007A   0x8020             STRH     R0,[R4, #+0]
   \   0000007C   0xE002             B.N      ??Mem_PoolBlkGet_7
   1650              } else {
   1651                 *p_err = LIB_MEM_ERR_NONE;
   \                     ??Mem_PoolBlkGet_6: (+1)
   \   0000007E   0xF242 0x7010      MOVW     R0,#+10000
   \   00000082   0x8020             STRH     R0,[R4, #+0]
   1652              }
   1653          
   1654              return (p_blk);
   \                     ??Mem_PoolBlkGet_7: (+1)
   \   00000084   0x0038             MOVS     R0,R7
   \                     ??Mem_PoolBlkGet_2: (+1)
   \   00000086   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1655          }
   1656          #endif
   1657          
   1658          
   1659          /*
   1660          *********************************************************************************************************
   1661          *                                          Mem_PoolBlkFree()
   1662          *
   1663          * Description : Free a memory block to memory pool.
   1664          *
   1665          * Argument(s) : p_pool  Pointer to memory pool to free memory block.
   1666          *
   1667          *               p_blk   Pointer to memory block address to free.
   1668          *
   1669          *               p_err   Pointer to variable that will receive the return error code from this function :
   1670          *
   1671          *                           LIB_MEM_ERR_NONE                        Operation was successful.
   1672          *                           LIB_MEM_ERR_NULL_PTR                    Argument 'p_pool'/'p_blk' passed
   1673          *                                                                       a NULL pointer.
   1674          *                           LIB_MEM_ERR_INVALID_BLK_ADDR            Invalid memory block address.
   1675          *                           LIB_MEM_ERR_INVALID_BLK_ADDR_IN_POOL            Memory block address already
   1676          *                                                                        in memory pool.
   1677          *                           LIB_MEM_ERR_POOL_FULL                   Pool is full.
   1678          *
   1679          * Return(s)   : none.
   1680          *
   1681          * Caller(s)   : Application.
   1682          *
   1683          * Note(s)     : (1) This function is DEPRECATED and will be removed in a future version of this product.
   1684          *                   Mem_DynPoolBlkFree() should be used instead.
   1685          *********************************************************************************************************
   1686          */
   1687          
   1688          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)

   \                                 In section .text, align 2, keep-with-next
   1689          void  Mem_PoolBlkFree (MEM_POOL  *p_pool,
   1690                                 void      *p_blk,
   1691                                 LIB_ERR   *p_err)
   1692          {
   \                     Mem_PoolBlkFree: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0014             MOVS     R4,R2
   1693          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1694              CPU_SIZE_T   tbl_ix;
   1695              CPU_BOOLEAN  addr_valid;
   1696          #endif
   1697              CPU_SR_ALLOC();
   \   00000008   0x2700             MOVS     R7,#+0
   1698          
   1699          
   1700          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* -------------- VALIDATE MEM POOL FREE -------------- */
   1701              if (p_err == DEF_NULL) {
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD101             BNE.N    ??Mem_PoolBlkFree_0
   1702                  CPU_SW_EXCEPTION(;);
   \   0000000E   0x.... 0x....      BL       CPU_SW_Exception
   1703              }
   1704          
   1705              if (p_pool == DEF_NULL) {                                   /* Validate mem ptrs.                                   */
   \                     ??Mem_PoolBlkFree_0: (+1)
   \   00000012   0x2D00             CMP      R5,#+0
   \   00000014   0xD103             BNE.N    ??Mem_PoolBlkFree_1
   1706                 *p_err = LIB_MEM_ERR_NULL_PTR;
   \   00000016   0xF242 0x7011      MOVW     R0,#+10001
   \   0000001A   0x8020             STRH     R0,[R4, #+0]
   1707                  return;
   \   0000001C   0xE045             B.N      ??Mem_PoolBlkFree_2
   1708              }
   1709          
   1710              if (p_blk == DEF_NULL) {
   \                     ??Mem_PoolBlkFree_1: (+1)
   \   0000001E   0x2E00             CMP      R6,#+0
   \   00000020   0xD103             BNE.N    ??Mem_PoolBlkFree_3
   1711                 *p_err = LIB_MEM_ERR_NULL_PTR;
   \   00000022   0xF242 0x7011      MOVW     R0,#+10001
   \   00000026   0x8020             STRH     R0,[R4, #+0]
   1712                  return;
   \   00000028   0xE03F             B.N      ??Mem_PoolBlkFree_2
   1713              }
   1714          
   1715              addr_valid = Mem_PoolBlkIsValidAddr(p_pool, p_blk);         /* Validate mem blk as valid pool blk addr.             */
   \                     ??Mem_PoolBlkFree_3: (+1)
   \   0000002A   0x0031             MOVS     R1,R6
   \   0000002C   0x0028             MOVS     R0,R5
   \   0000002E   0x.... 0x....      BL       Mem_PoolBlkIsValidAddr
   1716              if (addr_valid != DEF_OK) {
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   0x2801             CMP      R0,#+1
   \   00000036   0xD003             BEQ.N    ??Mem_PoolBlkFree_4
   1717                 *p_err = LIB_MEM_ERR_INVALID_BLK_ADDR;
   \   00000038   0xF242 0x7097      MOVW     R0,#+10135
   \   0000003C   0x8020             STRH     R0,[R4, #+0]
   1718                  return;
   \   0000003E   0xE034             B.N      ??Mem_PoolBlkFree_2
   1719              }
   1720          
   1721              CPU_CRITICAL_ENTER();                                       /* Make sure blk isn't already in free list.            */
   \                     ??Mem_PoolBlkFree_4: (+1)
   \   00000040   0x.... 0x....      BL       CPU_SR_Save
   \   00000044   0x0007             MOVS     R7,R0
   \   00000046   0x.... 0x....      BL       CPU_IntDisMeasStart
   1722              for (tbl_ix = 0u; tbl_ix < p_pool->BlkNbr; tbl_ix++) {
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0xE000             B.N      ??Mem_PoolBlkFree_5
   \                     ??Mem_PoolBlkFree_6: (+1)
   \   0000004E   0x1C40             ADDS     R0,R0,#+1
   \                     ??Mem_PoolBlkFree_5: (+1)
   \   00000050   0x68A9             LDR      R1,[R5, #+8]
   \   00000052   0x4288             CMP      R0,R1
   \   00000054   0xD20D             BCS.N    ??Mem_PoolBlkFree_7
   1723                  if (p_pool->BlkFreeTbl[tbl_ix] == p_blk) {
   \   00000056   0x6929             LDR      R1,[R5, #+16]
   \   00000058   0xF851 0x1020      LDR      R1,[R1, R0, LSL #+2]
   \   0000005C   0x42B1             CMP      R1,R6
   \   0000005E   0xD1F6             BNE.N    ??Mem_PoolBlkFree_6
   1724                      CPU_CRITICAL_EXIT();
   \   00000060   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000064   0x0038             MOVS     R0,R7
   \   00000066   0x.... 0x....      BL       CPU_SR_Restore
   1725                     *p_err = LIB_MEM_ERR_INVALID_BLK_ADDR_IN_POOL;
   \   0000006A   0xF242 0x7098      MOVW     R0,#+10136
   \   0000006E   0x8020             STRH     R0,[R4, #+0]
   1726                      return;
   \   00000070   0xE01B             B.N      ??Mem_PoolBlkFree_2
   1727                  }
   1728              }
   1729          #else                                                           /* Double-free possibility if not in critical section.  */
   1730              CPU_CRITICAL_ENTER();
   1731          #endif
   1732                                                                          /* --------------- FREE MEM BLK TO POOL --------------- */
   1733              if (p_pool->BlkFreeTblIx >= p_pool->BlkNbr) {
   \                     ??Mem_PoolBlkFree_7: (+1)
   \   00000072   0x6968             LDR      R0,[R5, #+20]
   \   00000074   0x68A9             LDR      R1,[R5, #+8]
   \   00000076   0x4288             CMP      R0,R1
   \   00000078   0xD308             BCC.N    ??Mem_PoolBlkFree_8
   1734                  CPU_CRITICAL_EXIT();
   \   0000007A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000007E   0x0038             MOVS     R0,R7
   \   00000080   0x.... 0x....      BL       CPU_SR_Restore
   1735                 *p_err = LIB_MEM_ERR_POOL_FULL;
   \   00000084   0xF242 0x70DD      MOVW     R0,#+10205
   \   00000088   0x8020             STRH     R0,[R4, #+0]
   1736                  return;
   \   0000008A   0xE00E             B.N      ??Mem_PoolBlkFree_2
   1737              }
   1738          
   1739              p_pool->BlkFreeTbl[p_pool->BlkFreeTblIx]  = p_blk;
   \                     ??Mem_PoolBlkFree_8: (+1)
   \   0000008C   0x6928             LDR      R0,[R5, #+16]
   \   0000008E   0x6969             LDR      R1,[R5, #+20]
   \   00000090   0xF840 0x6021      STR      R6,[R0, R1, LSL #+2]
   1740              p_pool->BlkFreeTblIx                     += 1u;
   \   00000094   0x6968             LDR      R0,[R5, #+20]
   \   00000096   0x1C40             ADDS     R0,R0,#+1
   \   00000098   0x6168             STR      R0,[R5, #+20]
   1741              CPU_CRITICAL_EXIT();
   \   0000009A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000009E   0x0038             MOVS     R0,R7
   \   000000A0   0x.... 0x....      BL       CPU_SR_Restore
   1742          
   1743             *p_err = LIB_MEM_ERR_NONE;
   \   000000A4   0xF242 0x7010      MOVW     R0,#+10000
   \   000000A8   0x8020             STRH     R0,[R4, #+0]
   1744          }
   \                     ??Mem_PoolBlkFree_2: (+1)
   \   000000AA   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1745          #endif
   1746          
   1747          
   1748          /*
   1749          *********************************************************************************************************
   1750          *                                      Mem_PoolBlkGetNbrAvail()
   1751          *
   1752          * Description : Get memory pool's remaining number of blocks available to allocate.
   1753          *
   1754          * Argument(s) : p_pool   Pointer to a memory pool structure.
   1755          *
   1756          *               p_err    Pointer to variable that will receive the return error code from this function :
   1757          *
   1758          *                               LIB_MEM_ERR_NONE                Operation was successful.
   1759          *                               LIB_MEM_ERR_NULL_PTR            Argument 'p_pool' passed a NULL pointer.
   1760          *
   1761          * Return(s)   : Remaining memory pool blocks,   if NO error(s).
   1762          *
   1763          *               0,                              otherwise.
   1764          *
   1765          * Caller(s)   : Application.
   1766          *
   1767          * Note(s)     : (1) This function is DEPRECATED and will be removed in a future version of this product.
   1768          *                   Mem_DynPoolBlkNbrAvailGet() should be used instead.
   1769          *********************************************************************************************************
   1770          */
   1771          
   1772          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)

   \                                 In section .text, align 2, keep-with-next
   1773          MEM_POOL_BLK_QTY  Mem_PoolBlkGetNbrAvail (MEM_POOL  *p_pool,
   1774                                                    LIB_ERR   *p_err)
   1775          {
   \                     Mem_PoolBlkGetNbrAvail: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1776              CPU_SIZE_T  nbr_avail;
   1777              CPU_SR_ALLOC();
   \   00000006   0x2600             MOVS     R6,#+0
   1778          
   1779          
   1780          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1781                                                                          /* --------------- VALIDATE RTN ERR PTR --------------- */
   1782              if (p_err == DEF_NULL) {
   \   00000008   0x2D00             CMP      R5,#+0
   \   0000000A   0xD101             BNE.N    ??Mem_PoolBlkGetNbrAvail_0
   1783                  CPU_SW_EXCEPTION(0u);
   \   0000000C   0x.... 0x....      BL       CPU_SW_Exception
   1784              }
   1785                                                                          /* ---------------- VALIDATE MEM POOL ----------------- */
   1786              if (p_pool == DEF_NULL) {                                   /* Validate mem ptr.                                    */
   \                     ??Mem_PoolBlkGetNbrAvail_0: (+1)
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD104             BNE.N    ??Mem_PoolBlkGetNbrAvail_1
   1787                 *p_err =  LIB_MEM_ERR_NULL_PTR;
   \   00000014   0xF242 0x7011      MOVW     R0,#+10001
   \   00000018   0x8028             STRH     R0,[R5, #+0]
   1788                  return (0u);
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE00E             B.N      ??Mem_PoolBlkGetNbrAvail_2
   1789              }
   1790          #endif
   1791          
   1792              CPU_CRITICAL_ENTER();
   \                     ??Mem_PoolBlkGetNbrAvail_1: (+1)
   \   0000001E   0x.... 0x....      BL       CPU_SR_Save
   \   00000022   0x0006             MOVS     R6,R0
   \   00000024   0x.... 0x....      BL       CPU_IntDisMeasStart
   1793              nbr_avail = p_pool->BlkFreeTblIx;
   \   00000028   0x6964             LDR      R4,[R4, #+20]
   1794              CPU_CRITICAL_EXIT();
   \   0000002A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000002E   0x0030             MOVS     R0,R6
   \   00000030   0x.... 0x....      BL       CPU_SR_Restore
   1795          
   1796             *p_err = LIB_MEM_ERR_NONE;
   \   00000034   0xF242 0x7010      MOVW     R0,#+10000
   \   00000038   0x8028             STRH     R0,[R5, #+0]
   1797          
   1798              return (nbr_avail);
   \   0000003A   0x0020             MOVS     R0,R4
   \                     ??Mem_PoolBlkGetNbrAvail_2: (+1)
   \   0000003C   0xBD70             POP      {R4-R6,PC}       ;; return
   1799          }
   1800          #endif
   1801          
   1802          
   1803          /*
   1804          *********************************************************************************************************
   1805          *                                          Mem_DynPoolCreate()
   1806          *
   1807          * Description : Creates a dynamic memory pool.
   1808          *
   1809          * Argument(s) : p_name          Pointer to pool name.
   1810          *
   1811          *               p_pool          Pointer to pool data.
   1812          *
   1813          *               p_seg           Pointer to segment from which to allocate memory. Will be allocated from
   1814          *                               general-purpose heap if null.
   1815          *
   1816          *               blk_size        Size of memory block to allocate from pool, in bytes. See Note #1.
   1817          *
   1818          *               blk_align       Required alignment of memory block, in bytes. MUST be a power of 2.
   1819          *
   1820          *               blk_qty_init    Initial number of elements to be allocated in pool.
   1821          *
   1822          *               blk_qty_max     Maximum number of elements that can be allocated from this pool. Set to
   1823          *                               LIB_MEM_BLK_QTY_UNLIMITED if no limit.
   1824          *
   1825          *               p_err           Pointer to variable that will receive the return error code from this function :
   1826          *
   1827          *                                   LIB_MEM_ERR_NONE                Operation was successful.
   1828          *
   1829          *                                   --------------------RETURNED BY Mem_DynPoolCreateInternal()-------------------
   1830          *                                   LIB_MEM_ERR_INVALID_BLK_ALIGN   Invalid requested block alignment.
   1831          *                                   LIB_MEM_ERR_INVALID_BLK_SIZE    Invalid requested block size.
   1832          *                                   LIB_MEM_ERR_INVALID_BLK_NBR     Invalid requested block quantity max.
   1833          *                                   LIB_MEM_ERR_NULL_PTR            Pool data pointer NULL.
   1834          *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
   1835          *                                   LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
   1836          *                                   LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
   1837          *                                   LIB_MEM_ERR_SEG_OVF             Allocation would overflow memory segment.
   1838          *
   1839          * Return(s)   : None.
   1840          *
   1841          * Caller(s)   : Application.
   1842          *
   1843          * Note(s)     : (1) 'blk_size' must be big enough to fit a pointer since the pointer to the next free
   1844          *                   block is stored in the block itself (only when free/unused).
   1845          *********************************************************************************************************
   1846          */
   1847          

   \                                 In section .text, align 2, keep-with-next
   1848          void  Mem_DynPoolCreate (const  CPU_CHAR      *p_name,
   1849                                          MEM_DYN_POOL  *p_pool,
   1850                                          MEM_SEG       *p_seg,
   1851                                          CPU_SIZE_T     blk_size,
   1852                                          CPU_SIZE_T     blk_align,
   1853                                          CPU_SIZE_T     blk_qty_init,
   1854                                          CPU_SIZE_T     blk_qty_max,
   1855                                          LIB_ERR       *p_err)
   1856          {
   \                     Mem_DynPoolCreate: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   1857              if (p_seg == DEF_NULL) {                                    /* Alloc from heap if p_seg is null.                    */
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD101             BNE.N    ??Mem_DynPoolCreate_0
   1858          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
   1859                  p_seg = &Mem_SegHeap;
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable12_2
   1860          #else
   1861                 *p_err = LIB_MEM_ERR_NULL_PTR;
   1862                  return;
   1863          #endif
   1864              }
   1865          
   1866              Mem_DynPoolCreateInternal(p_name,
   1867                                        p_pool,
   1868                                        p_seg,
   1869                                        blk_size,
   1870                                        blk_align,
   1871                                        LIB_MEM_PADDING_ALIGN_NONE,
   1872                                        blk_qty_init,
   1873                                        blk_qty_max,
   1874                                        p_err);
   \                     ??Mem_DynPoolCreate_0: (+1)
   \   0000000C   0x9C0B             LDR      R4,[SP, #+44]
   \   0000000E   0x9404             STR      R4,[SP, #+16]
   \   00000010   0x9C0A             LDR      R4,[SP, #+40]
   \   00000012   0x9403             STR      R4,[SP, #+12]
   \   00000014   0x9C09             LDR      R4,[SP, #+36]
   \   00000016   0x9402             STR      R4,[SP, #+8]
   \   00000018   0x2401             MOVS     R4,#+1
   \   0000001A   0x9401             STR      R4,[SP, #+4]
   \   0000001C   0x9C08             LDR      R4,[SP, #+32]
   \   0000001E   0x9400             STR      R4,[SP, #+0]
   \   00000020   0x.... 0x....      BL       Mem_DynPoolCreateInternal
   1875          }
   \   00000024   0xB006             ADD      SP,SP,#+24
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
   1876          
   1877          
   1878          /*
   1879          *********************************************************************************************************
   1880          *                                        Mem_DynPoolCreateHW()
   1881          *
   1882          * Description : Creates a dynamic memory pool. Memory blocks will be padded according to memory segment's
   1883          *               properties.
   1884          *
   1885          * Argument(s) : p_name          Pointer to pool name.
   1886          *
   1887          *               p_pool          Pointer to pool data.
   1888          *
   1889          *               p_seg           Pointer to segment from which to allocate memory. Will allocate from
   1890          *                               general-purpose heap if null.
   1891          *
   1892          *               blk_size        Size of memory block to allocate from pool, in bytes. See Note #1.
   1893          *
   1894          *               blk_align       Required alignment of memory block, in bytes. MUST be a power of 2.
   1895          *
   1896          *               blk_qty_init    Initial number of elements to be allocated in pool.
   1897          *
   1898          *               blk_qty_max     Maximum number of elements that can be allocated from this pool. Set to
   1899          *                               LIB_MEM_BLK_QTY_UNLIMITED if no limit.
   1900          *
   1901          *               p_err           Pointer to variable that will receive the return error code from this function :
   1902          *
   1903          *                                   LIB_MEM_ERR_NONE                Operation was successful.
   1904          *
   1905          *                                   -------------------RETURNED BY Mem_DynPoolCreateInternal()-------------------
   1906          *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
   1907          *                                   LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
   1908          *                                   LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
   1909          *                                   LIB_MEM_ERR_SEG_OVF             Allocation would overflow memory segment.
   1910          *
   1911          * Return(s)   : None.
   1912          *
   1913          * Caller(s)   : Application.
   1914          *
   1915          * Note(s)     : (1) 'blk_size' must be big enough to fit a pointer since the pointer to the next free
   1916          *                   block is stored in the block itself (only when free/unused).
   1917          *********************************************************************************************************
   1918          */
   1919          

   \                                 In section .text, align 2, keep-with-next
   1920          void  Mem_DynPoolCreateHW (const  CPU_CHAR      *p_name,
   1921                                            MEM_DYN_POOL  *p_pool,
   1922                                            MEM_SEG       *p_seg,
   1923                                            CPU_SIZE_T     blk_size,
   1924                                            CPU_SIZE_T     blk_align,
   1925                                            CPU_SIZE_T     blk_qty_init,
   1926                                            CPU_SIZE_T     blk_qty_max,
   1927                                            LIB_ERR       *p_err)
   1928          {
   \                     Mem_DynPoolCreateHW: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   1929              if (p_seg == DEF_NULL) {                                    /* Alloc from heap if p_seg is null.                    */
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD101             BNE.N    ??Mem_DynPoolCreateHW_0
   1930          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
   1931                  p_seg = &Mem_SegHeap;
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable12_2
   1932          #else
   1933                 *p_err = LIB_MEM_ERR_NULL_PTR;
   1934                  return;
   1935          #endif
   1936              }
   1937          
   1938              Mem_DynPoolCreateInternal(p_name,
   1939                                        p_pool,
   1940                                        p_seg,
   1941                                        blk_size,
   1942                                        blk_align,
   1943                                        p_seg->PaddingAlign,
   1944                                        blk_qty_init,
   1945                                        blk_qty_max,
   1946                                        p_err);
   \                     ??Mem_DynPoolCreateHW_0: (+1)
   \   0000000C   0x9C0B             LDR      R4,[SP, #+44]
   \   0000000E   0x9404             STR      R4,[SP, #+16]
   \   00000010   0x9C0A             LDR      R4,[SP, #+40]
   \   00000012   0x9403             STR      R4,[SP, #+12]
   \   00000014   0x9C09             LDR      R4,[SP, #+36]
   \   00000016   0x9402             STR      R4,[SP, #+8]
   \   00000018   0x6914             LDR      R4,[R2, #+16]
   \   0000001A   0x9401             STR      R4,[SP, #+4]
   \   0000001C   0x9C08             LDR      R4,[SP, #+32]
   \   0000001E   0x9400             STR      R4,[SP, #+0]
   \   00000020   0x.... 0x....      BL       Mem_DynPoolCreateInternal
   1947          }
   \   00000024   0xB006             ADD      SP,SP,#+24
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
   1948          
   1949          
   1950          /*
   1951          *********************************************************************************************************
   1952          *                                          Mem_DynPoolBlkGet()
   1953          *
   1954          * Description : Gets a memory block from specified pool, growing it if needed.
   1955          *
   1956          * Argument(s) : p_pool  Pointer to pool data.
   1957          *
   1958          *               p_err   Pointer to variable that will receive the return error code from this function :
   1959          *
   1960          *                           LIB_MEM_ERR_NONE                    Operation was successful.
   1961          *                           LIB_MEM_ERR_NULL_PTR                Pool data pointer NULL.
   1962          *                           LIB_MEM_ERR_POOL_EMPTY              Pools is empty.
   1963          *
   1964          *                           ----------------------RETURNED BY Mem_SegAllocInternal()-----------------------
   1965          *                           LIB_MEM_ERR_INVALID_MEM_ALIGN       Invalid memory block alignment requested.
   1966          *                           LIB_MEM_ERR_INVALID_MEM_SIZE        Invalid memory block size specified.
   1967          *                           LIB_MEM_ERR_NULL_PTR                Error or segment data pointer NULL.
   1968          *                           LIB_MEM_ERR_SEG_OVF                 Allocation would overflow memory segment.
   1969          *
   1970          * Return(s)   : Pointer to memory block, if successful.
   1971          *
   1972          *               DEF_NULL, otherwise.
   1973          *
   1974          * Caller(s)   : Application.
   1975          *
   1976          * Note(s)     : none.
   1977          *********************************************************************************************************
   1978          */
   1979          

   \                                 In section .text, align 2, keep-with-next
   1980          void  *Mem_DynPoolBlkGet (MEM_DYN_POOL  *p_pool,
   1981                                    LIB_ERR       *p_err)
   1982          {
   \                     Mem_DynPoolBlkGet: (+1)
   \   00000000   0xB5FE             PUSH     {R1-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
   1983                     void      *p_blk;
   1984              const  CPU_CHAR  *p_pool_name;
   1985              CPU_SR_ALLOC();
   \   00000006   0x2600             MOVS     R6,#+0
   1986          
   1987          
   1988          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1989              if (p_err == DEF_NULL) {                                    /* Chk for NULL err ptr.                                */
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD101             BNE.N    ??Mem_DynPoolBlkGet_0
   1990                  CPU_SW_EXCEPTION(DEF_NULL);
   \   0000000C   0x.... 0x....      BL       CPU_SW_Exception
   1991              }
   1992          
   1993              if (p_pool == DEF_NULL) {                                   /* Chk for NULL pool data ptr.                          */
   \                     ??Mem_DynPoolBlkGet_0: (+1)
   \   00000010   0x2D00             CMP      R5,#+0
   \   00000012   0xD104             BNE.N    ??Mem_DynPoolBlkGet_1
   1994                 *p_err = LIB_MEM_ERR_NULL_PTR;
   \   00000014   0xF242 0x7011      MOVW     R0,#+10001
   \   00000018   0x8020             STRH     R0,[R4, #+0]
   1995                  return (DEF_NULL);
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE04C             B.N      ??Mem_DynPoolBlkGet_2
   1996              }
   1997          #endif
   1998          
   1999                                                                          /* Ensure pool is not empty if qty is limited.          */
   2000              if (p_pool->BlkQtyMax != LIB_MEM_BLK_QTY_UNLIMITED) {
   \                     ??Mem_DynPoolBlkGet_1: (+1)
   \   0000001E   0x6968             LDR      R0,[R5, #+20]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD01A             BEQ.N    ??Mem_DynPoolBlkGet_3
   2001                  CPU_CRITICAL_ENTER();
   \   00000024   0x.... 0x....      BL       CPU_SR_Save
   \   00000028   0x0006             MOVS     R6,R0
   \   0000002A   0x.... 0x....      BL       CPU_IntDisMeasStart
   2002                  if (p_pool->BlkAllocCnt >= p_pool->BlkQtyMax) {
   \   0000002E   0x69A8             LDR      R0,[R5, #+24]
   \   00000030   0x6969             LDR      R1,[R5, #+20]
   \   00000032   0x4288             CMP      R0,R1
   \   00000034   0xD309             BCC.N    ??Mem_DynPoolBlkGet_4
   2003                      CPU_CRITICAL_EXIT();
   \   00000036   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000003A   0x0030             MOVS     R0,R6
   \   0000003C   0x.... 0x....      BL       CPU_SR_Restore
   2004          
   2005                     *p_err = LIB_MEM_ERR_POOL_EMPTY;
   \   00000040   0xF242 0x70DE      MOVW     R0,#+10206
   \   00000044   0x8020             STRH     R0,[R4, #+0]
   2006                      return (DEF_NULL);
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xE036             B.N      ??Mem_DynPoolBlkGet_2
   2007                  }
   2008          
   2009                  p_pool->BlkAllocCnt++;
   \                     ??Mem_DynPoolBlkGet_4: (+1)
   \   0000004A   0x69A8             LDR      R0,[R5, #+24]
   \   0000004C   0x1C40             ADDS     R0,R0,#+1
   \   0000004E   0x61A8             STR      R0,[R5, #+24]
   2010                  CPU_CRITICAL_EXIT();
   \   00000050   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000054   0x0030             MOVS     R0,R6
   \   00000056   0x.... 0x....      BL       CPU_SR_Restore
   2011              }
   2012          
   2013                                                                          /* --------------- ALLOC FROM FREE LIST --------------- */
   2014              CPU_CRITICAL_ENTER();
   \                     ??Mem_DynPoolBlkGet_3: (+1)
   \   0000005A   0x.... 0x....      BL       CPU_SR_Save
   \   0000005E   0x0006             MOVS     R6,R0
   \   00000060   0x.... 0x....      BL       CPU_IntDisMeasStart
   2015              if (p_pool->BlkFreePtr != DEF_NULL) {
   \   00000064   0x6928             LDR      R0,[R5, #+16]
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD00C             BEQ.N    ??Mem_DynPoolBlkGet_5
   2016                  p_blk              = p_pool->BlkFreePtr;
   \   0000006A   0x692F             LDR      R7,[R5, #+16]
   2017                  p_pool->BlkFreePtr = *((void **)p_blk);
   \   0000006C   0x6838             LDR      R0,[R7, #+0]
   \   0000006E   0x6128             STR      R0,[R5, #+16]
   2018                  CPU_CRITICAL_EXIT();
   \   00000070   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000074   0x0030             MOVS     R0,R6
   \   00000076   0x.... 0x....      BL       CPU_SR_Restore
   2019          
   2020                 *p_err = LIB_MEM_ERR_NONE;
   \   0000007A   0xF242 0x7010      MOVW     R0,#+10000
   \   0000007E   0x8020             STRH     R0,[R4, #+0]
   2021          
   2022                  return (p_blk);
   \   00000080   0x0038             MOVS     R0,R7
   \   00000082   0xE019             B.N      ??Mem_DynPoolBlkGet_2
   2023              }
   2024              CPU_CRITICAL_EXIT();
   \                     ??Mem_DynPoolBlkGet_5: (+1)
   \   00000084   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000088   0x0030             MOVS     R0,R6
   \   0000008A   0x.... 0x....      BL       CPU_SR_Restore
   2025          
   2026                                                                          /* ------------------ ALLOC NEW BLK ------------------- */
   2027          #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
   2028              p_pool_name = p_pool->NamePtr;
   2029          #else
   2030              p_pool_name = DEF_NULL;
   \   0000008E   0x2000             MOVS     R0,#+0
   2031          #endif
   2032              p_blk = Mem_SegAllocInternal(p_pool_name,
   2033                                           p_pool->PoolSegPtr,
   2034                                           p_pool->BlkSize,
   2035                                           p_pool->BlkAlign,
   2036                                           p_pool->BlkPaddingAlign,
   2037                                           DEF_NULL,
   2038                                           p_err);
   \   00000090   0x9402             STR      R4,[SP, #+8]
   \   00000092   0x2100             MOVS     R1,#+0
   \   00000094   0x9101             STR      R1,[SP, #+4]
   \   00000096   0x68E9             LDR      R1,[R5, #+12]
   \   00000098   0x9100             STR      R1,[SP, #+0]
   \   0000009A   0x68AB             LDR      R3,[R5, #+8]
   \   0000009C   0x686A             LDR      R2,[R5, #+4]
   \   0000009E   0x6829             LDR      R1,[R5, #+0]
   \   000000A0   0x.... 0x....      BL       Mem_SegAllocInternal
   \   000000A4   0x0007             MOVS     R7,R0
   2039              if (*p_err != LIB_MEM_ERR_NONE) {
   \   000000A6   0xF9B4 0x0000      LDRSH    R0,[R4, #+0]
   \   000000AA   0xF242 0x7110      MOVW     R1,#+10000
   \   000000AE   0x4288             CMP      R0,R1
   \   000000B0   0xD001             BEQ.N    ??Mem_DynPoolBlkGet_6
   2040                  return (DEF_NULL);
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0xE000             B.N      ??Mem_DynPoolBlkGet_2
   2041              }
   2042          
   2043              return (p_blk);
   \                     ??Mem_DynPoolBlkGet_6: (+1)
   \   000000B6   0x0038             MOVS     R0,R7
   \                     ??Mem_DynPoolBlkGet_2: (+1)
   \   000000B8   0xBDFE             POP      {R1-R7,PC}       ;; return
   2044          }
   2045          
   2046          
   2047          /*
   2048          *********************************************************************************************************
   2049          *                                         Mem_DynPoolBlkFree()
   2050          *
   2051          * Description : Frees memory block, making it available for future use.
   2052          *
   2053          * Argument(s) : p_pool  Pointer to pool data.
   2054          *
   2055          *               p_blk   Pointer to first byte of memory block.
   2056          *
   2057          *               p_err   Pointer to variable that will receive the return error code from this function :
   2058          *
   2059          *                           LIB_MEM_ERR_NONE        Operation was successful.
   2060          *                           LIB_MEM_ERR_NULL_PTR    'p_pool' or 'p_blk' pointer passed is NULL.
   2061          *                           LIB_MEM_ERR_POOL_FULL   Pool is full.
   2062          *
   2063          * Return(s)   : none.
   2064          *
   2065          * Caller(s)   : Application.
   2066          *
   2067          * Note(s)     : none.
   2068          *********************************************************************************************************
   2069          */
   2070          

   \                                 In section .text, align 2, keep-with-next
   2071          void  Mem_DynPoolBlkFree (MEM_DYN_POOL  *p_pool,
   2072                                    void          *p_blk,
   2073                                    LIB_ERR       *p_err)
   2074          {
   \                     Mem_DynPoolBlkFree: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0014             MOVS     R4,R2
   2075              CPU_SR_ALLOC();
   \   00000008   0x2700             MOVS     R7,#+0
   2076          
   2077          
   2078          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   2079              if (p_err == DEF_NULL) {                                    /* Chk for NULL err ptr.                                */
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD101             BNE.N    ??Mem_DynPoolBlkFree_0
   2080                  CPU_SW_EXCEPTION(;);
   \   0000000E   0x.... 0x....      BL       CPU_SW_Exception
   2081              }
   2082          
   2083              if (p_pool == DEF_NULL) {                                   /* Chk for NULL pool data ptr.                          */
   \                     ??Mem_DynPoolBlkFree_0: (+1)
   \   00000012   0x2D00             CMP      R5,#+0
   \   00000014   0xD103             BNE.N    ??Mem_DynPoolBlkFree_1
   2084                 *p_err = LIB_MEM_ERR_NULL_PTR;
   \   00000016   0xF242 0x7011      MOVW     R0,#+10001
   \   0000001A   0x8020             STRH     R0,[R4, #+0]
   2085                  return;
   \   0000001C   0xE031             B.N      ??Mem_DynPoolBlkFree_2
   2086              }
   2087          
   2088              if (p_blk == DEF_NULL) {
   \                     ??Mem_DynPoolBlkFree_1: (+1)
   \   0000001E   0x2E00             CMP      R6,#+0
   \   00000020   0xD103             BNE.N    ??Mem_DynPoolBlkFree_3
   2089                 *p_err = LIB_MEM_ERR_NULL_PTR;
   \   00000022   0xF242 0x7011      MOVW     R0,#+10001
   \   00000026   0x8020             STRH     R0,[R4, #+0]
   2090                  return;
   \   00000028   0xE02B             B.N      ??Mem_DynPoolBlkFree_2
   2091              }
   2092          #endif
   2093          
   2094              if (p_pool->BlkQtyMax != LIB_MEM_BLK_QTY_UNLIMITED) {       /* Ensure pool is not full.                             */
   \                     ??Mem_DynPoolBlkFree_3: (+1)
   \   0000002A   0x6968             LDR      R0,[R5, #+20]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD018             BEQ.N    ??Mem_DynPoolBlkFree_4
   2095                  CPU_CRITICAL_ENTER();
   \   00000030   0x.... 0x....      BL       CPU_SR_Save
   \   00000034   0x0007             MOVS     R7,R0
   \   00000036   0x.... 0x....      BL       CPU_IntDisMeasStart
   2096                  if (p_pool->BlkAllocCnt == 0u) {
   \   0000003A   0x69A8             LDR      R0,[R5, #+24]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD108             BNE.N    ??Mem_DynPoolBlkFree_5
   2097                      CPU_CRITICAL_EXIT();
   \   00000040   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000044   0x0038             MOVS     R0,R7
   \   00000046   0x.... 0x....      BL       CPU_SR_Restore
   2098          
   2099                     *p_err = LIB_MEM_ERR_POOL_FULL;
   \   0000004A   0xF242 0x70DD      MOVW     R0,#+10205
   \   0000004E   0x8020             STRH     R0,[R4, #+0]
   2100                      return;
   \   00000050   0xE017             B.N      ??Mem_DynPoolBlkFree_2
   2101                  }
   2102          
   2103                  p_pool->BlkAllocCnt--;
   \                     ??Mem_DynPoolBlkFree_5: (+1)
   \   00000052   0x69A8             LDR      R0,[R5, #+24]
   \   00000054   0x1E40             SUBS     R0,R0,#+1
   \   00000056   0x61A8             STR      R0,[R5, #+24]
   2104                  CPU_CRITICAL_EXIT();
   \   00000058   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000005C   0x0038             MOVS     R0,R7
   \   0000005E   0x.... 0x....      BL       CPU_SR_Restore
   2105              }
   2106          
   2107              CPU_CRITICAL_ENTER();
   \                     ??Mem_DynPoolBlkFree_4: (+1)
   \   00000062   0x.... 0x....      BL       CPU_SR_Save
   \   00000066   0x0007             MOVS     R7,R0
   \   00000068   0x.... 0x....      BL       CPU_IntDisMeasStart
   2108             *((void **)p_blk)   = p_pool->BlkFreePtr;
   \   0000006C   0x6928             LDR      R0,[R5, #+16]
   \   0000006E   0x6030             STR      R0,[R6, #+0]
   2109              p_pool->BlkFreePtr = p_blk;
   \   00000070   0x612E             STR      R6,[R5, #+16]
   2110              CPU_CRITICAL_EXIT();
   \   00000072   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000076   0x0038             MOVS     R0,R7
   \   00000078   0x.... 0x....      BL       CPU_SR_Restore
   2111          
   2112             *p_err = LIB_MEM_ERR_NONE;
   \   0000007C   0xF242 0x7010      MOVW     R0,#+10000
   \   00000080   0x8020             STRH     R0,[R4, #+0]
   2113          }
   \                     ??Mem_DynPoolBlkFree_2: (+1)
   \   00000082   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   2114          
   2115          
   2116          /*
   2117          *********************************************************************************************************
   2118          *                                     Mem_DynPoolBlkNbrAvailGet()
   2119          *
   2120          * Description : Gets number of available blocks in dynamic memory pool. This call will fail with a
   2121          *               dynamic memory pool for which no limit was set at creation.
   2122          *
   2123          * Argument(s) : p_pool  Pointer to pool data.
   2124          *
   2125          *               p_err   Pointer to variable that will receive the return error code from this function :
   2126          *
   2127          *                           LIB_MEM_ERR_NONE                Operation was successful.
   2128          *                           LIB_MEM_ERR_NULL_PTR            'p_pool' pointer passed is NULL.
   2129          *                           LIB_MEM_ERR_POOL_UNLIMITED      Pool has no specified limit.
   2130          *
   2131          * Return(s)   : Number of blocks available in dynamic memory pool, if successful.
   2132          *
   2133          *               0, if pool is empty or if an error occurred.
   2134          *
   2135          * Caller(s)   : Application.
   2136          *
   2137          * Note(s)     : None.
   2138          *********************************************************************************************************
   2139          */
   2140          

   \                                 In section .text, align 2, keep-with-next
   2141          CPU_SIZE_T  Mem_DynPoolBlkNbrAvailGet (MEM_DYN_POOL  *p_pool,
   2142                                                 LIB_ERR       *p_err)
   2143          {
   \                     Mem_DynPoolBlkNbrAvailGet: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
   2144              CPU_SIZE_T  blk_nbr_avail;
   2145              CPU_SR_ALLOC();
   \   00000006   0x2600             MOVS     R6,#+0
   2146          
   2147          
   2148          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   2149              if (p_err == DEF_NULL) {                                    /* Chk for NULL err ptr.                                */
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD101             BNE.N    ??Mem_DynPoolBlkNbrAvailGet_0
   2150                  CPU_SW_EXCEPTION(0);
   \   0000000C   0x.... 0x....      BL       CPU_SW_Exception
   2151              }
   2152          
   2153              if (p_pool == DEF_NULL) {                                   /* Chk for NULL pool data ptr.                          */
   \                     ??Mem_DynPoolBlkNbrAvailGet_0: (+1)
   \   00000010   0x2D00             CMP      R5,#+0
   \   00000012   0xD104             BNE.N    ??Mem_DynPoolBlkNbrAvailGet_1
   2154                 *p_err = LIB_MEM_ERR_NULL_PTR;
   \   00000014   0xF242 0x7011      MOVW     R0,#+10001
   \   00000018   0x8020             STRH     R0,[R4, #+0]
   2155                  return (0u);
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE018             B.N      ??Mem_DynPoolBlkNbrAvailGet_2
   2156              }
   2157          #endif
   2158          
   2159              if (p_pool->BlkQtyMax != LIB_MEM_BLK_QTY_UNLIMITED) {
   \                     ??Mem_DynPoolBlkNbrAvailGet_1: (+1)
   \   0000001E   0x6968             LDR      R0,[R5, #+20]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD010             BEQ.N    ??Mem_DynPoolBlkNbrAvailGet_3
   2160                  CPU_CRITICAL_ENTER();
   \   00000024   0x.... 0x....      BL       CPU_SR_Save
   \   00000028   0x0006             MOVS     R6,R0
   \   0000002A   0x.... 0x....      BL       CPU_IntDisMeasStart
   2161                  blk_nbr_avail = p_pool->BlkQtyMax - p_pool->BlkAllocCnt;
   \   0000002E   0x6968             LDR      R0,[R5, #+20]
   \   00000030   0x69A9             LDR      R1,[R5, #+24]
   \   00000032   0x1A45             SUBS     R5,R0,R1
   2162                  CPU_CRITICAL_EXIT();
   \   00000034   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000038   0x0030             MOVS     R0,R6
   \   0000003A   0x.... 0x....      BL       CPU_SR_Restore
   2163          
   2164                 *p_err = LIB_MEM_ERR_NONE;
   \   0000003E   0xF242 0x7010      MOVW     R0,#+10000
   \   00000042   0x8020             STRH     R0,[R4, #+0]
   \   00000044   0xE003             B.N      ??Mem_DynPoolBlkNbrAvailGet_4
   2165              } else {
   2166                  blk_nbr_avail = 0u;
   \                     ??Mem_DynPoolBlkNbrAvailGet_3: (+1)
   \   00000046   0x2500             MOVS     R5,#+0
   2167                 *p_err         = LIB_MEM_ERR_POOL_UNLIMITED;
   \   00000048   0xF242 0x70DF      MOVW     R0,#+10207
   \   0000004C   0x8020             STRH     R0,[R4, #+0]
   2168              }
   2169          
   2170              return (blk_nbr_avail);
   \                     ??Mem_DynPoolBlkNbrAvailGet_4: (+1)
   \   0000004E   0x0028             MOVS     R0,R5
   \                     ??Mem_DynPoolBlkNbrAvailGet_2: (+1)
   \   00000050   0xBD70             POP      {R4-R6,PC}       ;; return
   2171          }
   2172          
   2173          
   2174          /*
   2175          *********************************************************************************************************
   2176          *                                           Mem_OutputUsage()
   2177          *
   2178          * Description : Outputs memory usage report through 'out_fnct'.
   2179          *
   2180          * Argument(s) : out_fnct        Pointer to output function.
   2181          *
   2182          *               print_details   DEF_YES, if the size of each allocation should be printed.
   2183          *                               DEF_NO,  otherwise.
   2184          *
   2185          *               p_err           Pointer to variable that will receive the return error code from this function :
   2186          *
   2187          *                                   LIB_MEM_ERR_NONE                Operation was successful.
   2188          *                                   LIB_MEM_ERR_NULL_PTR            'out_fnct' pointer passed is NULL.
   2189          *
   2190          *                                   ---------------------RETURNED BY Mem_SegRemSizeGet()--------------------
   2191          *                                   LIB_MEM_ERR_NULL_PTR            Segment data pointer NULL.
   2192          *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory alignment.
   2193          *
   2194          * Return(s)   : None.
   2195          *
   2196          * Caller(s)   : Application.
   2197          *
   2198          * Note(s)     : none.
   2199          *********************************************************************************************************
   2200          */
   2201          
   2202          #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
   2203          void  Mem_OutputUsage(void     (*out_fnct) (CPU_CHAR *),
   2204                                LIB_ERR   *p_err)
   2205          {
   2206              CPU_CHAR   str[DEF_INT_32U_NBR_DIG_MAX];
   2207              MEM_SEG   *p_seg;
   2208              CPU_SR_ALLOC();
   2209          
   2210          
   2211          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   2212              if (p_err == DEF_NULL) {                                    /* Chk for NULL err ptr.                                */
   2213                  CPU_SW_EXCEPTION(;);
   2214              }
   2215          
   2216              if (out_fnct == DEF_NULL) {                                 /* Chk for NULL out fnct ptr.                           */
   2217                 *p_err = LIB_MEM_ERR_NULL_PTR;
   2218                  return;
   2219              }
   2220          #endif
   2221          
   2222              out_fnct((CPU_CHAR *)"---------------- Memory allocation info ----------------\r\n");
   2223              out_fnct((CPU_CHAR *)"| Type    | Size       | Free size  | Name\r\n");
   2224              out_fnct((CPU_CHAR *)"|---------|------------|------------|-------------------\r\n");
   2225          
   2226              CPU_CRITICAL_ENTER();
   2227              p_seg = Mem_SegHeadPtr;
   2228              while (p_seg != DEF_NULL) {
   2229                  CPU_SIZE_T       rem_size;
   2230                  MEM_SEG_INFO     seg_info;
   2231                  MEM_ALLOC_INFO  *p_alloc;
   2232          
   2233          
   2234                  rem_size = Mem_SegRemSizeGet(p_seg, 1u, &seg_info, p_err);
   2235                  if (*p_err != LIB_MEM_ERR_NONE) {
   2236                      return;
   2237                  }
   2238          
   2239                  out_fnct((CPU_CHAR *)"| Section | ");
   2240          
   2241                  (void)Str_FmtNbr_Int32U(seg_info.TotalSize,
   2242                                          10u,
   2243                                          DEF_NBR_BASE_DEC,
   2244                                          ' ',
   2245                                          DEF_NO,
   2246                                          DEF_YES,
   2247                                         &str[0u]);
   2248          
   2249                  out_fnct(str);
   2250                  out_fnct((CPU_CHAR *)" | ");
   2251          
   2252                  (void)Str_FmtNbr_Int32U(rem_size,
   2253                                          10u,
   2254                                          DEF_NBR_BASE_DEC,
   2255                                          ' ',
   2256                                          DEF_NO,
   2257                                          DEF_YES,
   2258                                         &str[0u]);
   2259          
   2260                  out_fnct(str);
   2261                  out_fnct((CPU_CHAR *)" | ");
   2262                  out_fnct((p_seg->NamePtr != DEF_NULL) ? (CPU_CHAR *)p_seg->NamePtr : (CPU_CHAR *)"Unknown");
   2263                  out_fnct((CPU_CHAR *)"\r\n");
   2264          
   2265                  p_alloc = p_seg->AllocInfoHeadPtr;
   2266                  while (p_alloc != DEF_NULL) {
   2267                      out_fnct((CPU_CHAR *)"| -> Obj  | ");
   2268          
   2269                      (void)Str_FmtNbr_Int32U(p_alloc->Size,
   2270                                              10u,
   2271                                              DEF_NBR_BASE_DEC,
   2272                                              ' ',
   2273                                              DEF_NO,
   2274                                              DEF_YES,
   2275                                             &str[0u]);
   2276          
   2277                      out_fnct(str);
   2278                      out_fnct((CPU_CHAR *)" |            | ");
   2279          
   2280                      out_fnct((p_alloc->NamePtr != DEF_NULL) ? (CPU_CHAR *)p_alloc->NamePtr : (CPU_CHAR *)"Unknown");
   2281                      out_fnct((CPU_CHAR *)"\r\n");
   2282          
   2283                      p_alloc = p_alloc->NextPtr;
   2284                  }
   2285          
   2286                  p_seg = p_seg->NextPtr;
   2287              }
   2288              CPU_CRITICAL_EXIT();
   2289          
   2290             *p_err = LIB_MEM_ERR_NONE;
   2291          }
   2292          #endif
   2293          
   2294          
   2295          /*
   2296          *********************************************************************************************************
   2297          *********************************************************************************************************
   2298          *                                           LOCAL FUNCTIONS
   2299          *********************************************************************************************************
   2300          *********************************************************************************************************
   2301          */
   2302          
   2303          /*
   2304          *********************************************************************************************************
   2305          *                                       Mem_SegCreateCritical()
   2306          *
   2307          * Description : Creates a new memory segment to be used for runtime memory allocation or dynamic pools.
   2308          *
   2309          * Argument(s) : p_name          Pointer to segment name.
   2310          *
   2311          *               p_seg           Pointer to segment data. Must be allocated by caller.
   2312          *               -----           Argument validated by caller.
   2313          *
   2314          *               seg_base_addr   Segment's first byte address.
   2315          *
   2316          *               padding_align   Padding alignment, in bytes, that will be added to any allocated buffer
   2317          *                               from this memory segment. MUST be a power of 2.
   2318          *                               LIB_MEM_PADDING_ALIGN_NONE means no padding.
   2319          *               -------------   Argument validated by caller.
   2320          *
   2321          *               size            Total size of segment, in bytes.
   2322          *               ----            Argument validated by caller.
   2323          *
   2324          * Return(s)   : Pointer to segment data, if successful.
   2325          *
   2326          *               DEF_NULL, otherwise.
   2327          *
   2328          * Caller(s)   : Mem_PoolCreate(),
   2329          *               Mem_SegCreate().
   2330          *
   2331          * Note(s)     : (1) This function MUST be called within a CRITICAL_SECTION.
   2332          *********************************************************************************************************
   2333          */
   2334          

   \                                 In section .text, align 2, keep-with-next
   2335          static  void  Mem_SegCreateCritical(const  CPU_CHAR    *p_name,
   2336                                                     MEM_SEG     *p_seg,
   2337                                                     CPU_ADDR     seg_base_addr,
   2338                                                     CPU_SIZE_T   padding_align,
   2339                                                     CPU_SIZE_T   size)
   2340          {
   2341              p_seg->AddrBase         =  seg_base_addr;
   \                     Mem_SegCreateCritical: (+1)
   \   00000000   0x600A             STR      R2,[R1, #+0]
   2342              p_seg->AddrEnd          = (seg_base_addr + (size - 1u));
   \   00000002   0x9800             LDR      R0,[SP, #+0]
   \   00000004   0x1880             ADDS     R0,R0,R2
   \   00000006   0x1E40             SUBS     R0,R0,#+1
   \   00000008   0x6048             STR      R0,[R1, #+4]
   2343              p_seg->AddrNext         =  seg_base_addr;
   \   0000000A   0x608A             STR      R2,[R1, #+8]
   2344              p_seg->NextPtr          =  Mem_SegHeadPtr;
   \   0000000C   0x....             LDR.N    R0,??DataTable12
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x60C8             STR      R0,[R1, #+12]
   2345              p_seg->PaddingAlign     =  padding_align;
   \   00000012   0x610B             STR      R3,[R1, #+16]
   2346          
   2347          #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
   2348              p_seg->NamePtr          = p_name;
   2349              p_seg->AllocInfoHeadPtr = DEF_NULL;
   2350          #else
   2351              (void)p_name;
   2352          #endif
   2353          
   2354              Mem_SegHeadPtr = p_seg;
   \   00000014   0x....             LDR.N    R0,??DataTable12
   \   00000016   0x6001             STR      R1,[R0, #+0]
   2355          }
   \   00000018   0x4770             BX       LR               ;; return
   2356          
   2357          
   2358          /*
   2359          *********************************************************************************************************
   2360          *                                      Mem_SegOverlapChkCritical()
   2361          *
   2362          * Description : Checks if existing memory segment exists or overlaps with specified memory area.
   2363          *
   2364          * Argument(s) : seg_base_addr   Address of first byte of memory area.
   2365          *
   2366          *               size            Size of memory area, in bytes.
   2367          *
   2368          *               p_err       Pointer to variable that will receive the return error code from this function :
   2369          *
   2370          *                               LIB_MEM_ERR_INVALID_SEG_OVERLAP     Segment overlaps another existing segment.
   2371          *                               LIB_MEM_ERR_INVALID_SEG_EXISTS      Segment already exists.
   2372          *
   2373          * Return(s)   : Pointer to memory segment that overlaps.
   2374          *
   2375          *               DEF_NULL, otherwise.
   2376          *
   2377          * Caller(s)   : Mem_PoolCreate(),
   2378          *               Mem_SegCreate().
   2379          *
   2380          * Note(s)     : (1) This function MUST be called within a CRITICAL_SECTION.
   2381          *********************************************************************************************************
   2382          */
   2383          
   2384          #if  (LIB_MEM_CFG_HEAP_SIZE      >  0u)

   \                                 In section .text, align 2, keep-with-next
   2385          static  MEM_SEG  *Mem_SegOverlapChkCritical (CPU_ADDR     seg_base_addr,
   2386                                                       CPU_SIZE_T   size,
   2387                                                       LIB_ERR     *p_err)
   2388          {
   \                     Mem_SegOverlapChkCritical: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   2389              MEM_SEG   *p_seg_chk;
   2390              CPU_ADDR   seg_new_end;
   2391              CPU_ADDR   seg_chk_start;
   2392              CPU_ADDR   seg_chk_end;
   2393          
   2394          
   2395              seg_new_end = seg_base_addr + (size - 1u);
   \   00000002   0x1809             ADDS     R1,R1,R0
   \   00000004   0x1E4B             SUBS     R3,R1,#+1
   2396              p_seg_chk   = Mem_SegHeadPtr;
   \   00000006   0x....             LDR.N    R1,??DataTable12
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0xE000             B.N      ??Mem_SegOverlapChkCritical_0
   2397          
   2398              while (p_seg_chk != DEF_NULL) {
   2399                  seg_chk_start = (CPU_ADDR)p_seg_chk->AddrBase;
   2400                  seg_chk_end   = (CPU_ADDR)p_seg_chk->AddrEnd;
   2401          
   2402                  if ((seg_base_addr == seg_chk_start) && (seg_new_end == seg_chk_end)) {
   2403                     *p_err = LIB_MEM_ERR_INVALID_SEG_EXISTS;
   2404                      return (p_seg_chk);
   2405                  } else if (((seg_base_addr >= seg_chk_start) && (seg_base_addr <= seg_chk_end)) ||
   2406                             ((seg_base_addr <= seg_chk_start) && (seg_new_end   >= seg_chk_start))) {
   2407                     *p_err = LIB_MEM_ERR_INVALID_SEG_OVERLAP;
   2408                      return (p_seg_chk);
   2409                  }
   2410          
   2411                  p_seg_chk = p_seg_chk->NextPtr;
   \                     ??Mem_SegOverlapChkCritical_1: (+1)
   \   0000000C   0x68C9             LDR      R1,[R1, #+12]
   \                     ??Mem_SegOverlapChkCritical_0: (+1)
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD017             BEQ.N    ??Mem_SegOverlapChkCritical_2
   \   00000012   0x680C             LDR      R4,[R1, #+0]
   \   00000014   0x684D             LDR      R5,[R1, #+4]
   \   00000016   0x42A0             CMP      R0,R4
   \   00000018   0xD106             BNE.N    ??Mem_SegOverlapChkCritical_3
   \   0000001A   0x42AB             CMP      R3,R5
   \   0000001C   0xD104             BNE.N    ??Mem_SegOverlapChkCritical_3
   \   0000001E   0xF44F 0x501E      MOV      R0,#+10112
   \   00000022   0x8010             STRH     R0,[R2, #+0]
   \   00000024   0x0008             MOVS     R0,R1
   \   00000026   0xE010             B.N      ??Mem_SegOverlapChkCritical_4
   \                     ??Mem_SegOverlapChkCritical_3: (+1)
   \   00000028   0x42A0             CMP      R0,R4
   \   0000002A   0xD301             BCC.N    ??Mem_SegOverlapChkCritical_5
   \   0000002C   0x4285             CMP      R5,R0
   \   0000002E   0xD203             BCS.N    ??Mem_SegOverlapChkCritical_6
   \                     ??Mem_SegOverlapChkCritical_5: (+1)
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD3EB             BCC.N    ??Mem_SegOverlapChkCritical_1
   \   00000034   0x42A3             CMP      R3,R4
   \   00000036   0xD3E9             BCC.N    ??Mem_SegOverlapChkCritical_1
   \                     ??Mem_SegOverlapChkCritical_6: (+1)
   \   00000038   0xF242 0x707F      MOVW     R0,#+10111
   \   0000003C   0x8010             STRH     R0,[R2, #+0]
   \   0000003E   0x0008             MOVS     R0,R1
   \   00000040   0xE003             B.N      ??Mem_SegOverlapChkCritical_4
   2412              }
   2413          
   2414             *p_err = LIB_MEM_ERR_NONE;
   \                     ??Mem_SegOverlapChkCritical_2: (+1)
   \   00000042   0xF242 0x7010      MOVW     R0,#+10000
   \   00000046   0x8010             STRH     R0,[R2, #+0]
   2415          
   2416              return (DEF_NULL);
   \   00000048   0x2000             MOVS     R0,#+0
   \                     ??Mem_SegOverlapChkCritical_4: (+1)
   \   0000004A   0xBC30             POP      {R4,R5}
   \   0000004C   0x4770             BX       LR               ;; return
   2417          }
   2418          #endif
   2419          
   2420          
   2421          /*
   2422          *********************************************************************************************************
   2423          *                                       Mem_SegAllocInternal()
   2424          *
   2425          * Description : Allocates memory from specified segment.
   2426          *
   2427          * Argument(s) : p_name  Pointer to allocated object name. Used for allocations tracking. May be DEF_NULL.
   2428          *
   2429          *               p_seg           Pointer to segment from which to allocate memory.
   2430          *               -----           Argument validated by caller.
   2431          *
   2432          *               size            Size of memory block to allocate, in bytes.
   2433          *
   2434          *               align           Required alignment of memory block, in bytes. MUST be a power of 2.
   2435          *
   2436          *               padding_align   Padding alignment, in bytes, that will be added to any allocated buffer from
   2437          *                               this memory segment. MUST be a power of 2. LIB_MEM_PADDING_ALIGN_NONE
   2438          *                               means no padding.
   2439          *
   2440          *               p_bytes_reqd    Pointer to variable that will receive the number of free bytes missing for
   2441          *                               the allocation to succeed. Set to DEF_NULL to skip calculation.
   2442          *
   2443          *               p_err           Pointer to variable that will receive the return error code from this function :
   2444          *
   2445          *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
   2446          *                                   LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
   2447          *                                   LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
   2448          *
   2449          *                                   ------------------RETURNED BY Mem_SegAllocExtCritical()------------------
   2450          *                                   LIB_MEM_ERR_SEG_OVF             Allocation would overflow memory segment.
   2451          *
   2452          * Return(s)   : Pointer to allocated memory block, if successful.
   2453          *
   2454          *               DEF_NULL, otherwise.
   2455          *
   2456          * Caller(s)   : Mem_DynPoolBlkGet(),
   2457          *               Mem_DynPoolCreateInternal(),
   2458          *               Mem_HeapAlloc(),
   2459          *               Mem_PoolCreate(),
   2460          *               Mem_SegAlloc(),
   2461          *               Mem_SegAllocExt(),
   2462          *               Mem_SegAllocHW().
   2463          *
   2464          * Note(s)     : none.
   2465          *********************************************************************************************************
   2466          */
   2467          

   \                                 In section .text, align 2, keep-with-next
   2468          static  void  *Mem_SegAllocInternal (const  CPU_CHAR    *p_name,
   2469                                                      MEM_SEG     *p_seg,
   2470                                                      CPU_SIZE_T   size,
   2471                                                      CPU_SIZE_T   align,
   2472                                                      CPU_SIZE_T   padding_align,
   2473                                                      CPU_SIZE_T  *p_bytes_reqd,
   2474                                                      LIB_ERR     *p_err)
   2475          {
   \                     Mem_SegAllocInternal: (+1)
   \   00000000   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0017             MOVS     R7,R2
   \   00000008   0x4698             MOV      R8,R3
   2476              void  *p_blk;
   2477              CPU_SR_ALLOC();
   \   0000000A   0x2500             MOVS     R5,#+0
   \   0000000C   0x9C0A             LDR      R4,[SP, #+40]
   2478          
   2479          
   2480          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   2481              if (p_err == DEF_NULL) {                                    /* Chk for null err ptr.                                */
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD101             BNE.N    ??Mem_SegAllocInternal_0
   2482                  CPU_SW_EXCEPTION(DEF_NULL);
   \   00000012   0x.... 0x....      BL       CPU_SW_Exception
   2483              }
   2484          
   2485              if (size < 1u) {                                            /* Chk for invalid sized mem req.                       */
   \                     ??Mem_SegAllocInternal_0: (+1)
   \   00000016   0x2F00             CMP      R7,#+0
   \   00000018   0xD104             BNE.N    ??Mem_SegAllocInternal_1
   2486                 *p_err = LIB_MEM_ERR_INVALID_MEM_SIZE;
   \   0000001A   0xF242 0x7074      MOVW     R0,#+10100
   \   0000001E   0x8020             STRH     R0,[R4, #+0]
   2487                  return (DEF_NULL);
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xE033             B.N      ??Mem_SegAllocInternal_2
   2488              }
   2489          
   2490              if (MATH_IS_PWR2(align) != DEF_YES) {                       /* Chk that align is a pwr of 2.                        */
   \                     ??Mem_SegAllocInternal_1: (+1)
   \   00000024   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000028   0xD006             BEQ.N    ??Mem_SegAllocInternal_3
   \   0000002A   0xF1B8 0x0001      SUBS     R0,R8,#+1
   \   0000002E   0xEA18 0x0F00      TST      R8,R0
   \   00000032   0xD101             BNE.N    ??Mem_SegAllocInternal_3
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0xE000             B.N      ??Mem_SegAllocInternal_4
   \                     ??Mem_SegAllocInternal_3: (+1)
   \   00000038   0x2000             MOVS     R0,#+0
   \                     ??Mem_SegAllocInternal_4: (+1)
   \   0000003A   0x2801             CMP      R0,#+1
   \   0000003C   0xD004             BEQ.N    ??Mem_SegAllocInternal_5
   2491                 *p_err = LIB_MEM_ERR_INVALID_MEM_ALIGN;
   \   0000003E   0xF242 0x7075      MOVW     R0,#+10101
   \   00000042   0x8020             STRH     R0,[R4, #+0]
   2492                  return (DEF_NULL);
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xE021             B.N      ??Mem_SegAllocInternal_2
   2493              }
   2494          #endif
   2495          
   2496              CPU_CRITICAL_ENTER();
   \                     ??Mem_SegAllocInternal_5: (+1)
   \   00000048   0x.... 0x....      BL       CPU_SR_Save
   \   0000004C   0x0005             MOVS     R5,R0
   \   0000004E   0x.... 0x....      BL       CPU_IntDisMeasStart
   2497              p_blk = Mem_SegAllocExtCritical(p_seg,
   2498                                              size,
   2499                                              align,
   2500                                              padding_align,
   2501                                              p_bytes_reqd,
   2502                                              p_err);
   \   00000052   0x9401             STR      R4,[SP, #+4]
   \   00000054   0x9809             LDR      R0,[SP, #+36]
   \   00000056   0x9000             STR      R0,[SP, #+0]
   \   00000058   0x9B08             LDR      R3,[SP, #+32]
   \   0000005A   0x4642             MOV      R2,R8
   \   0000005C   0x0039             MOVS     R1,R7
   \   0000005E   0x0030             MOVS     R0,R6
   \   00000060   0x.... 0x....      BL       Mem_SegAllocExtCritical
   \   00000064   0x0006             MOVS     R6,R0
   2503              if (*p_err != LIB_MEM_ERR_NONE) {
   \   00000066   0xF9B4 0x0000      LDRSH    R0,[R4, #+0]
   \   0000006A   0xF242 0x7110      MOVW     R1,#+10000
   \   0000006E   0x4288             CMP      R0,R1
   \   00000070   0xD006             BEQ.N    ??Mem_SegAllocInternal_6
   2504                  CPU_CRITICAL_EXIT();
   \   00000072   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000076   0x0028             MOVS     R0,R5
   \   00000078   0x.... 0x....      BL       CPU_SR_Restore
   2505                  return (DEF_NULL);
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0xE005             B.N      ??Mem_SegAllocInternal_2
   2506              }
   2507          
   2508          #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)                    /* Track alloc if req'd.                                */
   2509              Mem_SegAllocTrackCritical(p_name,
   2510                                        p_seg,
   2511                                        size,
   2512                                        p_err);
   2513              if (*p_err != LIB_MEM_ERR_NONE) {
   2514                  CPU_CRITICAL_EXIT();
   2515                  return (DEF_NULL);
   2516              }
   2517          #else
   2518              (void)p_name;
   2519          #endif
   2520              CPU_CRITICAL_EXIT();
   \                     ??Mem_SegAllocInternal_6: (+1)
   \   00000080   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000084   0x0028             MOVS     R0,R5
   \   00000086   0x.... 0x....      BL       CPU_SR_Restore
   2521          
   2522              return (p_blk);
   \   0000008A   0x0030             MOVS     R0,R6
   \                     ??Mem_SegAllocInternal_2: (+1)
   \   0000008C   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   2523          }
   2524          
   2525          
   2526          /*
   2527          *********************************************************************************************************
   2528          *                                      Mem_SegAllocExtCritical()
   2529          *
   2530          * Description : Allocates memory from specified segment.
   2531          *
   2532          * Argument(s) : p_seg           Pointer to segment from which to allocate memory.
   2533          *
   2534          *               size            Size of memory block to allocate, in bytes.
   2535          *
   2536          *               align           Required alignment of memory block, in bytes. MUST be a power of 2.
   2537          *
   2538          *               padding_align   Padding alignment, in bytes, that will be added to any allocated buffer from
   2539          *                               this memory segment. MUST be a power of 2. LIB_MEM_PADDING_ALIGN_NONE
   2540          *                               means no padding.
   2541          *
   2542          *               p_bytes_reqd    Pointer to variable that will receive the number of free bytes missing for
   2543          *                               the allocation to succeed. Set to DEF_NULL to skip calculation.
   2544          *
   2545          *               p_err           Pointer to variable that will receive the return error code from this function :
   2546          *
   2547          *                                   LIB_MEM_ERR_SEG_OVF     Allocation would overflow memory segment.
   2548          *
   2549          * Return(s)   : Pointer to allocated memory block, if successful.
   2550          *
   2551          *               DEF_NULL, otherwise.
   2552          *
   2553          * Caller(s)   : Mem_PoolCreate(),
   2554          *               Mem_SegAllocInternal(),
   2555          *               Mem_SegAllocTrackCritical().
   2556          *
   2557          * Note(s)     : (1) This function MUST be called within a CRITICAL_SECTION.
   2558          *********************************************************************************************************
   2559          */
   2560          

   \                                 In section .text, align 2, keep-with-next
   2561          static  void  *Mem_SegAllocExtCritical (MEM_SEG     *p_seg,
   2562                                                  CPU_SIZE_T   size,
   2563                                                  CPU_SIZE_T   align,
   2564                                                  CPU_SIZE_T   padding_align,
   2565                                                  CPU_SIZE_T  *p_bytes_reqd,
   2566                                                  LIB_ERR     *p_err)
   2567          {
   \                     Mem_SegAllocExtCritical: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   2568              CPU_ADDR    blk_addr;
   2569              CPU_ADDR    addr_next;
   2570              CPU_SIZE_T  size_rem_seg;
   2571              CPU_SIZE_T  size_tot_blk;
   2572              CPU_SIZE_T  blk_align = DEF_MAX(align, padding_align);
   \   00000002   0x4293             CMP      R3,R2
   \   00000004   0xD300             BCC.N    ??Mem_SegAllocExtCritical_0
   \                     ??Mem_SegAllocExtCritical_1: (+1)
   \   00000006   0x001A             MOVS     R2,R3
   2573          
   2574          
   2575              blk_addr     = MATH_ROUND_INC_UP_PWR2(p_seg->AddrNext,      /* Compute align'ed blk addr.                           */
   2576                                                    blk_align);
   \                     ??Mem_SegAllocExtCritical_0: (+1)
   \   00000008   0x6884             LDR      R4,[R0, #+8]
   \   0000000A   0x1E55             SUBS     R5,R2,#+1
   \   0000000C   0x422C             TST      R4,R5
   \   0000000E   0xD101             BNE.N    ??Mem_SegAllocExtCritical_2
   \   00000010   0x2400             MOVS     R4,#+0
   \   00000012   0xE000             B.N      ??Mem_SegAllocExtCritical_3
   \                     ??Mem_SegAllocExtCritical_2: (+1)
   \   00000014   0x0014             MOVS     R4,R2
   \                     ??Mem_SegAllocExtCritical_3: (+1)
   \   00000016   0x6885             LDR      R5,[R0, #+8]
   \   00000018   0x1E52             SUBS     R2,R2,#+1
   \   0000001A   0xEA35 0x0202      BICS     R2,R5,R2
   \   0000001E   0x18A2             ADDS     R2,R4,R2
   2577              addr_next    = MATH_ROUND_INC_UP_PWR2(blk_addr + size,      /* Compute addr of next alloc.                          */
   2578                                                    padding_align);
   \   00000020   0x188C             ADDS     R4,R1,R2
   \   00000022   0x1E5D             SUBS     R5,R3,#+1
   \   00000024   0x422C             TST      R4,R5
   \   00000026   0xD101             BNE.N    ??Mem_SegAllocExtCritical_4
   \   00000028   0x2400             MOVS     R4,#+0
   \   0000002A   0xE000             B.N      ??Mem_SegAllocExtCritical_5
   \                     ??Mem_SegAllocExtCritical_4: (+1)
   \   0000002C   0x001C             MOVS     R4,R3
   \                     ??Mem_SegAllocExtCritical_5: (+1)
   \   0000002E   0x1889             ADDS     R1,R1,R2
   \   00000030   0x1E5B             SUBS     R3,R3,#+1
   \   00000032   0x4399             BICS     R1,R1,R3
   \   00000034   0x1863             ADDS     R3,R4,R1
   2579              size_rem_seg = (p_seg->AddrEnd - p_seg->AddrNext) + 1u;
   \   00000036   0x6841             LDR      R1,[R0, #+4]
   \   00000038   0x6884             LDR      R4,[R0, #+8]
   \   0000003A   0x1B09             SUBS     R1,R1,R4
   \   0000003C   0x1C4C             ADDS     R4,R1,#+1
   2580              size_tot_blk =  addr_next      - p_seg->AddrNext;           /* Compute tot blk size including align and padding.    */
   \   0000003E   0x6881             LDR      R1,[R0, #+8]
   \   00000040   0x1A5D             SUBS     R5,R3,R1
   \   00000042   0x9903             LDR      R1,[SP, #+12]
   2581              if (size_rem_seg < size_tot_blk) {                          /* If seg doesn't have enough space ...                 */
   \   00000044   0x42AC             CMP      R4,R5
   \   00000046   0xD209             BCS.N    ??Mem_SegAllocExtCritical_6
   \   00000048   0x9802             LDR      R0,[SP, #+8]
   2582                  if (p_bytes_reqd != DEF_NULL) {                         /* ... calc nbr of req'd bytes.                         */
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD001             BEQ.N    ??Mem_SegAllocExtCritical_7
   2583                     *p_bytes_reqd = size_tot_blk - size_rem_seg;
   \   0000004E   0x1B2A             SUBS     R2,R5,R4
   \   00000050   0x6002             STR      R2,[R0, #+0]
   2584                  }
   2585          
   2586                 *p_err = LIB_MEM_ERR_SEG_OVF;
   \                     ??Mem_SegAllocExtCritical_7: (+1)
   \   00000052   0xF242 0x70D9      MOVW     R0,#+10201
   \   00000056   0x8008             STRH     R0,[R1, #+0]
   2587                  return (DEF_NULL);
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xE004             B.N      ??Mem_SegAllocExtCritical_8
   2588              }
   2589          
   2590              p_seg->AddrNext = addr_next;
   \                     ??Mem_SegAllocExtCritical_6: (+1)
   \   0000005C   0x6083             STR      R3,[R0, #+8]
   2591          
   2592             *p_err = LIB_MEM_ERR_NONE;
   \   0000005E   0xF242 0x7010      MOVW     R0,#+10000
   \   00000062   0x8008             STRH     R0,[R1, #+0]
   2593          
   2594              return ((void *)blk_addr);
   \   00000064   0x0010             MOVS     R0,R2
   \                     ??Mem_SegAllocExtCritical_8: (+1)
   \   00000066   0xBC30             POP      {R4,R5}
   \   00000068   0x4770             BX       LR               ;; return
   2595          }
   2596          
   2597          
   2598          /*
   2599          *********************************************************************************************************
   2600          *                                     Mem_SegAllocTrackCritical()
   2601          *
   2602          * Description : Tracks segment allocation, adding the 'size' of the allocation under the 'p_name' entry.
   2603          *
   2604          * Argument(s) : p_name  Pointer to the name of the object. This string is not copied and its memory should
   2605          *                       remain accessible at all times.
   2606          *
   2607          *               p_seg   Pointer to segment data.
   2608          *
   2609          *               size    Allocation size, in bytes.
   2610          *
   2611          *               p_err   Pointer to variable that will receive the return error code from this function :
   2612          *
   2613          *                           LIB_MEM_ERR_HEAP_EMPTY      No more memory available on heap
   2614          *
   2615          *                           --------------RETURNED BY Mem_SegAllocExtCritical()---------------
   2616          *                           LIB_MEM_ERR_SEG_OVF         Allocation would overflow memory segment.
   2617          *
   2618          * Return(s)   : none.
   2619          *
   2620          * Caller(s)   : Mem_PoolCreate(),
   2621          *               Mem_SegAllocInternal().
   2622          *
   2623          * Note(s)     : none.
   2624          *********************************************************************************************************
   2625          */
   2626          
   2627          #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
   2628          static  void  Mem_SegAllocTrackCritical (const  CPU_CHAR    *p_name,
   2629                                                          MEM_SEG     *p_seg,
   2630                                                          CPU_SIZE_T   size,
   2631                                                          LIB_ERR     *p_err)
   2632          {
   2633              MEM_ALLOC_INFO  *p_alloc;
   2634          
   2635          
   2636                                                                          /* ------- UPDATE ALLOC INFO LIST, IF POSSIBLE -------- */
   2637              p_alloc = p_seg->AllocInfoHeadPtr;
   2638              while (p_alloc != DEF_NULL) {
   2639                  if (p_alloc->NamePtr == p_name) {
   2640                      p_alloc->Size += size;
   2641                     *p_err = LIB_MEM_ERR_NONE;
   2642                      return;
   2643                  }
   2644          
   2645                  p_alloc = p_alloc->NextPtr;
   2646              }
   2647          
   2648                                                                          /* --------- ADD NEW ALLOC INFO ENTRY IN LIST --------- */
   2649              p_alloc = (MEM_ALLOC_INFO *)Mem_SegAllocExtCritical(&Mem_SegHeap,             /* Alloc new alloc info struct on heap.                 */
   2650                                                                   sizeof(MEM_ALLOC_INFO),
   2651                                                                   sizeof(CPU_ALIGN),
   2652                                                                   LIB_MEM_PADDING_ALIGN_NONE,
   2653                                                                   DEF_NULL,
   2654                                                                   p_err);
   2655              if (*p_err != LIB_MEM_ERR_NONE) {
   2656                  return;
   2657              }
   2658          
   2659              p_alloc->NamePtr = p_name;                                  /* Populate alloc info.                                 */
   2660              p_alloc->Size    = size;
   2661          
   2662              p_alloc->NextPtr        = p_seg->AllocInfoHeadPtr;          /* Prepend new item in list.                            */
   2663              p_seg->AllocInfoHeadPtr = p_alloc;
   2664          }
   2665          #endif
   2666          
   2667          
   2668          /*
   2669          *********************************************************************************************************
   2670          *                                     Mem_DynPoolCreateInternal()
   2671          *
   2672          * Description : Creates a dynamic memory pool.
   2673          *
   2674          * Argument(s) : p_name              Pointer to pool name.
   2675          *
   2676          *               p_pool              Pointer to pool data.
   2677          *
   2678          *               p_seg               Pointer to segment from which to allocate memory.
   2679          *
   2680          *               blk_size            Size of memory block to allocate from pool, in bytes. See Note #1.
   2681          *
   2682          *               blk_align           Required alignment of memory block, in bytes. MUST be a power of 2.
   2683          *
   2684          *               blk_padding_align   Block's padding alignment, in bytes, that will be added at the end
   2685          *                                   of block's buffer. MUST be a power of 2. LIB_MEM_PADDING_ALIGN_NONE
   2686          *                                   means no padding.
   2687          *
   2688          *               blk_qty_init        Initial number of elements to be allocated in pool.
   2689          *
   2690          *               blk_qty_max         Maximum number of elements that can be allocated from this pool. Set to
   2691          *                                   LIB_MEM_BLK_QTY_UNLIMITED if no limit.
   2692          *
   2693          *               p_err           Pointer to variable that will receive the return error code from this function :
   2694          *
   2695          *                                   LIB_MEM_ERR_INVALID_BLK_ALIGN   Invalid requested block alignment.
   2696          *                                   LIB_MEM_ERR_INVALID_BLK_SIZE    Invalid requested block size.
   2697          *                                   LIB_MEM_ERR_INVALID_BLK_NBR     Invalid requested block quantity max.
   2698          *                                   LIB_MEM_ERR_NULL_PTR            Pool data pointer NULL.
   2699          *
   2700          *                                   ------------------RETURNED BY Mem_SegAllocInternal()-------------------
   2701          *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
   2702          *                                   LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
   2703          *                                   LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
   2704          *                                   LIB_MEM_ERR_SEG_OVF             Allocation would overflow memory segment.
   2705          *
   2706          * Return(s)   : None.
   2707          *
   2708          * Caller(s)   : Mem_DynPoolCreate(),
   2709          *               Mem_DynPoolCreateHW().
   2710          *
   2711          * Note(s)     : (1) 'blk_size' must be big enough to fit a pointer since the pointer to the next free
   2712          *                   block is stored in the block itself (only when free/unused).
   2713          *********************************************************************************************************
   2714          */
   2715          

   \                                 In section .text, align 2, keep-with-next
   2716          static  void  Mem_DynPoolCreateInternal (const  CPU_CHAR      *p_name,
   2717                                                          MEM_DYN_POOL  *p_pool,
   2718                                                          MEM_SEG       *p_seg,
   2719                                                          CPU_SIZE_T     blk_size,
   2720                                                          CPU_SIZE_T     blk_align,
   2721                                                          CPU_SIZE_T     blk_padding_align,
   2722                                                          CPU_SIZE_T     blk_qty_init,
   2723                                                          CPU_SIZE_T     blk_qty_max,
   2724                                                          LIB_ERR       *p_err)
   2725          {
   \                     Mem_DynPoolCreateInternal: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   2726              CPU_INT08U  *p_blks          = DEF_NULL;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x9C0E             LDR      R4,[SP, #+56]
   \   00000010   0xF8DD 0x803C      LDR      R8,[SP, #+60]
   2727              CPU_SIZE_T   blk_size_align;
   2728              CPU_SIZE_T   blk_align_worst = DEF_MAX(blk_align, blk_padding_align);
   \   00000014   0x45A0             CMP      R8,R4
   \   00000016   0xD201             BCS.N    ??Mem_DynPoolCreateInternal_0
   \   00000018   0x46A3             MOV      R11,R4
   \   0000001A   0xE000             B.N      ??Mem_DynPoolCreateInternal_1
   \                     ??Mem_DynPoolCreateInternal_0: (+1)
   \   0000001C   0x46C3             MOV      R11,R8
   \                     ??Mem_DynPoolCreateInternal_1: (+1)
   \   0000001E   0xF8DD 0xA048      LDR      R10,[SP, #+72]
   2729          
   2730          
   2731          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   2732              if (p_err == DEF_NULL) {                                    /* Chk for NULL err ptr.                                */
   \   00000022   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000026   0xD101             BNE.N    ??Mem_DynPoolCreateInternal_2
   2733                  CPU_SW_EXCEPTION(;);
   \   00000028   0x.... 0x....      BL       CPU_SW_Exception
   2734              }
   2735          
   2736              if (p_pool == DEF_NULL) {                                   /* Chk for NULL pool data ptr.                          */
   \                     ??Mem_DynPoolCreateInternal_2: (+1)
   \   0000002C   0x2D00             CMP      R5,#+0
   \   0000002E   0xD104             BNE.N    ??Mem_DynPoolCreateInternal_3
   2737                 *p_err = LIB_MEM_ERR_NULL_PTR;
   \   00000030   0xF242 0x7011      MOVW     R0,#+10001
   \   00000034   0xF8AA 0x0000      STRH     R0,[R10, #+0]
   2738                  return;
   \   00000038   0xE07F             B.N      ??Mem_DynPoolCreateInternal_4
   2739              }
   2740          
   2741              if (blk_size < 1u) {                                        /* Chk for inv blk size.                                */
   \                     ??Mem_DynPoolCreateInternal_3: (+1)
   \   0000003A   0x2F00             CMP      R7,#+0
   \   0000003C   0xD104             BNE.N    ??Mem_DynPoolCreateInternal_5
   2742                 *p_err = LIB_MEM_ERR_INVALID_BLK_SIZE;
   \   0000003E   0xF242 0x7093      MOVW     R0,#+10131
   \   00000042   0xF8AA 0x0000      STRH     R0,[R10, #+0]
   2743                  return;
   \   00000046   0xE078             B.N      ??Mem_DynPoolCreateInternal_4
   2744              }
   \                     ??Mem_DynPoolCreateInternal_5: (+1)
   \   00000048   0xF8DD 0x9044      LDR      R9,[SP, #+68]
   2745          
   2746              if ((blk_qty_max  != LIB_MEM_BLK_QTY_UNLIMITED) &&          /* Chk for invalid blk qty.                             */
   2747                  (blk_qty_init >  blk_qty_max)) {
   \   0000004C   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000050   0xD007             BEQ.N    ??Mem_DynPoolCreateInternal_6
   \   00000052   0x9810             LDR      R0,[SP, #+64]
   \   00000054   0x4581             CMP      R9,R0
   \   00000056   0xD204             BCS.N    ??Mem_DynPoolCreateInternal_6
   2748                 *p_err = LIB_MEM_ERR_INVALID_BLK_NBR;
   \   00000058   0xF242 0x7092      MOVW     R0,#+10130
   \   0000005C   0xF8AA 0x0000      STRH     R0,[R10, #+0]
   2749                  return;
   \   00000060   0xE06B             B.N      ??Mem_DynPoolCreateInternal_4
   2750              }
   2751          
   2752              if (MATH_IS_PWR2(blk_align) != DEF_YES) {                   /* Chk for illegal align spec.                          */
   \                     ??Mem_DynPoolCreateInternal_6: (+1)
   \   00000062   0x2C00             CMP      R4,#+0
   \   00000064   0xD004             BEQ.N    ??Mem_DynPoolCreateInternal_7
   \   00000066   0x1E60             SUBS     R0,R4,#+1
   \   00000068   0x4204             TST      R4,R0
   \   0000006A   0xD101             BNE.N    ??Mem_DynPoolCreateInternal_7
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0xE000             B.N      ??Mem_DynPoolCreateInternal_8
   \                     ??Mem_DynPoolCreateInternal_7: (+1)
   \   00000070   0x2000             MOVS     R0,#+0
   \                     ??Mem_DynPoolCreateInternal_8: (+1)
   \   00000072   0x2801             CMP      R0,#+1
   \   00000074   0xD004             BEQ.N    ??Mem_DynPoolCreateInternal_9
   2753                 *p_err = LIB_MEM_ERR_INVALID_BLK_ALIGN;
   \   00000076   0xF242 0x7094      MOVW     R0,#+10132
   \   0000007A   0xF8AA 0x0000      STRH     R0,[R10, #+0]
   2754                  return;
   \   0000007E   0xE05C             B.N      ??Mem_DynPoolCreateInternal_4
   2755              }
   2756          #endif
   2757          
   2758                                                                          /* Calc blk size with align.                            */
   2759              if (blk_size < sizeof(void *)) {                            /* If size if smaller than ptr ...                      */
   \                     ??Mem_DynPoolCreateInternal_9: (+1)
   \   00000080   0x2F04             CMP      R7,#+4
   \   00000082   0xD20E             BCS.N    ??Mem_DynPoolCreateInternal_10
   2760                                                                          /* ... inc size to ptr size.                            */
   2761                  blk_size_align = MATH_ROUND_INC_UP_PWR2(sizeof(void *), blk_align_worst);
   \   00000084   0xF1BB 0x0001      SUBS     R0,R11,#+1
   \   00000088   0x0740             LSLS     R0,R0,#+29
   \   0000008A   0xD401             BMI.N    ??Mem_DynPoolCreateInternal_11
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0xE000             B.N      ??Mem_DynPoolCreateInternal_12
   \                     ??Mem_DynPoolCreateInternal_11: (+1)
   \   00000090   0x4658             MOV      R0,R11
   \                     ??Mem_DynPoolCreateInternal_12: (+1)
   \   00000092   0xF1BB 0x0101      SUBS     R1,R11,#+1
   \   00000096   0x43C9             MVNS     R1,R1
   \   00000098   0xF011 0x0104      ANDS     R1,R1,#0x4
   \   0000009C   0x1840             ADDS     R0,R0,R1
   \   0000009E   0x9003             STR      R0,[SP, #+12]
   \   000000A0   0xE00C             B.N      ??Mem_DynPoolCreateInternal_13
   2762              } else {
   2763                  blk_size_align = MATH_ROUND_INC_UP_PWR2(blk_size, blk_align_worst);
   \                     ??Mem_DynPoolCreateInternal_10: (+1)
   \   000000A2   0xF1BB 0x0001      SUBS     R0,R11,#+1
   \   000000A6   0x4207             TST      R7,R0
   \   000000A8   0xD101             BNE.N    ??Mem_DynPoolCreateInternal_14
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0xE000             B.N      ??Mem_DynPoolCreateInternal_15
   \                     ??Mem_DynPoolCreateInternal_14: (+1)
   \   000000AE   0x4658             MOV      R0,R11
   \                     ??Mem_DynPoolCreateInternal_15: (+1)
   \   000000B0   0xF1BB 0x0101      SUBS     R1,R11,#+1
   \   000000B4   0xEA37 0x0101      BICS     R1,R7,R1
   \   000000B8   0x1840             ADDS     R0,R0,R1
   \   000000BA   0x9003             STR      R0,[SP, #+12]
   2764              }
   2765          
   2766              if (blk_qty_init != 0u) {                                   /* Alloc init blks.                                     */
   \                     ??Mem_DynPoolCreateInternal_13: (+1)
   \   000000BC   0x9810             LDR      R0,[SP, #+64]
   \   000000BE   0x2800             CMP      R0,#+0
   \   000000C0   0xD028             BEQ.N    ??Mem_DynPoolCreateInternal_16
   2767                  CPU_SIZE_T  i;
   2768                  p_blks = (CPU_INT08U *)Mem_SegAllocInternal(p_name,
   2769                                                              p_seg,
   2770                                                              blk_size_align * blk_qty_init,
   2771                                                              DEF_MAX(blk_align, sizeof(void *)),
   2772                                                              LIB_MEM_PADDING_ALIGN_NONE,
   2773                                                              DEF_NULL,
   2774                                                              p_err);
   \   000000C2   0x2C05             CMP      R4,#+5
   \   000000C4   0xD301             BCC.N    ??Mem_DynPoolCreateInternal_17
   \   000000C6   0x0023             MOVS     R3,R4
   \   000000C8   0xE000             B.N      ??Mem_DynPoolCreateInternal_18
   \                     ??Mem_DynPoolCreateInternal_17: (+1)
   \   000000CA   0x2304             MOVS     R3,#+4
   \                     ??Mem_DynPoolCreateInternal_18: (+1)
   \   000000CC   0xF8CD 0xA008      STR      R10,[SP, #+8]
   \   000000D0   0x2000             MOVS     R0,#+0
   \   000000D2   0x9001             STR      R0,[SP, #+4]
   \   000000D4   0x2001             MOVS     R0,#+1
   \   000000D6   0x9000             STR      R0,[SP, #+0]
   \   000000D8   0x9803             LDR      R0,[SP, #+12]
   \   000000DA   0x9910             LDR      R1,[SP, #+64]
   \   000000DC   0xFB01 0xF200      MUL      R2,R1,R0
   \   000000E0   0x0031             MOVS     R1,R6
   \   000000E2   0x9804             LDR      R0,[SP, #+16]
   \   000000E4   0x.... 0x....      BL       Mem_SegAllocInternal
   2775                  if (*p_err != LIB_MEM_ERR_NONE) {
   \   000000E8   0xF9BA 0x1000      LDRSH    R1,[R10, #+0]
   \   000000EC   0xF242 0x7210      MOVW     R2,#+10000
   \   000000F0   0x4291             CMP      R1,R2
   \   000000F2   0xD122             BNE.N    ??Mem_DynPoolCreateInternal_4
   2776                      return;
   2777                  }
   2778          
   2779                                                                          /* ----------------- CREATE POOL DATA ----------------- */
   2780                                                                          /* Init free list.                                      */
   2781                  p_pool->BlkFreePtr = (void *)p_blks;
   \                     ??Mem_DynPoolCreateInternal_19: (+1)
   \   000000F4   0x6128             STR      R0,[R5, #+16]
   2782                  for (i = 0u; i < blk_qty_init - 1u; i++) {
   \   000000F6   0x2100             MOVS     R1,#+0
   \   000000F8   0xE005             B.N      ??Mem_DynPoolCreateInternal_20
   2783                     *((void **)p_blks)  = p_blks + blk_size_align;
   \                     ??Mem_DynPoolCreateInternal_21: (+1)
   \   000000FA   0x9A03             LDR      R2,[SP, #+12]
   \   000000FC   0x1812             ADDS     R2,R2,R0
   \   000000FE   0x6002             STR      R2,[R0, #+0]
   2784                      p_blks            += blk_size_align;
   \   00000100   0x9A03             LDR      R2,[SP, #+12]
   \   00000102   0x1810             ADDS     R0,R2,R0
   2785                  }
   \   00000104   0x1C49             ADDS     R1,R1,#+1
   \                     ??Mem_DynPoolCreateInternal_20: (+1)
   \   00000106   0x9A10             LDR      R2,[SP, #+64]
   \   00000108   0x1E52             SUBS     R2,R2,#+1
   \   0000010A   0x4291             CMP      R1,R2
   \   0000010C   0xD3F5             BCC.N    ??Mem_DynPoolCreateInternal_21
   2786                 *((void **)p_blks) = DEF_NULL;
   \   0000010E   0x2100             MOVS     R1,#+0
   \   00000110   0x6001             STR      R1,[R0, #+0]
   \   00000112   0xE001             B.N      ??Mem_DynPoolCreateInternal_22
   2787              } else {
   2788                  p_pool->BlkFreePtr = DEF_NULL;
   \                     ??Mem_DynPoolCreateInternal_16: (+1)
   \   00000114   0x2000             MOVS     R0,#+0
   \   00000116   0x6128             STR      R0,[R5, #+16]
   2789              }
   2790          
   2791          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
   2792              p_pool->PoolSegPtr      = ((p_seg != DEF_NULL) ? p_seg : &Mem_SegHeap);
   \                     ??Mem_DynPoolCreateInternal_22: (+1)
   \   00000118   0x2E00             CMP      R6,#+0
   \   0000011A   0xD100             BNE.N    ??Mem_DynPoolCreateInternal_23
   \                     ??Mem_DynPoolCreateInternal_24: (+1)
   \   0000011C   0x....             LDR.N    R6,??DataTable12_2
   \                     ??Mem_DynPoolCreateInternal_23: (+1)
   \   0000011E   0x602E             STR      R6,[R5, #+0]
   2793          #else
   2794              p_pool->PoolSegPtr      =   p_seg;
   2795          #endif
   2796              p_pool->BlkSize         =   blk_size;
   \   00000120   0x606F             STR      R7,[R5, #+4]
   2797              p_pool->BlkAlign        =   blk_align_worst;
   \   00000122   0xF8C5 0xB008      STR      R11,[R5, #+8]
   2798              p_pool->BlkPaddingAlign =   blk_padding_align;
   \   00000126   0xF8C5 0x800C      STR      R8,[R5, #+12]
   2799              p_pool->BlkQtyMax       =   blk_qty_max;
   \   0000012A   0xF8C5 0x9014      STR      R9,[R5, #+20]
   2800              p_pool->BlkAllocCnt     =   0u;
   \   0000012E   0x2000             MOVS     R0,#+0
   \   00000130   0x61A8             STR      R0,[R5, #+24]
   2801          
   2802          #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
   2803              p_pool->NamePtr = p_name;
   2804          #endif
   2805          
   2806             *p_err = LIB_MEM_ERR_NONE;
   \   00000132   0xF242 0x7010      MOVW     R0,#+10000
   \   00000136   0xF8AA 0x0000      STRH     R0,[R10, #+0]
   2807          }
   \                     ??Mem_DynPoolCreateInternal_4: (+1)
   \   0000013A   0xB005             ADD      SP,SP,#+20
   \   0000013C   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   2808          
   2809          
   2810          /*
   2811          *********************************************************************************************************
   2812          *                                      Mem_PoolBlkIsValidAddr()
   2813          *
   2814          * Description : Calculates if a given memory block address is valid for the memory pool.
   2815          *
   2816          * Argument(s) : p_pool   Pointer to memory pool structure to validate memory block address.
   2817          *               ------   Argument validated by caller.
   2818          *
   2819          *               p_mem    Pointer to memory block address to validate.
   2820          *               -----    Argument validated by caller.
   2821          *
   2822          * Return(s)   : DEF_YES, if valid memory pool block address.
   2823          *
   2824          *               DEF_NO,  otherwise.
   2825          *
   2826          * Caller(s)   : Mem_PoolBlkFree().
   2827          *
   2828          * Note(s)     : (1) This function is DEPRECATED and will be removed in a future version of this product.
   2829          *********************************************************************************************************
   2830          */
   2831          
   2832          #if ((LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED) && \
   2833               (LIB_MEM_CFG_HEAP_SIZE      >  0u))

   \                                 In section .text, align 2, keep-with-next
   2834          static  CPU_BOOLEAN  Mem_PoolBlkIsValidAddr (MEM_POOL  *p_pool,
   2835                                                       void      *p_mem)
   2836          {
   2837              CPU_ADDR  pool_offset;
   2838          
   2839          
   2840              if ((p_mem < p_pool->PoolAddrStart) ||
   2841                  (p_mem > p_pool->PoolAddrEnd)) {
   \                     Mem_PoolBlkIsValidAddr: (+1)
   \   00000000   0x6802             LDR      R2,[R0, #+0]
   \   00000002   0x4291             CMP      R1,R2
   \   00000004   0xD302             BCC.N    ??Mem_PoolBlkIsValidAddr_0
   \   00000006   0x6842             LDR      R2,[R0, #+4]
   \   00000008   0x428A             CMP      R2,R1
   \   0000000A   0xD201             BCS.N    ??Mem_PoolBlkIsValidAddr_1
   2842                  return (DEF_FALSE);
   \                     ??Mem_PoolBlkIsValidAddr_0: (+1)
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xE00B             B.N      ??Mem_PoolBlkIsValidAddr_2
   2843              }
   2844          
   2845              pool_offset = (CPU_ADDR)p_mem - (CPU_ADDR)p_pool->PoolAddrStart;
   \                     ??Mem_PoolBlkIsValidAddr_1: (+1)
   \   00000010   0x6802             LDR      R2,[R0, #+0]
   \   00000012   0x1A89             SUBS     R1,R1,R2
   2846              if (pool_offset % p_pool->BlkSize != 0u) {
   \   00000014   0x68C0             LDR      R0,[R0, #+12]
   \   00000016   0xFBB1 0xF2F0      UDIV     R2,R1,R0
   \   0000001A   0xFB00 0x1012      MLS      R0,R0,R2,R1
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD001             BEQ.N    ??Mem_PoolBlkIsValidAddr_3
   2847                  return (DEF_FALSE);
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xE000             B.N      ??Mem_PoolBlkIsValidAddr_2
   2848              } else {
   2849                  return (DEF_TRUE);
   \                     ??Mem_PoolBlkIsValidAddr_3: (+1)
   \   00000026   0x2001             MOVS     R0,#+1
   \                     ??Mem_PoolBlkIsValidAddr_2: (+1)
   \   00000028   0x4770             BX       LR               ;; return
   2850              }
   2851          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x........         DC32     Mem_SegHeadPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x........         DC32     Mem_Heap

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \   00000000   0x........         DC32     Mem_SegHeap

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x48 0x65          DC8 "Heap"
   \              0x61 0x70    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x55 0x6E          DC8 "Unnamed static pool"
   \              0x6E 0x61    
   \              0x6D 0x65    
   \              0x64 0x20    
   \              0x73 0x74    
   \              0x61 0x74    
   \              0x69 0x63    
   \              0x20 0x70    
   \              0x6F 0x6F    
   \              0x6C 0x00    

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x55 0x6E          DC8 "Unnamed static pool free blk tbl"
   \              0x6E 0x61    
   \              0x6D 0x65    
   \              0x64 0x20    
   \              0x73 0x74    
   \              0x61 0x74    
   \              0x69 0x63    
   \              0x20 0x70    
   \              0x6F 0x6F    
   \              0x6C 0x20    
   \              0x66 0x72    
   \              0x65 0x65    
   \              0x20 0x62    
   \              0x6C 0x6B    
   \              0x20 0x74    
   \              0x62 0x6C    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   2852          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   Mem_Clr
         8   -> Mem_Set
      12   Mem_Cmp
      24   Mem_DynPoolBlkFree
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> CPU_SW_Exception
      32   Mem_DynPoolBlkGet
        32   -> CPU_IntDisMeasStart
        32   -> CPU_IntDisMeasStop
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> CPU_SW_Exception
        32   -> Mem_SegAllocInternal
      16   Mem_DynPoolBlkNbrAvailGet
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> CPU_SW_Exception
      32   Mem_DynPoolCreate
        32   -> Mem_DynPoolCreateInternal
      32   Mem_DynPoolCreateHW
        32   -> Mem_DynPoolCreateInternal
      56   Mem_DynPoolCreateInternal
        56   -> CPU_SW_Exception
        56   -> Mem_SegAllocInternal
      24   Mem_HeapAlloc
        24   -> Mem_SegAllocInternal
       8   Mem_HeapGetSizeRem
         8   -> Mem_SegRemSizeGet
      16   Mem_Init
        16   -> CPU_SW_Exception
        16   -> Mem_SegCreate
      16   Mem_Move
        16   -> Mem_Copy
      24   Mem_PoolBlkFree
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> CPU_SW_Exception
        24   -> Mem_PoolBlkIsValidAddr
      24   Mem_PoolBlkGet
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> CPU_SW_Exception
      16   Mem_PoolBlkGetNbrAvail
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> CPU_SW_Exception
       0   Mem_PoolBlkIsValidAddr
      16   Mem_PoolClr
        16   -> CPU_SW_Exception
      56   Mem_PoolCreate
        56   -> CPU_IntDisMeasStart
        56   -> CPU_IntDisMeasStop
        56   -> CPU_SR_Restore
        56   -> CPU_SR_Save
        56   -> CPU_SW_Exception
        56   -> Mem_PoolClr
        56   -> Mem_SegAllocExtCritical
        56   -> Mem_SegAllocInternal
        56   -> Mem_SegCreateCritical
        56   -> Mem_SegOverlapChkCritical
      16   Mem_SegAlloc
        16   -> Mem_SegAllocInternal
      24   Mem_SegAllocExt
        24   -> Mem_SegAllocInternal
       8   Mem_SegAllocExtCritical
      24   Mem_SegAllocHW
        24   -> Mem_SegAllocInternal
      32   Mem_SegAllocInternal
        32   -> CPU_IntDisMeasStart
        32   -> CPU_IntDisMeasStop
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> CPU_SW_Exception
        32   -> Mem_SegAllocExtCritical
      16   Mem_SegClr
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> CPU_SW_Exception
      40   Mem_SegCreate
        40   -> CPU_IntDisMeasStart
        40   -> CPU_IntDisMeasStop
        40   -> CPU_SR_Restore
        40   -> CPU_SR_Save
        40   -> CPU_SW_Exception
        40   -> Mem_SegCreateCritical
        40   -> Mem_SegOverlapChkCritical
       0   Mem_SegCreateCritical
       8   Mem_SegOverlapChkCritical
      24   Mem_SegRemSizeGet
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> CPU_SW_Exception
       8   Mem_Set


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       8  ?_0
      20  ?_1
      36  ?_2
      12  Mem_Clr
     182  Mem_Cmp
     132  Mem_DynPoolBlkFree
     186  Mem_DynPoolBlkGet
      82  Mem_DynPoolBlkNbrAvailGet
      40  Mem_DynPoolCreate
      40  Mem_DynPoolCreateHW
     320  Mem_DynPoolCreateInternal
   27648  Mem_Heap
      50  Mem_HeapAlloc
      36  Mem_HeapGetSizeRem
      56  Mem_Init
     148  Mem_Move
     172  Mem_PoolBlkFree
     136  Mem_PoolBlkGet
      62  Mem_PoolBlkGetNbrAvail
      42  Mem_PoolBlkIsValidAddr
      58  Mem_PoolClr
     428  Mem_PoolCreate
      28  Mem_SegAlloc
      32  Mem_SegAllocExt
     106  Mem_SegAllocExtCritical
      32  Mem_SegAllocHW
     144  Mem_SegAllocInternal
      60  Mem_SegClr
     196  Mem_SegCreate
      26  Mem_SegCreateCritical
       4  Mem_SegHeadPtr
      20  Mem_SegHeap
      78  Mem_SegOverlapChkCritical
     160  Mem_SegRemSizeGet
      90  Mem_Set

 
 27 672 bytes in section .bss
     64 bytes in section .rodata
  3 158 bytes in section .text
 
  3 158 bytes of CODE  memory
     64 bytes of CONST memory
 27 672 bytes of DATA  memory

Errors: none
Warnings: none
