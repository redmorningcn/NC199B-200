###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       15/Jul/2018  10:36:22
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC210\NC210-200处理板\source\Software\uC-MB\Source\MB.C
#    Command line =  
#        F:\iar\NC210\NC210-200处理板\source\Software\uC-MB\Source\MB.C -D
#        USE_STDPERIPH_DRIVER -D APP_RELEASE -lCN
#        F:\iar\NC210\NC210-200处理板\project\app_release\List -o
#        F:\iar\NC210\NC210-200处理板\project\app_release\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC210\NC210-200处理板\project\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\config\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\task\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\user\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\OS\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\Ports\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\driver\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-LIB\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Source\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\ST\STM32\inc\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Ports\STM32\STM32F103\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Source\
#        -Ol --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC210\NC210-200处理板\project\app_release\List\MB.lst
#    Object file  =  F:\iar\NC210\NC210-200处理板\project\app_release\Obj\MB.o
#
###############################################################################

F:\iar\NC210\NC210-200处理板\source\Software\uC-MB\Source\MB.C
      1          /*
      2          *********************************************************************************************************
      3          *                                              uC/Modbus
      4          *                                       The Embedded Modbus Stack
      5          *
      6          *                          (c) Copyright 2003-2009; Micrium, Inc.; Weston, FL               
      7          *
      8          *               All rights reserved.  Protected by international copyright laws.
      9          *               Knowledge of the source code may NOT be used to develop a similar product.
     10          *               Please help us continue to provide the Embedded community with the finest
     11          *               software available.  Your honesty is greatly appreciated.
     12          *********************************************************************************************************
     13          */
     14          
     15          /*
     16          *********************************************************************************************************
     17          *
     18          *                                        uC/MODBUS Source Code
     19          *
     20          * Filename      : mb.c
     21          * Version       : V2.12
     22          * Programmer(s) : JJL
     23          *********************************************************************************************************
     24          * Note(s)       :
     25          *********************************************************************************************************
     26          */
     27          
     28          /*
     29          *********************************************************************************************************
     30          *                                            INCLUDE FILES
     31          *********************************************************************************************************
     32          */
     33          
     34          #define   MB_MODULE
     35          // modified by SE
     36          #include  <includes.h>

   \                                 In section .bss, align 2
   \   __absolute CPU_INT16U MB_RTU_Freq
   \                     MB_RTU_Freq:
   \   00000000                      DS8 2

   \                                 In section .bss, align 4
   \   __absolute CPU_INT32U MB_RTU_TmrCtr
   \                     MB_RTU_TmrCtr:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute OS_SEM MB_OS_RxSemTbl[4]
   \                     MB_OS_RxSemTbl:
   \   00000000                      DS8 160

   \                                 In section .bss, align 4
   \   __absolute OS_SEM MB_OS_TxSemTbl[4]
   \                     MB_OS_TxSemTbl:
   \   00000000                      DS8 160

   \                                 In section .bss, align 1
   \   __absolute CPU_INT08U MB_ChCtr
   \                     MB_ChCtr:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \   __absolute MODBUS_CH MB_ChTbl[4]
   \                     MB_ChTbl:
   \   00000000                      DS8 8608
     37          
     38          
     39          /*
     40          *********************************************************************************************************
     41          *                                            LOCAL DEFINES
     42          *********************************************************************************************************
     43          */
     44          
     45          /*
     46          *********************************************************************************************************
     47          *                                           LOCAL CONSTANTS
     48          *********************************************************************************************************
     49          */
     50          
     51          
     52          /*
     53          *********************************************************************************************************
     54          *                                          LOCAL DATA TYPES
     55          *********************************************************************************************************
     56          */
     57          
     58          
     59          /*
     60          *********************************************************************************************************
     61          *                                            LOCAL TABLES
     62          *********************************************************************************************************
     63          */
     64          
     65          /*
     66          *********************************************************************************************************
     67          *                                       LOCAL GLOBAL VARIABLES
     68          *********************************************************************************************************
     69          */
     70          /*
     71          *********************************************************************************************************
     72          *                                        RAM STORAGE REQUIREMENTS
     73          *********************************************************************************************************
     74          */
     75                                                                          /* RAM Storage Requiremets                            */
     76          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)

   \                                 In section .rodata, align 4
     77          CPU_INT32U  const  MB_TotalRAMSize = sizeof(MB_RTU_Freq)
   \                     MB_TotalRAMSize:
   \   00000000   0x000021A6         DC32 8614
     78                                             + sizeof(MB_RTU_TmrCtr)
     79                                             + sizeof(MB_ChTbl);
     80          #else
     81          CPU_INT32U  const  MB_TotalRAMSize = sizeof(MB_ChTbl);
     82          #endif
     83          

   \                                 In section .rodata, align 2
     84          CPU_INT16U  const  MB_ChSize       = sizeof(MODBUS_CH);
   \                     MB_ChSize:
   \   00000000   0x0868             DC16 2152
     85          
     86          /*
     87          *********************************************************************************************************
     88          *                                      LOCAL FUNCTION PROTOTYPES
     89          *********************************************************************************************************
     90          */
     91          
     92          
     93          /*
     94          *********************************************************************************************************
     95          *                                     LOCAL CONFIGURATION ERRORS
     96          *********************************************************************************************************
     97          */
     98          
     99          
    100          /*
    101          *********************************************************************************************************
    102          *                                               MB_Init()
    103          *
    104          * Description : Handle either Modbus ASCII or Modbus RTU received packets.
    105          *
    106          * Argument(s) : freq       Specifies the Modbus RTU timer frequency (in Hz)
    107          *
    108          * Return(s)   : none.
    109          *
    110          * Caller(s)   : Application
    111          *
    112          * Note(s)     : none.
    113          *********************************************************************************************************
    114          */
    115          

   \                                 In section .text, align 2, keep-with-next
    116          void  MB_Init (CPU_INT32U freq)
    117          {
   \                     MB_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    118              CPU_INT08U   ch;
    119              MODBUS_CH   *pch;
    120          
    121          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)
    122              MB_RTU_Freq = freq;                              /* Save the RTU frequency                         */
   \   00000002   0x....             LDR.N    R1,??DataTable3
   \   00000004   0x8008             STRH     R0,[R1, #+0]
    123          #endif
    124          
    125              pch         = &MB_ChTbl[0];                      /* Save Modbus channel number in data structure   */
   \   00000006   0x....             LDR.N    R4,??DataTable3_1
    126              for (ch = 0; ch < MODBUS_CFG_MAX_CH; ch++) {                /* Initialize default values                          */
   \   00000008   0x2500             MOVS     R5,#+0
   \   0000000A   0xE017             B.N      ??MB_Init_0
    127                  pch->Ch            = ch;
   \                     ??MB_Init_1: (+1)
   \   0000000C   0x7025             STRB     R5,[R4, #+0]
    128                  pch->NodeAddr      = 1;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x7220             STRB     R0,[R4, #+8]
    129                  pch->MasterSlave   = MODBUS_SLAVE;           /* Channel defaults to MODBUS_SLAVE mode          */
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x7520             STRB     R0,[R4, #+20]
    130                  pch->Mode          = MODBUS_MODE_ASCII;
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x74E0             STRB     R0,[R4, #+19]
    131                  pch->RxBufByteCtr  = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x8620             STRH     R0,[R4, #+48]
    132                  pch->RxBufPtr      = &pch->RxBuf[0];
   \   0000001E   0xF114 0x0038      ADDS     R0,R4,#+56
   \   00000022   0x6360             STR      R0,[R4, #+52]
    133                  pch->WrEn          = MODBUS_WR_EN;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x7060             STRB     R0,[R4, #+1]
    134                  pch->WrCtr         = 0;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x6060             STR      R0,[R4, #+4]
    135          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)
    136                  pch->RTU_TimeoutEn = DEF_TRUE;
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x7720             STRB     R0,[R4, #+28]
    137          #endif
    138          
    139          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED)  && \
    140              (MODBUS_CFG_FC08_EN  == DEF_ENABLED)
    141                  MBS_StatInit(pch);
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       MBS_StatInit
    142          #endif
    143                  pch++;
   \   00000036   0xF604 0x0468      ADDW     R4,R4,#+2152
    144              }
   \   0000003A   0x1C6D             ADDS     R5,R5,#+1
   \                     ??MB_Init_0: (+1)
   \   0000003C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003E   0x2D04             CMP      R5,#+4
   \   00000040   0xDBE4             BLT.N    ??MB_Init_1
    145          
    146              MB_ChCtr = 0;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x....             LDR.N    R1,??DataTable3_2
   \   00000046   0x7008             STRB     R0,[R1, #+0]
    147          
    148              MB_OS_Init();                                    /* Initialize OS interface functions              */
   \   00000048   0x.... 0x....      BL       MB_OS_Init
    149          
    150          
    151          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)                         /* MODBUS 'RTU' Initialization                         */
    152              MB_RTU_TmrInit();
   \   0000004C   0x.... 0x....      BL       MB_RTU_TmrInit
    153          #else
    154              (void)&freq;
    155          #endif
    156          }
   \   00000050   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    157          
    158          /*
    159          *********************************************************************************************************
    160          *                                               MB_Exit()
    161          *
    162          * Description : This function is called to terminate all Modbus communications
    163          *
    164          * Argument(s) : none.
    165          *
    166          * Return(s)   : none.
    167          *
    168          * Caller(s)   : Application.
    169          *
    170          * Note(s)     : none.
    171          *********************************************************************************************************
    172          */

   \                                 In section .text, align 2, keep-with-next
    173          void  MB_Exit (void)
    174          {
   \                     MB_Exit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    175          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)
    176              MB_RTU_TmrExit();                                /* Stop the RTU timer interrupts                  */
   \   00000002   0x.... 0x....      BL       MB_RTU_TmrExit
    177          #endif
    178          
    179              MB_CommExit();                                   /* Disable all communications                     */
   \   00000006   0x.... 0x....      BL       MB_CommExit
    180          
    181              MB_OS_Exit();                                    /* Stop RTOS services                             */
   \   0000000A   0x.... 0x....      BL       MB_OS_Exit
    182          }
   \   0000000E   0xBD01             POP      {R0,PC}          ;; return
    183          
    184          
    185          /*
    186          *********************************************************************************************************
    187          *                                              MB_CfgCh()
    188          *
    189          * Description : This function must be called after calling MB_Init() to initialize each of the Modbus
    190          *               channels in your system.
    191          *
    192          * Argument(s) : node_addr     is the Modbus node address that the channel is assigned to.
    193          *
    194          *               master_slave  specifies whether the channel is a MODBUS_MASTER or a MODBUS_SLAVE
    195          *
    196          *               rx_timeout    amount of time Master will wait for a response from the slave.
    197          *
    198          *               modbus_mode   specifies the type of modbus channel.  The choices are:
    199          *                             MODBUS_MODE_ASCII
    200          *                             MODBUS_MODE_RTU
    201          *
    202          *               port_nbr      is the UART port number associated with the channel
    203          *
    204          *               baud          is the desired baud rate
    205          *
    206          *               parity        is the UART's parity setting:
    207          *                             MODBUS_PARITY_NONE
    208          *                             MODBUS_PARITY_ODD
    209          *                             MODBUS_PARITY_EVEN
    210          *
    211          *               bits          UART's number of bits (7 or 8)
    212          *
    213          *               stops         Number of stops bits (1 or 2)
    214          *
    215          *               wr_en         This argument determines whether a Modbus WRITE request will be accepted.
    216          *                             The choices are:
    217          *                             MODBUS_WR_EN
    218          *                             MODBUS_WR_DIS
    219          *
    220          * Return(s)   : none.
    221          *
    222          * Caller(s)   : Application.
    223          *
    224          * Note(s)     : none.
    225          *********************************************************************************************************
    226          */
    227          

   \                                 In section .text, align 2, keep-with-next
    228          MODBUS_CH  *MB_CfgCh (CPU_INT08U  node_addr,
    229                                CPU_INT08U  master_slave,
    230                                CPU_INT32U  rx_timeout,
    231                                CPU_INT08U  modbus_mode,
    232                                CPU_INT08U  port_nbr,
    233                                CPU_INT32U  baud,
    234                                CPU_INT08U  bits,
    235                                CPU_INT08U  parity,
    236                                CPU_INT08U  stops,
    237                                CPU_INT08U  wr_en)
    238          {
   \                     MB_CfgCh: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0011             MOVS     R1,R2
   \   0000000A   0x001F             MOVS     R7,R3
    239              MODBUS_CH   *pch;
    240          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)
    241              CPU_INT16U   cnts;
    242          #endif
    243          
    244              if (MB_ChCtr < MODBUS_CFG_MAX_CH) {
   \   0000000C   0x....             LDR.N    R0,??DataTable3_2
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2804             CMP      R0,#+4
   \   00000012   0xDA43             BGE.N    ??MB_CfgCh_0
    245                  pch = &MB_ChTbl[MB_ChCtr];
   \   00000014   0x....             LDR.N    R0,??DataTable3_1
   \   00000016   0x....             LDR.N    R2,??DataTable3_2
   \   00000018   0x7812             LDRB     R2,[R2, #+0]
   \   0000001A   0xF640 0x0368      MOVW     R3,#+2152
   \   0000001E   0xFB03 0x0502      MLA      R5,R3,R2,R0
    246                  MB_MasterTimeoutSet(pch, rx_timeout);
   \   00000022   0x0028             MOVS     R0,R5
   \   00000024   0x.... 0x....      BL       MB_MasterTimeoutSet
    247                  MB_NodeAddrSet(pch, node_addr);
   \   00000028   0x0021             MOVS     R1,R4
   \   0000002A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002C   0x0028             MOVS     R0,R5
   \   0000002E   0x.... 0x....      BL       MB_NodeAddrSet
    248                  MB_ModeSet(pch, master_slave, modbus_mode);
   \   00000032   0x003A             MOVS     R2,R7
   \   00000034   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000036   0x0031             MOVS     R1,R6
   \   00000038   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000003A   0x0028             MOVS     R0,R5
   \   0000003C   0x.... 0x....      BL       MB_ModeSet
    249                  MB_WrEnSet(pch, wr_en);
   \   00000040   0x990D             LDR      R1,[SP, #+52]
   \   00000042   0x0028             MOVS     R0,R5
   \   00000044   0x.... 0x....      BL       MB_WrEnSet
   \   00000048   0x9C08             LDR      R4,[SP, #+32]
    250                  MB_ChToPortMap(pch, port_nbr);
   \   0000004A   0x0021             MOVS     R1,R4
   \   0000004C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000004E   0x0028             MOVS     R0,R5
   \   00000050   0x.... 0x....      BL       MB_ChToPortMap
   \   00000054   0x9E09             LDR      R6,[SP, #+36]
    251                  MB_CommPortCfg(pch, port_nbr, baud, bits, parity, stops);
   \   00000056   0x980C             LDR      R0,[SP, #+48]
   \   00000058   0x9001             STR      R0,[SP, #+4]
   \   0000005A   0x980B             LDR      R0,[SP, #+44]
   \   0000005C   0x9000             STR      R0,[SP, #+0]
   \   0000005E   0x9B0A             LDR      R3,[SP, #+40]
   \   00000060   0x0032             MOVS     R2,R6
   \   00000062   0x0021             MOVS     R1,R4
   \   00000064   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000066   0x0028             MOVS     R0,R5
   \   00000068   0x.... 0x....      BL       MB_CommPortCfg
    252          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)
    253                  if (pch->MasterSlave == MODBUS_MASTER) {
   \   0000006C   0x7D28             LDRB     R0,[R5, #+20]
   \   0000006E   0x2801             CMP      R0,#+1
   \   00000070   0xD101             BNE.N    ??MB_CfgCh_1
    254                      pch->RTU_TimeoutEn = DEF_FALSE;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x7728             STRB     R0,[R5, #+28]
    255                  }
    256          
    257                  cnts = ((CPU_INT32U)MB_RTU_Freq * 5L * 10L) / baud;           /* Freq * 5 char * 10 bits/char * 1/BaudRate  */
   \                     ??MB_CfgCh_1: (+1)
   \   00000076   0x....             LDR.N    R0,??DataTable3
   \   00000078   0x8800             LDRH     R0,[R0, #+0]
   \   0000007A   0x2132             MOVS     R1,#+50
   \   0000007C   0x4348             MULS     R0,R1,R0
   \   0000007E   0xFBB0 0xF0F6      UDIV     R0,R0,R6
    258                  if (cnts <= 1) {
   \   00000082   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000084   0x2802             CMP      R0,#+2
   \   00000086   0xDA00             BGE.N    ??MB_CfgCh_2
    259                      cnts = 2;
   \   00000088   0x2002             MOVS     R0,#+2
    260                  }
    261                  pch->RTU_TimeoutCnts = cnts;
   \                     ??MB_CfgCh_2: (+1)
   \   0000008A   0x8328             STRH     R0,[R5, #+24]
    262                  pch->RTU_TimeoutCtr  = cnts;
   \   0000008C   0x8368             STRH     R0,[R5, #+26]
    263          #endif
    264                  MB_ChCtr++;
   \   0000008E   0x....             LDR.N    R0,??DataTable3_2
   \   00000090   0x7800             LDRB     R0,[R0, #+0]
   \   00000092   0x1C40             ADDS     R0,R0,#+1
   \   00000094   0x....             LDR.N    R1,??DataTable3_2
   \   00000096   0x7008             STRB     R0,[R1, #+0]
    265                  return (pch);
   \   00000098   0x0028             MOVS     R0,R5
   \   0000009A   0xE000             B.N      ??MB_CfgCh_3
    266              } else {
    267                  return ((MODBUS_CH *)0);
   \                     ??MB_CfgCh_0: (+1)
   \   0000009C   0x2000             MOVS     R0,#+0
   \                     ??MB_CfgCh_3: (+1)
   \   0000009E   0xBDFE             POP      {R1-R7,PC}       ;; return
    268              }
    269          }
    270          
    271          /*
    272          *********************************************************************************************************
    273          *                                         MB_MasterTimeoutSet()
    274          *
    275          * Description : This function is called to change the operating mode of a Modbus channel.
    276          *
    277          * Argument(s) : pch          is a pointer to the Modbus channel to change
    278          *
    279          *               modbus_mode  specifies the type of modbus channel.  The choices are:
    280          *                            MODBUS_MODE_ASCII
    281          *                            MODBUS_MODE_RTU
    282          *
    283          * Return(s)   : none.
    284          *
    285          * Caller(s)   : Application.
    286          *
    287          * Note(s)     : none.
    288          *********************************************************************************************************
    289          */
    290          

   \                                 In section .text, align 2, keep-with-next
    291          void  MB_MasterTimeoutSet (MODBUS_CH  *pch,
    292                                     CPU_INT32U  timeout)
    293          {
    294              if (pch != (MODBUS_CH *)0) {
   \                     MB_MasterTimeoutSet: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD000             BEQ.N    ??MB_MasterTimeoutSet_0
    295                  pch->RxTimeout = timeout;
   \   00000004   0x6281             STR      R1,[R0, #+40]
    296              }
    297          }
   \                     ??MB_MasterTimeoutSet_0: (+1)
   \   00000006   0x4770             BX       LR               ;; return
    298          
    299          /*
    300          *********************************************************************************************************
    301          *                                             MB_ModeSet()
    302          *
    303          * Description : This function is called to change the operating mode of a Modbus channel.
    304          *
    305          * Argument(s) : pch          is a pointer to the Modbus channel to change
    306          *
    307          *               modbus_mode  specifies the type of modbus channel.  The choices are:
    308          *                            MODBUS_MODE_ASCII
    309          *                            MODBUS_MODE_RTU
    310          *
    311          * Return(s)   : none.
    312          *
    313          * Caller(s)   : Application.
    314          *
    315          * Note(s)     : none.
    316          *********************************************************************************************************
    317          */
    318          

   \                                 In section .text, align 2, keep-with-next
    319          void  MB_ModeSet (MODBUS_CH  *pch,
    320                            CPU_INT08U  master_slave,
    321                            CPU_INT08U  mode)
    322          {
    323              if (pch != (MODBUS_CH *)0) {
   \                     MB_ModeSet: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD00F             BEQ.N    ??MB_ModeSet_0
    324          
    325                  switch (master_slave) {
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0x2901             CMP      R1,#+1
   \   00000008   0xD102             BNE.N    ??MB_ModeSet_1
    326                      case MODBUS_MASTER:
    327                           pch->MasterSlave = MODBUS_MASTER;
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x7501             STRB     R1,[R0, #+20]
    328                           break;
   \   0000000E   0xE001             B.N      ??MB_ModeSet_2
    329          
    330                      case MODBUS_SLAVE:
    331                      default:
    332                           pch->MasterSlave = MODBUS_SLAVE;
   \                     ??MB_ModeSet_1: (+1)
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x7501             STRB     R1,[R0, #+20]
    333                           break;
    334                  }
    335          
    336                  switch (mode) {
   \                     ??MB_ModeSet_2: (+1)
   \   00000014   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000016   0x2A00             CMP      R2,#+0
   \   00000018   0xD102             BNE.N    ??MB_ModeSet_3
    337          #if (MODBUS_CFG_ASCII_EN == DEF_ENABLED)
    338                      case MODBUS_MODE_ASCII:
    339                           pch->Mode = MODBUS_MODE_ASCII;
    340                           break;
    341          #endif
    342          
    343          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)
    344                      case MODBUS_MODE_RTU:
    345                           pch->Mode = MODBUS_MODE_RTU;
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x74C1             STRB     R1,[R0, #+19]
    346                           break;
   \   0000001E   0xE001             B.N      ??MB_ModeSet_0
    347          #endif
    348          
    349                      default:
    350          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)
    351                           pch->Mode = MODBUS_MODE_RTU;
   \                     ??MB_ModeSet_3: (+1)
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x74C1             STRB     R1,[R0, #+19]
    352          #else
    353                           pch->Mode = MODBUS_MODE_ASCII;
    354          #endif
    355                           break;
    356                  }
    357              }
    358          }
   \                     ??MB_ModeSet_0: (+1)
   \   00000024   0x4770             BX       LR               ;; return
    359          
    360          /*
    361          *********************************************************************************************************
    362          *                                           MB_NodeAddrSet()
    363          *
    364          * Description : This function is called to change the Modbus node address that the channel will respond to.
    365          *
    366          * Argument(s) : pch          is a pointer to the Modbus channel to change
    367          *
    368          *               node_addr    is the Modbus node address that the channel is assigned to.
    369          *
    370          * Return(s)   : none.
    371          *
    372          * Caller(s)   : Application.
    373          *
    374          * Note(s)     : none.
    375          *********************************************************************************************************
    376          */
    377          

   \                                 In section .text, align 2, keep-with-next
    378          void  MB_NodeAddrSet (MODBUS_CH  *pch,
    379                                CPU_INT08U  node_addr)
    380          {
    381              if (pch != (MODBUS_CH *)0) {
   \                     MB_NodeAddrSet: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD000             BEQ.N    ??MB_NodeAddrSet_0
    382                  pch->NodeAddr = node_addr;
   \   00000004   0x7201             STRB     R1,[R0, #+8]
    383              }
    384          }
   \                     ??MB_NodeAddrSet_0: (+1)
   \   00000006   0x4770             BX       LR               ;; return
    385          
    386          /*
    387          *********************************************************************************************************
    388          *                                             MB_WrEnSet()
    389          *
    390          * Description : This function is called to enable or disable write accesses to the data.
    391          *
    392          * Argument(s) : ch           is the Modbus channel to change
    393          *
    394          *               wr_en        This argument determines whether a Modbus WRITE request will be accepted.
    395          *                            The choices are:
    396          *                            MODBUS_WR_EN
    397          *                            MODBUS_WR_DIS
    398          *
    399          * Return(s)   : none.
    400          *
    401          * Caller(s)   : Application.
    402          *
    403          * Note(s)     : none.
    404          *********************************************************************************************************
    405          */
    406          

   \                                 In section .text, align 2, keep-with-next
    407          void  MB_WrEnSet (MODBUS_CH  *pch,
    408                            CPU_INT08U  wr_en)
    409          {
    410              if (pch != (MODBUS_CH *)0) {
   \                     MB_WrEnSet: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD000             BEQ.N    ??MB_WrEnSet_0
    411                  pch->WrEn = wr_en;
   \   00000004   0x7041             STRB     R1,[R0, #+1]
    412              }
    413          }
   \                     ??MB_WrEnSet_0: (+1)
   \   00000006   0x4770             BX       LR               ;; return
    414          
    415          
    416          /*
    417          *********************************************************************************************************
    418          *                                           MB_ChToPortMap()
    419          *
    420          * Description : This function is called to change the physical port number of the Modbus channel.
    421          *
    422          * Argument(s) : pch          is a pointer to the Modbus channel to change
    423          *
    424          *               port_nbr     This argument determines the physical port number of the Modbus channel
    425          *
    426          * Return(s)   : none.
    427          *
    428          * Caller(s)   : Application.
    429          *
    430          * Note(s)     : none.
    431          *********************************************************************************************************
    432          */
    433          

   \                                 In section .text, align 2, keep-with-next
    434          void  MB_ChToPortMap (MODBUS_CH  *pch,
    435                                CPU_INT08U  port_nbr)
    436          {
    437              if (pch != (MODBUS_CH *)0) {
   \                     MB_ChToPortMap: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD000             BEQ.N    ??MB_ChToPortMap_0
    438                  pch->PortNbr = port_nbr;
   \   00000004   0x7241             STRB     R1,[R0, #+9]
    439              }
    440          }
   \                     ??MB_ChToPortMap_0: (+1)
   \   00000006   0x4770             BX       LR               ;; return
    441          
    442          /*$PAGE*/
    443          /*
    444          *********************************************************************************************************
    445          *                                              MB_RxByte()
    446          *
    447          * Description : A byte has been received from a serial port.  We just store it in the buffer for processing
    448          *               when a complete packet has been received.
    449          *
    450          * Argument(s) : pch         Is a pointer to the Modbus channel's data structure.
    451          *
    452          *               rx_byte     Is the byte received.
    453          *
    454          * Return(s)   : none.
    455          *
    456          * Caller(s)   : MB_CommRxTxISR_Handler()
    457          *
    458          * Note(s)     : none.
    459          *********************************************************************************************************
    460          */
    461          

   \                                 In section .text, align 2, keep-with-next
    462          void  MB_RxByte (MODBUS_CH  *pch,
    463                           CPU_INT08U  rx_byte)
    464          {
   \                     MB_RxByte: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    465              switch (pch->Mode) {
   \   00000002   0x7CC2             LDRB     R2,[R0, #+19]
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD103             BNE.N    ??MB_RxByte_0
    466          #if (MODBUS_CFG_ASCII_EN == DEF_ENABLED)
    467                  case MODBUS_MODE_ASCII:
    468                       MB_ASCII_RxByte(pch, rx_byte & 0x7F);
    469                       break;
    470          #endif
    471          
    472          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)
    473                  case MODBUS_MODE_RTU:
    474                       MB_RTU_RxByte(pch, rx_byte);
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x.... 0x....      BL       MB_RTU_RxByte
    475                       break;
   \   0000000E   0xE7FF             B.N      ??MB_RxByte_1
    476          #endif
    477          
    478                  default:
    479                       break;
    480              }
    481          }
   \                     ??MB_RxByte_0: (+1)
   \                     ??MB_RxByte_1: (+1)
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
    482          
    483          /*$PAGE*/
    484          /*
    485          *********************************************************************************************************
    486          *                                              MB_RxTask() 
    487          *
    488          * Description : This function is called when a packet needs to be processed. 
    489          *
    490          * Argument(s) : pch         Is a pointer to the Modbus channel's data structure.
    491          *
    492          * Return(s)   : none.
    493          *
    494          * Caller(s)   : MB_OS_RxTask()
    495          *
    496          * Note(s)     : none.
    497          *********************************************************************************************************
    498          */
    499          

   \                                 In section .text, align 2, keep-with-next
    500          void  MB_RxTask (MODBUS_CH *pch)
    501          {
   \                     MB_RxTask: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    502          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED)
    503              if (pch != (MODBUS_CH *)0) {
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD004             BEQ.N    ??MB_RxTask_0
    504                  if (pch->MasterSlave == MODBUS_SLAVE) {
   \   00000006   0x7D01             LDRB     R1,[R0, #+20]
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD101             BNE.N    ??MB_RxTask_0
    505                      MBS_RxTask(pch);
   \   0000000C   0x.... 0x....      BL       MBS_RxTask
    506                  }
    507              }
    508          #endif
    509          }
   \                     ??MB_RxTask_0: (+1)
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
    510          /*
    511          *********************************************************************************************************
    512          *                                                MB_Tx()
    513          *
    514          * Description : This function is called to start transmitting a packet to a modbus channel.
    515          *
    516          * Argument(s) : pch      Is a pointer to the Modbus channel's data structure.
    517          *
    518          * Return(s)   : none.
    519          *
    520          * Caller(s)   : MB_ASCII_Tx()
    521          *               MB_RTU_Tx()
    522          *
    523          * Note(s)     : none.
    524          *********************************************************************************************************
    525          */
    526          

   \                                 In section .text, align 2, keep-with-next
    527          void  MB_Tx (MODBUS_CH  *pch)
    528          {
   \                     MB_Tx: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    529              pch->TxBufPtr = &pch->TxBuf[0];
   \   00000004   0xF514 0x7011      ADDS     R0,R4,#+580
   \   00000008   0xF8C4 0x0240      STR      R0,[R4, #+576]
    530              MB_TxByte(pch);
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       MB_TxByte
    531              MB_CommRxIntDis(pch);
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       MB_CommRxIntDis
    532              MB_CommTxIntEn(pch); 
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       MB_CommTxIntEn
    533          }
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
    534          
    535          /*$PAGE*/
    536          /*
    537          *********************************************************************************************************
    538          *                                              MB_TxByte()
    539          *
    540          * Description : This function is called to obtain the next byte to send from the transmit buffer.  When
    541          *               all bytes in the reply have been sent, transmit interrupts are disabled and the receiver
    542          *               is enabled to accept the next Modbus request.
    543          *
    544          * Argument(s) : pch      Is a pointer to the Modbus channel's data structure.
    545          *
    546          * Return(s)   : none.
    547          *
    548          * Caller(s)   : MB_CommRxTxISR_Handler()
    549          *               MB_Tx()
    550          *
    551          * Note(s)     : none.
    552          *********************************************************************************************************
    553          */
    554          

   \                                 In section .text, align 2, keep-with-next
    555          void  MB_TxByte (MODBUS_CH  *pch)
    556          {
   \                     MB_TxByte: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    557              CPU_INT08U  c;
    558          
    559          
    560              if (pch->TxBufByteCtr > 0) {
   \   00000004   0xF8B4 0x023C      LDRH     R0,[R4, #+572]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD01B             BEQ.N    ??MB_TxByte_0
    561                  pch->TxBufByteCtr--;
   \   0000000C   0xF8B4 0x023C      LDRH     R0,[R4, #+572]
   \   00000010   0x1E40             SUBS     R0,R0,#+1
   \   00000012   0xF8A4 0x023C      STRH     R0,[R4, #+572]
    562                  pch->TxCtr++;
   \   00000016   0xF8D4 0x0238      LDR      R0,[R4, #+568]
   \   0000001A   0x1C40             ADDS     R0,R0,#+1
   \   0000001C   0xF8C4 0x0238      STR      R0,[R4, #+568]
    563                  c = *pch->TxBufPtr++;
   \   00000020   0xF8D4 0x0240      LDR      R0,[R4, #+576]
   \   00000024   0x1C41             ADDS     R1,R0,#+1
   \   00000026   0xF8C4 0x1240      STR      R1,[R4, #+576]
   \   0000002A   0x7801             LDRB     R1,[R0, #+0]
    564                  MB_CommTx1(pch,                                         /* Write one byte to the serial port                  */
    565                             c);                                     
   \   0000002C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0x.... 0x....      BL       MB_CommTx1
    566          #if (MODBUS_CFG_MASTER_EN == DEF_ENABLED)
    567                  if (pch->MasterSlave == MODBUS_MASTER) {
   \   00000034   0x7D20             LDRB     R0,[R4, #+20]
   \   00000036   0x2801             CMP      R0,#+1
   \   00000038   0xD10E             BNE.N    ??MB_TxByte_1
    568          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)
    569                      pch->RTU_TimeoutEn = MODBUS_FALSE;                  /* Disable RTU timeout timer until we start receiving */
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x7720             STRB     R0,[R4, #+28]
    570          #endif            
    571                      pch->RxBufByteCtr  = 0;                /* Flush Rx buffer                                           */
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x8620             STRH     R0,[R4, #+48]
   \   00000042   0xE009             B.N      ??MB_TxByte_1
    572                  }
    573          #endif
    574              } else {                                       /* If there is nothing to do end transmission                */
    575                  pch->TxBufPtr = &pch->TxBuf[0];            /* Reset at beginning of buffer                              */
   \                     ??MB_TxByte_0: (+1)
   \   00000044   0xF514 0x7011      ADDS     R0,R4,#+580
   \   00000048   0xF8C4 0x0240      STR      R0,[R4, #+576]
    576                  MB_CommTxIntDis(pch);                      /* No more data to send, disable Tx interrupts               */
   \   0000004C   0x0020             MOVS     R0,R4
   \   0000004E   0x.... 0x....      BL       MB_CommTxIntDis
    577                  MB_CommRxIntEn(pch);                       /* Re-enable the receiver for the next packet                */
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0x.... 0x....      BL       MB_CommRxIntEn
    578              }
    579          }
   \                     ??MB_TxByte_1: (+1)
   \   00000058   0xBD10             POP      {R4,PC}          ;; return
    580          
    581          /*$PAGE*/
    582          /*
    583          *********************************************************************************************************
    584          *                                           MB_ASCII_RxByte()
    585          *
    586          * Description : A byte has been received from a serial port.  We just store it in the buffer for processing
    587          *               when a complete packet has been received.
    588          *
    589          * Argument(s) : pch         Is a pointer to the Modbus channel's data structure.
    590          *
    591          *               rx_byte     Is the byte received.
    592          *
    593          * Return(s)   : none.
    594          *
    595          * Caller(s)   : MB_RxByte().
    596          *
    597          * Return(s)   : none.
    598          *********************************************************************************************************
    599          */
    600          
    601          #if (MODBUS_CFG_ASCII_EN == DEF_ENABLED)
    602          void  MB_ASCII_RxByte (MODBUS_CH  *pch,
    603                                 CPU_INT08U  rx_byte)
    604          {
    605              CPU_INT08U    node_addr;
    606              CPU_INT08U   *phex;
    607          
    608          
    609              pch->RxCtr++;                                   /* Increment the number of bytes received                   */
    610              if (rx_byte == ':') {                           /* Is it the start of frame character?                      */
    611                  pch->RxBufPtr     = &pch->RxBuf[0];         /* Yes, Restart a new frame                                 */
    612                  pch->RxBufByteCtr = 0;
    613              }
    614              if (pch->RxBufByteCtr < MODBUS_CFG_BUF_SIZE) {              /* No, add received byte to buffer                    */
    615                  *pch->RxBufPtr++  = rx_byte;
    616                  pch->RxBufByteCtr++;                                    /* Increment byte counter to see if we have Rx ...    */
    617                                                                          /* ... activity                                       */
    618              }
    619              if (rx_byte == MODBUS_ASCII_END_FRAME_CHAR2) {  /* See if we received a complete ASCII frame                */
    620                  phex      = &pch->RxBuf[1];
    621                  node_addr = MB_ASCII_HexToBin(phex);
    622                  if ((node_addr == pch->NodeAddr) ||                     /* Is the address for us?                             */
    623                      (node_addr == 0)) {                                 /* ... or a 'broadcast'?                              */
    624                      MB_OS_RxSignal(pch);                    /* Yes, Let task handle reply                               */
    625                  } else {
    626                      pch->RxBufPtr     = &pch->RxBuf[0];     /* No,  Wipe out anything, we have to re-synchronize.       */
    627                      pch->RxBufByteCtr = 0;
    628                  }
    629              }
    630          }
    631          #endif
    632          
    633          /*$PAGE*/
    634          /*
    635          *********************************************************************************************************
    636          *                                             MB_ASCII_Rx()
    637          *
    638          * Description : Parses and converts an ASCII style message into a Modbus frame.  A check is performed
    639          *               to verify that the Modbus packet is valid.
    640          *
    641          * Argument(s) : pch         Is a pointer to the Modbus channel's data structure.
    642          *
    643          * Return(s)   : DEF_TRUE        If all checks pass.
    644          *               DEF_FALSE       If any checks fail.
    645          *
    646          * Caller(s)   : MBM_RxReply().
    647          *
    648          * Note(s)     : none.
    649          *********************************************************************************************************
    650          */
    651          
    652          #if (MODBUS_CFG_ASCII_EN == DEF_ENABLED)
    653          CPU_BOOLEAN  MB_ASCII_Rx (MODBUS_CH  *pch)
    654          {
    655              CPU_INT08U    *pmsg;
    656              CPU_INT08U    *prx_data;
    657              CPU_INT16U     rx_size;
    658          
    659          
    660              pmsg      = &pch->RxBuf[0];
    661              rx_size   =  pch->RxBufByteCtr;
    662              prx_data  = &pch->RxFrameData[0];
    663              if ((rx_size & 0x01)                                     &&        /* Message should have an ODD nbr of bytes.        */
    664                  (rx_size           >  MODBUS_ASCII_MIN_MSG_SIZE)     &&        /* Check if message is long enough                 */
    665                  (pmsg[0]           == MODBUS_ASCII_START_FRAME_CHAR) &&        /* Check the first char.                           */
    666                  (pmsg[rx_size - 2] == MODBUS_ASCII_END_FRAME_CHAR1)  &&        /* Check the last two.                             */
    667                  (pmsg[rx_size - 1] == MODBUS_ASCII_END_FRAME_CHAR2)) {
    668                  rx_size               -= 3;                                    /* Take away for the ':', CR, and LF               */
    669                  pmsg++;                                                        /* Point past the ':' to the address.              */
    670                  pch->RxFrameNDataBytes = 0;                                    /* Get the data from the message                   */
    671                  while (rx_size > 2) {
    672                      *prx_data++  = MB_ASCII_HexToBin(pmsg);
    673                      pmsg        += 2;
    674                      rx_size     -= 2;
    675                      pch->RxFrameNDataBytes++;                                  /* Increment the number of Modbus packets received */
    676                  }
    677                  pch->RxFrameNDataBytes -= 2;                                   /* Subtract the Address and function code          */
    678                  pch->RxFrameCRC         = (CPU_INT16U)MB_ASCII_HexToBin(pmsg); /* Extract the message's LRC                       */
    679                  return (DEF_TRUE);
    680              } else {
    681                  return (DEF_FALSE);
    682              }
    683          }
    684          #endif
    685          
    686          /*$PAGE*/
    687          /*
    688          *********************************************************************************************************
    689          *                                             MB_ASCII_Tx()
    690          *
    691          * Description : The format of the message is ASCII.  The actual information is taken from the given
    692          *               MODBUS frame.
    693          *
    694          * Argument(s) : pch      Is a pointer to the Modbus channel's data structure.
    695          *
    696          * Return(s)   : none.
    697          *
    698          * Caller(s)   : MBM_TxCmd()
    699          *               MBS_ASCII_Task()
    700          *
    701          * Note(s)     : none.   
    702          *********************************************************************************************************
    703          */
    704          
    705          #if (MODBUS_CFG_ASCII_EN == DEF_ENABLED)
    706          void  MB_ASCII_Tx (MODBUS_CH  *pch)
    707          {
    708              CPU_INT08U    *ptx_data;
    709              CPU_INT08U    *pbuf;
    710              CPU_INT16U     i;
    711              CPU_INT16U     tx_bytes;
    712              CPU_INT08U     lrc;
    713          
    714          
    715              ptx_data = &pch->TxFrameData[0];
    716              pbuf     = &pch->TxBuf[0];
    717              *pbuf++  = MODBUS_ASCII_START_FRAME_CHAR;                   /* Place the start-of-frame character into output buffer  */
    718              pbuf     = MB_ASCII_BinToHex(*ptx_data++, 
    719                                           pbuf);
    720              pbuf     = MB_ASCII_BinToHex(*ptx_data++, 
    721                                           pbuf);
    722              tx_bytes = 5;
    723              i        = (CPU_INT08U)pch->TxFrameNDataBytes;             /* Transmit the actual data                                 */
    724              while (i > 0) {
    725                  pbuf      = MB_ASCII_BinToHex(*ptx_data++, 
    726                                                pbuf);
    727                  tx_bytes += 2;
    728                  i--;
    729              }
    730              lrc               = MB_ASCII_TxCalcLRC(pch,                 /* Compute outbound packet LRC                            */
    731                                                     tx_bytes);      
    732              pbuf              = MB_ASCII_BinToHex(lrc,                  /* Add the LRC checksum in the packet                     */
    733                                                    pbuf);           
    734              *pbuf++           = MODBUS_ASCII_END_FRAME_CHAR1;           /* Add 1st end-of-frame character (0x0D) to output buffer */
    735              *pbuf++           = MODBUS_ASCII_END_FRAME_CHAR2;           /* Add 2nd end-of-frame character (0x0A) to output buffer */
    736              tx_bytes         += 4;
    737              pch->TxFrameCRC   = (CPU_INT16U)lrc;                       /* Save the computed LRC into the channel                   */
    738              pch->TxBufByteCtr = tx_bytes;                              /* Update the total number of bytes to send                 */
    739              MB_Tx(pch);                                                /* Send it out the communication driver.                    */
    740          }
    741          #endif
    742          
    743          /*$PAGE*/
    744          /*
    745          *********************************************************************************************************
    746          *                                            MB_RTU_RxByte()
    747          *
    748          * Description : A byte has been received from a serial port.  We just store it in the buffer for processing
    749          *               when a complete packet has been received.
    750          *
    751          * Argument(s) : pch         Is a pointer to the Modbus channel's data structure.
    752          *
    753          *               rx_byte     Is the byte received.
    754          *
    755          * Return(s)   : none.
    756          *
    757          * Caller(s)   : MB_RxByte()
    758          *
    759          * Note(s)     : none.
    760          *********************************************************************************************************
    761          */
    762          
    763          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    764          void  MB_RTU_RxByte (MODBUS_CH  *pch,
    765                               CPU_INT08U  rx_byte)
    766          {
   \                     MB_RTU_RxByte: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    767              MB_RTU_TmrReset(pch);                                         /* Reset the timeout timer on a new character               */
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       MB_RTU_TmrReset
    768          #if (MODBUS_CFG_MASTER_EN == DEF_ENABLED)
    769              if (pch->MasterSlave == MODBUS_MASTER) {
   \   0000000C   0x7D20             LDRB     R0,[R4, #+20]
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xD101             BNE.N    ??MB_RTU_RxByte_0
    770                  pch->RTU_TimeoutEn = MODBUS_TRUE;
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x7720             STRB     R0,[R4, #+28]
    771              }
    772          #endif
    773              if (pch->RxBufByteCtr < MODBUS_CFG_BUF_SIZE) {              /* No, add received byte to buffer                        */
   \                     ??MB_RTU_RxByte_0: (+1)
   \   00000016   0x8E20             LDRH     R0,[R4, #+48]
   \   00000018   0xF5B0 0x7F00      CMP      R0,#+512
   \   0000001C   0xDA09             BGE.N    ??MB_RTU_RxByte_1
    774                  pch->RxCtr++;                                             /* Increment the number of bytes received                   */
   \   0000001E   0x6AE0             LDR      R0,[R4, #+44]
   \   00000020   0x1C40             ADDS     R0,R0,#+1
   \   00000022   0x62E0             STR      R0,[R4, #+44]
    775                  *pch->RxBufPtr++ = rx_byte;
   \   00000024   0x6B60             LDR      R0,[R4, #+52]
   \   00000026   0x1C41             ADDS     R1,R0,#+1
   \   00000028   0x6361             STR      R1,[R4, #+52]
   \   0000002A   0x7005             STRB     R5,[R0, #+0]
    776                  pch->RxBufByteCtr++;                                      /* Increment byte counter to see if we have Rx activity     */
   \   0000002C   0x8E20             LDRH     R0,[R4, #+48]
   \   0000002E   0x1C40             ADDS     R0,R0,#+1
   \   00000030   0x8620             STRH     R0,[R4, #+48]
    777              }
    778          }
   \                     ??MB_RTU_RxByte_1: (+1)
   \   00000032   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    779          #endif
    780          
    781          /*$PAGE*/
    782          /*
    783          *********************************************************************************************************
    784          *                                              MB_RTU_Rx()
    785          *
    786          * Description : Parses a Modbus RTU packet and processes the request if the packet is valid.
    787          *
    788          * Argument(s) : pch         Is a pointer to the Modbus channel's data structure.
    789          *
    790          * Return(s)   : DEF_TRUE    If all checks pass.
    791          *               DEF_FALSE   If any checks fail.
    792          *
    793          * Caller(s)   : MBM_RxReply()
    794          *               MBS_RTU_Task()
    795          *
    796          * Note(s)     : none.
    797          *********************************************************************************************************
    798          */
    799          
    800          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    801          CPU_BOOLEAN  MB_RTU_Rx (MODBUS_CH  *pch)
    802          {
   \                     MB_RTU_Rx: (+1)
   \   00000000   0xB410             PUSH     {R4}
    803              CPU_INT08U    *prx_data;
    804              CPU_INT08U    *pmsg;
    805              CPU_INT16U     rx_size;
    806              CPU_INT16U     crc;
    807          
    808              pmsg    = &pch->RxBuf[0];
   \   00000002   0xF110 0x0238      ADDS     R2,R0,#+56
    809              rx_size =  pch->RxBufByteCtr;
   \   00000006   0x8E03             LDRH     R3,[R0, #+48]
    810              if (rx_size >= MODBUS_RTU_MIN_MSG_SIZE) {         /* Is the message long enough?                        */
   \   00000008   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000000A   0x2B04             CMP      R3,#+4
   \   0000000C   0xDB2C             BLT.N    ??MB_RTU_Rx_0
    811                  if (rx_size <= MODBUS_CFG_BUF_SIZE) {
   \   0000000E   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000010   0xF5B3 0x7F00      CMP      R3,#+512
   \   00000014   0xDC26             BGT.N    ??MB_RTU_Rx_1
    812                      prx_data    = &pch->RxFrameData[0];
   \   00000016   0xF200 0x4144      ADDW     R1,R0,#+1092
    813                      *prx_data++ = *pmsg++;                    /* Transfer the node address                          */
   \   0000001A   0x7814             LDRB     R4,[R2, #+0]
   \   0000001C   0x700C             STRB     R4,[R1, #+0]
   \   0000001E   0x1C52             ADDS     R2,R2,#+1
   \   00000020   0x1C49             ADDS     R1,R1,#+1
    814                      rx_size--;
   \   00000022   0x1E5B             SUBS     R3,R3,#+1
    815          
    816                      *prx_data++ = *pmsg++;                    /* Transfer the function code                         */
   \   00000024   0x7814             LDRB     R4,[R2, #+0]
   \   00000026   0x700C             STRB     R4,[R1, #+0]
   \   00000028   0x1C52             ADDS     R2,R2,#+1
   \   0000002A   0x1C49             ADDS     R1,R1,#+1
    817                      rx_size--;
   \   0000002C   0x1E5B             SUBS     R3,R3,#+1
    818          
    819                      pch->RxFrameNDataBytes = 0;               /* Transfer the data                                  */
   \   0000002E   0x2400             MOVS     R4,#+0
   \   00000030   0xF8A0 0x4644      STRH     R4,[R0, #+1604]
   \   00000034   0xE009             B.N      ??MB_RTU_Rx_2
    820                      while (rx_size > 2) {
    821                          *prx_data++ = *pmsg++;
   \                     ??MB_RTU_Rx_3: (+1)
   \   00000036   0x7814             LDRB     R4,[R2, #+0]
   \   00000038   0x700C             STRB     R4,[R1, #+0]
   \   0000003A   0x1C52             ADDS     R2,R2,#+1
   \   0000003C   0x1C49             ADDS     R1,R1,#+1
    822                          pch->RxFrameNDataBytes++;
   \   0000003E   0xF8B0 0x4644      LDRH     R4,[R0, #+1604]
   \   00000042   0x1C64             ADDS     R4,R4,#+1
   \   00000044   0xF8A0 0x4644      STRH     R4,[R0, #+1604]
    823                          rx_size--;
   \   00000048   0x1E5B             SUBS     R3,R3,#+1
    824                      }
   \                     ??MB_RTU_Rx_2: (+1)
   \   0000004A   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000004C   0x2B03             CMP      R3,#+3
   \   0000004E   0xDAF2             BGE.N    ??MB_RTU_Rx_3
    825          
    826                      crc              = (CPU_INT16U)*pmsg++;   /* Transfer the CRC over.  It's LSB first, then MSB.  */
   \   00000050   0x7811             LDRB     R1,[R2, #+0]
   \   00000052   0x1C52             ADDS     R2,R2,#+1
    827                      crc             += (CPU_INT16U)*pmsg << 8;
   \   00000054   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000056   0x7812             LDRB     R2,[R2, #+0]
   \   00000058   0xEB11 0x2102      ADDS     R1,R1,R2, LSL #+8
    828                      pch->RxFrameCRC  = crc;
   \   0000005C   0xF8A0 0x1646      STRH     R1,[R0, #+1606]
    829                      return (DEF_TRUE);
   \   00000060   0x2001             MOVS     R0,#+1
   \   00000062   0xE002             B.N      ??MB_RTU_Rx_4
    830                  } else {
    831                      return (DEF_FALSE);
   \                     ??MB_RTU_Rx_1: (+1)
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xE000             B.N      ??MB_RTU_Rx_4
    832                  }
    833              } else {
    834                  return (DEF_FALSE);
   \                     ??MB_RTU_Rx_0: (+1)
   \   00000068   0x2000             MOVS     R0,#+0
   \                     ??MB_RTU_Rx_4: (+1)
   \   0000006A   0xBC10             POP      {R4}
   \   0000006C   0x4770             BX       LR               ;; return
    835              }
    836          }
    837          #endif
    838          
    839          /*$PAGE*/
    840          /*
    841          *********************************************************************************************************
    842          *                                              MB_RTU_Tx()
    843          *
    844          * Description : A MODBUS message is formed into a buffer and sent to the appropriate communication port.
    845          *               The actual reply is taken from the given MODBUS Frame.
    846          *
    847          * Argument(s) : pch      Is a pointer to the Modbus channel's data structure.
    848          *
    849          * Return(s)   : none.
    850          *
    851          * Caller(s)   : MBM_TxCmd()
    852          *               MBS_RTU_Task()
    853          * 
    854          * Note(s)     : none.
    855          *********************************************************************************************************
    856          */
    857          
    858          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    859          void  MB_RTU_Tx (MODBUS_CH  *pch)
    860          {
   \                     MB_RTU_Tx: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    861              CPU_INT08U  *ptx_data;
    862              CPU_INT08U  *pbuf;
    863              CPU_INT08U   i;
    864              CPU_INT16U   tx_bytes;
    865              CPU_INT16U   crc;
    866          
    867          
    868              tx_bytes  = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    869              pbuf      = &pch->TxBuf[0];                                    /* Point to the beginning of the output buffer.             */
   \   00000006   0xF514 0x7611      ADDS     R6,R4,#+580
    870              ptx_data  = &(pch->TxFrameData[0]);
   \   0000000A   0xF204 0x604E      ADDW     R0,R4,#+1614
    871              i         = (CPU_INT08U)pch->TxFrameNDataBytes + 2;            /* Include the actual data in the buffer                    */
   \   0000000E   0xF8B4 0x184E      LDRH     R1,[R4, #+2126]
   \   00000012   0x1C89             ADDS     R1,R1,#+2
   \   00000014   0xE005             B.N      ??MB_RTU_Tx_0
    872              while (i > 0) {
    873                  *pbuf++ = *ptx_data++;
   \                     ??MB_RTU_Tx_1: (+1)
   \   00000016   0x7802             LDRB     R2,[R0, #+0]
   \   00000018   0x7032             STRB     R2,[R6, #+0]
   \   0000001A   0x1C40             ADDS     R0,R0,#+1
   \   0000001C   0x1C76             ADDS     R6,R6,#+1
    874                  tx_bytes++;
   \   0000001E   0x1C6D             ADDS     R5,R5,#+1
    875                  i--;
   \   00000020   0x1E49             SUBS     R1,R1,#+1
    876              }
   \                     ??MB_RTU_Tx_0: (+1)
   \   00000022   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000024   0x2900             CMP      R1,#+0
   \   00000026   0xD1F6             BNE.N    ??MB_RTU_Tx_1
    877              crc               = MB_RTU_TxCalcCRC(pch);
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0x.... 0x....      BL       MB_RTU_TxCalcCRC
    878              *pbuf++           = (CPU_INT08U)(crc & 0x00FF);                /* Add in the CRC checksum.  Low byte first!                */
   \   0000002E   0x7030             STRB     R0,[R6, #+0]
   \   00000030   0x1C76             ADDS     R6,R6,#+1
    879              *pbuf             = (CPU_INT08U)(crc >> 8);
   \   00000032   0x0001             MOVS     R1,R0
   \   00000034   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000036   0x0A09             LSRS     R1,R1,#+8
   \   00000038   0x7031             STRB     R1,[R6, #+0]
    880              tx_bytes         += 2;
   \   0000003A   0x1CAD             ADDS     R5,R5,#+2
    881              pch->TxFrameCRC   = crc;                                       /* Save the calculated CRC in the channel                   */
   \   0000003C   0xF8A4 0x0850      STRH     R0,[R4, #+2128]
    882              pch->TxBufByteCtr = tx_bytes;
   \   00000040   0xF8A4 0x523C      STRH     R5,[R4, #+572]
    883          
    884              MB_Tx(pch);                                                    /* Send it out the communication driver.                    */
   \   00000044   0x0020             MOVS     R0,R4
   \   00000046   0x.... 0x....      BL       MB_Tx
    885          }
   \   0000004A   0xBD70             POP      {R4-R6,PC}       ;; return
    886          #endif
    887          
    888          /*$PAGE*/
    889          /*
    890          *********************************************************************************************************
    891          *                                           MB_RTU_TmrReset()
    892          *
    893          * Description : This function is called when a byte a received and thus, we reset the RTU timeout timer value
    894          *               indicating that we are not done receiving a complete RTU packet.
    895          *
    896          * Argument(s) : none
    897          *
    898          * Return(s)   : none.
    899          *
    900          * Caller(s)   : MB_RTU_TmrResetAll()
    901          *
    902          * Note(s)     : none.
    903          *********************************************************************************************************
    904          */
    905          
    906          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    907          void  MB_RTU_TmrReset (MODBUS_CH  *pch)
    908          {
    909              pch->RTU_TimeoutCtr = pch->RTU_TimeoutCnts;
   \                     MB_RTU_TmrReset: (+1)
   \   00000000   0x8B01             LDRH     R1,[R0, #+24]
   \   00000002   0x8341             STRH     R1,[R0, #+26]
    910          }
   \   00000004   0x4770             BX       LR               ;; return
    911          #endif
    912          
    913          /*$PAGE*/
    914          /*
    915          *********************************************************************************************************
    916          *                                           MB_RTU_TmrResetAll()
    917          *
    918          * Description : This function is used to reset all the RTU timers for all Modbus channels.
    919          *
    920          * Argument(s) : none
    921          *
    922          * Return(s)   : none.
    923          *
    924          * Caller(s)   : MB_RTU_TmrInit()
    925          *
    926          * Note(s)     : none.
    927          *********************************************************************************************************
    928          */
    929          
    930          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    931          void  MB_RTU_TmrResetAll (void)
    932          {
   \                     MB_RTU_TmrResetAll: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    933              CPU_INT08U   ch;
    934              MODBUS_CH   *pch;
    935          
    936          
    937              pch = &MB_ChTbl[0];
   \   00000002   0x....             LDR.N    R5,??DataTable3_1
    938              for (ch = 0; ch < MODBUS_CFG_MAX_CH; ch++) {
   \   00000004   0x2400             MOVS     R4,#+0
   \   00000006   0xE008             B.N      ??MB_RTU_TmrResetAll_0
    939                  if (pch->Mode == MODBUS_MODE_RTU) {
   \                     ??MB_RTU_TmrResetAll_1: (+1)
   \   00000008   0x7CE8             LDRB     R0,[R5, #+19]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD102             BNE.N    ??MB_RTU_TmrResetAll_2
    940                      MB_RTU_TmrReset(pch);
   \   0000000E   0x0028             MOVS     R0,R5
   \   00000010   0x.... 0x....      BL       MB_RTU_TmrReset
    941                  }
    942                  pch++;
   \                     ??MB_RTU_TmrResetAll_2: (+1)
   \   00000014   0xF605 0x0568      ADDW     R5,R5,#+2152
    943              }
   \   00000018   0x1C64             ADDS     R4,R4,#+1
   \                     ??MB_RTU_TmrResetAll_0: (+1)
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x2C04             CMP      R4,#+4
   \   0000001E   0xDBF3             BLT.N    ??MB_RTU_TmrResetAll_1
    944          }
   \   00000020   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    945          #endif
    946          
    947          /*$PAGE*/
    948          /*
    949          *********************************************************************************************************
    950          *                                           MB_RTU_TmrUpdate()
    951          *
    952          * Description : This function is called when the application supplied RTU framing timer expires.
    953          *
    954          * Argument(s) : none
    955          *
    956          * Return(s)   : none.
    957          *
    958          * Caller(s)   : MB_RTU_TmrISR_Handler()
    959          *
    960          * Note(s)     : none.
    961          *********************************************************************************************************
    962          */
    963          
    964          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    965          void  MB_RTU_TmrUpdate (void)
    966          {
   \                     MB_RTU_TmrUpdate: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    967              CPU_INT08U   ch;
    968              MODBUS_CH   *pch;
    969          
    970              pch = &MB_ChTbl[0];
   \   00000002   0x....             LDR.N    R4,??DataTable3_1
    971              for (ch = 0; ch < MODBUS_CFG_MAX_CH; ch++) {
   \   00000004   0x2500             MOVS     R5,#+0
   \   00000006   0xE004             B.N      ??MB_RTU_TmrUpdate_0
    972                  if (pch->Mode == MODBUS_MODE_RTU) {
    973                      if (pch->RTU_TimeoutEn == DEF_TRUE) {
    974                          if (pch->RTU_TimeoutCtr > 0) {
    975                              pch->RTU_TimeoutCtr--;
    976                              if (pch->RTU_TimeoutCtr == 0) {
    977          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)
    978                                  if (pch->MasterSlave == MODBUS_MASTER) {
    979                                      pch->RTU_TimeoutEn = DEF_FALSE;
    980                                  }
    981          #endif
    982                                  MB_OS_RxSignal(pch);          /* RTU Timer expired for this Modbus channel         */
    983                              }
    984                          }
    985                      } else {
    986                          pch->RTU_TimeoutCtr = pch->RTU_TimeoutCnts;
   \                     ??MB_RTU_TmrUpdate_1: (+1)
   \   00000008   0x8B20             LDRH     R0,[R4, #+24]
   \   0000000A   0x8360             STRH     R0,[R4, #+26]
    987                      }
    988                  }
    989                  pch++;
   \                     ??MB_RTU_TmrUpdate_2: (+1)
   \   0000000C   0xF604 0x0468      ADDW     R4,R4,#+2152
   \   00000010   0x1C6D             ADDS     R5,R5,#+1
   \                     ??MB_RTU_TmrUpdate_0: (+1)
   \   00000012   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000014   0x2D04             CMP      R5,#+4
   \   00000016   0xDA17             BGE.N    ??MB_RTU_TmrUpdate_3
   \   00000018   0x7CE0             LDRB     R0,[R4, #+19]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD1F6             BNE.N    ??MB_RTU_TmrUpdate_2
   \   0000001E   0x7F20             LDRB     R0,[R4, #+28]
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xD1F1             BNE.N    ??MB_RTU_TmrUpdate_1
   \   00000024   0x8B60             LDRH     R0,[R4, #+26]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD0F0             BEQ.N    ??MB_RTU_TmrUpdate_2
   \   0000002A   0x8B60             LDRH     R0,[R4, #+26]
   \   0000002C   0x1E40             SUBS     R0,R0,#+1
   \   0000002E   0x8360             STRH     R0,[R4, #+26]
   \   00000030   0x8B60             LDRH     R0,[R4, #+26]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD1EA             BNE.N    ??MB_RTU_TmrUpdate_2
   \   00000036   0x7D20             LDRB     R0,[R4, #+20]
   \   00000038   0x2801             CMP      R0,#+1
   \   0000003A   0xD101             BNE.N    ??MB_RTU_TmrUpdate_4
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x7720             STRB     R0,[R4, #+28]
   \                     ??MB_RTU_TmrUpdate_4: (+1)
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0x.... 0x....      BL       MB_OS_RxSignal
   \   00000046   0xE7E1             B.N      ??MB_RTU_TmrUpdate_2
    990              }
    991          }
   \                     ??MB_RTU_TmrUpdate_3: (+1)
   \   00000048   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     MB_RTU_Freq

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x........         DC32     MB_ChTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x........         DC32     MB_ChCtr
    992          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   MB_CfgCh
        32   -> MB_ChToPortMap
        32   -> MB_CommPortCfg
        32   -> MB_MasterTimeoutSet
        32   -> MB_ModeSet
        32   -> MB_NodeAddrSet
        32   -> MB_WrEnSet
       0   MB_ChToPortMap
       8   MB_Exit
         8   -> MB_CommExit
         8   -> MB_OS_Exit
         8   -> MB_RTU_TmrExit
      16   MB_Init
        16   -> MBS_StatInit
        16   -> MB_OS_Init
        16   -> MB_RTU_TmrInit
       0   MB_MasterTimeoutSet
       0   MB_ModeSet
       0   MB_NodeAddrSet
       4   MB_RTU_Rx
      16   MB_RTU_RxByte
        16   -> MB_RTU_TmrReset
       0   MB_RTU_TmrReset
      16   MB_RTU_TmrResetAll
        16   -> MB_RTU_TmrReset
      16   MB_RTU_TmrUpdate
        16   -> MB_OS_RxSignal
      16   MB_RTU_Tx
        16   -> MB_RTU_TxCalcCRC
        16   -> MB_Tx
       8   MB_RxByte
         8   -> MB_RTU_RxByte
       8   MB_RxTask
         8   -> MBS_RxTask
       8   MB_Tx
         8   -> MB_CommRxIntDis
         8   -> MB_CommTxIntEn
         8   -> MB_TxByte
       8   MB_TxByte
         8   -> MB_CommRxIntEn
         8   -> MB_CommTx1
         8   -> MB_CommTxIntDis
       0   MB_WrEnSet


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
     160  MB_CfgCh
       1  MB_ChCtr
       2  MB_ChSize
    8608  MB_ChTbl
       8  MB_ChToPortMap
      16  MB_Exit
      82  MB_Init
       8  MB_MasterTimeoutSet
      38  MB_ModeSet
       8  MB_NodeAddrSet
     160  MB_OS_RxSemTbl
     160  MB_OS_TxSemTbl
       2  MB_RTU_Freq
     110  MB_RTU_Rx
      52  MB_RTU_RxByte
       4  MB_RTU_TmrCtr
       6  MB_RTU_TmrReset
      34  MB_RTU_TmrResetAll
      74  MB_RTU_TmrUpdate
      76  MB_RTU_Tx
      18  MB_RxByte
      18  MB_RxTask
       4  MB_TotalRAMSize
      32  MB_Tx
      90  MB_TxByte
       8  MB_WrEnSet

 
 8 935 bytes in section .bss
     6 bytes in section .rodata
   850 bytes in section .text
 
   850 bytes of CODE  memory
     6 bytes of CONST memory
 8 935 bytes of DATA  memory

Errors: none
Warnings: none
