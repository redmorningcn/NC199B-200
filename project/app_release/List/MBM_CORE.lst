###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       15/Jul/2018  10:36:24
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC210\NC210-200处理板\source\Software\uC-MB\Source\MBM_CORE.C
#    Command line =  
#        F:\iar\NC210\NC210-200处理板\source\Software\uC-MB\Source\MBM_CORE.C
#        -D USE_STDPERIPH_DRIVER -D APP_RELEASE -lCN
#        F:\iar\NC210\NC210-200处理板\project\app_release\List -o
#        F:\iar\NC210\NC210-200处理板\project\app_release\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC210\NC210-200处理板\project\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\config\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\task\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\user\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\OS\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\Ports\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\driver\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-LIB\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Source\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\ST\STM32\inc\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Ports\STM32\STM32F103\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Source\
#        -Ol --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC210\NC210-200处理板\project\app_release\List\MBM_CORE.lst
#    Object file  =  
#        F:\iar\NC210\NC210-200处理板\project\app_release\Obj\MBM_CORE.o
#
###############################################################################

F:\iar\NC210\NC210-200处理板\source\Software\uC-MB\Source\MBM_CORE.C
      1          /*
      2          *********************************************************************************************************
      3          *                                              uC/Modbus
      4          *                                       The Embedded Modbus Stack
      5          *
      6          *                          (c) Copyright 2003-2009; Micrium, Inc.; Weston, FL
      7          *
      8          *               All rights reserved.  Protected by international copyright laws.
      9          *               Knowledge of the source code may NOT be used to develop a similar product.
     10          *               Please help us continue to provide the Embedded community with the finest
     11          *               software available.  Your honesty is greatly appreciated.
     12          *********************************************************************************************************
     13          */
     14          
     15          /*
     16          *********************************************************************************************************
     17          *
     18          *                                     uC/MODBUS SLAVE COMMAND PROCESSOR
     19          *
     20          * Filename      : mbm_core.c
     21          * Version       : V2.12
     22          * Programmer(s) : JJL
     23          *********************************************************************************************************
     24          * Note(s)       :
     25          *********************************************************************************************************
     26          */
     27          
     28          /*
     29          *********************************************************************************************************
     30          *                                             INCLUDE FILES
     31          *********************************************************************************************************
     32          */
     33          
     34          #define  MBM_MODULE
     35          #include <includes.h>
     36          
     37          /*
     38          *********************************************************************************************************
     39          *                                                MACROS
     40          *********************************************************************************************************
     41          */
     42          #define  MBM_FCXX_ADDR          (pch->RxFrameData[0])
     43          #define  MBM_FCXX_CODE          (pch->RxFrameData[1])
     44          #define  MBM_TX_FCXX_ADDR       (pch->TxFrameData[0])
     45          #define  MBM_TX_FCXX_CODE       (pch->TxFrameData[1])
     46          #define  MBM_RX_FCXX_ADDR       (pch->RxFrameData[0])
     47          #define  MBM_RX_FCXX_CODE       (pch->RxFrameData[1])
     48          
     49          /***********************************************
     50          * 描述：接收帧数据格式，代码：MODBUS_FC01_COIL_RD
     51          */
     52          #define  MBM_RX_FC01_DATA_COIL      (((CPU_INT16U)pch->RxFrameData[4] << 8) + (CPU_INT16U)pch->RxFrameData[5])
     53          #define  MBM_RX_FC01_DATA_COIL_H     (pch->RxFrameData[4])
     54          #define  MBM_RX_FC01_DATA_COIL_L     (pch->RxFrameData[5])
     55          #define  MBM_TX_FC01_DATA_COIL      (((CPU_INT16U)pch->TxFrameData[4] << 8) + (CPU_INT16U)pch->TxFrameData[5])
     56          #define  MBM_TX_FC01_DATA_COIL_H     (pch->TxFrameData[4])
     57          #define  MBM_TX_FC01_DATA_COIL_L     (pch->TxFrameData[5])
     58          #define  MBM_RX_FC01_DATA(i)         (pch->RxFrameData[3 + i])
     59          #define  MBM_RX_FC01_NBYTE           (pch->RxFrameData[2])
     60          
     61          /***********************************************
     62          * 描述：接收帧数据格式，代码：MODBUS_FC02_DI_RD
     63          */
     64          /***********************************************
     65          * 描述：接收帧数据格式，代码：MODBUS_FC03_HOLDING_REG_RD
     66          */
     67          #define  MBM_TX_FC03_REG      (((CPU_INT16U)pch->TxFrameData[2] << 8) + (CPU_INT16U)pch->TxFrameData[3])
     68          #define  MBM_TX_FC03_REG_H      (pch->TxFrameData[2])
     69          #define  MBM_TX_FC03_REG_L      (pch->RxFrameData[3])
     70          #define  MBM_TX_FC03_NREG     (((CPU_INT16U)pch->TxFrameData[4] << 8) + (CPU_INT16U)pch->TxFrameData[5])
     71          #define  MBM_TX_FC03_NREG_H     (pch->TxFrameData[4])
     72          #define  MBM_TX_FC03_NREG_L     (pch->TxFrameData[5])
     73          #define  MBM_TX_FC03_CRC      (((CPU_INT16U)pch->TxFrameData[6] << 8) + (CPU_INT16U)pch->TxFrameData[7])
     74          #define  MBM_TX_FC03_CRC_H      (pch->TxFrameData[6])
     75          #define  MBM_TX_FC03_CRC_L      (pch->TxFrameData[7])
     76          
     77          
     78          #define  MBM_RX_FC03_NBYTE      (pch->RxFrameData[2])
     79          #define  MBM_RX_FC03_DATA(i)  (((CPU_INT16U)pch->RxFrameData[3 + i * 2] << 8) + (CPU_INT16U)pch->RxFrameData[4 + i * 2])
     80          #define  MBM_RX_FC03_DATA_H(i)  (pch->RxFrameData[3 + i * 2])
     81          #define  MBM_RX_FC03_DATA_L(i)  (pch->RxFrameData[4 + i * 2])
     82          
     83          #define  MBM_RX_FC03_IDX_NBYTE  2
     84          #define  MBM_RX_FC03_IDX_DATA   3
     85          #define  MBM_RX_FC03_IDX_DATA_H 3
     86          #define  MBM_RX_FC03_IDX_DATA_L 4
     87          
     88          /***********************************************
     89          * 描述：接收帧数据格式，代码：MODBUS_FC04_IN_REG_RD
     90          */
     91          /***********************************************
     92          * 描述：接收帧数据格式，代码：MODBUS_FC05_COIL_WR
     93          */
     94          #define  MBM_RX_FC05_COIL         (((CPU_INT16U)pch->RxFrameData[2] << 8) + (CPU_INT16U)pch->RxFrameData[3])
     95          #define  MBM_RX_FC05_COIL_H         (pch->RxFrameData[2])
     96          #define  MBM_RX_FC05_COIL_L         (pch->RxFrameData[3])
     97          #define  MBM_RX_FC05_COIL_DATA    (((CPU_INT16U)pch->RxFrameData[4] << 8) + (CPU_INT16U)pch->RxFrameData[5])
     98          #define  MBM_RX_FC05_COIL_DATA_H    (pch->RxFrameData[4])
     99          #define  MBM_RX_FC05_COIL_DATA_L    (pch->RxFrameData[5])
    100          #define  MBM_RX_FC05_COIL_CRC     (((CPU_INT16U)pch->RxFrameData[6] << 8) + (CPU_INT16U)pch->RxFrameData[7])
    101          #define  MBM_RX_FC05_COIL_CRC_H     (pch->RxFrameData[6])
    102          #define  MBM_RX_FC05_COIL_CRC_L     (pch->RxFrameData[7])
    103          /***********************************************
    104          * 描述：接收帧数据格式，代码：MODBUS_FC06_HOLDING_REG_WR
    105          */
    106          #define  MBM_TX_FC06_REG      (((CPU_INT16U)pch->TxFrameData[2] << 8) + (CPU_INT16U)pch->TxFrameData[3])
    107          #define  MBM_TX_FC06_REG_H      (pch->TxFrameData[2])
    108          #define  MBM_TX_FC06_REG_L      (pch->RxFrameData[3])
    109          #define  MBM_TX_FC06_DATA     (((CPU_INT16U)pch->TxFrameData[4] << 8) + (CPU_INT16U)pch->TxFrameData[5])
    110          #define  MBM_TX_FC06_DATA_H     (pch->TxFrameData[4])
    111          #define  MBM_TX_FC06_DATA_L     (pch->TxFrameData[5])
    112          #define  MBM_TX_FC06_CRC      (((CPU_INT16U)pch->TxFrameData[6] << 8) + (CPU_INT16U)pch->TxFrameData[7])
    113          #define  MBM_TX_FC06_CRC_H      (pch->TxFrameData[6])
    114          #define  MBM_TX_FC06_CRC_L      (pch->TxFrameData[7])
    115          
    116          #define  MBM_RX_FC06_REG      (((CPU_INT16U)pch->RxFrameData[2] << 8) + (CPU_INT16U)pch->RxFrameData[3])
    117          #define  MBM_RX_FC06_REG_H      (pch->RxFrameData[2])
    118          #define  MBM_RX_FC06_REG_L      (pch->RxFrameData[3])
    119          #define  MBM_RX_FC06_DATA     (((CPU_INT16U)pch->RxFrameData[4] << 8) + (CPU_INT16U)pch->RxFrameData[5])
    120          #define  MBM_RX_FC06_DATA_H     (pch->RxFrameData[4])
    121          #define  MBM_RX_FC06_DATA_L     (pch->RxFrameData[5])
    122          #define  MBM_RX_FC06_CRC      (((CPU_INT16U)pch->RxFrameData[6] << 8) + (CPU_INT16U)pch->RxFrameData[7])
    123          #define  MBM_RX_FC06_CRC_H      (pch->RxFrameData[6])
    124          #define  MBM_RX_FC06_CRC_L      (pch->RxFrameData[7])
    125          
    126          /***********************************************
    127          * 描述：接收帧数据格式，代码：MODBUS_FC08_LOOPBACK
    128          */
    129          /***********************************************
    130          * 描述：接收帧数据格式，代码：MODBUS_FC15_COIL_WR_MULTIPLE
    131          */
    132          #define  MBM_RX_FC15_COIL      (((CPU_INT16U)pch->RxFrameData[2] << 8) + (CPU_INT16U)pch->RxFrameData[3])
    133          #define  MBM_RX_FC15_COIL_H      (pch->RxFrameData[2])
    134          #define  MBM_RX_FC15_COIL_L      (pch->RxFrameData[3])
    135          #define  MBM_RX_FC15_COIL_DATA (((CPU_INT16U)pch->RxFrameData[4] << 8) + (CPU_INT16U)pch->RxFrameData[5])
    136          #define  MBM_RX_FC15_COIL_DATA_H (pch->RxFrameData[4])
    137          #define  MBM_RX_FC15_COIL_DATA_L (pch->RxFrameData[5])
    138          #define  MBM_RX_FC15_COIL_BYTES  (pch->RxFrameData[6])
    139          
    140          /***********************************************
    141          * 描述：接收帧数据格式，代码：MODBUS_FC16_HOLDING_REG_WR_MULTIPLE
    142          */
    143          #define  MBM_TX_FC16_REG      (((CPU_INT16U)pch->TxFrameData[2] << 8) + (CPU_INT16U)pch->TxFrameData[3])
    144          #define  MBM_TX_FC16_REG_H      (pch->TxFrameData[2])
    145          #define  MBM_TX_FC16_REG_L      (pch->RxFrameData[3])
    146          #define  MBM_TX_FC16_NREG     (((CPU_INT16U)pch->TxFrameData[4] << 8) + (CPU_INT16U)pch->TxFrameData[5])
    147          #define  MBM_TX_FC16_NREG_H     (pch->TxFrameData[4])
    148          #define  MBM_TX_FC16_NREG_L     (pch->TxFrameData[5])
    149          #define  MBM_TX_FC16_NBYTE      (pch->TxFrameData[6])
    150          #define  MBM_TX_FC16_DATA_IDX   7
    151          
    152          #define  MBM_TX_FC16_DATA(i)  (((CPU_INT16U)pch->TxFrameData[7 + i * 2] << 8) + (CPU_INT16U)pch->TxFrameData[8 + i * 2])
    153          #define  MBM_TX_FC16_DATA_H(i)  (pch->TxFrameData[7 + i * 2])
    154          #define  MBM_TX_FC16_DATA_L(i)  (pch->TxFrameData[8 + i * 2])
    155          
    156          #define  MBM_RX_FC16_REG      (((CPU_INT16U)pch->RxFrameData[2] << 8) + (CPU_INT16U)pch->RxFrameData[3])
    157          #define  MBM_RX_FC16_REG_H      (pch->RxFrameData[2])
    158          #define  MBM_RX_FC16_REG_L      (pch->RxFrameData[3])
    159          #define  MBM_RX_FC16_NREG     (((CPU_INT16U)pch->RxFrameData[4] << 8) + (CPU_INT16U)pch->RxFrameData[5])
    160          #define  MBM_RX_FC16_NREG_H     (pch->RxFrameData[4])
    161          #define  MBM_RX_FC16_NREG_L     (pch->RxFrameData[5])
    162          #define  MBM_RX_FC16_CRC      (((CPU_INT16U)pch->RxFrameData[6] << 8) + (CPU_INT16U)pch->RxFrameData[7])
    163          #define  MBM_RX_FC16_CRC_H      (pch->RxFrameData[6])
    164          #define  MBM_RX_FC16_CRC_L      (pch->RxFrameData[7])
    165          
    166          /***********************************************
    167          * 描述：接收帧数据格式，代码：MODBUS_FC20_FILE_RD
    168          */
    169          /***********************************************
    170          * 描述：接收帧数据格式，代码：MODBUS_FC21_FILE_WR
    171          */
    172          
    173          
    174          #define  MBM_TX_FRAME_DATA      (pch->TxFrameData[2])
    175          
    176          #define  MBM_RX_DATA_START     (((CPU_INT16U)pch->RxFrameData[2] << 8) + (CPU_INT16U)pch->RxFrameData[3])
    177          #define  MBM_RX_DATA_START_H    (pch->RxFrameData[2])
    178          #define  MBM_RX_DATA_START_L    (pch->RxFrameData[3])
    179          
    180          #define  MBM_RX_DATA_POINTS    (((CPU_INT16U)pch->RxFrameData[4] << 8) + (CPU_INT16U)pch->RxFrameData[5])
    181          #define  MBM_RX_DATA_POINTS_H   (pch->RxFrameData[4])
    182          #define  MBM_RX_DATA_POINTS_L   (pch->RxFrameData[5])
    183          
    184          #define  MBM_RX_DATA_COIL      (((CPU_INT16U)pch->RxFrameData[4] << 8) + (CPU_INT16U)pch->RxFrameData[5])
    185          #define  MBM_RX_DATA_COIL_H     (pch->RxFrameData[4])
    186          #define  MBM_RX_DATA_COIL_L     (pch->RxFrameData[5])
    187          
    188          #define  MBM_RX_DATA_REG       (((CPU_INT16U)pch->RxFrameData[4] << 8) + (CPU_INT16U)pch->RxFrameData[5])
    189          #define  MBM_RX_DATA_REG_H      (pch->RxFrameData[4])
    190          #define  MBM_RX_DATA_REG_L      (pch->RxFrameData[5])
    191          
    192          #define  MBM_RX_DIAG_CODE      (((CPU_INT16U)pch->RxFrameData[2] << 8) + (CPU_INT16U)pch->RxFrameData[3])
    193          #define  MBM_RX_DIAG_CODE_H     (pch->RxFrameData[2])
    194          #define  MBM_RX_DIAG_CODE_L     (pch->RxFrameData[3])
    195          #define  MBM_RX_DIAG_DATA      (((CPU_INT16U)pch->RxFrameData[4] << 8) + (CPU_INT16U)pch->RxFrameData[5])
    196          #define  MBM_RX_DIAG_DATA_H     (pch->RxFrameData[4])
    197          #define  MBM_RX_DIAG_DATA_L     (pch->RxFrameData[5])
    198          
    199          #define  MBM_RX_FRAME          (&pch->RxFrame)
    200          #define  MBM_RX_FRAME_ADDR      (pch->RxFrameData[0])
    201          #define  MBM_RX_FRAME_FC        (pch->RxFrameData[1])
    202          #define  MBM_RX_FRAME_DATA      (pch->RxFrameData[2])
    203          #define  MBM_RX_FRAME_NBYTES    (pch->RxFrameNDataBytes)
    204          
    205          
    206          #define  MBM_TX_DATA_START_H    (pch->TxFrameData[2])
    207          #define  MBM_TX_DATA_START_L    (pch->TxFrameData[3])
    208          
    209          #define  MBM_TX_DATA_POINTS_H   (pch->TxFrameData[4])
    210          #define  MBM_TX_DATA_POINTS_L   (pch->TxFrameData[5])
    211          
    212          #define  MBM_TX_DATA_COIL_H     (pch->TxFrameData[4])
    213          #define  MBM_TX_DATA_COIL_L     (pch->TxFrameData[5])
    214          
    215          #define  MBM_TX_DATA_REG_H      (pch->TxFrameData[4])
    216          #define  MBM_TX_DATA_REG_L      (pch->TxFrameData[5])
    217          
    218          #define  MBM_TX_DIAG_CODE_H     (pch->TxFrameData[2])
    219          #define  MBM_TX_DIAG_CODE_L     (pch->TxFrameData[3])
    220          #define  MBM_TX_DIAG_DATA_H     (pch->TxFrameData[4])
    221          #define  MBM_TX_DIAG_DATA_L     (pch->TxFrameData[5])
    222          
    223          
    224          #define  MBM_TX_FRAME          (&pch->TxFrame)
    225          #define  MBM_TX_FRAME_ADDR      (pch->TxFrameData[0])
    226          #define  MBM_TX_FRAME_FC        (pch->TxFrameData[1])
    227          #define  MBM_TX_FRAME_DATA      (pch->TxFrameData[2])
    228          #define  MBM_TX_FRAME_NBYTES    (pch->TxFrameNDataBytes)
    229          
    230          //SE Added defines from this point forward
    231          #define  MBM_FC100_DATA_BYTES    (5u)
    232          
    233          /*$PAGE*/
    234          /*
    235          *********************************************************************************************************
    236          *                                    LOCAL FUNCTION PROTOTYPES
    237          *********************************************************************************************************
    238          */
    239          
    240          /*$PAGE*/
    241          /*
    242          *********************************************************************************************************
    243          *                                           MBM_FCxx_Handler()
    244          *
    245          * Description : This is the main processing function for MODBUS commands.  The message integrity is
    246          *               verified, and if valid, the function requested is processed.  Unimplemented functions
    247          *               will generate an Illegal Function Exception Response code (01).
    248          *
    249          * Argument(s) : pch      Is a pointer to the Modbus channel's data structure.
    250          *
    251          * Return(s)   : none.
    252          *
    253          * Caller(s)   : MBM_ASCII_Task()
    254          *               MBM_RTU_Task
    255          *
    256          * Note(s)     : none.
    257          *********************************************************************************************************
    258          */
    259          
    260          #if (MODBUS_CFG_MASTER_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    261          CPU_BOOLEAN  MBM_FCxx_Handler (MODBUS_CH  *pch)
    262          {
    263              CPU_BOOLEAN   send_reply;
    264          
    265              if (MBM_RX_FRAME_ADDR == pch->NodeAddr) {
   \                     MBM_FCxx_Handler: (+1)
   \   00000000   0xF890 0x2444      LDRB     R2,[R0, #+1092]
   \   00000004   0x7A03             LDRB     R3,[R0, #+8]
   \   00000006   0x429A             CMP      R2,R3
   \   00000008   0xD134             BNE.N    ??MBM_FCxx_Handler_0
    266          
    267                  switch (MBM_RX_FRAME_FC) {
   \   0000000A   0xF890 0x2445      LDRB     R2,[R0, #+1093]
   \   0000000E   0x2A01             CMP      R2,#+1
   \   00000010   0xD010             BEQ.N    ??MBM_FCxx_Handler_1
   \   00000012   0x2A03             CMP      R2,#+3
   \   00000014   0xD00F             BEQ.N    ??MBM_FCxx_Handler_2
   \   00000016   0x2A05             CMP      R2,#+5
   \   00000018   0xD00E             BEQ.N    ??MBM_FCxx_Handler_3
   \   0000001A   0x2A06             CMP      R2,#+6
   \   0000001C   0xD011             BEQ.N    ??MBM_FCxx_Handler_4
   \   0000001E   0x2A08             CMP      R2,#+8
   \   00000020   0xD014             BEQ.N    ??MBM_FCxx_Handler_5
   \   00000022   0x2A0F             CMP      R2,#+15
   \   00000024   0xD013             BEQ.N    ??MBM_FCxx_Handler_6
   \   00000026   0x2A10             CMP      R2,#+16
   \   00000028   0xD016             BEQ.N    ??MBM_FCxx_Handler_7
   \   0000002A   0x2A14             CMP      R2,#+20
   \   0000002C   0xD019             BEQ.N    ??MBM_FCxx_Handler_8
   \   0000002E   0x2A15             CMP      R2,#+21
   \   00000030   0xD018             BEQ.N    ??MBM_FCxx_Handler_9
   \   00000032   0xE01C             B.N      ??MBM_FCxx_Handler_10
    268          #if (MODBUS_CFG_FC01_EN == DEF_ENABLED)
    269                      case MODBUS_FC01_COIL_RD:
    270                           break;
   \                     ??MBM_FCxx_Handler_1: (+1)
   \   00000034   0xE01E             B.N      ??MBM_FCxx_Handler_0
    271          #endif
    272          
    273          #if (MODBUS_CFG_FC02_EN == DEF_ENABLED)
    274                      case MODBUS_FC02_DI_RD:
    275                           break;
    276          #endif
    277          
    278          #if (MODBUS_CFG_FC03_EN == DEF_ENABLED)
    279                      case MODBUS_FC03_HOLDING_REG_RD:
    280                           break;
   \                     ??MBM_FCxx_Handler_2: (+1)
   \   00000036   0xE01D             B.N      ??MBM_FCxx_Handler_0
    281          #endif
    282          
    283          #if (MODBUS_CFG_FC04_EN == DEF_ENABLED)
    284                      case MODBUS_FC04_IN_REG_RD:
    285                           break;
    286          #endif
    287          
    288          #if (MODBUS_CFG_FC05_EN == DEF_ENABLED)
    289                      case MODBUS_FC05_COIL_WR:
    290                           if (pch->WrEn == DEF_TRUE) {
   \                     ??MBM_FCxx_Handler_3: (+1)
   \   00000038   0x7840             LDRB     R0,[R0, #+1]
   \   0000003A   0x2801             CMP      R0,#+1
   \   0000003C   0xD000             BEQ.N    ??MBM_FCxx_Handler_11
    291                           } else {
    292                               send_reply  = DEF_FALSE;
   \   0000003E   0x2100             MOVS     R1,#+0
    293                           }
    294                           break;
   \                     ??MBM_FCxx_Handler_11: (+1)
   \   00000040   0xE018             B.N      ??MBM_FCxx_Handler_0
    295          #endif
    296          
    297          #if (MODBUS_CFG_FC06_EN == DEF_ENABLED)
    298                      case MODBUS_FC06_HOLDING_REG_WR:
    299                           if (pch->WrEn == DEF_TRUE) {
   \                     ??MBM_FCxx_Handler_4: (+1)
   \   00000042   0x7840             LDRB     R0,[R0, #+1]
   \   00000044   0x2801             CMP      R0,#+1
   \   00000046   0xD000             BEQ.N    ??MBM_FCxx_Handler_12
    300                           } else {
    301                               send_reply  = DEF_FALSE;
   \   00000048   0x2100             MOVS     R1,#+0
    302                           }
    303                           break;
   \                     ??MBM_FCxx_Handler_12: (+1)
   \   0000004A   0xE013             B.N      ??MBM_FCxx_Handler_0
    304          #endif
    305          
    306          #if (MODBUS_CFG_FC08_EN == DEF_ENABLED)
    307                      case MODBUS_FC08_LOOPBACK:
    308                           break;
   \                     ??MBM_FCxx_Handler_5: (+1)
   \   0000004C   0xE012             B.N      ??MBM_FCxx_Handler_0
    309          #endif
    310          
    311          #if (MODBUS_CFG_FC15_EN == DEF_ENABLED)
    312                      case MODBUS_FC15_COIL_WR_MULTIPLE:
    313                           if (pch->WrEn == DEF_TRUE) {
   \                     ??MBM_FCxx_Handler_6: (+1)
   \   0000004E   0x7840             LDRB     R0,[R0, #+1]
   \   00000050   0x2801             CMP      R0,#+1
   \   00000052   0xD000             BEQ.N    ??MBM_FCxx_Handler_13
    314                           } else {
    315                               send_reply  = DEF_FALSE;
   \   00000054   0x2100             MOVS     R1,#+0
    316                           }
    317                           break;
   \                     ??MBM_FCxx_Handler_13: (+1)
   \   00000056   0xE00D             B.N      ??MBM_FCxx_Handler_0
    318          #endif
    319          
    320          #if (MODBUS_CFG_FC16_EN == DEF_ENABLED)
    321                      case MODBUS_FC16_HOLDING_REG_WR_MULTIPLE:
    322                           if (pch->WrEn == DEF_TRUE) {
   \                     ??MBM_FCxx_Handler_7: (+1)
   \   00000058   0x7840             LDRB     R0,[R0, #+1]
   \   0000005A   0x2801             CMP      R0,#+1
   \   0000005C   0xD000             BEQ.N    ??MBM_FCxx_Handler_14
    323                           } else {
    324                               send_reply  = DEF_FALSE;
   \   0000005E   0x2100             MOVS     R1,#+0
    325                           }
    326                           break;
   \                     ??MBM_FCxx_Handler_14: (+1)
   \   00000060   0xE008             B.N      ??MBM_FCxx_Handler_0
    327          #endif
    328          
    329          #if (MODBUS_CFG_FC20_EN == DEF_ENABLED)
    330                      case MODBUS_FC20_FILE_RD:
    331                           break;
   \                     ??MBM_FCxx_Handler_8: (+1)
   \   00000062   0xE007             B.N      ??MBM_FCxx_Handler_0
    332          #endif
    333          
    334          #if (MODBUS_CFG_FC21_EN == DEF_ENABLED)
    335                      case MODBUS_FC21_FILE_WR:
    336                           if (pch->WrEn == DEF_TRUE) {
   \                     ??MBM_FCxx_Handler_9: (+1)
   \   00000064   0x7840             LDRB     R0,[R0, #+1]
   \   00000066   0x2801             CMP      R0,#+1
   \   00000068   0xD000             BEQ.N    ??MBM_FCxx_Handler_15
    337                           } else {
    338                               send_reply = DEF_FALSE;
   \   0000006A   0x2100             MOVS     R1,#+0
    339                           }
    340                           break;
   \                     ??MBM_FCxx_Handler_15: (+1)
   \   0000006C   0xE002             B.N      ??MBM_FCxx_Handler_0
    341          #endif
    342          
    343          #if MODBUS_FC43_EN > 0 // Read Device ID
    344                     case MODBUS_FC43_READ_DEV_ID:
    345                      break;
    346          #endif
    347          
    348          #if MODBUS_FC100_EN > 0 // Scattered Read
    349                      case MODBUS_FC100_SCATTERED_READ:
    350                      break;
    351          #endif
    352          
    353                      default:
    354                           pch->Err   = MODBUS_ERR_ILLEGAL_FC;
   \                     ??MBM_FCxx_Handler_10: (+1)
   \   0000006E   0x2101             MOVS     R1,#+1
   \   00000070   0x82C1             STRH     R1,[R0, #+22]
    355                           send_reply = DEF_TRUE;
   \   00000072   0x2101             MOVS     R1,#+1
    356                           break;
    357                  }
    358              } else {
    359              }
    360          
    361              return (send_reply);
   \                     ??MBM_FCxx_Handler_0: (+1)
   \   00000074   0x0008             MOVS     R0,R1
   \   00000076   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000078   0x4770             BX       LR               ;; return
    362          }
    363          #endif
    364          /*$PAGE*/
    365          /*
    366          *********************************************************************************************************
    367          *                                           MBM_TxCmd()
    368          *
    369          * Description : This is the main processing function for MODBUS commands.  The message integrity is
    370          *               verified, and if valid, the function requested is processed.  Unimplemented functions
    371          *               will generate an Illegal Function Exception Response code (01).
    372          *
    373          * Argument(s) : pch      Is a pointer to the Modbus channel's data structure.
    374          *
    375          * Return(s)   : none.
    376          *
    377          * Caller(s)   : MBM_FCxx_xx()
    378          *
    379          * Note(s)     : none.
    380          *********************************************************************************************************
    381          */
    382          #if (MODBUS_CFG_MASTER_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    383          void MBM_TxCmd(MODBUS_CH *pch)
    384          {
   \                     MBM_TxCmd: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    385          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)
    386              MB_RTU_Tx (pch);
   \   00000002   0x.... 0x....      BL       MB_RTU_Tx
    387          #endif
    388          #if (MODBUS_CFG_ASCII_EN == DEF_ENABLED)
    389              MB_ASCII_Tx(pch);
    390          #endif
    391          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
    392          #endif
    393          
    394          /*$PAGE*/
    395          /*
    396          *********************************************************************************************************
    397          *                                           MBM_RxReply()
    398          *
    399          * Description : This is the main processing function for MODBUS commands.  The message integrity is
    400          *               verified, and if valid, the function requested is processed.  Unimplemented functions
    401          *               will generate an Illegal Function Exception Response code (01).
    402          *
    403          * Argument(s) : pch      Is a pointer to the Modbus channel's data structure.
    404          *
    405          * Return(s)   : none.
    406          *
    407          * Caller(s)   : MBM_FCxx_xx
    408          *
    409          * Note(s)     : none.
    410          *********************************************************************************************************
    411          */
    412          #if (MODBUS_CFG_MASTER_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    413          CPU_BOOLEAN MBM_RxReply(MODBUS_CH *pch )
    414          {
   \                     MBM_RxReply: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    415          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)
    416              return MB_RTU_Rx(pch);
   \   00000002   0x.... 0x....      BL       MB_RTU_Rx
   \   00000006   0xBD02             POP      {R1,PC}          ;; return
    417          
    418          #endif
    419          #if (MODBUS_CFG_ASCII_EN == DEF_ENABLED)
    420              return MB_ASCII_Rx(pch);
    421          #endif
    422          }
    423          #endif
    424          
    425          
    426          /*$PAGE*/
    427          /*
    428          *********************************************************************************************************
    429          *                                           MBS_FC01_CoilRd()
    430          *
    431          * Description : Responds to a request to read the status of any number of coils.
    432          *
    433          * Argument(s) : pch       Is a pointer to the Modbus channel's data structure.
    434          *
    435          * Return(s)   : DEF_TRUE      If a response needs to be sent
    436          *               DEF_FALSE     If not
    437          *
    438          * Caller(s)   : MBS_FCxx_Handler()
    439          *
    440          * Note(s)     : none
    441          *********************************************************************************************************
    442          */
    443          
    444          #if (MODBUS_CFG_MASTER_EN == DEF_ENABLED)
    445          #if (MODBUS_CFG_FC01_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    446          CPU_INT16U  MBM_FC01_CoilRd          (MODBUS_CH   *pch,
    447                                                CPU_INT08U   slave_node,
    448                                                CPU_INT16U   slave_addr,
    449                                                CPU_INT08U  *p_coil_tbl,
    450                                                CPU_INT16U   nbr_coils)
    451          {
   \                     MBM_FC01_CoilRd: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000F             MOVS     R7,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001D             MOVS     R5,R3
    452              CPU_INT16U      nbr_bytes;
    453              CPU_INT08U     *ptx_data;
    454              CPU_INT16U      err;
    455              CPU_BOOLEAN     ok;
    456              CPU_INT16U      calc_crc;
    457          
    458              MB_OS_TxWait(pch,&err);
   \   0000000A   0x4669             MOV      R1,SP
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       MB_OS_TxWait
    459              if ( err != MODBUS_ERR_NONE )
   \   00000012   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD001             BEQ.N    ??MBM_FC01_CoilRd_0
    460                  return 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE06E             B.N      ??MBM_FC01_CoilRd_1
    461              ptx_data    = &(pch->TxFrameData[0]);
   \                     ??MBM_FC01_CoilRd_0: (+1)
   \   0000001E   0xF204 0x624E      ADDW     R2,R4,#+1614
    462              pch->TxFrameNDataBytes  = 4;
   \   00000022   0x2004             MOVS     R0,#+4
   \   00000024   0xF8A4 0x084E      STRH     R0,[R4, #+2126]
    463          
    464             *ptx_data++ = slave_node;
   \   00000028   0x7017             STRB     R7,[R2, #+0]
   \   0000002A   0x1C52             ADDS     R2,R2,#+1
    465             *ptx_data++ = MODBUS_FC01_COIL_RD;
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x7010             STRB     R0,[R2, #+0]
   \   00000030   0x1C52             ADDS     R2,R2,#+1
    466             *ptx_data++ = HI_INT16U(slave_addr);
   \   00000032   0x0030             MOVS     R0,R6
   \   00000034   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000036   0x0A00             LSRS     R0,R0,#+8
   \   00000038   0x7010             STRB     R0,[R2, #+0]
   \   0000003A   0x1C52             ADDS     R2,R2,#+1
    467             *ptx_data++ = LO_INT16U(slave_addr);
   \   0000003C   0x7016             STRB     R6,[R2, #+0]
   \   0000003E   0x1C52             ADDS     R2,R2,#+1
   \   00000040   0x9906             LDR      R1,[SP, #+24]
    468             *ptx_data++ = HI_INT16U(nbr_coils);
   \   00000042   0x0008             MOVS     R0,R1
   \   00000044   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000046   0x0A00             LSRS     R0,R0,#+8
   \   00000048   0x7010             STRB     R0,[R2, #+0]
   \   0000004A   0x1C52             ADDS     R2,R2,#+1
    469             *ptx_data++ = LO_INT16U(nbr_coils);
   \   0000004C   0x7011             STRB     R1,[R2, #+0]
   \   0000004E   0x1C52             ADDS     R2,R2,#+1
    470              nbr_bytes  = 0;
   \   00000050   0x2600             MOVS     R6,#+0
    471          
    472              /***********************************************
    473              * 描述： 发送
    474              */
    475              CPU_INT08S  retrys  = pch->Retrys;
   \   00000052   0xF894 0x0852      LDRB     R0,[R4, #+2130]
   \   00000056   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000058   0x08C7             LSRS     R7,R0,#+3
    476              do {
    477                MBM_TxCmd(pch);
   \                     ??MBM_FC01_CoilRd_2: (+1)
   \   0000005A   0x0020             MOVS     R0,R4
   \   0000005C   0x.... 0x....      BL       MBM_TxCmd
    478                MB_OS_RxWait(pch,&err);
   \   00000060   0x4669             MOV      R1,SP
   \   00000062   0x0020             MOVS     R0,R4
   \   00000064   0x.... 0x....      BL       MB_OS_RxWait
    479              } while ( ( err == MODBUS_ERR_TIMED_OUT ) && --retrys  );
   \   00000068   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000006C   0xF640 0x31B8      MOVW     R1,#+3000
   \   00000070   0x4288             CMP      R0,R1
   \   00000072   0xD103             BNE.N    ??MBM_FC01_CoilRd_3
   \   00000074   0x1E7F             SUBS     R7,R7,#+1
   \   00000076   0xB27F             SXTB     R7,R7            ;; SignExt  R7,R7,#+24,#+24
   \   00000078   0x2F00             CMP      R7,#+0
   \   0000007A   0xD1EE             BNE.N    ??MBM_FC01_CoilRd_2
    480          
    481              if ( err == MODBUS_ERR_NONE ) {
   \                     ??MBM_FC01_CoilRd_3: (+1)
   \   0000007C   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD12E             BNE.N    ??MBM_FC01_CoilRd_4
    482                  ok = MBM_RxReply(pch);
   \   00000084   0x0020             MOVS     R0,R4
   \   00000086   0x.... 0x....      BL       MBM_RxReply
    483                  if ( DEF_TRUE == ok ) {
   \   0000008A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008C   0x2801             CMP      R0,#+1
   \   0000008E   0xD12B             BNE.N    ??MBM_FC01_CoilRd_5
    484                      calc_crc = MB_RTU_RxCalcCRC(pch);          /* Do our own calculation of the CRC.                              */
   \   00000090   0x0020             MOVS     R0,R4
   \   00000092   0x.... 0x....      BL       MB_RTU_RxCalcCRC
    485                      if (calc_crc != pch->RxFrameCRC) {         /* If the calculated CRC does not match the CRC received,          */
   \   00000096   0xF8B4 0x1646      LDRH     R1,[R4, #+1606]
   \   0000009A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000009C   0x4288             CMP      R0,R1
   \   0000009E   0xD003             BEQ.N    ??MBM_FC01_CoilRd_6
    486                        /***********************************************
    487                        * 描述： 校验错误
    488                        */
    489                        pch->StatCRCErrCtr++;                    /* then the frame was not received properly.                       */
   \   000000A0   0x8C20             LDRH     R0,[R4, #+32]
   \   000000A2   0x1C40             ADDS     R0,R0,#+1
   \   000000A4   0x8420             STRH     R0,[R4, #+32]
   \   000000A6   0xE01F             B.N      ??MBM_FC01_CoilRd_5
    490                      } else if (MBM_RX_FCXX_CODE == 0X81) {
   \                     ??MBM_FC01_CoilRd_6: (+1)
   \   000000A8   0xF894 0x0445      LDRB     R0,[R4, #+1093]
   \   000000AC   0x2881             CMP      R0,#+129
   \   000000AE   0xD104             BNE.N    ??MBM_FC01_CoilRd_7
    491                        pch->StatExceptCtr++;
   \   000000B0   0x8C60             LDRH     R0,[R4, #+34]
   \   000000B2   0x1C40             ADDS     R0,R0,#+1
   \   000000B4   0x8460             STRH     R0,[R4, #+34]
    492                        /***********************************************
    493                        * 描述： 其他错误
    494                        //功能码03H： 读寄存器值错误响应
    495                        //第1字节	    ADR      	：	从机地址码（=001～254）
    496                        //第2字节　   83H			：	读寄存器值出错
    497                        //第3字节　   信息码		：	见信息码表
    498                        //第4、5字节	CRC			：	从字节1到3的CRC16校验和
    499                        //数息码	    表示意义
    500                        //01H	        非法的功能号
    501                        //02H	        非法的数据地址
    502                        //03H	        非法的数据值
    503                        //04H	        CRC16校验错
    504                        //05H	        接收正确
    505                        //06H	        接收错误
    506                        //07	        参数错误
    507                        */
    508                        nbr_bytes  = 0;
   \   000000B6   0x2600             MOVS     R6,#+0
   \   000000B8   0xE016             B.N      ??MBM_FC01_CoilRd_5
    509                      } else {
    510                        pch->StatMsgCtr++;
   \                     ??MBM_FC01_CoilRd_7: (+1)
   \   000000BA   0x8BE0             LDRH     R0,[R4, #+30]
   \   000000BC   0x1C40             ADDS     R0,R0,#+1
   \   000000BE   0x83E0             STRH     R0,[R4, #+30]
    511          #if MBM_STAT_CTR_AUTO_CLR_EN        == DEF_ENABLED
    512                        pch->StatNoRespCtr    = 0;
    513                        pch->StatCRCErrCtr    = 0;
    514                        pch->StatExceptCtr    = 0;
    515          #endif
    516                        /***********************************************
    517                        * 描述： 接收正确,且输入指针与数据指针不相等
    518                        */
    519                        nbr_bytes        = MBM_RX_FC01_NBYTE;
   \   000000C0   0xF894 0x6446      LDRB     R6,[R4, #+1094]
    520                        CPU_INT08U    idx    = 0;
   \   000000C4   0x2000             MOVS     R0,#+0
    521                        while(idx < nbr_bytes) {
   \                     ??MBM_FC01_CoilRd_8: (+1)
   \   000000C6   0x0001             MOVS     R1,R0
   \   000000C8   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000CA   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000CC   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000CE   0x42B1             CMP      R1,R6
   \   000000D0   0xD20A             BCS.N    ??MBM_FC01_CoilRd_5
    522                          p_coil_tbl[idx]    = MBM_RX_FC01_DATA(idx);
   \   000000D2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D4   0x1901             ADDS     R1,R0,R4
   \   000000D6   0xF891 0x1447      LDRB     R1,[R1, #+1095]
   \   000000DA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000DC   0x5541             STRB     R1,[R0, R5]
    523                          idx++;
   \   000000DE   0x1C40             ADDS     R0,R0,#+1
   \   000000E0   0xE7F1             B.N      ??MBM_FC01_CoilRd_8
    524                        }
    525                      }
    526                  }
    527              } else {
    528                  pch->StatNoRespCtr++;
   \                     ??MBM_FC01_CoilRd_4: (+1)
   \   000000E2   0x8CE0             LDRH     R0,[R4, #+38]
   \   000000E4   0x1C40             ADDS     R0,R0,#+1
   \   000000E6   0x84E0             STRH     R0,[R4, #+38]
    529              }
    530          
    531              pch->RxBufByteCtr = 0;
   \                     ??MBM_FC01_CoilRd_5: (+1)
   \   000000E8   0x2000             MOVS     R0,#+0
   \   000000EA   0x8620             STRH     R0,[R4, #+48]
    532              pch->RxBufPtr     = &pch->RxBuf[0];
   \   000000EC   0xF114 0x0038      ADDS     R0,R4,#+56
   \   000000F0   0x6360             STR      R0,[R4, #+52]
    533          
    534              MB_OS_TxOver(pch);
   \   000000F2   0x0020             MOVS     R0,R4
   \   000000F4   0x.... 0x....      BL       MB_OS_TxOver
    535          
    536              return nbr_bytes;
   \   000000F8   0x0030             MOVS     R0,R6
   \   000000FA   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??MBM_FC01_CoilRd_1: (+1)
   \   000000FC   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    537          }
    538          #endif
    539          #endif
    540          
    541          /*$PAGE*/
    542          /*
    543          *********************************************************************************************************
    544          *                                           MBS_FC05_CoilWr()
    545          *
    546          * Description : Responds to a request to force a coil to a specified state.
    547          *
    548          * Argument(s) : pch       Is a pointer to the Modbus channel's data structure.
    549          *
    550          * Return(s)   : DEF_TRUE      If a response needs to be sent
    551          *               DEF_FALSE     If not
    552          *
    553          * Caller(s)   : MBS_FCxx_Handler()
    554          *
    555          * Note(s)     : none
    556          *********************************************************************************************************
    557          */
    558          
    559          #if (MODBUS_CFG_MASTER_EN == DEF_ENABLED)
    560          #if (MODBUS_CFG_FC05_EN  == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    561          CPU_INT16U  MBM_FC05_CoilWr          (MODBUS_CH   *pch,
    562                                                CPU_INT08U   slave_node,
    563                                                CPU_INT16U   slave_addr,
    564                                                CPU_BOOLEAN  coil_val)
    565          {
   \                     MBM_FC05_CoilWr: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000F             MOVS     R7,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001D             MOVS     R5,R3
    566          
    567              CPU_INT08U     *ptx_data;
    568              CPU_INT16U      err;
    569              CPU_BOOLEAN     ok;
    570              CPU_INT16U      calc_crc;
    571              CPU_INT32U      timeout;
    572          
    573          
    574              MB_OS_TxWait(pch,&err);
   \   0000000A   0x4669             MOV      R1,SP
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       MB_OS_TxWait
    575              if ( err != MODBUS_ERR_NONE )
   \   00000012   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD001             BEQ.N    ??MBM_FC05_CoilWr_0
    576                  return 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE07A             B.N      ??MBM_FC05_CoilWr_1
    577              ptx_data  = &(pch->TxFrameData[0]);
   \                     ??MBM_FC05_CoilWr_0: (+1)
   \   0000001E   0xF204 0x614E      ADDW     R1,R4,#+1614
    578          
    579             *ptx_data++ = slave_node;
   \   00000022   0x700F             STRB     R7,[R1, #+0]
   \   00000024   0x1C49             ADDS     R1,R1,#+1
    580             *ptx_data++ = MODBUS_FC05_COIL_WR;
   \   00000026   0x2005             MOVS     R0,#+5
   \   00000028   0x7008             STRB     R0,[R1, #+0]
   \   0000002A   0x1C49             ADDS     R1,R1,#+1
    581             *ptx_data++ = HI_INT16U(slave_addr);
   \   0000002C   0x0030             MOVS     R0,R6
   \   0000002E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000030   0x0A00             LSRS     R0,R0,#+8
   \   00000032   0x7008             STRB     R0,[R1, #+0]
   \   00000034   0x1C49             ADDS     R1,R1,#+1
    582             *ptx_data++ = LO_INT16U(slave_addr);
   \   00000036   0x700E             STRB     R6,[R1, #+0]
   \   00000038   0x1C49             ADDS     R1,R1,#+1
    583             *ptx_data++ = (coil_val) ? 0xff : 0x00;
   \   0000003A   0x0008             MOVS     R0,R1
   \   0000003C   0x1C41             ADDS     R1,R0,#+1
   \   0000003E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000040   0x2D00             CMP      R5,#+0
   \   00000042   0xD001             BEQ.N    ??MBM_FC05_CoilWr_2
   \   00000044   0x22FF             MOVS     R2,#+255
   \   00000046   0xE000             B.N      ??MBM_FC05_CoilWr_3
   \                     ??MBM_FC05_CoilWr_2: (+1)
   \   00000048   0x2200             MOVS     R2,#+0
   \                     ??MBM_FC05_CoilWr_3: (+1)
   \   0000004A   0x7002             STRB     R2,[R0, #+0]
    584             *ptx_data++ = 0x00;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x7008             STRB     R0,[R1, #+0]
   \   00000050   0x1C49             ADDS     R1,R1,#+1
    585              pch->TxFrameNDataBytes  = 4;
   \   00000052   0x2004             MOVS     R0,#+4
   \   00000054   0xF8A4 0x084E      STRH     R0,[R4, #+2126]
    586          
    587              coil_val   = 0;
   \   00000058   0x2500             MOVS     R5,#+0
    588          
    589              timeout = pch->RxTimeout;
   \   0000005A   0x6AA6             LDR      R6,[R4, #+40]
    590              MB_MasterTimeoutSet(pch, 300u);                    // 设置MODBUS主机超时为500ms
   \   0000005C   0xF44F 0x7196      MOV      R1,#+300
   \   00000060   0x0020             MOVS     R0,R4
   \   00000062   0x.... 0x....      BL       MB_MasterTimeoutSet
    591              /***********************************************
    592              * 描述： 发送
    593              */
    594              CPU_INT08S  retrys  = pch->Retrys;
   \   00000066   0xF894 0x0852      LDRB     R0,[R4, #+2130]
   \   0000006A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006C   0x08C7             LSRS     R7,R0,#+3
    595              do {
    596                MBM_TxCmd(pch);
   \                     ??MBM_FC05_CoilWr_4: (+1)
   \   0000006E   0x0020             MOVS     R0,R4
   \   00000070   0x.... 0x....      BL       MBM_TxCmd
    597                MB_OS_RxWait(pch,&err);
   \   00000074   0x4669             MOV      R1,SP
   \   00000076   0x0020             MOVS     R0,R4
   \   00000078   0x.... 0x....      BL       MB_OS_RxWait
    598              } while ( ( err == MODBUS_ERR_TIMED_OUT ) && --retrys  );
   \   0000007C   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000080   0xF640 0x31B8      MOVW     R1,#+3000
   \   00000084   0x4288             CMP      R0,R1
   \   00000086   0xD103             BNE.N    ??MBM_FC05_CoilWr_5
   \   00000088   0x1E7F             SUBS     R7,R7,#+1
   \   0000008A   0xB27F             SXTB     R7,R7            ;; SignExt  R7,R7,#+24,#+24
   \   0000008C   0x2F00             CMP      R7,#+0
   \   0000008E   0xD1EE             BNE.N    ??MBM_FC05_CoilWr_4
    599          
    600              MB_MasterTimeoutSet(pch, timeout);                // 设置MODBUS主机超时为500ms
   \                     ??MBM_FC05_CoilWr_5: (+1)
   \   00000090   0x0031             MOVS     R1,R6
   \   00000092   0x0020             MOVS     R0,R4
   \   00000094   0x.... 0x....      BL       MB_MasterTimeoutSet
    601          
    602              if ( err == MODBUS_ERR_NONE ) {
   \   00000098   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000009C   0x2800             CMP      R0,#+0
   \   0000009E   0xD12B             BNE.N    ??MBM_FC05_CoilWr_6
    603                  ok = MBM_RxReply(pch);
   \   000000A0   0x0020             MOVS     R0,R4
   \   000000A2   0x.... 0x....      BL       MBM_RxReply
    604                  if ( DEF_TRUE == ok ) {
   \   000000A6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A8   0x2801             CMP      R0,#+1
   \   000000AA   0xD128             BNE.N    ??MBM_FC05_CoilWr_7
    605                      calc_crc = MB_RTU_RxCalcCRC(pch);          /* Do our own calculation of the CRC.                              */
   \   000000AC   0x0020             MOVS     R0,R4
   \   000000AE   0x.... 0x....      BL       MB_RTU_RxCalcCRC
    606                      if (calc_crc != pch->RxFrameCRC) {         /* If the calculated CRC does not match the CRC received,          */
   \   000000B2   0xF8B4 0x1646      LDRH     R1,[R4, #+1606]
   \   000000B6   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000B8   0x4288             CMP      R0,R1
   \   000000BA   0xD003             BEQ.N    ??MBM_FC05_CoilWr_8
    607                        /***********************************************
    608                        * 描述： 校验错误
    609                        */
    610                        pch->StatCRCErrCtr++;                    /* then the frame was not received properly.                       */
   \   000000BC   0x8C20             LDRH     R0,[R4, #+32]
   \   000000BE   0x1C40             ADDS     R0,R0,#+1
   \   000000C0   0x8420             STRH     R0,[R4, #+32]
   \   000000C2   0xE01C             B.N      ??MBM_FC05_CoilWr_7
    611                      } else if (MBM_RX_FCXX_CODE == 0X85) {
   \                     ??MBM_FC05_CoilWr_8: (+1)
   \   000000C4   0xF894 0x0445      LDRB     R0,[R4, #+1093]
   \   000000C8   0x2885             CMP      R0,#+133
   \   000000CA   0xD10A             BNE.N    ??MBM_FC05_CoilWr_9
    612                        pch->StatExceptCtr++;
   \   000000CC   0x8C60             LDRH     R0,[R4, #+34]
   \   000000CE   0x1C40             ADDS     R0,R0,#+1
   \   000000D0   0x8460             STRH     R0,[R4, #+34]
    613                        /***********************************************
    614                        * 描述： 其他错误
    615                        //功能码06H： 写单个寄存器值
    616                        //第1字节	    ADR      		：从机地址码（=001～254）
    617                        //第2字节　   86H			    ：写寄存器值出错功能码
    618                        //第3字节　   错误数息码		：	见信息码表
    619                        //第4、5字节	CRC			    ：	从字节1到3的CRC16校验和
    620                        //数息码	    表示意义
    621                        //01H	        非法的功能号
    622                        //02H	        非法的数据地址
    623                        //03H	        非法的数据值
    624                        //04H	        CRC16校验错
    625                        //05H	        接收正确
    626                        //06H	        接收错误
    627                        //07	        参数错误
    628                        */
    629                        coil_val   = (MBM_RX_FC05_COIL_DATA_H) ? 1 : 0;
   \   000000D2   0xF894 0x0448      LDRB     R0,[R4, #+1096]
   \   000000D6   0x2800             CMP      R0,#+0
   \   000000D8   0xD001             BEQ.N    ??MBM_FC05_CoilWr_10
   \   000000DA   0x2501             MOVS     R5,#+1
   \   000000DC   0xE00F             B.N      ??MBM_FC05_CoilWr_7
   \                     ??MBM_FC05_CoilWr_10: (+1)
   \   000000DE   0x2500             MOVS     R5,#+0
   \   000000E0   0xE00D             B.N      ??MBM_FC05_CoilWr_7
    630                      } else {
    631                        pch->StatMsgCtr++;
   \                     ??MBM_FC05_CoilWr_9: (+1)
   \   000000E2   0x8BE0             LDRH     R0,[R4, #+30]
   \   000000E4   0x1C40             ADDS     R0,R0,#+1
   \   000000E6   0x83E0             STRH     R0,[R4, #+30]
    632          #if MBM_STAT_CTR_AUTO_CLR_EN        == DEF_ENABLED
    633                        pch->StatNoRespCtr    = 0;
    634                        pch->StatCRCErrCtr    = 0;
    635                        pch->StatExceptCtr    = 0;
    636          #endif
    637                        /***********************************************
    638                        * 描述： 接收正确
    639                        */
    640                        coil_val = (MBM_RX_FC05_COIL_DATA_H) ? 1 : 0;
   \   000000E8   0xF894 0x0448      LDRB     R0,[R4, #+1096]
   \   000000EC   0x2800             CMP      R0,#+0
   \   000000EE   0xD001             BEQ.N    ??MBM_FC05_CoilWr_11
   \   000000F0   0x2501             MOVS     R5,#+1
   \   000000F2   0xE004             B.N      ??MBM_FC05_CoilWr_7
   \                     ??MBM_FC05_CoilWr_11: (+1)
   \   000000F4   0x2500             MOVS     R5,#+0
   \   000000F6   0xE002             B.N      ??MBM_FC05_CoilWr_7
    641                      }
    642                  }
    643              } else {
    644                  pch->StatNoRespCtr++;
   \                     ??MBM_FC05_CoilWr_6: (+1)
   \   000000F8   0x8CE0             LDRH     R0,[R4, #+38]
   \   000000FA   0x1C40             ADDS     R0,R0,#+1
   \   000000FC   0x84E0             STRH     R0,[R4, #+38]
    645              }
    646          
    647              pch->RxBufByteCtr = 0;
   \                     ??MBM_FC05_CoilWr_7: (+1)
   \   000000FE   0x2000             MOVS     R0,#+0
   \   00000100   0x8620             STRH     R0,[R4, #+48]
    648              pch->RxBufPtr     = &pch->RxBuf[0];
   \   00000102   0xF114 0x0038      ADDS     R0,R4,#+56
   \   00000106   0x6360             STR      R0,[R4, #+52]
    649          
    650              MB_OS_TxOver(pch);
   \   00000108   0x0020             MOVS     R0,R4
   \   0000010A   0x.... 0x....      BL       MB_OS_TxOver
    651          
    652              return coil_val;
   \   0000010E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000110   0x0028             MOVS     R0,R5
   \   00000112   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??MBM_FC05_CoilWr_1: (+1)
   \   00000114   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    653          }
    654          #endif
    655          #endif
    656          
    657          
    658          /*$PAGE*/
    659          /*
    660          *********************************************************************************************************
    661          *                                           MBM_FC03_HoldingRegRd()
    662          *
    663          * Description : This is the main processing function for MODBUS commands.  The message integrity is
    664          *               verified, and if valid, the function requested is processed.  Unimplemented functions
    665          *               will generate an Illegal Function Exception Response code (01).
    666          *
    667          * Argument(s) : pch      Is a pointer to the Modbus channel's data structure.
    668          *
    669          * Return(s)   : none.
    670          *
    671          * Caller(s)   : Application
    672          *
    673          * Note(s)     : none.
    674          *********************************************************************************************************
    675          */
    676          
    677          #if (MODBUS_CFG_MASTER_EN == DEF_ENABLED)   && \
    678              (MODBUS_CFG_RTU_EN == DEF_ENABLED)      && \
    679              (MODBUS_CFG_FC03_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    680          CPU_INT16U  MBM_FC03_HoldingRegRd    (MODBUS_CH   *pch,
    681                                                CPU_INT08U   slave_node,
    682                                                CPU_INT16U   slave_addr,
    683                                                CPU_INT16U  *p_reg_tbl,
    684                                                CPU_INT16U   nbr_regs)
    685          {
   \                     MBM_FC03_HoldingRegRd: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000F             MOVS     R7,R1
   \   00000006   0x0014             MOVS     R4,R2
   \   00000008   0x001E             MOVS     R6,R3
    686              CPU_INT08U     *ptx_data;
    687              CPU_INT16U      err;
    688              CPU_BOOLEAN     ok;
    689              CPU_INT16U      calc_crc;
    690          
    691              MB_OS_TxWait(pch,&err);
   \   0000000A   0x4669             MOV      R1,SP
   \   0000000C   0x0028             MOVS     R0,R5
   \   0000000E   0x.... 0x....      BL       MB_OS_TxWait
    692              if ( err != MODBUS_ERR_NONE )
   \   00000012   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD001             BEQ.N    ??MBM_FC03_HoldingRegRd_0
    693                  return 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE07A             B.N      ??MBM_FC03_HoldingRegRd_1
    694              ptx_data    = &(pch->TxFrameData[0]);
   \                     ??MBM_FC03_HoldingRegRd_0: (+1)
   \   0000001E   0xF205 0x614E      ADDW     R1,R5,#+1614
    695              pch->TxFrameNDataBytes  = 4;
   \   00000022   0x2004             MOVS     R0,#+4
   \   00000024   0xF8A5 0x084E      STRH     R0,[R5, #+2126]
    696          
    697             *ptx_data++ = slave_node;
   \   00000028   0x700F             STRB     R7,[R1, #+0]
   \   0000002A   0x1C49             ADDS     R1,R1,#+1
    698             *ptx_data++ = MODBUS_FC03_HOLDING_REG_RD;
   \   0000002C   0x2003             MOVS     R0,#+3
   \   0000002E   0x7008             STRB     R0,[R1, #+0]
   \   00000030   0x1C49             ADDS     R1,R1,#+1
    699             *ptx_data++ = HI_INT16U(slave_addr);
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000036   0x0A00             LSRS     R0,R0,#+8
   \   00000038   0x7008             STRB     R0,[R1, #+0]
   \   0000003A   0x1C49             ADDS     R1,R1,#+1
    700             *ptx_data++ = LO_INT16U(slave_addr);
   \   0000003C   0x700C             STRB     R4,[R1, #+0]
   \   0000003E   0x1C49             ADDS     R1,R1,#+1
   \   00000040   0x9C06             LDR      R4,[SP, #+24]
    701             *ptx_data++ = HI_INT16U(nbr_regs);
   \   00000042   0x0020             MOVS     R0,R4
   \   00000044   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000046   0x0A00             LSRS     R0,R0,#+8
   \   00000048   0x7008             STRB     R0,[R1, #+0]
   \   0000004A   0x1C49             ADDS     R1,R1,#+1
    702             *ptx_data++ = LO_INT16U(nbr_regs);
   \   0000004C   0x700C             STRB     R4,[R1, #+0]
   \   0000004E   0x1C49             ADDS     R1,R1,#+1
    703              nbr_regs    = 0;
   \   00000050   0x2400             MOVS     R4,#+0
    704          
    705              /***********************************************
    706              * 描述： 发送
    707              */
    708              CPU_INT08S  retrys  = pch->Retrys;
   \   00000052   0xF895 0x0852      LDRB     R0,[R5, #+2130]
   \   00000056   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000058   0x08C7             LSRS     R7,R0,#+3
    709              do {
    710                MBM_TxCmd(pch);
   \                     ??MBM_FC03_HoldingRegRd_2: (+1)
   \   0000005A   0x0028             MOVS     R0,R5
   \   0000005C   0x.... 0x....      BL       MBM_TxCmd
    711                MB_OS_RxWait(pch,&err);
   \   00000060   0x4669             MOV      R1,SP
   \   00000062   0x0028             MOVS     R0,R5
   \   00000064   0x.... 0x....      BL       MB_OS_RxWait
    712              } while ( ( err == MODBUS_ERR_TIMED_OUT ) && --retrys  );
   \   00000068   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000006C   0xF640 0x31B8      MOVW     R1,#+3000
   \   00000070   0x4288             CMP      R0,R1
   \   00000072   0xD103             BNE.N    ??MBM_FC03_HoldingRegRd_3
   \   00000074   0x1E7F             SUBS     R7,R7,#+1
   \   00000076   0xB27F             SXTB     R7,R7            ;; SignExt  R7,R7,#+24,#+24
   \   00000078   0x2F00             CMP      R7,#+0
   \   0000007A   0xD1EE             BNE.N    ??MBM_FC03_HoldingRegRd_2
    713          
    714              if ( err == MODBUS_ERR_NONE ) {
   \                     ??MBM_FC03_HoldingRegRd_3: (+1)
   \   0000007C   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD13A             BNE.N    ??MBM_FC03_HoldingRegRd_4
    715                  ok = MBM_RxReply(pch);
   \   00000084   0x0028             MOVS     R0,R5
   \   00000086   0x.... 0x....      BL       MBM_RxReply
    716                  if ( DEF_TRUE == ok ) {
   \   0000008A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008C   0x2801             CMP      R0,#+1
   \   0000008E   0xD137             BNE.N    ??MBM_FC03_HoldingRegRd_5
    717                      calc_crc = MB_RTU_RxCalcCRC(pch);          /* Do our own calculation of the CRC.                              */
   \   00000090   0x0028             MOVS     R0,R5
   \   00000092   0x.... 0x....      BL       MB_RTU_RxCalcCRC
    718                      if (calc_crc != pch->RxFrameCRC) {         /* If the calculated CRC does not match the CRC received,          */
   \   00000096   0xF8B5 0x1646      LDRH     R1,[R5, #+1606]
   \   0000009A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000009C   0x4288             CMP      R0,R1
   \   0000009E   0xD003             BEQ.N    ??MBM_FC03_HoldingRegRd_6
    719                        /***********************************************
    720                        * 描述： 校验错误
    721                        */
    722                        pch->StatCRCErrCtr++;                    /* then the frame was not received properly.                       */
   \   000000A0   0x8C28             LDRH     R0,[R5, #+32]
   \   000000A2   0x1C40             ADDS     R0,R0,#+1
   \   000000A4   0x8428             STRH     R0,[R5, #+32]
   \   000000A6   0xE02B             B.N      ??MBM_FC03_HoldingRegRd_5
    723                      } else if (MBM_RX_FCXX_CODE == 0X83) {
   \                     ??MBM_FC03_HoldingRegRd_6: (+1)
   \   000000A8   0xF895 0x0445      LDRB     R0,[R5, #+1093]
   \   000000AC   0x2883             CMP      R0,#+131
   \   000000AE   0xD104             BNE.N    ??MBM_FC03_HoldingRegRd_7
    724                        pch->StatExceptCtr++;
   \   000000B0   0x8C68             LDRH     R0,[R5, #+34]
   \   000000B2   0x1C40             ADDS     R0,R0,#+1
   \   000000B4   0x8468             STRH     R0,[R5, #+34]
    725                        /***********************************************
    726                        * 描述： 其他错误
    727                        //功能码03H： 读寄存器值错误响应
    728                        //第1字节	    ADR      	：	从机地址码（=001～254）
    729                        //第2字节　   83H			：	读寄存器值出错
    730                        //第3字节　   信息码		：	见信息码表
    731                        //第4、5字节	CRC			：	从字节1到3的CRC16校验和
    732                        //数息码	    表示意义
    733                        //01H	        非法的功能号
    734                        //02H	        非法的数据地址
    735                        //03H	        非法的数据值
    736                        //04H	        CRC16校验错
    737                        //05H	        接收正确
    738                        //06H	        接收错误
    739                        //07	        参数错误
    740                        */
    741                        nbr_regs  = 0;
   \   000000B6   0x2400             MOVS     R4,#+0
   \   000000B8   0xE022             B.N      ??MBM_FC03_HoldingRegRd_5
    742                      } else {
    743                        pch->StatMsgCtr++;
   \                     ??MBM_FC03_HoldingRegRd_7: (+1)
   \   000000BA   0x8BE8             LDRH     R0,[R5, #+30]
   \   000000BC   0x1C40             ADDS     R0,R0,#+1
   \   000000BE   0x83E8             STRH     R0,[R5, #+30]
    744          #if MBM_STAT_CTR_AUTO_CLR_EN        == DEF_ENABLED
    745                        pch->StatNoRespCtr    = 0;
    746                        pch->StatCRCErrCtr    = 0;
    747                        pch->StatExceptCtr    = 0;
    748          #endif
    749                        /***********************************************
    750                        * 描述： 接收正确,且输入指针与数据指针不相等
    751                        */
    752                        nbr_regs        = MBM_RX_FC03_NBYTE / 2;
   \   000000C0   0xF895 0x0446      LDRB     R0,[R5, #+1094]
   \   000000C4   0x2102             MOVS     R1,#+2
   \   000000C6   0xFB90 0xF4F1      SDIV     R4,R0,R1
    753                        CPU_INT08U    idx    = 0;
   \   000000CA   0x2000             MOVS     R0,#+0
    754                        while(idx < nbr_regs) {
   \                     ??MBM_FC03_HoldingRegRd_8: (+1)
   \   000000CC   0x0001             MOVS     R1,R0
   \   000000CE   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000D0   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000D2   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000D4   0x42A1             CMP      R1,R4
   \   000000D6   0xD213             BCS.N    ??MBM_FC03_HoldingRegRd_5
    755                          p_reg_tbl[idx]    = MBM_RX_FC03_DATA(idx);
   \   000000D8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000DA   0xEB15 0x0140      ADDS     R1,R5,R0, LSL #+1
   \   000000DE   0xF891 0x1447      LDRB     R1,[R1, #+1095]
   \   000000E2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E4   0xEB15 0x0240      ADDS     R2,R5,R0, LSL #+1
   \   000000E8   0xF892 0x2448      LDRB     R2,[R2, #+1096]
   \   000000EC   0xEB12 0x2101      ADDS     R1,R2,R1, LSL #+8
   \   000000F0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000F2   0xF826 0x1010      STRH     R1,[R6, R0, LSL #+1]
    756                          idx++;
   \   000000F6   0x1C40             ADDS     R0,R0,#+1
   \   000000F8   0xE7E8             B.N      ??MBM_FC03_HoldingRegRd_8
    757                        }
    758                      }
    759                  }
    760              } else {
    761                  pch->StatNoRespCtr++;
   \                     ??MBM_FC03_HoldingRegRd_4: (+1)
   \   000000FA   0x8CE8             LDRH     R0,[R5, #+38]
   \   000000FC   0x1C40             ADDS     R0,R0,#+1
   \   000000FE   0x84E8             STRH     R0,[R5, #+38]
    762              }
    763          
    764              pch->RxBufByteCtr = 0;
   \                     ??MBM_FC03_HoldingRegRd_5: (+1)
   \   00000100   0x2000             MOVS     R0,#+0
   \   00000102   0x8628             STRH     R0,[R5, #+48]
    765              pch->RxBufPtr     = &pch->RxBuf[0];
   \   00000104   0xF115 0x0038      ADDS     R0,R5,#+56
   \   00000108   0x6368             STR      R0,[R5, #+52]
    766          
    767              MB_OS_TxOver(pch);
   \   0000010A   0x0028             MOVS     R0,R5
   \   0000010C   0x.... 0x....      BL       MB_OS_TxOver
    768          
    769              return nbr_regs;
   \   00000110   0x0020             MOVS     R0,R4
   \   00000112   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??MBM_FC03_HoldingRegRd_1: (+1)
   \   00000114   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    770          }
    771          #endif
    772          
    773          /*$PAGE*/
    774          /*
    775          *********************************************************************************************************
    776          *                                           MBM_FC06_HoldingRegWr()
    777          *
    778          * Description : This is the main processing function for MODBUS commands.  The message integrity is
    779          *               verified, and if valid, the function requested is processed.  Unimplemented functions
    780          *               will generate an Illegal Function Exception Response code (01).
    781          *
    782          * Argument(s) : pch      Is a pointer to the Modbus channel's data structure.
    783          *
    784          * Return(s)   : none.
    785          *
    786          * Caller(s)   : Application
    787          *
    788          * Note(s)     : none.
    789          *********************************************************************************************************
    790          */
    791          #if (MODBUS_CFG_MASTER_EN == DEF_ENABLED)   && \
    792              (MODBUS_CFG_RTU_EN == DEF_ENABLED)      && \
    793              (MODBUS_CFG_FC06_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    794          CPU_INT16U  MBM_FC06_HoldingRegWr (  MODBUS_CH   *pch,
    795                                               CPU_INT08U   slave_node,
    796                                               CPU_INT16U   slave_addr,
    797                                               CPU_INT16U   reg_val)
    798          {
   \                     MBM_FC06_HoldingRegWr: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000F             MOVS     R7,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001D             MOVS     R5,R3
    799              CPU_INT08U     *ptx_data;
    800              CPU_INT16U      err;
    801              CPU_BOOLEAN     ok;
    802              CPU_INT16U      calc_crc;
    803              CPU_INT32U      timeout;
    804          
    805          
    806              MB_OS_TxWait(pch,&err);
   \   0000000A   0x4669             MOV      R1,SP
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       MB_OS_TxWait
    807              if ( err != MODBUS_ERR_NONE )
   \   00000012   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD004             BEQ.N    ??MBM_FC06_HoldingRegWr_0
    808                  return (reg_val    = ~reg_val);                 // 取反，防止数据为0时相等
   \   0000001A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000001C   0x43ED             MVNS     R5,R5
   \   0000001E   0x0028             MOVS     R0,R5
   \   00000020   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000022   0xE06E             B.N      ??MBM_FC06_HoldingRegWr_1
    809              ptx_data  = &(pch->TxFrameData[0]);
   \                     ??MBM_FC06_HoldingRegWr_0: (+1)
   \   00000024   0xF204 0x614E      ADDW     R1,R4,#+1614
    810          
    811             *ptx_data++ = slave_node;
   \   00000028   0x700F             STRB     R7,[R1, #+0]
   \   0000002A   0x1C49             ADDS     R1,R1,#+1
    812             *ptx_data++ = MODBUS_FC06_HOLDING_REG_WR;
   \   0000002C   0x2006             MOVS     R0,#+6
   \   0000002E   0x7008             STRB     R0,[R1, #+0]
   \   00000030   0x1C49             ADDS     R1,R1,#+1
    813             *ptx_data++ = HI_INT16U(slave_addr);
   \   00000032   0x0030             MOVS     R0,R6
   \   00000034   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000036   0x0A00             LSRS     R0,R0,#+8
   \   00000038   0x7008             STRB     R0,[R1, #+0]
   \   0000003A   0x1C49             ADDS     R1,R1,#+1
    814             *ptx_data++ = LO_INT16U(slave_addr);
   \   0000003C   0x700E             STRB     R6,[R1, #+0]
   \   0000003E   0x1C49             ADDS     R1,R1,#+1
    815             *ptx_data++ = HI_INT16U(reg_val);
   \   00000040   0x0028             MOVS     R0,R5
   \   00000042   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000044   0x0A00             LSRS     R0,R0,#+8
   \   00000046   0x7008             STRB     R0,[R1, #+0]
   \   00000048   0x1C49             ADDS     R1,R1,#+1
    816             *ptx_data++ = LO_INT16U(reg_val);
   \   0000004A   0x700D             STRB     R5,[R1, #+0]
   \   0000004C   0x1C49             ADDS     R1,R1,#+1
    817              reg_val    = ~reg_val;                              // 取反，防止数据为0时相等
   \   0000004E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000050   0x43ED             MVNS     R5,R5
    818              pch->TxFrameNDataBytes  = 4;
   \   00000052   0x2004             MOVS     R0,#+4
   \   00000054   0xF8A4 0x084E      STRH     R0,[R4, #+2126]
    819          
    820              timeout = pch->RxTimeout;
   \   00000058   0x6AA6             LDR      R6,[R4, #+40]
    821              MB_MasterTimeoutSet(pch, 300u);                     // 设置MODBUS主机超时为500ms
   \   0000005A   0xF44F 0x7196      MOV      R1,#+300
   \   0000005E   0x0020             MOVS     R0,R4
   \   00000060   0x.... 0x....      BL       MB_MasterTimeoutSet
    822          
    823              /***********************************************
    824              * 描述： 发送
    825              */
    826              CPU_INT08S  retrys  = pch->Retrys;
   \   00000064   0xF894 0x0852      LDRB     R0,[R4, #+2130]
   \   00000068   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006A   0x08C7             LSRS     R7,R0,#+3
    827              do {
    828                MBM_TxCmd(pch);
   \                     ??MBM_FC06_HoldingRegWr_2: (+1)
   \   0000006C   0x0020             MOVS     R0,R4
   \   0000006E   0x.... 0x....      BL       MBM_TxCmd
    829                MB_OS_RxWait(pch,&err);
   \   00000072   0x4669             MOV      R1,SP
   \   00000074   0x0020             MOVS     R0,R4
   \   00000076   0x.... 0x....      BL       MB_OS_RxWait
    830              } while ( ( err == MODBUS_ERR_TIMED_OUT ) && --retrys  );
   \   0000007A   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000007E   0xF640 0x31B8      MOVW     R1,#+3000
   \   00000082   0x4288             CMP      R0,R1
   \   00000084   0xD103             BNE.N    ??MBM_FC06_HoldingRegWr_3
   \   00000086   0x1E7F             SUBS     R7,R7,#+1
   \   00000088   0xB27F             SXTB     R7,R7            ;; SignExt  R7,R7,#+24,#+24
   \   0000008A   0x2F00             CMP      R7,#+0
   \   0000008C   0xD1EE             BNE.N    ??MBM_FC06_HoldingRegWr_2
    831          
    832              MB_MasterTimeoutSet(pch, timeout);                // 设置MODBUS主机超时为500ms
   \                     ??MBM_FC06_HoldingRegWr_3: (+1)
   \   0000008E   0x0031             MOVS     R1,R6
   \   00000090   0x0020             MOVS     R0,R4
   \   00000092   0x.... 0x....      BL       MB_MasterTimeoutSet
    833          
    834              if ( err == MODBUS_ERR_NONE ) {
   \   00000096   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xD124             BNE.N    ??MBM_FC06_HoldingRegWr_4
    835                  ok = MBM_RxReply(pch);
   \   0000009E   0x0020             MOVS     R0,R4
   \   000000A0   0x.... 0x....      BL       MBM_RxReply
    836                  if ( DEF_TRUE == ok ) {
   \   000000A4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A6   0x2801             CMP      R0,#+1
   \   000000A8   0xD121             BNE.N    ??MBM_FC06_HoldingRegWr_5
    837                      calc_crc = MB_RTU_RxCalcCRC(pch);          /* Do our own calculation of the CRC.                              */
   \   000000AA   0x0020             MOVS     R0,R4
   \   000000AC   0x.... 0x....      BL       MB_RTU_RxCalcCRC
    838                      if (calc_crc != pch->RxFrameCRC) {         /* If the calculated CRC does not match the CRC received,          */
   \   000000B0   0xF8B4 0x1646      LDRH     R1,[R4, #+1606]
   \   000000B4   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000B6   0x4288             CMP      R0,R1
   \   000000B8   0xD003             BEQ.N    ??MBM_FC06_HoldingRegWr_6
    839                        /***********************************************
    840                        * 描述： 校验错误
    841                        */
    842                        pch->StatCRCErrCtr++;                    /* then the frame was not received properly.                       */
   \   000000BA   0x8C20             LDRH     R0,[R4, #+32]
   \   000000BC   0x1C40             ADDS     R0,R0,#+1
   \   000000BE   0x8420             STRH     R0,[R4, #+32]
   \   000000C0   0xE015             B.N      ??MBM_FC06_HoldingRegWr_5
    843                      } else if (MBM_RX_FCXX_CODE == 0X86) {
   \                     ??MBM_FC06_HoldingRegWr_6: (+1)
   \   000000C2   0xF894 0x0445      LDRB     R0,[R4, #+1093]
   \   000000C6   0x2886             CMP      R0,#+134
   \   000000C8   0xD104             BNE.N    ??MBM_FC06_HoldingRegWr_7
    844                        pch->StatExceptCtr++;
   \   000000CA   0x8C60             LDRH     R0,[R4, #+34]
   \   000000CC   0x1C40             ADDS     R0,R0,#+1
   \   000000CE   0x8460             STRH     R0,[R4, #+34]
    845                        /***********************************************
    846                        * 描述： 其他错误
    847                        //功能码06H： 写单个寄存器值
    848                        //第1字节	    ADR      		：从机地址码（=001～254）
    849                        //第2字节　   86H			    ：写寄存器值出错功能码
    850                        //第3字节　   错误数息码		：	见信息码表
    851                        //第4、5字节	CRC			    ：	从字节1到3的CRC16校验和
    852                        //数息码	    表示意义
    853                        //01H	        非法的功能号
    854                        //02H	        非法的数据地址
    855                        //03H	        非法的数据值
    856                        //04H	        CRC16校验错
    857                        //05H	        接收正确
    858                        //06H	        接收错误
    859                        //07	        参数错误
    860                        */
    861                        reg_val   = 0;
   \   000000D0   0x2500             MOVS     R5,#+0
   \   000000D2   0xE00C             B.N      ??MBM_FC06_HoldingRegWr_5
    862                      } else {
    863                        pch->StatMsgCtr++;
   \                     ??MBM_FC06_HoldingRegWr_7: (+1)
   \   000000D4   0x8BE0             LDRH     R0,[R4, #+30]
   \   000000D6   0x1C40             ADDS     R0,R0,#+1
   \   000000D8   0x83E0             STRH     R0,[R4, #+30]
    864          #if MBM_STAT_CTR_AUTO_CLR_EN        == DEF_ENABLED
    865                        pch->StatNoRespCtr    = 0;
    866                        pch->StatCRCErrCtr    = 0;
    867                        pch->StatExceptCtr    = 0;
    868          #endif
    869                        /***********************************************
    870                        * 描述： 接收正确
    871                        */
    872                        reg_val = MBM_RX_FC06_DATA;
   \   000000DA   0xF894 0x0448      LDRB     R0,[R4, #+1096]
   \   000000DE   0xF894 0x1449      LDRB     R1,[R4, #+1097]
   \   000000E2   0xEB11 0x2500      ADDS     R5,R1,R0, LSL #+8
   \   000000E6   0xE002             B.N      ??MBM_FC06_HoldingRegWr_5
    873                      }
    874                  }
    875              } else {
    876                  pch->StatNoRespCtr++;
   \                     ??MBM_FC06_HoldingRegWr_4: (+1)
   \   000000E8   0x8CE0             LDRH     R0,[R4, #+38]
   \   000000EA   0x1C40             ADDS     R0,R0,#+1
   \   000000EC   0x84E0             STRH     R0,[R4, #+38]
    877              }
    878          
    879              pch->RxBufByteCtr = 0;
   \                     ??MBM_FC06_HoldingRegWr_5: (+1)
   \   000000EE   0x2000             MOVS     R0,#+0
   \   000000F0   0x8620             STRH     R0,[R4, #+48]
    880              pch->RxBufPtr     = &pch->RxBuf[0];
   \   000000F2   0xF114 0x0038      ADDS     R0,R4,#+56
   \   000000F6   0x6360             STR      R0,[R4, #+52]
    881          
    882              MB_OS_TxOver(pch);
   \   000000F8   0x0020             MOVS     R0,R4
   \   000000FA   0x.... 0x....      BL       MB_OS_TxOver
    883          
    884              return reg_val;
   \   000000FE   0x0028             MOVS     R0,R5
   \   00000100   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??MBM_FC06_HoldingRegWr_1: (+1)
   \   00000102   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    885          }
    886          #endif
    887          /*$PAGE*/
    888          /*
    889          *********************************************************************************************************
    890          *                                       MBS_FC15_CoilWrMultiple()
    891          *
    892          * Description : Processes the MODBUS "Force Multiple COILS" command and writes the COIL states.
    893          *
    894          * Argument(s) : pch       Is a pointer to the Modbus channel's data structure.
    895          *
    896          * Return(s)   : DEF_TRUE      If a response needs to be sent
    897          *               DEF_FALSE     If not
    898          *
    899          * Caller(s)   : MBS_FCxx_Handler()
    900          *
    901          * Note(s)     : none
    902          *********************************************************************************************************
    903          */
    904          
    905          #if (MODBUS_CFG_MASTER_EN == DEF_ENABLED)
    906          #if (MODBUS_CFG_FC15_EN  == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    907          CPU_INT16U  MBM_FC15_CoilWr          (MODBUS_CH   *pch,
    908                                                CPU_INT08U   slave_node,
    909                                                CPU_INT16U   slave_addr,
    910                                                CPU_INT08U  *p_coil_tbl,
    911                                                CPU_INT16U   nbr_coils)
    912          {
   \                     MBM_FC15_CoilWr: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0005             MOVS     R5,R0
   \   00000008   0x4688             MOV      R8,R1
   \   0000000A   0x0017             MOVS     R7,R2
   \   0000000C   0x4699             MOV      R9,R3
   \   0000000E   0x9C0A             LDR      R4,[SP, #+40]
    913              CPU_INT16U      nbr_bytes       = (nbr_coils - 1) / 8 + 1;    /* Get the byte count for the data.                         */
   \   00000010   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000012   0x1E60             SUBS     R0,R4,#+1
   \   00000014   0x2108             MOVS     R1,#+8
   \   00000016   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000001A   0x1C46             ADDS     R6,R0,#+1
    914              CPU_INT08U     *ptx_data;
    915              CPU_INT16U      err;
    916              CPU_BOOLEAN     ok;
    917              CPU_INT16U      calc_crc;
    918              CPU_INT16U      ctr             = nbr_bytes;
   \   0000001C   0x46B2             MOV      R10,R6
    919          
    920              if ( nbr_coils == 0 )
   \   0000001E   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD101             BNE.N    ??MBM_FC15_CoilWr_0
    921                return 0;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xE0A7             B.N      ??MBM_FC15_CoilWr_1
    922              /***************************************************
    923              * 描述：
    924              */
    925              MB_OS_TxWait(pch,&err);
   \                     ??MBM_FC15_CoilWr_0: (+1)
   \   00000028   0x4669             MOV      R1,SP
   \   0000002A   0x0028             MOVS     R0,R5
   \   0000002C   0x.... 0x....      BL       MB_OS_TxWait
    926              if ( err != MODBUS_ERR_NONE )
   \   00000030   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD001             BEQ.N    ??MBM_FC15_CoilWr_2
    927                  return 0;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xE09D             B.N      ??MBM_FC15_CoilWr_1
    928          
    929              ptx_data    = &(pch->TxFrameData[MBM_TX_FC16_DATA_IDX]);
   \                     ??MBM_FC15_CoilWr_2: (+1)
   \   0000003C   0xF205 0x6155      ADDW     R1,R5,#+1621
    930              /***************************************************
    931              * 描述： 如果输入数组与数据数组是同一数组，且是从第0个数据开始
    932              */
    933              if ( (CPU_INT08U *)p_coil_tbl == &(pch->TxFrameData[0]) ) {
   \   00000040   0xF205 0x604E      ADDW     R0,R5,#+1614
   \   00000044   0x4581             CMP      R9,R0
   \   00000046   0xD114             BNE.N    ??MBM_FC15_CoilWr_3
    934                ptx_data  += nbr_bytes + MBM_TX_FC16_DATA_IDX-1;                          // 指向数据的最后一个元素
   \   00000048   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000004A   0x1870             ADDS     R0,R6,R1
   \   0000004C   0x1D81             ADDS     R1,R0,#+6
    935                p_coil_tbl += nbr_bytes-1;                              // 指向最后一个寄存器
   \   0000004E   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000050   0xEB16 0x0009      ADDS     R0,R6,R9
   \   00000054   0xF1B0 0x0901      SUBS     R9,R0,#+1
    936          
    937                while(ctr--) {
   \                     ??MBM_FC15_CoilWr_4: (+1)
   \   00000058   0x4650             MOV      R0,R10
   \   0000005A   0xF1B0 0x0A01      SUBS     R10,R0,#+1
   \   0000005E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD023             BEQ.N    ??MBM_FC15_CoilWr_5
    938                 *ptx_data--      = *p_coil_tbl--;
   \   00000064   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   00000068   0x7008             STRB     R0,[R1, #+0]
   \   0000006A   0xF1B9 0x0901      SUBS     R9,R9,#+1
   \   0000006E   0x1E49             SUBS     R1,R1,#+1
   \   00000070   0xE7F2             B.N      ??MBM_FC15_CoilWr_4
    939                }
    940              /***************************************************
    941              * 描述： 如果输入指针不是当前通道的数据帧的第7个元素，则拷贝元素到数据帧数组
    942              */
    943              } else if ( (CPU_INT08U *)p_coil_tbl == &(pch->TxFrameData[MBM_TX_FC16_DATA_IDX]) ) {
   \                     ??MBM_FC15_CoilWr_3: (+1)
   \   00000072   0xF205 0x6055      ADDW     R0,R5,#+1621
   \   00000076   0x4581             CMP      R9,R0
   \   00000078   0xD112             BNE.N    ??MBM_FC15_CoilWr_6
    944                while(ctr--) {
   \                     ??MBM_FC15_CoilWr_7: (+1)
   \   0000007A   0x4650             MOV      R0,R10
   \   0000007C   0xF1B0 0x0A01      SUBS     R10,R0,#+1
   \   00000080   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD012             BEQ.N    ??MBM_FC15_CoilWr_5
    945                 *ptx_data++      = *p_coil_tbl++;
   \   00000086   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   0000008A   0x7008             STRB     R0,[R1, #+0]
   \   0000008C   0xF119 0x0901      ADDS     R9,R9,#+1
   \   00000090   0x1C49             ADDS     R1,R1,#+1
   \   00000092   0xE7F2             B.N      ??MBM_FC15_CoilWr_7
    946                }
    947              } else {
    948                while(ctr--) {
    949                 *ptx_data++      = *p_coil_tbl++;
   \                     ??MBM_FC15_CoilWr_8: (+1)
   \   00000094   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   00000098   0x7008             STRB     R0,[R1, #+0]
   \   0000009A   0xF119 0x0901      ADDS     R9,R9,#+1
   \   0000009E   0x1C49             ADDS     R1,R1,#+1
    950                }
   \                     ??MBM_FC15_CoilWr_6: (+1)
   \   000000A0   0x4650             MOV      R0,R10
   \   000000A2   0xF1B0 0x0A01      SUBS     R10,R0,#+1
   \   000000A6   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000A8   0x2800             CMP      R0,#+0
   \   000000AA   0xD1F3             BNE.N    ??MBM_FC15_CoilWr_8
    951              }
    952          
    953              ptx_data    = &(pch->TxFrameData[0]);
   \                     ??MBM_FC15_CoilWr_5: (+1)
   \   000000AC   0xF205 0x614E      ADDW     R1,R5,#+1614
    954              /***************************************************
    955              * 描述：
    956              */
    957             *ptx_data++ = slave_node;
   \   000000B0   0xF881 0x8000      STRB     R8,[R1, #+0]
   \   000000B4   0x1C49             ADDS     R1,R1,#+1
    958             *ptx_data++ = MODBUS_FC15_COIL_WR_MULTIPLE;
   \   000000B6   0x200F             MOVS     R0,#+15
   \   000000B8   0x7008             STRB     R0,[R1, #+0]
   \   000000BA   0x1C49             ADDS     R1,R1,#+1
    959             *ptx_data++ = HI_INT16U(slave_addr);
   \   000000BC   0x0038             MOVS     R0,R7
   \   000000BE   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000C0   0x0A00             LSRS     R0,R0,#+8
   \   000000C2   0x7008             STRB     R0,[R1, #+0]
   \   000000C4   0x1C49             ADDS     R1,R1,#+1
    960             *ptx_data++ = LO_INT16U(slave_addr);
   \   000000C6   0x700F             STRB     R7,[R1, #+0]
   \   000000C8   0x1C49             ADDS     R1,R1,#+1
    961             *ptx_data++ = HI_INT16U(nbr_coils);
   \   000000CA   0x0020             MOVS     R0,R4
   \   000000CC   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000CE   0x0A00             LSRS     R0,R0,#+8
   \   000000D0   0x7008             STRB     R0,[R1, #+0]
   \   000000D2   0x1C49             ADDS     R1,R1,#+1
    962             *ptx_data++ = LO_INT16U(nbr_coils);
   \   000000D4   0x700C             STRB     R4,[R1, #+0]
   \   000000D6   0x1C49             ADDS     R1,R1,#+1
    963              pch->TxFrameNDataBytes  = 5 + nbr_bytes;
   \   000000D8   0x1D70             ADDS     R0,R6,#+5
   \   000000DA   0xF8A5 0x084E      STRH     R0,[R5, #+2126]
    964             *ptx_data++ = pch->TxFrameNDataBytes - 5;
   \   000000DE   0xF8B5 0x084E      LDRH     R0,[R5, #+2126]
   \   000000E2   0x1F40             SUBS     R0,R0,#+5
   \   000000E4   0x7008             STRB     R0,[R1, #+0]
   \   000000E6   0x1C49             ADDS     R1,R1,#+1
    965          
    966              nbr_bytes    = 0;
   \   000000E8   0x2600             MOVS     R6,#+0
    967          
    968              /***********************************************
    969              * 描述： 发送
    970              */
    971              CPU_INT08S  retrys  = pch->Retrys;
   \   000000EA   0xF895 0x0852      LDRB     R0,[R5, #+2130]
   \   000000EE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000F0   0x08C4             LSRS     R4,R0,#+3
    972              do {
    973                MBM_TxCmd(pch);
   \                     ??MBM_FC15_CoilWr_9: (+1)
   \   000000F2   0x0028             MOVS     R0,R5
   \   000000F4   0x.... 0x....      BL       MBM_TxCmd
    974                MB_OS_RxWait(pch,&err);
   \   000000F8   0x4669             MOV      R1,SP
   \   000000FA   0x0028             MOVS     R0,R5
   \   000000FC   0x.... 0x....      BL       MB_OS_RxWait
    975              } while ( ( err == MODBUS_ERR_TIMED_OUT ) && --retrys  );
   \   00000100   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000104   0xF640 0x31B8      MOVW     R1,#+3000
   \   00000108   0x4288             CMP      R0,R1
   \   0000010A   0xD103             BNE.N    ??MBM_FC15_CoilWr_10
   \   0000010C   0x1E64             SUBS     R4,R4,#+1
   \   0000010E   0xB264             SXTB     R4,R4            ;; SignExt  R4,R4,#+24,#+24
   \   00000110   0x2C00             CMP      R4,#+0
   \   00000112   0xD1EE             BNE.N    ??MBM_FC15_CoilWr_9
    976          
    977              /***************************************************
    978              * 描述：
    979              */
    980              if ( err == MODBUS_ERR_NONE ) {
   \                     ??MBM_FC15_CoilWr_10: (+1)
   \   00000114   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000118   0x2800             CMP      R0,#+0
   \   0000011A   0xD120             BNE.N    ??MBM_FC15_CoilWr_11
    981                  ok = MBM_RxReply(pch);
   \   0000011C   0x0028             MOVS     R0,R5
   \   0000011E   0x.... 0x....      BL       MBM_RxReply
    982                  if ( DEF_TRUE == ok ) {
   \   00000122   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000124   0x2801             CMP      R0,#+1
   \   00000126   0xD11D             BNE.N    ??MBM_FC15_CoilWr_12
    983                      calc_crc = MB_RTU_RxCalcCRC(pch);          /* Do our own calculation of the CRC.                              */
   \   00000128   0x0028             MOVS     R0,R5
   \   0000012A   0x.... 0x....      BL       MB_RTU_RxCalcCRC
    984                      if (calc_crc != pch->RxFrameCRC) {         /* If the calculated CRC does not match the CRC received,          */
   \   0000012E   0xF8B5 0x1646      LDRH     R1,[R5, #+1606]
   \   00000132   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000134   0x4288             CMP      R0,R1
   \   00000136   0xD003             BEQ.N    ??MBM_FC15_CoilWr_13
    985                        /***********************************************
    986                        * 描述： 校验错误
    987                        */
    988                        pch->StatCRCErrCtr++;                    /* then the frame was not received properly.                       */
   \   00000138   0x8C28             LDRH     R0,[R5, #+32]
   \   0000013A   0x1C40             ADDS     R0,R0,#+1
   \   0000013C   0x8428             STRH     R0,[R5, #+32]
   \   0000013E   0xE011             B.N      ??MBM_FC15_CoilWr_12
    989                      } else if (MBM_RX_FCXX_CODE == 0X8F) {
   \                     ??MBM_FC15_CoilWr_13: (+1)
   \   00000140   0xF895 0x0445      LDRB     R0,[R5, #+1093]
   \   00000144   0x288F             CMP      R0,#+143
   \   00000146   0xD104             BNE.N    ??MBM_FC15_CoilWr_14
    990                          pch->StatExceptCtr++;
   \   00000148   0x8C68             LDRH     R0,[R5, #+34]
   \   0000014A   0x1C40             ADDS     R0,R0,#+1
   \   0000014C   0x8468             STRH     R0,[R5, #+34]
    991                        /***********************************************
    992                        * 描述： 其他错误
    993                        //功能码10H： 连续写多个寄存器值
    994                        //第1字节	    ADR      		：	从机地址码（=001～254）
    995                        //第2字节　   90H			    ：　写寄存器值出错
    996                        //第3字节　   错误信息码		：	见信息码表
    997                        //第4、5字节	CRC			    ：	从字节1到3的CRC16校验和
    998                        //数息码	    表示意义
    999                        //01H	        非法的功能号
   1000                        //02H	        非法的数据地址
   1001                        //03H	        非法的数据值
   1002                        //04H	        CRC16校验错
   1003                        //05H	        接收正确
   1004                        //06H	        接收错误
   1005                        //07	        参数错误
   1006                        */
   1007                        nbr_bytes = 0;
   \   0000014E   0x2600             MOVS     R6,#+0
   \   00000150   0xE008             B.N      ??MBM_FC15_CoilWr_12
   1008                      } else {
   1009                        pch->StatMsgCtr++;
   \                     ??MBM_FC15_CoilWr_14: (+1)
   \   00000152   0x8BE8             LDRH     R0,[R5, #+30]
   \   00000154   0x1C40             ADDS     R0,R0,#+1
   \   00000156   0x83E8             STRH     R0,[R5, #+30]
   1010          #if MBM_STAT_CTR_AUTO_CLR_EN        == DEF_ENABLED
   1011                        pch->StatNoRespCtr    = 0;
   1012                        pch->StatCRCErrCtr    = 0;
   1013                        pch->StatExceptCtr    = 0;
   1014          #endif
   1015                        /***********************************************
   1016                        * 描述： 接收正确
   1017                        */
   1018                        nbr_bytes = MBM_RX_FC15_COIL_BYTES;
   \   00000158   0xF895 0x644A      LDRB     R6,[R5, #+1098]
   \   0000015C   0xE002             B.N      ??MBM_FC15_CoilWr_12
   1019                      }
   1020                  }
   1021              } else {
   1022                  pch->StatNoRespCtr++;
   \                     ??MBM_FC15_CoilWr_11: (+1)
   \   0000015E   0x8CE8             LDRH     R0,[R5, #+38]
   \   00000160   0x1C40             ADDS     R0,R0,#+1
   \   00000162   0x84E8             STRH     R0,[R5, #+38]
   1023              }
   1024          
   1025              pch->RxBufByteCtr = 0;
   \                     ??MBM_FC15_CoilWr_12: (+1)
   \   00000164   0x2000             MOVS     R0,#+0
   \   00000166   0x8628             STRH     R0,[R5, #+48]
   1026              pch->RxBufPtr     = &pch->RxBuf[0];
   \   00000168   0xF115 0x0038      ADDS     R0,R5,#+56
   \   0000016C   0x6368             STR      R0,[R5, #+52]
   1027          
   1028              MB_OS_TxOver(pch);
   \   0000016E   0x0028             MOVS     R0,R5
   \   00000170   0x.... 0x....      BL       MB_OS_TxOver
   1029          
   1030              return nbr_bytes;
   \   00000174   0x0030             MOVS     R0,R6
   \   00000176   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??MBM_FC15_CoilWr_1: (+1)
   \   00000178   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
   1031          }
   1032          #endif
   1033          #endif
   1034          
   1035          /*$PAGE*/
   1036          /*
   1037          *********************************************************************************************************
   1038          *                                           MBM_FC16_HoldingRegWrN()
   1039          *
   1040          * Description : This is the main processing function for MODBUS commands.  The message integrity is
   1041          *               verified, and if valid, the function requested is processed.  Unimplemented functions
   1042          *               will generate an Illegal Function Exception Response code (01).
   1043          *
   1044          * Argument(s) : pch      Is a pointer to the Modbus channel's data structure.
   1045          *
   1046          * Return(s)   : none.
   1047          *
   1048          * Caller(s)   : Application
   1049          *
   1050          * Note(s)     : none.
   1051          *********************************************************************************************************
   1052          */
   1053          #if (MODBUS_CFG_MASTER_EN == DEF_ENABLED)   && \
   1054              (MODBUS_CFG_RTU_EN == DEF_ENABLED)      && \
   1055              (MODBUS_CFG_FC16_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   1056          CPU_INT16U  MBM_FC16_HoldingRegWrN   (MODBUS_CH   *pch,
   1057                                                CPU_INT08U   slave_node,
   1058                                                CPU_INT16U   slave_addr,
   1059                                                CPU_INT16U  *p_reg_tbl,
   1060                                                CPU_INT16U   nbr_regs)
   1061          {
   \                     MBM_FC16_HoldingRegWrN: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000F             MOVS     R7,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x4698             MOV      R8,R3
   \   0000000C   0x9C08             LDR      R4,[SP, #+32]
   1062              CPU_INT08U     *ptx_data;
   1063              CPU_INT16U      err;
   1064              CPU_BOOLEAN     ok;
   1065              CPU_INT16U      calc_crc;
   1066              CPU_INT16U      temp;
   1067              CPU_INT16U      ctr         = nbr_regs;
   \   0000000E   0x46A1             MOV      R9,R4
   1068          
   1069              if ( nbr_regs == 0 )
   \   00000010   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xD101             BNE.N    ??MBM_FC16_HoldingRegWrN_0
   1070                return 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE0BD             B.N      ??MBM_FC16_HoldingRegWrN_1
   1071              /***************************************************
   1072              * 描述：
   1073              */
   1074              MB_OS_TxWait(pch,&err);
   \                     ??MBM_FC16_HoldingRegWrN_0: (+1)
   \   0000001A   0x4669             MOV      R1,SP
   \   0000001C   0x0028             MOVS     R0,R5
   \   0000001E   0x.... 0x....      BL       MB_OS_TxWait
   1075              if ( err != MODBUS_ERR_NONE )
   \   00000022   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD001             BEQ.N    ??MBM_FC16_HoldingRegWrN_2
   1076                  return 0;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xE0B3             B.N      ??MBM_FC16_HoldingRegWrN_1
   1077          
   1078              ptx_data    = &(pch->TxFrameData[MBM_TX_FC16_DATA_IDX]);
   \                     ??MBM_FC16_HoldingRegWrN_2: (+1)
   \   0000002E   0xF205 0x6155      ADDW     R1,R5,#+1621
   1079              /***************************************************
   1080              * 描述： 如果输入数组与数据数组是同一数组，且是从第0个数据开始
   1081              */
   1082              if ( (CPU_INT08U *)p_reg_tbl == &(pch->TxFrameData[0]) ) {
   \   00000032   0xF205 0x604E      ADDW     R0,R5,#+1614
   \   00000036   0x4580             CMP      R8,R0
   \   00000038   0xD11B             BNE.N    ??MBM_FC16_HoldingRegWrN_3
   1083                ptx_data  += nbr_regs * 2 + MBM_TX_FC16_DATA_IDX-1;   // 指向数据的最后一个元素
   \   0000003A   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000003C   0xEB11 0x0044      ADDS     R0,R1,R4, LSL #+1
   \   00000040   0x1D81             ADDS     R1,R0,#+6
   1084                p_reg_tbl += nbr_regs-1;                              // 指向最后一个寄存器
   \   00000042   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000044   0xEB18 0x0044      ADDS     R0,R8,R4, LSL #+1
   \   00000048   0xF1B0 0x0802      SUBS     R8,R0,#+2
   1085          
   1086                while(ctr--) {
   \                     ??MBM_FC16_HoldingRegWrN_4: (+1)
   \   0000004C   0x4648             MOV      R0,R9
   \   0000004E   0xF1B0 0x0901      SUBS     R9,R0,#+1
   \   00000052   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD033             BEQ.N    ??MBM_FC16_HoldingRegWrN_5
   1087                 *ptx_data--      = LO_INT16U(*p_reg_tbl);
   \   00000058   0xF8B8 0x0000      LDRH     R0,[R8, #+0]
   \   0000005C   0x7008             STRB     R0,[R1, #+0]
   \   0000005E   0x1E49             SUBS     R1,R1,#+1
   1088                 *ptx_data--      = HI_INT16U(*p_reg_tbl);
   \   00000060   0xF8B8 0x0000      LDRH     R0,[R8, #+0]
   \   00000064   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000066   0x0A00             LSRS     R0,R0,#+8
   \   00000068   0x7008             STRB     R0,[R1, #+0]
   \   0000006A   0x1E49             SUBS     R1,R1,#+1
   1089                  p_reg_tbl--;
   \   0000006C   0xF1B8 0x0802      SUBS     R8,R8,#+2
   \   00000070   0xE7EC             B.N      ??MBM_FC16_HoldingRegWrN_4
   1090                }
   1091              /***************************************************
   1092              * 描述： 如果输入指针不是当前通道的数据帧的第7个元素，则拷贝元素到数据帧数组
   1093              */
   1094              } else if ( (CPU_INT08U *)p_reg_tbl == &(pch->TxFrameData[MBM_TX_FC16_DATA_IDX]) ) {
   \                     ??MBM_FC16_HoldingRegWrN_3: (+1)
   \   00000072   0xF205 0x6055      ADDW     R0,R5,#+1621
   \   00000076   0x4580             CMP      R8,R0
   \   00000078   0xD11C             BNE.N    ??MBM_FC16_HoldingRegWrN_6
   1095                while(ctr--) {
   \                     ??MBM_FC16_HoldingRegWrN_7: (+1)
   \   0000007A   0x4648             MOV      R0,R9
   \   0000007C   0xF1B0 0x0901      SUBS     R9,R0,#+1
   \   00000080   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD01C             BEQ.N    ??MBM_FC16_HoldingRegWrN_5
   1096                  temp            = *p_reg_tbl;
   \   00000086   0xF8B8 0x2000      LDRH     R2,[R8, #+0]
   1097                 *ptx_data++      = HI_INT16U(temp);
   \   0000008A   0x0010             MOVS     R0,R2
   \   0000008C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000008E   0x0A00             LSRS     R0,R0,#+8
   \   00000090   0x7008             STRB     R0,[R1, #+0]
   \   00000092   0x1C49             ADDS     R1,R1,#+1
   1098                 *ptx_data++      = LO_INT16U(temp);
   \   00000094   0x700A             STRB     R2,[R1, #+0]
   \   00000096   0x1C49             ADDS     R1,R1,#+1
   1099                  p_reg_tbl++;
   \   00000098   0xF118 0x0802      ADDS     R8,R8,#+2
   \   0000009C   0xE7ED             B.N      ??MBM_FC16_HoldingRegWrN_7
   1100                }
   1101              } else {
   1102                while(ctr--) {
   1103                  temp            = *p_reg_tbl;
   \                     ??MBM_FC16_HoldingRegWrN_8: (+1)
   \   0000009E   0xF8B8 0x2000      LDRH     R2,[R8, #+0]
   1104                 //*ptx_data++      = LO_INT16U(temp);
   1105                 //*ptx_data++      = HI_INT16U(temp);
   1106                 *ptx_data++      = HI_INT16U(temp);
   \   000000A2   0x0010             MOVS     R0,R2
   \   000000A4   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000A6   0x0A00             LSRS     R0,R0,#+8
   \   000000A8   0x7008             STRB     R0,[R1, #+0]
   \   000000AA   0x1C49             ADDS     R1,R1,#+1
   1107                 *ptx_data++      = LO_INT16U(temp);
   \   000000AC   0x700A             STRB     R2,[R1, #+0]
   \   000000AE   0x1C49             ADDS     R1,R1,#+1
   1108                  p_reg_tbl++;
   \   000000B0   0xF118 0x0802      ADDS     R8,R8,#+2
   1109                }
   \                     ??MBM_FC16_HoldingRegWrN_6: (+1)
   \   000000B4   0x4648             MOV      R0,R9
   \   000000B6   0xF1B0 0x0901      SUBS     R9,R0,#+1
   \   000000BA   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000BC   0x2800             CMP      R0,#+0
   \   000000BE   0xD1EE             BNE.N    ??MBM_FC16_HoldingRegWrN_8
   1110              }
   1111          
   1112              ptx_data    = &(pch->TxFrameData[0]);
   \                     ??MBM_FC16_HoldingRegWrN_5: (+1)
   \   000000C0   0xF205 0x614E      ADDW     R1,R5,#+1614
   1113              /***************************************************
   1114              * 描述：
   1115              */
   1116             *ptx_data++ = slave_node;
   \   000000C4   0x700F             STRB     R7,[R1, #+0]
   \   000000C6   0x1C49             ADDS     R1,R1,#+1
   1117             *ptx_data++ = MODBUS_FC16_HOLDING_REG_WR_MULTIPLE;
   \   000000C8   0x2010             MOVS     R0,#+16
   \   000000CA   0x7008             STRB     R0,[R1, #+0]
   \   000000CC   0x1C49             ADDS     R1,R1,#+1
   1118             *ptx_data++ = HI_INT16U(slave_addr);
   \   000000CE   0x0030             MOVS     R0,R6
   \   000000D0   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000D2   0x0A00             LSRS     R0,R0,#+8
   \   000000D4   0x7008             STRB     R0,[R1, #+0]
   \   000000D6   0x1C49             ADDS     R1,R1,#+1
   1119             *ptx_data++ = LO_INT16U(slave_addr);
   \   000000D8   0x700E             STRB     R6,[R1, #+0]
   \   000000DA   0x1C49             ADDS     R1,R1,#+1
   1120             *ptx_data++ = HI_INT16U(nbr_regs);
   \   000000DC   0x0020             MOVS     R0,R4
   \   000000DE   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000E0   0x0A00             LSRS     R0,R0,#+8
   \   000000E2   0x7008             STRB     R0,[R1, #+0]
   \   000000E4   0x1C49             ADDS     R1,R1,#+1
   1121             *ptx_data++ = LO_INT16U(nbr_regs);
   \   000000E6   0x700C             STRB     R4,[R1, #+0]
   \   000000E8   0x1C49             ADDS     R1,R1,#+1
   1122              pch->TxFrameNDataBytes  = 5 + nbr_regs * 2;
   \   000000EA   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000EC   0x0060             LSLS     R0,R4,#+1
   \   000000EE   0x1D40             ADDS     R0,R0,#+5
   \   000000F0   0xF8A5 0x084E      STRH     R0,[R5, #+2126]
   1123             *ptx_data++ = pch->TxFrameNDataBytes - 5;
   \   000000F4   0xF8B5 0x084E      LDRH     R0,[R5, #+2126]
   \   000000F8   0x1F40             SUBS     R0,R0,#+5
   \   000000FA   0x7008             STRB     R0,[R1, #+0]
   \   000000FC   0x1C49             ADDS     R1,R1,#+1
   1124          
   1125              nbr_regs    = 0;
   \   000000FE   0x2400             MOVS     R4,#+0
   1126          
   1127              /***********************************************
   1128              * 描述： 发送
   1129              */
   1130              CPU_INT08S  retrys  = pch->Retrys;
   \   00000100   0xF895 0x0852      LDRB     R0,[R5, #+2130]
   \   00000104   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000106   0x08C6             LSRS     R6,R0,#+3
   1131              do {
   1132                MBM_TxCmd(pch);
   \                     ??MBM_FC16_HoldingRegWrN_9: (+1)
   \   00000108   0x0028             MOVS     R0,R5
   \   0000010A   0x.... 0x....      BL       MBM_TxCmd
   1133                MB_OS_RxWait(pch,&err);
   \   0000010E   0x4669             MOV      R1,SP
   \   00000110   0x0028             MOVS     R0,R5
   \   00000112   0x.... 0x....      BL       MB_OS_RxWait
   1134              } while ( ( err == MODBUS_ERR_TIMED_OUT ) && --retrys  );
   \   00000116   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000011A   0xF640 0x31B8      MOVW     R1,#+3000
   \   0000011E   0x4288             CMP      R0,R1
   \   00000120   0xD103             BNE.N    ??MBM_FC16_HoldingRegWrN_10
   \   00000122   0x1E76             SUBS     R6,R6,#+1
   \   00000124   0xB276             SXTB     R6,R6            ;; SignExt  R6,R6,#+24,#+24
   \   00000126   0x2E00             CMP      R6,#+0
   \   00000128   0xD1EE             BNE.N    ??MBM_FC16_HoldingRegWrN_9
   1135          
   1136              /***************************************************
   1137              * 描述：
   1138              */
   1139              if ( err == MODBUS_ERR_NONE ) {
   \                     ??MBM_FC16_HoldingRegWrN_10: (+1)
   \   0000012A   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000012E   0x2800             CMP      R0,#+0
   \   00000130   0xD124             BNE.N    ??MBM_FC16_HoldingRegWrN_11
   1140                  ok = MBM_RxReply(pch);
   \   00000132   0x0028             MOVS     R0,R5
   \   00000134   0x.... 0x....      BL       MBM_RxReply
   1141                  if ( DEF_TRUE == ok ) {
   \   00000138   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000013A   0x2801             CMP      R0,#+1
   \   0000013C   0xD121             BNE.N    ??MBM_FC16_HoldingRegWrN_12
   1142                      calc_crc = MB_RTU_RxCalcCRC(pch);          /* Do our own calculation of the CRC.                              */
   \   0000013E   0x0028             MOVS     R0,R5
   \   00000140   0x.... 0x....      BL       MB_RTU_RxCalcCRC
   1143                      if (calc_crc != pch->RxFrameCRC) {         /* If the calculated CRC does not match the CRC received,          */
   \   00000144   0xF8B5 0x1646      LDRH     R1,[R5, #+1606]
   \   00000148   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000014A   0x4288             CMP      R0,R1
   \   0000014C   0xD003             BEQ.N    ??MBM_FC16_HoldingRegWrN_13
   1144                        /***********************************************
   1145                        * 描述： 校验错误
   1146                        */
   1147                        pch->StatCRCErrCtr++;                    /* then the frame was not received properly.                       */
   \   0000014E   0x8C28             LDRH     R0,[R5, #+32]
   \   00000150   0x1C40             ADDS     R0,R0,#+1
   \   00000152   0x8428             STRH     R0,[R5, #+32]
   \   00000154   0xE015             B.N      ??MBM_FC16_HoldingRegWrN_12
   1148                      } else if (MBM_RX_FCXX_CODE == 0X90) {
   \                     ??MBM_FC16_HoldingRegWrN_13: (+1)
   \   00000156   0xF895 0x0445      LDRB     R0,[R5, #+1093]
   \   0000015A   0x2890             CMP      R0,#+144
   \   0000015C   0xD104             BNE.N    ??MBM_FC16_HoldingRegWrN_14
   1149                          pch->StatExceptCtr++;
   \   0000015E   0x8C68             LDRH     R0,[R5, #+34]
   \   00000160   0x1C40             ADDS     R0,R0,#+1
   \   00000162   0x8468             STRH     R0,[R5, #+34]
   1150                        /***********************************************
   1151                        * 描述： 其他错误
   1152                        //功能码10H： 连续写多个寄存器值
   1153                        //第1字节	    ADR      		：	从机地址码（=001～254）
   1154                        //第2字节　   90H			    ：　写寄存器值出错
   1155                        //第3字节　   错误信息码		：	见信息码表
   1156                        //第4、5字节	CRC			    ：	从字节1到3的CRC16校验和
   1157                        //数息码	    表示意义
   1158                        //01H	        非法的功能号
   1159                        //02H	        非法的数据地址
   1160                        //03H	        非法的数据值
   1161                        //04H	        CRC16校验错
   1162                        //05H	        接收正确
   1163                        //06H	        接收错误
   1164                        //07	        参数错误
   1165                        */
   1166                        nbr_regs = 0;
   \   00000164   0x2400             MOVS     R4,#+0
   \   00000166   0xE00C             B.N      ??MBM_FC16_HoldingRegWrN_12
   1167                      } else {
   1168                        pch->StatMsgCtr++;
   \                     ??MBM_FC16_HoldingRegWrN_14: (+1)
   \   00000168   0x8BE8             LDRH     R0,[R5, #+30]
   \   0000016A   0x1C40             ADDS     R0,R0,#+1
   \   0000016C   0x83E8             STRH     R0,[R5, #+30]
   1169          #if MBM_STAT_CTR_AUTO_CLR_EN        == DEF_ENABLED
   1170                        pch->StatNoRespCtr    = 0;
   1171                        pch->StatCRCErrCtr    = 0;
   1172                        pch->StatExceptCtr    = 0;
   1173          #endif
   1174                        /***********************************************
   1175                        * 描述： 接收正确
   1176                        */
   1177                        nbr_regs = MBM_RX_FC16_NREG;
   \   0000016E   0xF895 0x0448      LDRB     R0,[R5, #+1096]
   \   00000172   0xF895 0x1449      LDRB     R1,[R5, #+1097]
   \   00000176   0xEB11 0x2400      ADDS     R4,R1,R0, LSL #+8
   \   0000017A   0xE002             B.N      ??MBM_FC16_HoldingRegWrN_12
   1178                      }
   1179                  }
   1180              } else {
   1181                  pch->StatNoRespCtr++;
   \                     ??MBM_FC16_HoldingRegWrN_11: (+1)
   \   0000017C   0x8CE8             LDRH     R0,[R5, #+38]
   \   0000017E   0x1C40             ADDS     R0,R0,#+1
   \   00000180   0x84E8             STRH     R0,[R5, #+38]
   1182              }
   1183          
   1184              pch->RxBufByteCtr = 0;
   \                     ??MBM_FC16_HoldingRegWrN_12: (+1)
   \   00000182   0x2000             MOVS     R0,#+0
   \   00000184   0x8628             STRH     R0,[R5, #+48]
   1185              pch->RxBufPtr     = &pch->RxBuf[0];
   \   00000186   0xF115 0x0038      ADDS     R0,R5,#+56
   \   0000018A   0x6368             STR      R0,[R5, #+52]
   1186          
   1187              MB_OS_TxOver(pch);
   \   0000018C   0x0028             MOVS     R0,R5
   \   0000018E   0x.... 0x....      BL       MB_OS_TxOver
   1188          
   1189              return nbr_regs;
   \   00000192   0x0020             MOVS     R0,R4
   \   00000194   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??MBM_FC16_HoldingRegWrN_1: (+1)
   \   00000196   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1190          }
   1191          #endif
   1192          
   1193          /*$PAGE*/
   1194          /*
   1195          *********************************************************************************************************
   1196          *                                           MBM_FCU_HoldingRegWrN()
   1197          *
   1198          * Description : This is the main processing function for MODBUS commands.  The message integrity is
   1199          *               verified, and if valid, the function requested is processed.  Unimplemented functions
   1200          *               will generate an Illegal Function Exception Response code (01).
   1201          *
   1202          * Argument(s) : pch      Is a pointer to the Modbus channel's data structure.
   1203          *
   1204          * Return(s)   : none.
   1205          *
   1206          * Caller(s)   : Application
   1207          *
   1208          * Note(s)     : none.
   1209          *********************************************************************************************************
   1210          */
   1211          
   1212          #if (MODBUS_CFG_MASTER_EN == DEF_ENABLED)   && \
   1213              (MODBUS_CFG_RTU_EN == DEF_ENABLED)      && \
   1214              (MODBUS_CFG_FCU_EN == DEF_ENABLED)
   1215          CPU_INT16U  MBM_FCU_HoldingRegWrN(  MODBUS_CH   *pch,
   1216                                              CPU_INT08U   slave_node,
   1217                                              CPU_INT08U   fc,
   1218                                              CPU_INT16U   block,
   1219                                              CPU_INT16U   blocks,
   1220                                              CPU_INT16U  *p_reg_tbl,
   1221                                              CPU_INT16U   nbr_regs)
   1222          {
   1223              CPU_INT08U     *ptx_data;
   1224              CPU_INT16U      err;
   1225              CPU_BOOLEAN     ok;
   1226              CPU_INT16U      calc_crc;
   1227          
   1228          
   1229              MB_OS_TxWait(pch,&err);
   1230              if ( err != MODBUS_ERR_NONE )
   1231                  return 0;
   1232              ptx_data    = &(pch->TxFrameData[0]);
   1233          
   1234             *ptx_data++ = slave_node;                        // 地址
   1235             *ptx_data++ = fc;                                // 写文件
   1236          
   1237             *ptx_data++ = HI_INT16U(block);                  // 当前块
   1238             *ptx_data++ = LO_INT16U(block);
   1239          
   1240             *ptx_data++ = HI_INT16U(blocks);                 // 总块数
   1241             *ptx_data++ = LO_INT16U(blocks);
   1242             *ptx_data++ = HI_INT16U(nbr_regs);
   1243             *ptx_data++ = LO_INT16U(nbr_regs);
   1244          
   1245              pch->TxFrameNDataBytes  = 7 + nbr_regs * 2;
   1246          
   1247              while(nbr_regs--) {
   1248               *ptx_data++   = HI_INT16U(*p_reg_tbl);
   1249               *ptx_data++   = LO_INT16U(*p_reg_tbl);
   1250                p_reg_tbl++;
   1251              }
   1252              nbr_regs    = 0;
   1253          
   1254              /***********************************************
   1255              * 描述： 发送
   1256              */
   1257              CPU_INT08S  retrys  = pch->Retrys;
   1258              do {
   1259                MBM_TxCmd(pch);
   1260                MB_OS_RxWait(pch,&err);
   1261              } while ( ( err == MODBUS_ERR_TIMED_OUT ) && --retrys  );
   1262          
   1263              if ( err == MODBUS_ERR_NONE ) {
   1264                  ok = MBM_RxReply(pch);
   1265                  if ( DEF_TRUE == ok ) {
   1266                      calc_crc = MB_RTU_RxCalcCRC(pch);          /* Do our own calculation of the CRC.                              */
   1267                      if (calc_crc != pch->RxFrameCRC) {         /* If the calculated CRC does not match the CRC received,          */
   1268                        /***********************************************
   1269                        * 描述： 校验错误
   1270                        */
   1271                        pch->StatCRCErrCtr++;                    /* then the frame was not received properly.                       */
   1272                      } else if (MBM_RX_FCXX_CODE == (fc | 0x80)) {
   1273                          pch->StatExceptCtr++;
   1274                        /***********************************************
   1275                        * 描述： 其他错误
   1276                        //功能码10H： 连续写多个寄存器值
   1277                        //第1字节	    ADR      		：	从机地址码（=001～254）
   1278                        //第2字节　   90H			    ：　写寄存器值出错
   1279                        //第3字节　   错误信息码		：	见信息码表
   1280                        //第4、5字节	CRC			    ：	从字节1到3的CRC16校验和
   1281                        //数息码	    表示意义
   1282                        //01H	        非法的功能号
   1283                        //02H	        非法的数据地址
   1284                        //03H	        非法的数据值
   1285                        //04H	        CRC16校验错
   1286                        //05H	        接收正确
   1287                        //06H	        接收错误
   1288                        //07	        参数错误
   1289                        */
   1290                        nbr_regs = 0;
   1291                      } else {
   1292                        pch->StatMsgCtr++;
   1293          #if MBM_STAT_CTR_AUTO_CLR_EN        == DEF_ENABLED
   1294                        pch->StatNoRespCtr    = 0;
   1295                        pch->StatCRCErrCtr    = 0;
   1296                        pch->StatExceptCtr    = 0;
   1297          #endif
   1298                        /***********************************************
   1299                        * 描述： 接收正确
   1300                        */
   1301                        nbr_regs = MBM_RX_FC16_NREG;
   1302                      }
   1303                  }
   1304              } else {
   1305                  pch->StatNoRespCtr++;
   1306              }
   1307          
   1308              pch->RxBufByteCtr = 0;
   1309              pch->RxBufPtr     = &pch->RxBuf[0];
   1310          
   1311              MB_OS_TxOver(pch);
   1312          
   1313              return nbr_regs;
   1314          }
   1315          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   MBM_FC01_CoilRd
        24   -> MBM_RxReply
        24   -> MBM_TxCmd
        24   -> MB_OS_RxWait
        24   -> MB_OS_TxOver
        24   -> MB_OS_TxWait
        24   -> MB_RTU_RxCalcCRC
      24   MBM_FC03_HoldingRegRd
        24   -> MBM_RxReply
        24   -> MBM_TxCmd
        24   -> MB_OS_RxWait
        24   -> MB_OS_TxOver
        24   -> MB_OS_TxWait
        24   -> MB_RTU_RxCalcCRC
      24   MBM_FC05_CoilWr
        24   -> MBM_RxReply
        24   -> MBM_TxCmd
        24   -> MB_MasterTimeoutSet
        24   -> MB_OS_RxWait
        24   -> MB_OS_TxOver
        24   -> MB_OS_TxWait
        24   -> MB_RTU_RxCalcCRC
      24   MBM_FC06_HoldingRegWr
        24   -> MBM_RxReply
        24   -> MBM_TxCmd
        24   -> MB_MasterTimeoutSet
        24   -> MB_OS_RxWait
        24   -> MB_OS_TxOver
        24   -> MB_OS_TxWait
        24   -> MB_RTU_RxCalcCRC
      40   MBM_FC15_CoilWr
        40   -> MBM_RxReply
        40   -> MBM_TxCmd
        40   -> MB_OS_RxWait
        40   -> MB_OS_TxOver
        40   -> MB_OS_TxWait
        40   -> MB_RTU_RxCalcCRC
      32   MBM_FC16_HoldingRegWrN
        32   -> MBM_RxReply
        32   -> MBM_TxCmd
        32   -> MB_OS_RxWait
        32   -> MB_OS_TxOver
        32   -> MB_OS_TxWait
        32   -> MB_RTU_RxCalcCRC
       0   MBM_FCxx_Handler
       8   MBM_RxReply
         8   -> MB_RTU_Rx
       8   MBM_TxCmd
         8   -> MB_RTU_Tx


   Section sizes:

   Bytes  Function/Label
   -----  --------------
     254  MBM_FC01_CoilRd
     278  MBM_FC03_HoldingRegRd
     278  MBM_FC05_CoilWr
     260  MBM_FC06_HoldingRegWr
     380  MBM_FC15_CoilWr
     410  MBM_FC16_HoldingRegWrN
     122  MBM_FCxx_Handler
       8  MBM_RxReply
       8  MBM_TxCmd

 
 1 998 bytes in section .text
 
 1 998 bytes of CODE memory

Errors: none
Warnings: none
