###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       12/Jul/2018  12:04:25
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC210\NC210-200处理板\source\Software\uC-MB\OS\uCOS-III\MB_OS.C
#    Command line =  
#        F:\iar\NC210\NC210-200处理板\source\Software\uC-MB\OS\uCOS-III\MB_OS.C
#        -D USE_STDPERIPH_DRIVER -D APP_RELEASE -lCN
#        F:\iar\NC210\NC210-200处理板\project\app_release\List -o
#        F:\iar\NC210\NC210-200处理板\project\app_release\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC210\NC210-200处理板\project\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\config\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\task\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\user\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\OS\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\Ports\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\driver\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-LIB\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Source\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\ST\STM32\inc\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Ports\STM32\STM32F103\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Source\
#        -Ol --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC210\NC210-200处理板\project\app_release\List\MB_OS.lst
#    Object file  =  
#        F:\iar\NC210\NC210-200处理板\project\app_release\Obj\MB_OS.o
#
###############################################################################

F:\iar\NC210\NC210-200处理板\source\Software\uC-MB\OS\uCOS-III\MB_OS.C
      1          /*
      2          *********************************************************************************************************
      3          *                                               uC/MODBUS
      4          *                                         Embedded Modbus Stack
      5          *
      6          *                          (c) Copyright 2004-2009; Micrium, Inc.; Weston, FL
      7          *
      8          *               All rights reserved.  Protected by international copyright laws.
      9          *
     10          *               uC/Modbus is provided in source form for FREE evaluation, for educational
     11          *               use or peaceful research.  If you plan on using uC/Modbus in a commercial
     12          *               product you need to contact Micrium to properly license its use in your
     13          *               product.  We provide ALL the source code for your convenience and to
     14          *               help you experience uC/Modbus.  The fact that the source code is provided
     15          *               does NOT mean that you can use it without paying a licensing fee.
     16          *
     17          *               Knowledge of the source code may NOT be used to develop a similar product.
     18          *
     19          *               Please help us continue to provide the Embedded community with the finest
     20          *               software available.  Your honesty is greatly appreciated.
     21          *********************************************************************************************************
     22          */
     23          
     24          /*
     25          *********************************************************************************************************
     26          *
     27          *                                     MODBUS uC/OS-II LAYER INTERFACE
     28          *
     29          * Filename      : mb_os.c
     30          * Version       : V2.12
     31          * Programmer(s) : JJL
     32          *********************************************************************************************************
     33          * Note(s)       :
     34          *********************************************************************************************************
     35          */
     36          
     37          /*
     38          *********************************************************************************************************
     39          *                                             INCLUDE FILES
     40          *********************************************************************************************************
     41          */
     42          
     43          #include <mb_os.h>
     44          #include <app_cfg.h>
     45          #include <os_cfg_app.h>
     46          #if OS_VERSION > 30000U
     47          #include <bsp_os.h>
     48          #endif
     49          
     50          /*
     51          *********************************************************************************************************
     52          *                                               CONSTANTS
     53          *********************************************************************************************************
     54          */
     55          
     56          /*$PAGE*/
     57          /*
     58          *********************************************************************************************************
     59          *                                            LOCAL ERRORS
     60          *********************************************************************************************************
     61          */
     62          
     63          
     64          /*
     65          *********************************************************************************************************
     66          *                                        LOCAL GLOBAL VARIABLES
     67          *********************************************************************************************************
     68          */
     69          
     70          #if (MODBUS_CFG_SLAVE_EN  == DEF_ENABLED)

   \                                 In section .bss, align 4
     71          static  CPU_STK             MB_OS_RxTaskStk[MB_OS_CFG_RX_TASK_STK_SIZE];
   \                     MB_OS_RxTaskStk:
   \   00000000                      DS8 2048
     72          #if OS_VERSION > 30000u

   \                                 In section .bss, align 4
     73          static  OS_TCB              MB_OS_RxTaskTCB;
   \                     MB_OS_RxTaskTCB:
   \   00000000                      DS8 160

   \                                 In section .bss, align 4
     74          static  OS_Q                MB_OS_RxQ;
   \                     MB_OS_RxQ:
   \   00000000                      DS8 48
     75          //static  void               *MB_OS_RxQTbl[MODBUS_CFG_MAX_CH];
     76          #else
     77          static  OS_Q               *MB_OS_RxQ;
     78          static  void               *MB_OS_RxQTbl[MODBUS_CFG_MAX_CH];
     79          #endif
     80          #endif
     81          
     82          /*
     83          *********************************************************************************************************
     84          *                                              PROTOTYPES
     85          *********************************************************************************************************
     86          */
     87          
     88          #if (MODBUS_CFG_MASTER_EN == DEF_ENABLED)
     89          static  void                 MB_OS_InitMaster  (void);
     90          static  void                 MB_OS_ExitMaster  (void);
     91          #endif
     92          
     93          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED)
     94          static  void                 MB_OS_InitSlave   (void);
     95          static  void                 MB_OS_ExitSlave   (void);
     96          static  void                 MB_OS_RxTask      (void *p_arg);
     97          #endif
     98          
     99          
    100          /*$PAGE*/
    101          /*
    102          *********************************************************************************************************
    103          *                                              MB_OS_Init()
    104          *
    105          * Description : This function initializes the RTOS interface.  This function creates the following:
    106          *
    107          *               1) A message queue to signal the reception of a packet.
    108          *
    109          *               2) A task that waits for packets to be received.
    110          *
    111          * Argument(s) : none
    112          *
    113          * Return(s)   : none.
    114          *
    115          * Caller(s)   : MB_Init()
    116          *
    117          * Note(s)     : none.
    118          *********************************************************************************************************
    119          */
    120          

   \                                 In section .text, align 2, keep-with-next
    121          void  MB_OS_Init (void)
    122          {
   \                     MB_OS_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    123          #if (MODBUS_CFG_MASTER_EN == DEF_ENABLED)
    124              MB_OS_InitMaster();
   \   00000002   0x.... 0x....      BL       MB_OS_InitMaster
    125          #endif
    126          
    127          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED)
    128              MB_OS_InitSlave();
   \   00000006   0x.... 0x....      BL       MB_OS_InitSlave
    129          #endif
    130          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    131          
    132          /*$PAGE*/
    133          /*
    134          *********************************************************************************************************
    135          *                                          MB_OS_InitMaster()
    136          *
    137          * Description : This function initializes and creates the kernel objectes needed for Modbus Master
    138          *
    139          * Argument(s) : none
    140          *
    141          * Return(s)   : none.
    142          *
    143          * Caller(s)   : MB_OS_Init()
    144          *
    145          * Note(s)     : none.
    146          *********************************************************************************************************
    147          */
    148          
    149          #if (MODBUS_CFG_MASTER_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    150          static  void  MB_OS_InitMaster (void)
    151          {
   \                     MB_OS_InitMaster: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    152          #if OS_VERSION > 30000U
    153          #else
    154              OS_EVENT    *pevent;
    155          #endif
    156              CPU_INT08U   i;
    157          #if (OS_VERSION         < 287)
    158          #if (OS_EVENT_NAME_EN > 0) && (OS_EVENT_NAME_SIZE >  16)
    159              CPU_INT08U   err;
    160          #endif
    161          #endif
    162          
    163              for (i = 0; i < MODBUS_CFG_MAX_CH; i++) {                             /* Create a semaphore for each channel   */
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0xE012             B.N      ??MB_OS_InitMaster_0
    164          #if OS_VERSION > 30000U
    165                  BSP_OS_SemCreate(&MB_OS_RxSemTbl[i], 0, "uC/Modbus Rx Sem");
   \                     ??MB_OS_InitMaster_1: (+1)
   \   00000006   0x....             LDR.N    R2,??DataTable5_1
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x....             LDR.N    R0,??DataTable5_2
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0x2328             MOVS     R3,#+40
   \   00000010   0xFB03 0x0004      MLA      R0,R3,R4,R0
   \   00000014   0x.... 0x....      BL       BSP_OS_SemCreate
    166          #else
    167                  pevent = OSSemCreate(0);
    168                  if (pevent != (OS_EVENT *)0) {                                    /* Assign a name to the semaphore        */
    169          #endif
    170          #if (OS_VERSION         < 287)
    171          #if (OS_EVENT_NAME_EN > 0) && (OS_EVENT_NAME_SIZE >  16)
    172                      OSEventNameSet((OS_EVENT *)pevent,
    173                                     (INT8U    *)"uC/Modbus Rx Sem",
    174                                     (INT8U    *)&err);
    175                      (void)&err;
    176          #endif
    177                      MB_OS_RxSemTbl[i] = pevent;
    178                  }
    179          #endif
    180          #if OS_VERSION > 30000U
    181                  BSP_OS_SemCreate(&MB_OS_TxSemTbl[i], 1, "uC/Modbus Tx Sem");
   \   00000018   0x....             LDR.N    R2,??DataTable5_3
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0x....             LDR.N    R0,??DataTable5_4
   \   0000001E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000020   0x2328             MOVS     R3,#+40
   \   00000022   0xFB03 0x0004      MLA      R0,R3,R4,R0
   \   00000026   0x.... 0x....      BL       BSP_OS_SemCreate
    182          
    183          #else
    184                  pevent = OSSemCreate(1);
    185                  if (pevent != (OS_EVENT *)0) {                                    /* Assign a name to the semaphore        */
    186          #endif
    187          #if (OS_VERSION         < 287)
    188          #if (OS_EVENT_NAME_EN > 0) && (OS_EVENT_NAME_SIZE >  16)
    189                      OSEventNameSet((OS_EVENT *)pevent,
    190                                     (INT8U    *)"uC/Modbus Tx Sem",
    191                                     (INT8U    *)&err);
    192                      (void)&err;
    193          #endif
    194                      MB_OS_TxSemTbl[i] = pevent;
    195                  }
    196          #endif
    197              }
   \   0000002A   0x1C64             ADDS     R4,R4,#+1
   \                     ??MB_OS_InitMaster_0: (+1)
   \   0000002C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002E   0x2C04             CMP      R4,#+4
   \   00000030   0xDBE9             BLT.N    ??MB_OS_InitMaster_1
    198          }
   \   00000032   0xBD10             POP      {R4,PC}          ;; return
    199          #endif
    200          
    201          /*$PAGE*/
    202          /*
    203          *********************************************************************************************************
    204          *                                          MB_OS_InitSlave()
    205          *
    206          * Description : This function initializes and creates the kernel objectes needed for Modbus Salve
    207          *
    208          * Argument(s) : none
    209          *
    210          * Return(s)   : none.
    211          *
    212          * Caller(s)   : MB_OS_Init()
    213          *
    214          * Note(s)     : none.
    215          *********************************************************************************************************
    216          */
    217          
    218          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    219          static  void  MB_OS_InitSlave (void)
    220          {
   \                     MB_OS_InitSlave: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
    221          #if OS_VERSION > 30000u
    222              OS_ERR      err;
    223              OSQCreate ( (OS_Q        *)&MB_OS_RxQ,
    224                          (CPU_CHAR    *)"RxQ",
    225                          (OS_MSG_QTY   )MODBUS_CFG_MAX_CH,
    226                          (OS_ERR      *)&err);
   \   00000004   0xAB09             ADD      R3,SP,#+36
   \   00000006   0x2204             MOVS     R2,#+4
   \   00000008   0x....             ADR.N    R1,??DataTable5  ;; "RxQ"
   \   0000000A   0x....             LDR.N    R0,??DataTable5_5
   \   0000000C   0x.... 0x....      BL       OSQCreate
    227          #else
    228              CPU_INT08U  err;
    229              MB_OS_RxQ = OSQCreate(&MB_OS_RxQTbl[0],                              /* Create Rx Task message queue           */
    230                                    MODBUS_CFG_MAX_CH);
    231          #endif
    232          
    233          #if (OS_VERSION         < 287)
    234          #if (OS_EVENT_NAME_EN   > 0) && (OS_EVENT_NAME_SIZE >  14)
    235              if (MB_OS_RxQ != (OS_EVENT *)0) {                                    /* Assign a name to the message queue     */
    236                  OSEventNameSet((OS_EVENT *)MB_OS_RxQ,
    237                                 (INT8U    *)"uC/Modbus Rx Q",
    238                                 (INT8U    *)&err);
    239                 (void)&err;
    240              }
    241          #endif
    242          #endif
    243          #if OS_VERSION         > 30000u
    244              (void)OSTaskCreate((OS_TCB     *)&MB_OS_RxTaskTCB,                /* Create the start task                                */
    245                                 (CPU_CHAR   *)"App Task Start",
    246                                 (OS_TASK_PTR ) MB_OS_RxTask,
    247                                 (void       *) 0,
    248                                 (OS_PRIO     ) MB_OS_CFG_RX_TASK_PRIO,
    249                                 (CPU_STK    *)&MB_OS_RxTaskStk[0],
    250                                 (CPU_STK_SIZE) MB_OS_CFG_RX_TASK_STK_SIZE / 10,
    251                                 (CPU_STK_SIZE) MB_OS_CFG_RX_TASK_STK_SIZE,
    252                                 (OS_MSG_QTY  ) 0u,
    253                                 (OS_TICK     ) 0u,
    254                                 (void       *) 0,
    255                                 (OS_OPT      )(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR),
    256                                 (OS_ERR     *)&err);
   \   00000010   0xA809             ADD      R0,SP,#+36
   \   00000012   0x9008             STR      R0,[SP, #+32]
   \   00000014   0x2003             MOVS     R0,#+3
   \   00000016   0x9007             STR      R0,[SP, #+28]
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x9006             STR      R0,[SP, #+24]
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x9005             STR      R0,[SP, #+20]
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x9004             STR      R0,[SP, #+16]
   \   00000024   0xF44F 0x7000      MOV      R0,#+512
   \   00000028   0x9003             STR      R0,[SP, #+12]
   \   0000002A   0x2033             MOVS     R0,#+51
   \   0000002C   0x9002             STR      R0,[SP, #+8]
   \   0000002E   0x....             LDR.N    R0,??DataTable5_6
   \   00000030   0x9001             STR      R0,[SP, #+4]
   \   00000032   0x2032             MOVS     R0,#+50
   \   00000034   0x9000             STR      R0,[SP, #+0]
   \   00000036   0x2300             MOVS     R3,#+0
   \   00000038   0x.... 0x....      ADR.W    R2,MB_OS_RxTask
   \   0000003C   0x....             LDR.N    R1,??DataTable5_7
   \   0000003E   0x....             LDR.N    R0,??DataTable5_8
   \   00000040   0x.... 0x....      BL       OSTaskCreate
    257          #else
    258          #if (OS_TASK_CREATE_EXT_EN > 0)
    259              #if (OS_STK_GROWTH == 1)
    260              (void)OSTaskCreateExt((void (*)(void *)) MB_OS_RxTask,
    261                                    (void           *) 0,
    262                                    (OS_STK         *)&MB_OS_RxTaskStk[MB_OS_CFG_RX_TASK_STK_SIZE - 1],
    263                                    (INT8U           ) MB_OS_CFG_RX_TASK_PRIO,
    264                                    (INT16U          ) MB_OS_CFG_RX_TASK_ID,
    265                                    (OS_STK         *)&MB_OS_RxTaskStk[0],
    266                                    (INT32U          ) MB_OS_CFG_RX_TASK_STK_SIZE,
    267                                    (void           *) 0,
    268                                    (INT16U          )(OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR));
    269              #else
    270              (void)OSTaskCreateExt((void (*)(void *)) MB_OS_RxTask,
    271                                    (void           *) 0,
    272                                    (OS_STK         *)&MB_OS_RxTaskStk[0],
    273                                    (INT8U           ) MB_OS_CFG_RX_TASK_PRIO,
    274                                    (INT16U          ) MB_OS_CFG_RX_TASK_ID,
    275                                    (OS_STK         *)&MB_OS_RxTaskStk[MB_OS_CFG_RX_TASK_STK_SIZE - 1],
    276                                    (INT32U          ) MB_OS_CFG_RX_TASK_STK_SIZE,
    277                                    (void           *) 0,
    278                                    (INT16U          )(OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR));
    279              #endif
    280          #else
    281              #if OS_STK_GROWTH == 1
    282              (void)OSTaskCreate((void (*)(void *)) MB_OS_RxTask,
    283                                 (void           *) 0,
    284                                 (OS_STK         *)&MB_OS_RxTaskStk[MB_OS_CFG_RX_TASK_STK_SIZE - 1],
    285                                 (INT8U           ) MB_OS_CFG_RX_TASK_PRIO);
    286              #else
    287              (void)OSTaskCreate((void (*)(void *)) MB_OS_RxTask,
    288                                 (void           *) 0,
    289                                 (OS_STK         *)&MB_OS_RxTaskStk[0],
    290                                 (INT8U           ) MB_OS_CFG_RX_TASK_PRIO);
    291              #endif
    292          #endif
    293          #endif
    294          
    295          #if (OS_VERSION         < 287)
    296          #if (OS_EVENT_NAME_SIZE >  12)
    297          
    298              OSTaskNameSet((INT8U  )MB_OS_CFG_RX_TASK_PRIO,                       /* Assign a name to the event flag group  */
    299                            (INT8U *)"uC/Modbus Rx",
    300                            (INT8U *)&err);
    301          #endif
    302          #else
    303          #if (OS_EVENT_NAME_EN   > 0)
    304              OSTaskNameSet((INT8U  )MB_OS_CFG_RX_TASK_PRIO,
    305                            (INT8U *)"uC/Modbus Rx",
    306                            (INT8U *)&err);
    307          
    308          #endif
    309          #endif
    310          
    311          
    312          }
   \   00000044   0xB00B             ADD      SP,SP,#+44
   \   00000046   0xBD00             POP      {PC}             ;; return
    313          #endif
    314          
    315          /*
    316          *********************************************************************************************************
    317          *                                             MB_OS_Exit()
    318          *
    319          * Description : This function is called to terminate the RTOS interface for Modbus channels.  We delete
    320          *               the following uC/OS-II objects:
    321          *
    322          *               1) An event flag group to signal the reception of a packet.
    323          *               2) A task that waits for packets to be received.
    324          *
    325          * Argument(s) : none
    326          *
    327          * Return(s)   : none.
    328          *
    329          * Caller(s)   : MB_Exit()
    330          *
    331          * Note(s)     : none.
    332          *********************************************************************************************************
    333          */
    334          

   \                                 In section .text, align 2, keep-with-next
    335          void  MB_OS_Exit (void)
    336          {
   \                     MB_OS_Exit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    337          #if (MODBUS_CFG_MASTER_EN == DEF_ENABLED)
    338              MB_OS_ExitMaster();
   \   00000002   0x.... 0x....      BL       MB_OS_ExitMaster
    339          #endif
    340          
    341          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED)
    342              MB_OS_ExitSlave();
   \   00000006   0x.... 0x....      BL       MB_OS_ExitSlave
    343          #endif
    344          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    345          
    346          /*
    347          *********************************************************************************************************
    348          *                                          MB_OS_ExitMaster()
    349          *
    350          * Description : This function is called to terminate the RTOS interface for Modbus Master channels.  The
    351          *               Following objects are deleted.
    352          *
    353          *               (1) An event flag group to signal the reception of a packet.
    354          *
    355          * Argument(s) : none
    356          *
    357          * Return(s)   : none.
    358          *
    359          * Caller(s)   : MB_OS_Exit()
    360          *
    361          * Note(s)     : none.
    362          *********************************************************************************************************
    363          */
    364          
    365          #if (MODBUS_CFG_MASTER_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    366          static  void  MB_OS_ExitMaster (void)
    367          {
   \                     MB_OS_ExitMaster: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    368              CPU_INT08U  i;
    369              CPU_INT08U  err;
    370          
    371          
    372              for (i = 0; i < MODBUS_CFG_MAX_CH; i++) {                 /* Create a semaphore for each channel   */
   \   00000004   0x2400             MOVS     R4,#+0
   \   00000006   0xE009             B.N      ??MB_OS_ExitMaster_0
    373          #if OS_VERSION > 30000U
    374                  OSSemDel((OS_SEM *)&MB_OS_RxSemTbl[i],
    375                           (OS_OPT  )OS_OPT_DEL_ALWAYS,
    376                           (OS_ERR *)&err);
   \                     ??MB_OS_ExitMaster_1: (+1)
   \   00000008   0x466A             MOV      R2,SP
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x....             LDR.N    R0,??DataTable5_2
   \   0000000E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000010   0x2328             MOVS     R3,#+40
   \   00000012   0xFB03 0x0004      MLA      R0,R3,R4,R0
   \   00000016   0x.... 0x....      BL       OSSemDel
    377          #else
    378                  OSSemDel(MB_OS_RxSemTbl[i],
    379                           OS_DEL_ALWAYS,
    380                           &err);
    381                  OSSemDel(MB_OS_TxSemTbl[i],
    382                           OS_DEL_ALWAYS,
    383                           &err);
    384          #endif
    385              }
   \   0000001A   0x1C64             ADDS     R4,R4,#+1
   \                     ??MB_OS_ExitMaster_0: (+1)
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x2C04             CMP      R4,#+4
   \   00000020   0xDBF2             BLT.N    ??MB_OS_ExitMaster_1
    386          }
   \   00000022   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    387          #endif
    388          
    389          /*
    390          *********************************************************************************************************
    391          *                                          MB_OS_ExitSlave()
    392          *
    393          * Description : This function is called to terminate the RTOS interface for Modbus Salve channels.
    394          *               The following objects are deleted.
    395          *
    396          *               (1) A task that waits for packets to be received.
    397          *               (2) A message queue to signal the reception of a packet.
    398          *
    399          * Argument(s) : none
    400          *
    401          * Return(s)   : none.
    402          *
    403          * Caller(s)   : MB_OS_Exit()
    404          *
    405          * Note(s)     : none.
    406          *********************************************************************************************************
    407          */
    408          
    409          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    410          void  MB_OS_ExitSlave (void)
    411          {
   \                     MB_OS_ExitSlave: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    412              CPU_INT08U  err;
    413          
    414          #if OS_VERSION  > 30000u
    415              OSTaskDel   ( (OS_TCB  *)&MB_OS_RxTaskTCB,
    416                            (OS_ERR  *)&err);                           /* Delete Modbus Rx Task                 */
   \   00000002   0x4669             MOV      R1,SP
   \   00000004   0x....             LDR.N    R0,??DataTable5_8
   \   00000006   0x.... 0x....      BL       OSTaskDel
    417              OSQDel      ( (OS_Q    *)&MB_OS_RxQ,
    418                            (OS_OPT   )OS_OPT_DEL_ALWAYS,
    419                            (OS_ERR  *)&err);                           /* Delete the Queue                      */
   \   0000000A   0x466A             MOV      R2,SP
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0x....             LDR.N    R0,??DataTable5_5
   \   00000010   0x.... 0x....      BL       OSQDel
    420          #else
    421              OSTaskDel(MB_OS_CFG_RX_TASK_PRIO);                        /* Delete Modbus Rx Task                 */
    422              OSQDel(MB_OS_RxQ, OS_DEL_ALWAYS,                          /* Delete the Queue                      */
    423                     &err);
    424          #endif
    425          }
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
    426          #endif
    427          
    428          
    429          /*$PAGE*/
    430          /*
    431          *********************************************************************************************************
    432          *                                              MB_OS_RxSignal()
    433          *
    434          * Description : This function signals the reception of a packet either from the Rx ISR(s) or the RTU timeout
    435          *               timer(s) to indicate that a received packet needs to be processed.
    436          *
    437          * Argument(s) : pch     specifies the Modbus channel data structure in which a packet was received.
    438          *
    439          * Return(s)   : none.
    440          *
    441          * Caller(s)   : MB_ASCII_RxByte()
    442          *               MB_RTU_TmrUpdate()
    443          *
    444          * Note(s)     : none.
    445          *********************************************************************************************************
    446          */
    447          

   \                                 In section .text, align 2, keep-with-next
    448          void  MB_OS_RxSignal (MODBUS_CH *pch)
    449          {
   \                     MB_OS_RxSignal: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    450              OS_ERR  err;
    451          
    452              if (pch != (MODBUS_CH *)0) {
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD00F             BEQ.N    ??MB_OS_RxSignal_0
    453                  switch (pch->MasterSlave) {
   \   00000008   0x7D01             LDRB     R1,[R0, #+20]
   \   0000000A   0x2901             CMP      R1,#+1
   \   0000000C   0xD104             BNE.N    ??MB_OS_RxSignal_1
    454          #if (MODBUS_CFG_MASTER_EN == DEF_ENABLED)
    455                      case MODBUS_MASTER:
    456          #if OS_VERSION > 30000U
    457                           BSP_OS_SemPost (pch->RxSem);
   \   0000000E   0xF8D0 0x0854      LDR      R0,[R0, #+2132]
   \   00000012   0x.... 0x....      BL       BSP_OS_SemPost
    458          #else
    459                           (void)OSSemPost(pch->RxSem);
    460          #endif
    461                           break;
   \   00000016   0xE007             B.N      ??MB_OS_RxSignal_0
    462          #endif
    463          
    464          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED)
    465                      case MODBUS_SLAVE:
    466                      default:
    467          #if OS_VERSION  > 30000u
    468                           (void)OSQPost ( (OS_Q         *)&MB_OS_RxQ,
    469                                           (void         *)pch,
    470                                           (OS_MSG_SIZE   )1,
    471                                           (OS_OPT        )OS_OPT_POST_FIFO,
    472                                           (OS_ERR       *)&err);
   \                     ??MB_OS_RxSignal_1: (+1)
   \   00000018   0xA901             ADD      R1,SP,#+4
   \   0000001A   0x9100             STR      R1,[SP, #+0]
   \   0000001C   0x2300             MOVS     R3,#+0
   \   0000001E   0x2201             MOVS     R2,#+1
   \   00000020   0x0001             MOVS     R1,R0
   \   00000022   0x....             LDR.N    R0,??DataTable5_5
   \   00000024   0x.... 0x....      BL       OSQPost
    473          #else
    474                           (void)OSQPost(MB_OS_RxQ,
    475                                         (void *)pch);
    476          #endif
    477                           break;
    478          #endif
    479                  }
    480              }
    481          }
   \                     ??MB_OS_RxSignal_0: (+1)
   \   00000028   0xBD07             POP      {R0-R2,PC}       ;; return
    482          
    483          /*$PAGE*/
    484          /*
    485          *********************************************************************************************************
    486          *                                              MB_OS_RxWait()
    487          *
    488          * Description : This function waits for a response from a slave.
    489          *
    490          * Argument(s) : pch     specifies the Modbus channel data structure to wait on.
    491          *
    492          *               perr    is a pointer to a variable that will receive an error code.  Possible errors are:
    493          *
    494          *                       MODBUS_ERR_NONE        the call was successful and a packet was received
    495          *                       MODBUS_ERR_TIMED_OUT   a packet was not received within the specified timeout
    496          *                       MODBUS_ERR_NOT_MASTER  the channel is not a Master
    497          *                       MODBUS_ERR_INVALID     an invalid error was detected
    498          *
    499          * Caller(s)    : MBM_FCxx()  Modbus Master Functions
    500          *
    501          * Return(s)   : none
    502          *********************************************************************************************************
    503          */
    504          

   \                                 In section .text, align 2, keep-with-next
    505          void  MB_OS_RxWait (MODBUS_CH   *pch,
    506                              CPU_INT16U  *perr)
    507          {
   \                     MB_OS_RxWait: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    508          #if (MODBUS_CFG_MASTER_EN == DEF_ENABLED)
    509              CPU_INT08U  err;
    510          
    511              if (pch != (MODBUS_CH *)0) {
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD03E             BEQ.N    ??MB_OS_RxWait_0
    512                  if (pch->MasterSlave == MODBUS_MASTER) {
   \   0000000C   0x7D20             LDRB     R0,[R4, #+20]
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xD137             BNE.N    ??MB_OS_RxWait_1
    513          #if OS_VERSION > 30000U
    514                      OSSemPend((OS_SEM *)pch->RxSem,
    515                                (OS_TICK )pch->RxTimeout,
    516                                (OS_OPT  )OS_OPT_PEND_BLOCKING,
    517                                (CPU_TS  )0,
    518                                (OS_ERR *)&err);
   \   00000012   0xA801             ADD      R0,SP,#+4
   \   00000014   0x9000             STR      R0,[SP, #+0]
   \   00000016   0x2300             MOVS     R3,#+0
   \   00000018   0x2200             MOVS     R2,#+0
   \   0000001A   0x6AA1             LDR      R1,[R4, #+40]
   \   0000001C   0xF8D4 0x0854      LDR      R0,[R4, #+2132]
   \   00000020   0x.... 0x....      BL       OSSemPend
    519          #else
    520                      OSSemPend(pch->RxSem,
    521                                pch->RxTimeout,
    522                                &err);
    523          #endif
    524                      switch (err) {
   \   00000024   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD102             BNE.N    ??MB_OS_RxWait_2
    525                          //case OS_ERR_EVENT_TYPE:
    526                          case OS_ERR_PEND_ISR:
    527                          case OS_ERR_PEND_LOCKED:
    528                               *perr = MODBUS_ERR_INVALID;
    529                               break;
    530          
    531                          case OS_ERR_TIMEOUT:
    532                               *perr = MODBUS_ERR_TIMED_OUT;
    533                               break;
    534          
    535                          case OS_ERR_NONE:
    536                               *perr = MODBUS_ERR_NONE;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x8028             STRH     R0,[R5, #+0]
    537                               break;
   \   00000030   0xE002             B.N      ??MB_OS_RxWait_3
    538                          default:
    539                               *perr = MODBUS_ERR_INVALID;
   \                     ??MB_OS_RxWait_2: (+1)
   \   00000032   0xF640 0x30BA      MOVW     R0,#+3002
   \   00000036   0x8028             STRH     R0,[R5, #+0]
    540                      }
    541          
    542                      if ( err == OS_ERR_NONE ) {
   \                     ??MB_OS_RxWait_3: (+1)
   \   00000038   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD10C             BNE.N    ??MB_OS_RxWait_4
    543                          pch->RxFaildCtr     = 0;
   \   00000040   0xF894 0x085C      LDRB     R0,[R4, #+2140]
   \   00000044   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000048   0xF884 0x085C      STRB     R0,[R4, #+2140]
    544                          pch->RxFaildFlag    = 0;
   \   0000004C   0xF894 0x085C      LDRB     R0,[R4, #+2140]
   \   00000050   0xF010 0x00F7      ANDS     R0,R0,#0xF7
   \   00000054   0xF884 0x085C      STRB     R0,[R4, #+2140]
   \   00000058   0xE01A             B.N      ??MB_OS_RxWait_5
    545                      } else {
    546                        if (pch->RxFaildCtr < MODBUS_CFG_FAILD_MAX) {
   \                     ??MB_OS_RxWait_4: (+1)
   \   0000005A   0xF894 0x085C      LDRB     R0,[R4, #+2140]
   \   0000005E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000060   0x0900             LSRS     R0,R0,#+4
   \   00000062   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000064   0x2805             CMP      R0,#+5
   \   00000066   0xDA05             BGE.N    ??MB_OS_RxWait_6
    547                          pch->RxFaildCtr++;
   \   00000068   0xF894 0x085C      LDRB     R0,[R4, #+2140]
   \   0000006C   0x3010             ADDS     R0,R0,#+16
   \   0000006E   0xF884 0x085C      STRB     R0,[R4, #+2140]
   \   00000072   0xE00D             B.N      ??MB_OS_RxWait_5
    548                        } else {
    549                          pch->RxFaildFlag    = 1;
   \                     ??MB_OS_RxWait_6: (+1)
   \   00000074   0xF894 0x085C      LDRB     R0,[R4, #+2140]
   \   00000078   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000007C   0xF884 0x085C      STRB     R0,[R4, #+2140]
   \   00000080   0xE006             B.N      ??MB_OS_RxWait_5
    550                        }
    551                      }
    552                  } else {
    553                      *perr = MODBUS_ERR_NOT_MASTER;
   \                     ??MB_OS_RxWait_1: (+1)
   \   00000082   0xF640 0x30B9      MOVW     R0,#+3001
   \   00000086   0x8028             STRH     R0,[R5, #+0]
   \   00000088   0xE002             B.N      ??MB_OS_RxWait_5
    554                  }
    555              } else {
    556                  *perr = MODBUS_ERR_NULLPTR;
   \                     ??MB_OS_RxWait_0: (+1)
   \   0000008A   0xF640 0x30BB      MOVW     R0,#+3003
   \   0000008E   0x8028             STRH     R0,[R5, #+0]
    557              }
    558          #else
    559              *perr = MODBUS_ERR_INVALID;
    560          #endif
    561          }
   \                     ??MB_OS_RxWait_5: (+1)
   \   00000090   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    562          

   \                                 In section .text, align 2, keep-with-next
    563          void  MB_OS_TxWait (MODBUS_CH   *pch,
    564                              CPU_INT16U  *perr)
    565          {
   \                     MB_OS_TxWait: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x000C             MOVS     R4,R1
    566          #if (MODBUS_CFG_MASTER_EN == DEF_ENABLED)
    567              CPU_INT08U  err;
    568          
    569              if (pch != (MODBUS_CH *)0) {
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD01A             BEQ.N    ??MB_OS_TxWait_0
    570                  if (pch->MasterSlave == MODBUS_MASTER) {
   \   00000008   0x7D01             LDRB     R1,[R0, #+20]
   \   0000000A   0x2901             CMP      R1,#+1
   \   0000000C   0xD113             BNE.N    ??MB_OS_TxWait_1
    571          #if OS_VERSION > 30000U
    572                      OSSemPend((OS_SEM *)pch->TxSem,
    573                                (OS_TICK )pch->RxTimeout,
    574                                (OS_OPT  )OS_OPT_PEND_BLOCKING,
    575                                (CPU_TS  )0,
    576                                (OS_ERR *)&err);
   \   0000000E   0xA901             ADD      R1,SP,#+4
   \   00000010   0x9100             STR      R1,[SP, #+0]
   \   00000012   0x2300             MOVS     R3,#+0
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0x6A81             LDR      R1,[R0, #+40]
   \   00000018   0xF8D0 0x0858      LDR      R0,[R0, #+2136]
   \   0000001C   0x.... 0x....      BL       OSSemPend
    577          #else
    578                      OSSemPend(pch->TxSem,
    579                                pch->RxTimeout,
    580                                &err);
    581          #endif
    582                      switch (err) {
   \   00000020   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD102             BNE.N    ??MB_OS_TxWait_2
    583                          //case OS_ERR_EVENT_TYPE:
    584                          case OS_ERR_PEND_ISR:
    585                          case OS_ERR_PEND_LOCKED:
    586                               *perr = MODBUS_ERR_INVALID;
    587                               break;
    588          
    589                          case OS_ERR_TIMEOUT:
    590                               *perr = MODBUS_ERR_TIMED_OUT;
    591                               break;
    592          
    593                          case OS_ERR_NONE:
    594                               *perr = MODBUS_ERR_NONE;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x8020             STRH     R0,[R4, #+0]
    595                               break;
   \   0000002C   0xE00A             B.N      ??MB_OS_TxWait_3
    596                          default:
    597                            *perr = MODBUS_ERR_INVALID;
   \                     ??MB_OS_TxWait_2: (+1)
   \   0000002E   0xF640 0x30BA      MOVW     R0,#+3002
   \   00000032   0x8020             STRH     R0,[R4, #+0]
   \   00000034   0xE006             B.N      ??MB_OS_TxWait_3
    598                      }
    599                  } else {
    600                      *perr = MODBUS_ERR_NOT_MASTER;
   \                     ??MB_OS_TxWait_1: (+1)
   \   00000036   0xF640 0x30B9      MOVW     R0,#+3001
   \   0000003A   0x8020             STRH     R0,[R4, #+0]
   \   0000003C   0xE002             B.N      ??MB_OS_TxWait_3
    601                  }
    602              } else {
    603                  *perr = MODBUS_ERR_NULLPTR;
   \                     ??MB_OS_TxWait_0: (+1)
   \   0000003E   0xF640 0x30BB      MOVW     R0,#+3003
   \   00000042   0x8020             STRH     R0,[R4, #+0]
    604              }
    605          #else
    606              *perr = MODBUS_ERR_INVALID;
    607          #endif
    608          }
   \                     ??MB_OS_TxWait_3: (+1)
   \   00000044   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    609          

   \                                 In section .text, align 2, keep-with-next
    610          void  MB_OS_TxOver (MODBUS_CH   *pch )
    611          {
   \                     MB_OS_TxOver: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    612          #if OS_VERSION  > 30000u
    613            OS_ERR    err;
    614            OSSemPost((OS_SEM  *)pch->TxSem,
    615                      (OS_OPT   )OS_OPT_POST_1,
    616                      (OS_ERR  *)&err);
   \   00000002   0x466A             MOV      R2,SP
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0xF8D0 0x0858      LDR      R0,[R0, #+2136]
   \   0000000A   0x.... 0x....      BL       OSSemPost
    617          #else
    618            OSSemPost(pch->TxSem);
    619          #endif
    620          
    621          }
   \   0000000E   0xBD01             POP      {R0,PC}          ;; return
    622          /*$PAGE*/
    623          /*
    624          *********************************************************************************************************
    625          *                                            MB_OS_RxTask()
    626          *
    627          * Description : This task is created by MB_OS_Init() and waits for signals from either the Rx ISR(s) or
    628          *               the RTU timeout timer(s) to indicate that a packet needs to be processed.
    629          *
    630          * Argument(s) : p_arg       is a pointer to an optional argument that is passed by uC/OS-II to the task.
    631          *                           This argument is not used.
    632          *
    633          * Caller(s)   : This is a Task.
    634          *
    635          * Return(s)   : none.
    636          *********************************************************************************************************
    637          */
    638          
    639          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED)

   \                                 In section .text, align 4, keep-with-next
    640          static  void  MB_OS_RxTask (void *p_arg)
    641          {
   \                     MB_OS_RxTask: (+1)
   \   00000000   0xB5E0             PUSH     {R5-R7,LR}
    642              CPU_INT08U  err;
    643              MODBUS_CH  *pch;
    644          #if OS_VERSION  > 30000u
    645              OS_MSG_SIZE p_msg_size;
    646          #endif
    647              (void)p_arg;
    648          
    649              while (DEF_TRUE) {
    650          #if OS_VERSION  > 30000u
    651                  pch = (MODBUS_CH *)OSQPend ((OS_Q         *)&MB_OS_RxQ,
    652                                              (OS_TICK       )0,
    653                                              (OS_OPT        )OS_OPT_PEND_BLOCKING,//OS_OPT_PEND_NON_BLOCKING,
    654                                              (OS_MSG_SIZE  *)&p_msg_size,
    655                                              (CPU_TS       *)0,
    656                                              (OS_ERR       *)&err);
   \                     ??MB_OS_RxTask_0: (+1)
   \   00000002   0xA802             ADD      R0,SP,#+8
   \   00000004   0x9001             STR      R0,[SP, #+4]
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9000             STR      R0,[SP, #+0]
   \   0000000A   0xF10D 0x030A      ADD      R3,SP,#+10
   \   0000000E   0x2200             MOVS     R2,#+0
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x....             LDR.N    R0,??DataTable5_5
   \   00000014   0x.... 0x....      BL       OSQPend
    657          #else
    658                  pch = (MODBUS_CH *)OSQPend(MB_OS_RxQ,    /* Wait for a packet to be received                   */
    659                                             0,
    660                                             &err);
    661          #endif
    662                  MB_RxTask(pch);                          /* Process the packet received                        */
   \   00000018   0x.... 0x....      BL       MB_RxTask
   \   0000001C   0xE7F1             B.N      ??MB_OS_RxTask_0
    663              }
    664          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x52 0x78          DC8      "RxQ"
   \              0x51 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     MB_OS_RxSemTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x........         DC32     MB_OS_TxSemTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x........         DC32     MB_OS_RxQ

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x........         DC32     MB_OS_RxTaskStk

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0x........         DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_8:
   \   00000000   0x........         DC32     MB_OS_RxTaskTCB

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x75 0x43          DC8 "uC/Modbus Rx Sem"
   \              0x2F 0x4D    
   \              0x6F 0x64    
   \              0x62 0x75    
   \              0x73 0x20    
   \              0x52 0x78    
   \              0x20 0x53    
   \              0x65 0x6D    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x75 0x43          DC8 "uC/Modbus Tx Sem"
   \              0x2F 0x4D    
   \              0x6F 0x64    
   \              0x62 0x75    
   \              0x73 0x20    
   \              0x54 0x78    
   \              0x20 0x53    
   \              0x65 0x6D    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \   00000000   0x52 0x78          DC8 "RxQ"
   \              0x51 0x00    

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x41 0x70          DC8 "App Task Start"
   \              0x70 0x20    
   \              0x54 0x61    
   \              0x73 0x6B    
   \              0x20 0x53    
   \              0x74 0x61    
   \              0x72 0x74    
   \              0x00         
   \   0000000F   0x00               DC8 0
    665          #endif
    666          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   MB_OS_Exit
         8   -> MB_OS_ExitMaster
         8   -> MB_OS_ExitSlave
      16   MB_OS_ExitMaster
        16   -> OSSemDel
       8   MB_OS_ExitSlave
         8   -> OSQDel
         8   -> OSTaskDel
       8   MB_OS_Init
         8   -> MB_OS_InitMaster
         8   -> MB_OS_InitSlave
       8   MB_OS_InitMaster
         8   -> BSP_OS_SemCreate
      48   MB_OS_InitSlave
        48   -> OSQCreate
        48   -> OSTaskCreate
      16   MB_OS_RxSignal
        16   -> BSP_OS_SemPost
        16   -> OSQPost
      16   MB_OS_RxTask
        16   -> MB_RxTask
        16   -> OSQPend
      24   MB_OS_RxWait
        24   -> OSSemPend
       8   MB_OS_TxOver
         8   -> OSSemPost
      16   MB_OS_TxWait
        16   -> OSSemPend


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
      20  ?_0
      20  ?_1
       4  ?_2
      16  ?_3
      12  MB_OS_Exit
      36  MB_OS_ExitMaster
      22  MB_OS_ExitSlave
      12  MB_OS_Init
      52  MB_OS_InitMaster
      72  MB_OS_InitSlave
      48  MB_OS_RxQ
      42  MB_OS_RxSignal
      30  MB_OS_RxTask
    2048  MB_OS_RxTaskStk
     160  MB_OS_RxTaskTCB
     146  MB_OS_RxWait
      16  MB_OS_TxOver
      70  MB_OS_TxWait

 
 2 256 bytes in section .bss
    60 bytes in section .rodata
   546 bytes in section .text
 
   546 bytes of CODE  memory
    60 bytes of CONST memory
 2 256 bytes of DATA  memory

Errors: none
Warnings: none
