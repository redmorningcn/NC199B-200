###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       11/Jul/2018  11:13:10
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC210\NC210-200处理板\source\Software\uCOS-III\Source\os_mem.c
#    Command line =  
#        F:\iar\NC210\NC210-200处理板\source\Software\uCOS-III\Source\os_mem.c
#        -D USE_STDPERIPH_DRIVER -D APP_RELEASE -lCN
#        F:\iar\NC210\NC210-200处理板\project\app_release\List -o
#        F:\iar\NC210\NC210-200处理板\project\app_release\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        F:\iar\NC210\NC210-200处理板\project\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\config\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\task\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\user\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\OS\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\OSAL\Ports\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\driver\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-LIB\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uCOS-III\Source\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\ST\STM32\inc\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\OS\uCOS-III\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Ports\STM32\STM32F103\IAR\
#        -I
#        F:\iar\NC210\NC210-200处理板\project\..\source\Software\uC-MB\Source\
#        -Ol --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC210\NC210-200处理板\project\app_release\List\os_mem.lst
#    Object file  =  
#        F:\iar\NC210\NC210-200处理板\project\app_release\Obj\os_mem.o
#
###############################################################################

F:\iar\NC210\NC210-200处理板\source\Software\uCOS-III\Source\os_mem.c
      1          /*
      2          ************************************************************************************************************************
      3          *                                                      uC/OS-III
      4          *                                                 The Real-Time Kernel
      5          *
      6          *                                  (c) Copyright 2009-2016; Micrium, Inc.; Weston, FL
      7          *                           All rights reserved.  Protected by international copyright laws.
      8          *
      9          *                                             MEMORY PARTITION MANAGEMENT
     10          *
     11          * File    : OS_MEM.C
     12          * By      : JJL
     13          * Version : V3.06.00
     14          *
     15          * LICENSING TERMS:
     16          * ---------------
     17          *           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or
     18          *           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
     19          *           product then, you need to contact Micrium to properly license uC/OS-III for its use in your
     20          *           application/product.   We provide ALL the source code for your convenience and to help you
     21          *           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use
     22          *           it commercially without paying a licensing fee.
     23          *
     24          *           Knowledge of the source code may NOT be used to develop a similar product.
     25          *
     26          *           Please help us continue to provide the embedded community with the finest software available.
     27          *           Your honesty is greatly appreciated.
     28          *
     29          *           You can find our product's user manual, API reference, release notes and
     30          *           more information at https://doc.micrium.com.
     31          *           You can contact us at www.micrium.com.
     32          ************************************************************************************************************************
     33          */
     34          
     35          #define   MICRIUM_SOURCE
     36          #include "os.h"
     37          
     38          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     39          const  CPU_CHAR  *os_mem__c = "$Id: $";
     40          #endif
     41          
     42          
     43          #if (OS_CFG_MEM_EN == DEF_ENABLED)
     44          /*
     45          ************************************************************************************************************************
     46          *                                               CREATE A MEMORY PARTITION
     47          *
     48          * Description : Create a fixed-sized memory partition that will be managed by uC/OS-III.
     49          *
     50          * Arguments   : p_mem    is a pointer to a memory partition control block which is allocated in user memory space.
     51          *
     52          *               p_name   is a pointer to an ASCII string to provide a name to the memory partition.
     53          *
     54          *               p_addr   is the starting address of the memory partition
     55          *
     56          *               n_blks   is the number of memory blocks to create from the partition.
     57          *
     58          *               blk_size is the size (in bytes) of each block in the memory partition.
     59          *
     60          *               p_err    is a pointer to a variable containing an error message which will be set by this function to
     61          *                        either:
     62          *
     63          *                            OS_ERR_NONE                    If the memory partition has been created correctly
     64          *                            OS_ERR_ILLEGAL_CREATE_RUN_TIME If you are trying to create the memory partition after you
     65          *                                                             called OSSafetyCriticalStart()
     66          *                            OS_ERR_MEM_CREATE_ISR          If you called this function from an ISR
     67          *                            OS_ERR_MEM_INVALID_BLKS        User specified an invalid number of blocks (must be >= 2)
     68          *                            OS_ERR_MEM_INVALID_P_ADDR      If you are specifying an invalid address for the memory
     69          *                                                           storage of the partition or, the block does not align on a
     70          *                                                           pointer boundary
     71          *                            OS_ERR_MEM_INVALID_SIZE        User specified an invalid block size
     72          *                                                             - must be greater than the size of a pointer
     73          *                                                             - must be able to hold an integral number of pointers
     74          * Returns    : none
     75          *
     76          * Note(s)    : none
     77          ************************************************************************************************************************
     78          */
     79          

   \                                 In section .text, align 2, keep-with-next
     80          void  OSMemCreate (OS_MEM       *p_mem,
     81                             CPU_CHAR     *p_name,
     82                             void         *p_addr,
     83                             OS_MEM_QTY    n_blks,
     84                             OS_MEM_SIZE   blk_size,
     85                             OS_ERR       *p_err)
     86          {
   \                     OSMemCreate: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0017             MOVS     R7,R2
   \   0000000A   0x4698             MOV      R8,R3
     87          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
     88              CPU_DATA       align_msk;
     89          #endif
     90              OS_MEM_QTY     i;
     91              OS_MEM_QTY     loops;
     92              CPU_INT08U    *p_blk;
     93              void         **p_link;
     94              CPU_SR_ALLOC();
   \   0000000C   0xF05F 0x0A00      MOVS     R10,#+0
   \   00000010   0xF8DD 0x9024      LDR      R9,[SP, #+36]
     95          
     96          
     97          
     98          #ifdef OS_SAFETY_CRITICAL
     99              if (p_err == DEF_NULL) {
    100                  OS_SAFETY_CRITICAL_EXCEPTION();
    101                  return;
    102              }
    103          #endif
    104          
    105          #ifdef OS_SAFETY_CRITICAL_IEC61508
    106              if (OSSafetyCriticalStartFlag == DEF_TRUE) {
    107                 *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
    108                  return;
    109              }
    110          #endif
    111          
    112          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
    113              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
   \   00000014   0x....             LDR.N    R0,??DataTable4
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD004             BEQ.N    ??OSMemCreate_0
    114                 *p_err = OS_ERR_MEM_CREATE_ISR;
   \   0000001C   0xF245 0x60B9      MOVW     R0,#+22201
   \   00000020   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    115                  return;
   \   00000024   0xE05C             B.N      ??OSMemCreate_1
    116              }
    117          #endif
    118          
    119          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
    120              if (p_addr == DEF_NULL) {                                   /* Must pass a valid address for the memory part.       */
   \                     ??OSMemCreate_0: (+1)
   \   00000026   0x2F00             CMP      R7,#+0
   \   00000028   0xD104             BNE.N    ??OSMemCreate_2
    121                 *p_err   = OS_ERR_MEM_INVALID_P_ADDR;
   \   0000002A   0xF245 0x60BB      MOVW     R0,#+22203
   \   0000002E   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    122                  return;
   \   00000032   0xE055             B.N      ??OSMemCreate_1
    123              }
    124              if (n_blks < 2u) {                                          /* Must have at least 2 blocks per partition            */
   \                     ??OSMemCreate_2: (+1)
   \   00000034   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000038   0xF1B8 0x0F02      CMP      R8,#+2
   \   0000003C   0xD204             BCS.N    ??OSMemCreate_3
    125                 *p_err = OS_ERR_MEM_INVALID_BLKS;
   \   0000003E   0xF245 0x60BC      MOVW     R0,#+22204
   \   00000042   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    126                  return;
   \   00000046   0xE04B             B.N      ??OSMemCreate_1
    127              }
   \                     ??OSMemCreate_3: (+1)
   \   00000048   0x9C08             LDR      R4,[SP, #+32]
    128              if (blk_size < sizeof(void *)) {                            /* Must contain space for at least a pointer            */
   \   0000004A   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000004C   0x2C04             CMP      R4,#+4
   \   0000004E   0xD204             BCS.N    ??OSMemCreate_4
    129                 *p_err = OS_ERR_MEM_INVALID_SIZE;
   \   00000050   0xF245 0x60C1      MOVW     R0,#+22209
   \   00000054   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    130                  return;
   \   00000058   0xE042             B.N      ??OSMemCreate_1
    131              }
    132              align_msk = sizeof(void *) - 1u;
   \                     ??OSMemCreate_4: (+1)
   \   0000005A   0x2003             MOVS     R0,#+3
    133              if (align_msk > 0u) {
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD00F             BEQ.N    ??OSMemCreate_5
    134                  if (((CPU_ADDR)p_addr & align_msk) != 0u){              /* Must be pointer size aligned                         */
   \   00000060   0x4207             TST      R7,R0
   \   00000062   0xD004             BEQ.N    ??OSMemCreate_6
    135                     *p_err = OS_ERR_MEM_INVALID_P_ADDR;
   \   00000064   0xF245 0x60BB      MOVW     R0,#+22203
   \   00000068   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    136                      return;
   \   0000006C   0xE038             B.N      ??OSMemCreate_1
    137                  }
    138                  if ((blk_size & align_msk) != 0u) {                     /* Block size must be a multiple address size           */
   \                     ??OSMemCreate_6: (+1)
   \   0000006E   0x0021             MOVS     R1,R4
   \   00000070   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000072   0x4201             TST      R1,R0
   \   00000074   0xD004             BEQ.N    ??OSMemCreate_5
    139                     *p_err = OS_ERR_MEM_INVALID_SIZE;
   \   00000076   0xF245 0x60C1      MOVW     R0,#+22209
   \   0000007A   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    140                      return;
   \   0000007E   0xE02F             B.N      ??OSMemCreate_1
    141                  }
    142              }
    143          #endif
    144          
    145              p_link = (void **)p_addr;                                   /* Create linked list of free memory blocks             */
   \                     ??OSMemCreate_5: (+1)
   \   00000080   0x003B             MOVS     R3,R7
    146              p_blk  = (CPU_INT08U *)p_addr;
   \   00000082   0x003A             MOVS     R2,R7
    147              loops  = n_blks - 1u;
   \   00000084   0xF1B8 0x0101      SUBS     R1,R8,#+1
    148              for (i = 0u; i < loops; i++) {
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0xE004             B.N      ??OSMemCreate_7
    149                  p_blk +=  blk_size;
   \                     ??OSMemCreate_8: (+1)
   \   0000008C   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000008E   0x18A2             ADDS     R2,R4,R2
    150                 *p_link = (void  *)p_blk;                                /* Save pointer to NEXT block in CURRENT block          */
   \   00000090   0x601A             STR      R2,[R3, #+0]
    151                  p_link = (void **)(void *)p_blk;                        /* Position     to NEXT block                           */
   \   00000092   0x0013             MOVS     R3,R2
    152              }
   \   00000094   0x1C40             ADDS     R0,R0,#+1
   \                     ??OSMemCreate_7: (+1)
   \   00000096   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000098   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000009A   0x4288             CMP      R0,R1
   \   0000009C   0xD3F6             BCC.N    ??OSMemCreate_8
    153             *p_link             = DEF_NULL;                              /* Last memory block points to NULL                     */
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x6018             STR      R0,[R3, #+0]
    154          
    155              CPU_CRITICAL_ENTER();
   \   000000A2   0x.... 0x....      BL       CPU_SR_Save
   \   000000A6   0x4682             MOV      R10,R0
   \   000000A8   0x.... 0x....      BL       CPU_IntDisMeasStart
    156          #if (OS_OBJ_TYPE_REQ == DEF_ENABLED)
    157              p_mem->Type        = OS_OBJ_TYPE_MEM;                       /* Set the type of object                               */
   \   000000AC   0x....             LDR.N    R0,??DataTable4_1  ;; 0x204d454d
   \   000000AE   0x6028             STR      R0,[R5, #+0]
    158          #endif
    159          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    160              p_mem->NamePtr     = p_name;                                /* Save name of memory partition                        */
   \   000000B0   0x606E             STR      R6,[R5, #+4]
    161          #else
    162              (void)p_name;
    163          #endif
    164              p_mem->AddrPtr     = p_addr;                                /* Store start address of memory partition              */
   \   000000B2   0x60AF             STR      R7,[R5, #+8]
    165              p_mem->FreeListPtr = p_addr;                                /* Initialize pointer to pool of free blocks            */
   \   000000B4   0x60EF             STR      R7,[R5, #+12]
    166              p_mem->NbrFree     = n_blks;                                /* Store number of free blocks in MCB                   */
   \   000000B6   0xF8A5 0x8014      STRH     R8,[R5, #+20]
    167              p_mem->NbrMax      = n_blks;
   \   000000BA   0xF8A5 0x8012      STRH     R8,[R5, #+18]
    168              p_mem->BlkSize     = blk_size;                              /* Store block size of each memory blocks               */
   \   000000BE   0x822C             STRH     R4,[R5, #+16]
    169          
    170          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    171              OS_MemDbgListAdd(p_mem);
   \   000000C0   0x0028             MOVS     R0,R5
   \   000000C2   0x.... 0x....      BL       OS_MemDbgListAdd
    172              OSMemQty++;
   \   000000C6   0x....             LDR.N    R0,??DataTable4_2
   \   000000C8   0x8800             LDRH     R0,[R0, #+0]
   \   000000CA   0x1C40             ADDS     R0,R0,#+1
   \   000000CC   0x....             LDR.N    R1,??DataTable4_2
   \   000000CE   0x8008             STRH     R0,[R1, #+0]
    173          #endif
    174          
    175              OS_TRACE_MEM_CREATE(p_mem, p_name);
    176              CPU_CRITICAL_EXIT();
   \   000000D0   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000D4   0x4650             MOV      R0,R10
   \   000000D6   0x.... 0x....      BL       CPU_SR_Restore
    177             *p_err = OS_ERR_NONE;
   \   000000DA   0x2000             MOVS     R0,#+0
   \   000000DC   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    178          }
   \                     ??OSMemCreate_1: (+1)
   \   000000E0   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    179          
    180          
    181          /*
    182          ************************************************************************************************************************
    183          *                                                  GET A MEMORY BLOCK
    184          *
    185          * Description : Get a memory block from a partition.
    186          *
    187          * Arguments   : p_mem   is a pointer to the memory partition control block
    188          *
    189          *               p_err   is a pointer to a variable containing an error message which will be set by this function to
    190          *                       either:
    191          *
    192          *                           OS_ERR_NONE               If the memory partition has been created correctly
    193          *                           OS_ERR_MEM_INVALID_P_MEM  If you passed a NULL pointer for 'p_mem'
    194          *                           OS_ERR_MEM_NO_FREE_BLKS   If there are no more free memory blocks to allocate to the caller
    195          *                           OS_ERR_OBJ_TYPE           If 'p_mem' is not pointing at a memory partition
    196          *
    197          * Returns    : A pointer to a memory block if no error is detected
    198          *              A pointer to NULL if an error is detected
    199          *
    200          * Note(s)    : none
    201          ************************************************************************************************************************
    202          */
    203          

   \                                 In section .text, align 2, keep-with-next
    204          void  *OSMemGet (OS_MEM  *p_mem,
    205                           OS_ERR  *p_err)
    206          {
   \                     OSMemGet: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
    207              void    *p_blk;
    208              CPU_SR_ALLOC();
   \   00000006   0x2700             MOVS     R7,#+0
    209          
    210          
    211          
    212          #ifdef OS_SAFETY_CRITICAL
    213              if (p_err == DEF_NULL) {
    214                  OS_SAFETY_CRITICAL_EXCEPTION();
    215                  return (DEF_NULL);
    216              }
    217          #endif
    218          
    219              OS_TRACE_MEM_GET_ENTER(p_mem);
    220          
    221          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
    222              if (p_mem == DEF_NULL) {                                    /* Must point to a valid memory partition               */
   \   00000008   0x2D00             CMP      R5,#+0
   \   0000000A   0xD104             BNE.N    ??OSMemGet_0
    223                  OS_TRACE_MEM_GET_FAILED(p_mem);
    224                  OS_TRACE_MEM_GET_EXIT(OS_ERR_MEM_INVALID_P_MEM);
    225                 *p_err  = OS_ERR_MEM_INVALID_P_MEM;
   \   0000000C   0xF245 0x60BF      MOVW     R0,#+22207
   \   00000010   0x8020             STRH     R0,[R4, #+0]
    226                  return (DEF_NULL);
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xE028             B.N      ??OSMemGet_1
    227              }
    228          #endif
    229          
    230          #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
    231              if (p_mem->Type != OS_OBJ_TYPE_MEM) {                       /* Make sure the memory block was created               */
   \                     ??OSMemGet_0: (+1)
   \   00000016   0x6828             LDR      R0,[R5, #+0]
   \   00000018   0x....             LDR.N    R1,??DataTable4_1  ;; 0x204d454d
   \   0000001A   0x4288             CMP      R0,R1
   \   0000001C   0xD004             BEQ.N    ??OSMemGet_2
    232                  OS_TRACE_MEM_GET_EXIT(OS_ERR_OBJ_TYPE);
    233                 *p_err = OS_ERR_OBJ_TYPE;
   \   0000001E   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000022   0x8020             STRH     R0,[R4, #+0]
    234                  return (DEF_NULL);
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xE01F             B.N      ??OSMemGet_1
    235              }
    236          #endif
    237          
    238          
    239              CPU_CRITICAL_ENTER();
   \                     ??OSMemGet_2: (+1)
   \   00000028   0x.... 0x....      BL       CPU_SR_Save
   \   0000002C   0x0007             MOVS     R7,R0
   \   0000002E   0x.... 0x....      BL       CPU_IntDisMeasStart
    240              if (p_mem->NbrFree == 0u) {                                 /* See if there are any free memory blocks              */
   \   00000032   0x8AA8             LDRH     R0,[R5, #+20]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD109             BNE.N    ??OSMemGet_3
    241                  CPU_CRITICAL_EXIT();
   \   00000038   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000003C   0x0038             MOVS     R0,R7
   \   0000003E   0x.... 0x....      BL       CPU_SR_Restore
    242                  OS_TRACE_MEM_GET_FAILED(p_mem);
    243                  OS_TRACE_MEM_GET_EXIT(OS_ERR_MEM_NO_FREE_BLKS);
    244                 *p_err = OS_ERR_MEM_NO_FREE_BLKS;                        /* No,  Notify caller of empty memory partition         */
   \   00000042   0xF245 0x60C2      MOVW     R0,#+22210
   \   00000046   0x8020             STRH     R0,[R4, #+0]
    245                  return (DEF_NULL);                                      /* Return NULL pointer to caller                        */
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xE00D             B.N      ??OSMemGet_1
    246              }
    247              p_blk              = p_mem->FreeListPtr;                    /* Yes, point to next free memory block                 */
   \                     ??OSMemGet_3: (+1)
   \   0000004C   0x68EE             LDR      R6,[R5, #+12]
    248              p_mem->FreeListPtr = *(void **)p_blk;                       /* Adjust pointer to new free list                      */
   \   0000004E   0x6830             LDR      R0,[R6, #+0]
   \   00000050   0x60E8             STR      R0,[R5, #+12]
    249              p_mem->NbrFree--;                                           /* One less memory block in this partition              */
   \   00000052   0x8AA8             LDRH     R0,[R5, #+20]
   \   00000054   0x1E40             SUBS     R0,R0,#+1
   \   00000056   0x82A8             STRH     R0,[R5, #+20]
    250              CPU_CRITICAL_EXIT();
   \   00000058   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000005C   0x0038             MOVS     R0,R7
   \   0000005E   0x.... 0x....      BL       CPU_SR_Restore
    251              OS_TRACE_MEM_GET(p_mem);
    252              OS_TRACE_MEM_GET_EXIT(OS_ERR_NONE);
    253             *p_err = OS_ERR_NONE;                                        /* No error                                             */
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x8020             STRH     R0,[R4, #+0]
    254              return (p_blk);                                             /* Return memory block to caller                        */
   \   00000066   0x0030             MOVS     R0,R6
   \                     ??OSMemGet_1: (+1)
   \   00000068   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    255          }
    256          
    257          
    258          /*
    259          ************************************************************************************************************************
    260          *                                                 RELEASE A MEMORY BLOCK
    261          *
    262          * Description : Returns a memory block to a partition.
    263          *
    264          * Arguments   : p_mem    is a pointer to the memory partition control block
    265          *
    266          *               p_blk    is a pointer to the memory block being released.
    267          *
    268          *               p_err    is a pointer to a variable that will contain an error code returned by this function.
    269          *
    270          *                            OS_ERR_NONE               If the memory block was inserted into the partition
    271          *                            OS_ERR_MEM_FULL           If you are returning a memory block to an already FULL memory
    272          *                                                      partition (You freed more blocks than you allocated!)
    273          *                            OS_ERR_MEM_INVALID_P_BLK  If you passed a NULL pointer for the block to release.
    274          *                            OS_ERR_MEM_INVALID_P_MEM  If you passed a NULL pointer for 'p_mem'
    275          *                            OS_ERR_OBJ_TYPE           If 'p_mem' is not pointing at a memory partition
    276          *
    277          * Returns    : none
    278          *
    279          * Note(s)    : none
    280          ************************************************************************************************************************
    281          */
    282          

   \                                 In section .text, align 2, keep-with-next
    283          void  OSMemPut (OS_MEM  *p_mem,
    284                          void    *p_blk,
    285                          OS_ERR  *p_err)
    286          {
   \                     OSMemPut: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0014             MOVS     R4,R2
    287              CPU_SR_ALLOC();
   \   00000008   0x2700             MOVS     R7,#+0
    288          
    289          
    290          
    291          #ifdef OS_SAFETY_CRITICAL
    292              if (p_err == DEF_NULL) {
    293                  OS_SAFETY_CRITICAL_EXCEPTION();
    294                  return;
    295              }
    296          #endif
    297          
    298              OS_TRACE_MEM_PUT_ENTER(p_mem, p_blk);
    299          
    300          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
    301              if (p_mem == DEF_NULL) {                                    /* Must point to a valid memory partition               */
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD103             BNE.N    ??OSMemPut_0
    302                  OS_TRACE_MEM_PUT_FAILED(p_mem);
    303                  OS_TRACE_MEM_PUT_EXIT(OS_ERR_MEM_INVALID_P_MEM);
    304                 *p_err  = OS_ERR_MEM_INVALID_P_MEM;
   \   0000000E   0xF245 0x60BF      MOVW     R0,#+22207
   \   00000012   0x8020             STRH     R0,[R4, #+0]
    305                  return;
   \   00000014   0xE02C             B.N      ??OSMemPut_1
    306              }
    307              if (p_blk == DEF_NULL) {                                    /* Must release a valid block                           */
   \                     ??OSMemPut_0: (+1)
   \   00000016   0x2E00             CMP      R6,#+0
   \   00000018   0xD103             BNE.N    ??OSMemPut_2
    308                  OS_TRACE_MEM_PUT_FAILED(p_mem);
    309                  OS_TRACE_MEM_PUT_EXIT(OS_ERR_MEM_INVALID_P_BLK);
    310                 *p_err  = OS_ERR_MEM_INVALID_P_BLK;
   \   0000001A   0xF245 0x60BE      MOVW     R0,#+22206
   \   0000001E   0x8020             STRH     R0,[R4, #+0]
    311                  return;
   \   00000020   0xE026             B.N      ??OSMemPut_1
    312              }
    313          #endif
    314          
    315          #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
    316              if (p_mem->Type != OS_OBJ_TYPE_MEM) {                       /* Make sure the memory block was created               */
   \                     ??OSMemPut_2: (+1)
   \   00000022   0x6828             LDR      R0,[R5, #+0]
   \   00000024   0x....             LDR.N    R1,??DataTable4_1  ;; 0x204d454d
   \   00000026   0x4288             CMP      R0,R1
   \   00000028   0xD003             BEQ.N    ??OSMemPut_3
    317                  OS_TRACE_MEM_PUT_EXIT(OS_ERR_OBJ_TYPE);
    318                 *p_err = OS_ERR_OBJ_TYPE;
   \   0000002A   0xF645 0x50C4      MOVW     R0,#+24004
   \   0000002E   0x8020             STRH     R0,[R4, #+0]
    319                  return;
   \   00000030   0xE01E             B.N      ??OSMemPut_1
    320              }
    321          #endif
    322          
    323          
    324              CPU_CRITICAL_ENTER();
   \                     ??OSMemPut_3: (+1)
   \   00000032   0x.... 0x....      BL       CPU_SR_Save
   \   00000036   0x0007             MOVS     R7,R0
   \   00000038   0x.... 0x....      BL       CPU_IntDisMeasStart
    325              if (p_mem->NbrFree >= p_mem->NbrMax) {                      /* Make sure all blocks not already returned            */
   \   0000003C   0x8AA8             LDRH     R0,[R5, #+20]
   \   0000003E   0x8A69             LDRH     R1,[R5, #+18]
   \   00000040   0x4288             CMP      R0,R1
   \   00000042   0xD308             BCC.N    ??OSMemPut_4
    326                  CPU_CRITICAL_EXIT();
   \   00000044   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000048   0x0038             MOVS     R0,R7
   \   0000004A   0x.... 0x....      BL       CPU_SR_Restore
    327                  OS_TRACE_MEM_PUT_FAILED(p_mem);
    328                  OS_TRACE_MEM_PUT_EXIT(OS_ERR_MEM_FULL);
    329                 *p_err = OS_ERR_MEM_FULL;
   \   0000004E   0xF245 0x60BA      MOVW     R0,#+22202
   \   00000052   0x8020             STRH     R0,[R4, #+0]
    330                  return;
   \   00000054   0xE00C             B.N      ??OSMemPut_1
    331              }
    332              *(void **)p_blk    = p_mem->FreeListPtr;                    /* Insert released block into free block list           */
   \                     ??OSMemPut_4: (+1)
   \   00000056   0x68E8             LDR      R0,[R5, #+12]
   \   00000058   0x6030             STR      R0,[R6, #+0]
    333              p_mem->FreeListPtr = p_blk;
   \   0000005A   0x60EE             STR      R6,[R5, #+12]
    334              p_mem->NbrFree++;                                           /* One more memory block in this partition              */
   \   0000005C   0x8AA8             LDRH     R0,[R5, #+20]
   \   0000005E   0x1C40             ADDS     R0,R0,#+1
   \   00000060   0x82A8             STRH     R0,[R5, #+20]
    335              CPU_CRITICAL_EXIT();
   \   00000062   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000066   0x0038             MOVS     R0,R7
   \   00000068   0x.... 0x....      BL       CPU_SR_Restore
    336              OS_TRACE_MEM_PUT(p_mem);
    337              OS_TRACE_MEM_PUT_EXIT(OS_ERR_NONE);
    338             *p_err              = OS_ERR_NONE;                           /* Notify caller that memory block was released         */
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x8020             STRH     R0,[R4, #+0]
    339          }
   \                     ??OSMemPut_1: (+1)
   \   00000070   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    340          
    341          
    342          /*
    343          ************************************************************************************************************************
    344          *                                           ADD MEMORY PARTITION TO DEBUG LIST
    345          *
    346          * Description : This function is called by OSMemCreate() to add the memory partition to the debug table.
    347          *
    348          * Arguments   : p_mem    Is a pointer to the memory partition
    349          *
    350          * Returns     : none
    351          *
    352          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
    353          ************************************************************************************************************************
    354          */
    355          
    356          #if (OS_CFG_DBG_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    357          void  OS_MemDbgListAdd (OS_MEM  *p_mem)
    358          {
    359              p_mem->DbgPrevPtr               = DEF_NULL;
   \                     OS_MemDbgListAdd: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6181             STR      R1,[R0, #+24]
    360              if (OSMemDbgListPtr == DEF_NULL) {
   \   00000004   0x....             LDR.N    R1,??DataTable4_3
   \   00000006   0x6809             LDR      R1,[R1, #+0]
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD102             BNE.N    ??OS_MemDbgListAdd_0
    361                  p_mem->DbgNextPtr           = DEF_NULL;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x61C1             STR      R1,[R0, #+28]
   \   00000010   0xE005             B.N      ??OS_MemDbgListAdd_1
    362              } else {
    363                  p_mem->DbgNextPtr           =  OSMemDbgListPtr;
   \                     ??OS_MemDbgListAdd_0: (+1)
   \   00000012   0x....             LDR.N    R1,??DataTable4_3
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0x61C1             STR      R1,[R0, #+28]
    364                  OSMemDbgListPtr->DbgPrevPtr =  p_mem;
   \   00000018   0x....             LDR.N    R1,??DataTable4_3
   \   0000001A   0x6809             LDR      R1,[R1, #+0]
   \   0000001C   0x6188             STR      R0,[R1, #+24]
    365              }
    366              OSMemDbgListPtr                 =  p_mem;
   \                     ??OS_MemDbgListAdd_1: (+1)
   \   0000001E   0x....             LDR.N    R1,??DataTable4_3
   \   00000020   0x6008             STR      R0,[R1, #+0]
    367          }
   \   00000022   0x4770             BX       LR               ;; return
    368          #endif
    369          
    370          
    371          /*
    372          ************************************************************************************************************************
    373          *                                           INITIALIZE MEMORY PARTITION MANAGER
    374          *
    375          * Description : This function is called by uC/OS-III to initialize the memory partition manager.  Your
    376          *               application MUST NOT call this function.
    377          *
    378          * Arguments   : none
    379          *
    380          * Returns     : none
    381          *
    382          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
    383          ************************************************************************************************************************
    384          */
    385          

   \                                 In section .text, align 2, keep-with-next
    386          void  OS_MemInit (OS_ERR  *p_err)
    387          {
    388          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    389              OSMemDbgListPtr = DEF_NULL;
   \                     OS_MemInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x....             LDR.N    R2,??DataTable4_3
   \   00000004   0x6011             STR      R1,[R2, #+0]
    390              OSMemQty        = 0u;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x....             LDR.N    R2,??DataTable4_2
   \   0000000A   0x8011             STRH     R1,[R2, #+0]
    391          #endif
    392             *p_err           = OS_ERR_NONE;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x8001             STRH     R1,[R0, #+0]
    393          }
   \   00000010   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x204D454D         DC32     0x204d454d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x........         DC32     OSMemQty

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x........         DC32     OSMemDbgListPtr
    394          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   OSMemCreate
        32   -> CPU_IntDisMeasStart
        32   -> CPU_IntDisMeasStop
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> OS_MemDbgListAdd
      24   OSMemGet
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
      24   OSMemPut
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
       0   OS_MemDbgListAdd
       0   OS_MemInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
     228  OSMemCreate
     106  OSMemGet
     114  OSMemPut
      36  OS_MemDbgListAdd
      18  OS_MemInit

 
 518 bytes in section .text
 
 518 bytes of CODE memory

Errors: none
Warnings: none
